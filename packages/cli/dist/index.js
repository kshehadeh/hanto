var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  };
  var stringify = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node2 = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node2 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node2 == null) {
        node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node2[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version, hashfunc) {
    function generateUUID(value2, namespace, buf, offset) {
      var _namespace;
      if (typeof value2 === "string") {
        value2 = stringToBytes(value2);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value2.length);
      bytes.set(namespace);
      bytes.set(value2, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _default = v4;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/toml/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  module.exports = function() {
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
    }
    function SyntaxError2(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;
      this.name = "SyntaxError";
    }
    peg$subclass(SyntaxError2, Error);
    function parse2(input) {
      var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
        return nodes;
      }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: "\"#\"" }, peg$c5 = undefined, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: "\"[\"" }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: "\"]\"" }, peg$c11 = function(name) {
        addNode(node2("ObjectPath", name, line, column));
      }, peg$c12 = function(name) {
        addNode(node2("ArrayPath", name, line, column));
      }, peg$c13 = function(parts, name) {
        return parts.concat(name);
      }, peg$c14 = function(name) {
        return [name];
      }, peg$c15 = function(name) {
        return name;
      }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: "\".\"" }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: "\"=\"" }, peg$c20 = function(key, value2) {
        addNode(node2("Assign", value2, line, column, key));
      }, peg$c21 = function(chars) {
        return chars.join("");
      }, peg$c22 = function(node3) {
        return node3.value;
      }, peg$c23 = "\"\"\"", peg$c24 = { type: "literal", value: "\"\"\"", description: "\"\\\"\\\"\\\"\"" }, peg$c25 = null, peg$c26 = function(chars) {
        return node2("String", chars.join(""), line, column);
      }, peg$c27 = "\"", peg$c28 = { type: "literal", value: "\"", description: "\"\\\"\"" }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: "\"'''\"" }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: "\"'\"" }, peg$c33 = function(char) {
        return char;
      }, peg$c34 = function(char) {
        return char;
      }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: "\"\\\\\"" }, peg$c37 = function() {
        return "";
      }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: "\"e\"" }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: "\"E\"" }, peg$c42 = function(left2, right2) {
        return node2("Float", parseFloat(left2 + "e" + right2), line, column);
      }, peg$c43 = function(text2) {
        return node2("Float", parseFloat(text2), line, column);
      }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: "\"+\"" }, peg$c46 = function(digits) {
        return digits.join("");
      }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: "\"-\"" }, peg$c49 = function(digits) {
        return "-" + digits.join("");
      }, peg$c50 = function(text2) {
        return node2("Integer", parseInt(text2, 10), line, column);
      }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: "\"true\"" }, peg$c53 = function() {
        return node2("Boolean", true, line, column);
      }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: "\"false\"" }, peg$c56 = function() {
        return node2("Boolean", false, line, column);
      }, peg$c57 = function() {
        return node2("Array", [], line, column);
      }, peg$c58 = function(value2) {
        return node2("Array", value2 ? [value2] : [], line, column);
      }, peg$c59 = function(values) {
        return node2("Array", values, line, column);
      }, peg$c60 = function(values, value2) {
        return node2("Array", values.concat(value2), line, column);
      }, peg$c61 = function(value2) {
        return value2;
      }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: "\",\"" }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: "\"{\"" }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: "\"}\"" }, peg$c68 = function(values) {
        return node2("InlineTable", values, line, column);
      }, peg$c69 = function(key, value2) {
        return node2("InlineTableValue", value2, line, column, key);
      }, peg$c70 = function(digits) {
        return "." + digits;
      }, peg$c71 = function(date) {
        return date.join("");
      }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: "\":\"" }, peg$c74 = function(time) {
        return time.join("");
      }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: "\"T\"" }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: "\"Z\"" }, peg$c79 = function(date, time) {
        return node2("Date", new Date(date + "T" + time + "Z"), line, column);
      }, peg$c80 = function(date, time) {
        return node2("Date", new Date(date + "T" + time), line, column);
      }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: "\"\\n\"" }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: "\"\\r\"" }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: "\"_\"" }, peg$c93 = function() {
        return "";
      }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
        return d.join("");
      }, peg$c97 = "\\\"", peg$c98 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" }, peg$c99 = function() {
        return '"';
      }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" }, peg$c102 = function() {
        return "\\";
      }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: "\"\\\\b\"" }, peg$c105 = function() {
        return "\b";
      }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: "\"\\\\t\"" }, peg$c108 = function() {
        return "\t";
      }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: "\"\\\\n\"" }, peg$c111 = function() {
        return "\n";
      }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: "\"\\\\f\"" }, peg$c114 = function() {
        return "\f";
      }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: "\"\\\\r\"" }, peg$c117 = function() {
        return "\r";
      }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: "\"\\\\U\"" }, peg$c120 = function(digits) {
        return convertCodePoint(digits.join(""));
      }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: "\"\\\\u\"" }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$reportedPos, peg$currPos);
      }
      function offset() {
        return peg$reportedPos;
      }
      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }
      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }
      function expected(description) {
        throw peg$buildException(null, [{ type: "other", description }], peg$reportedPos);
      }
      function error(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }
      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;
          for (p = startPos;p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === "\n") {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }
        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }
        return peg$cachedPosDetails;
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildException(message, expected2, pos) {
        function cleanupExpected(expected3) {
          var i = 1;
          expected3.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });
          while (i < expected3.length) {
            if (expected3[i - 1] === expected3[i]) {
              expected3.splice(i, 1);
            } else {
              i++;
            }
          }
        }
        function buildMessage(expected3, found2) {
          function stringEscape(s) {
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return "\\x" + hex(ch);
            }).replace(/[\u0180-\u0FFF]/g, function(ch) {
              return "\\u0" + hex(ch);
            }).replace(/[\u1080-\uFFFF]/g, function(ch) {
              return "\\u" + hex(ch);
            });
          }
          var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
          for (i = 0;i < expected3.length; i++) {
            expectedDescs[i] = expected3[i].description;
          }
          expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
          foundDesc = found2 ? "\"" + stringEscape(found2) + "\"" : "end of input";
          return "Expected " + expectedDesc + " but " + foundDesc + " found.";
        }
        var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
        if (expected2 !== null) {
          cleanupExpected(expected2);
        }
        return new SyntaxError2(message !== null ? message : buildMessage(expected2, found), expected2, found, pos, posDetails.line, posDetails.column);
      }
      function peg$parsestart() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 0, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseline();
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c1();
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseline() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 1, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpression();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsecomment();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsecomment();
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseNL();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseNL();
                  }
                } else {
                  s5 = peg$c2;
                }
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseNL();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseNL();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseEOF();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseexpression() {
        var s0;
        var key = peg$currPos * 49 + 2, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parsecomment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepath();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetablearray();
            if (s0 === peg$FAILED) {
              s0 = peg$parseassignment();
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 3, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseNL();
          if (s5 === peg$FAILED) {
            s5 = peg$parseEOF();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c5;
          } else {
            peg$currPos = s4;
            s4 = peg$c2;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsepath() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 4, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetable_key();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c9;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c11(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetablearray() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 49 + 5, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c7;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsetable_key();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s6 = peg$c9;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s7 = peg$c9;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c12(s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 6, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedot_ended_table_key_part();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsedot_ended_table_key_part();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsetable_key_part();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsetable_key_part();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key_part() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 7, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c15(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedot_ended_table_key_part() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 8, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseassignment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 9, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsevalue();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c20(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsequoted_key();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsekey() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 10, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseASCII_BASIC();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseASCII_BASIC();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c21(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsequoted_key() {
        var s0, s1;
        var key = peg$currPos * 49 + 11, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedouble_quoted_single_line_string();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsesingle_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsevalue() {
        var s0;
        var key = peg$currPos * 49 + 12, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedatetime();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefloat();
            if (s0 === peg$FAILED) {
              s0 = peg$parseinteger();
              if (s0 === peg$FAILED) {
                s0 = peg$parseboolean();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsearray();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseinline_table();
                  }
                }
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring() {
        var s0;
        var key = peg$currPos * 49 + 13, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parsedouble_quoted_multiline_string();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_quoted_single_line_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesingle_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_single_line_string();
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 14, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_string_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_string_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s4 = peg$c23;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 15, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsestring_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsestring_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 16, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s1 = peg$c29;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_literal_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_literal_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c29) {
                s4 = peg$c29;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 17, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseliteral_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseliteral_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c31;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 18, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c27;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseliteral_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 19, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 20, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemultiline_string_delim();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s2 = peg$c23;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c34(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_delim() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 21, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseNLS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseNLS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c37();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_literal_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 22, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s2 = peg$c29;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 23, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsefloat_text();
        if (s1 === peg$FAILED) {
          s1 = peg$parseinteger_text();
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 101) {
            s2 = peg$c38;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
              s2 = peg$c40;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c41);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseinteger_text();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c42(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c43(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat_text() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 24, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseDIGITS();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGITS();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c46(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c49(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger() {
        var s0, s1;
        var key = peg$currPos * 49 + 25, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseinteger_text();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c50(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger_text() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 26, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c5;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseboolean() {
        var s0, s1;
        var key = peg$currPos * 49 + 27, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c51) {
          s1 = peg$c51;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c54) {
            s1 = peg$c54;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c55);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c56();
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 28, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearray_sep();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_sep();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearray_value();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c58(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_value_list();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsearray_value_list();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c59(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsearray_value();
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s4 = peg$c9;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c60(s2, s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 29, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c61(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 30, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c62;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c63);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsearray_sep();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsearray_sep();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_sep() {
        var s0;
        var key = peg$currPos * 49 + 31, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseS();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecomment();
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 32, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c64;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseinline_table_assignment();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseinline_table_assignment();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s5 = peg$c66;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c68(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table_assignment() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 33, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s4 = peg$c18;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsevalue();
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parseS();
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseS();
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s8 = peg$c62;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c63);
                        }
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = [];
                        s10 = peg$parseS();
                        while (s10 !== peg$FAILED) {
                          s9.push(s10);
                          s10 = peg$parseS();
                        }
                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c69(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesecfragment() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 34, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDIGITS();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c70(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        var key = peg$currPos * 49 + 35, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDIGIT_OR_UNDER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s6 = peg$c47;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c48);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDIGIT_OR_UNDER();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 45) {
                        s9 = peg$c47;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c48);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseDIGIT_OR_UNDER();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseDIGIT_OR_UNDER();
                          if (s11 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 36, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime_with_offset() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
        var key = peg$currPos * 49 + 37, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s11 = peg$c47;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s11 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 43) {
                              s11 = peg$c44;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c45);
                              }
                            }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseDIGIT_OR_UNDER();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseDIGIT_OR_UNDER();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 58) {
                                  s14 = peg$c72;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c73);
                                  }
                                }
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parseDIGIT_OR_UNDER();
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseDIGIT_OR_UNDER();
                                    if (s16 !== peg$FAILED) {
                                      s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                      s1 = s2;
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedatetime() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 38, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedate();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 84) {
            s2 = peg$c75;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetime();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 90) {
                s4 = peg$c77;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c79(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime_with_offset();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c80(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseS() {
        var s0;
        var key = peg$currPos * 49 + 39, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c81.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNL() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 40, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c83;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c85;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s2 = peg$c83;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNLS() {
        var s0;
        var key = peg$currPos * 49 + 41, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseNL();
        if (s0 === peg$FAILED) {
          s0 = peg$parseS();
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        var key = peg$currPos * 49 + 42, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = peg$c5;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseHEX() {
        var s0;
        var key = peg$currPos * 49 + 43, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c87.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGIT_OR_UNDER() {
        var s0, s1;
        var key = peg$currPos * 49 + 44, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 95) {
            s1 = peg$c91;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c93();
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseASCII_BASIC() {
        var s0;
        var key = peg$currPos * 49 + 45, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c94.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGITS() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 46, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseDIGIT_OR_UNDER();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c96(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED() {
        var s0, s1;
        var key = peg$currPos * 49 + 47, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c97) {
          s1 = peg$c97;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c99();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s1 = peg$c100;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c101);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c102();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c103) {
              s1 = peg$c103;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c104);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c105();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c106) {
                s1 = peg$c106;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c107);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c108();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c109) {
                  s1 = peg$c109;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c110);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c111();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c112) {
                    s1 = peg$c112;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c113);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c114();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c115) {
                      s1 = peg$c115;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c116);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c117();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseESCAPED_UNICODE();
                    }
                  }
                }
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED_UNICODE() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 48, cached = peg$cache[key];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c118) {
          s1 = peg$c118;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseHEX();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseHEX();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHEX();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseHEX();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseHEX();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseHEX();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseHEX();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseHEX();
                        if (s10 !== peg$FAILED) {
                          s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                          s2 = s3;
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c120(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s3 = [s3, s4, s5, s6];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      var nodes = [];
      function genError(err, line2, col) {
        var ex = new Error(err);
        ex.line = line2;
        ex.column = col;
        throw ex;
      }
      function addNode(node3) {
        nodes.push(node3);
      }
      function node2(type, value2, line2, column2, key) {
        var obj = { type, value: value2, line: line2(), column: column2() };
        if (key)
          obj.key = key;
        return obj;
      }
      function convertCodePoint(str, line2, col) {
        var num = parseInt("0x" + str);
        if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
          genError("Invalid Unicode escape code: " + str, line2, col);
        } else {
          return fromCodePoint(num);
        }
      }
      function fromCodePoint() {
        var MAX_SIZE = 16384;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return "";
        }
        var result = "";
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: "end", description: "end of input" });
        }
        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }
    return {
      SyntaxError: SyntaxError2,
      parse: parse2
    };
  }();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/toml/lib/compiler.js
var require_compiler = __commonJS((exports, module) => {
  var compile = function(nodes) {
    var assignedPaths = [];
    var valueAssignments = [];
    var currentPath = "";
    var data = Object.create(null);
    var context = data;
    var arrayMode = false;
    return reduce(nodes);
    function reduce(nodes2) {
      var node2;
      for (var i = 0;i < nodes2.length; i++) {
        node2 = nodes2[i];
        switch (node2.type) {
          case "Assign":
            assign(node2);
            break;
          case "ObjectPath":
            setPath(node2);
            break;
          case "ArrayPath":
            addTableArray(node2);
            break;
        }
      }
      return data;
    }
    function genError(err, line, col) {
      var ex = new Error(err);
      ex.line = line;
      ex.column = col;
      throw ex;
    }
    function assign(node2) {
      var key = node2.key;
      var value2 = node2.value;
      var line = node2.line;
      var column = node2.column;
      var fullPath;
      if (currentPath) {
        fullPath = currentPath + "." + key;
      } else {
        fullPath = key;
      }
      if (typeof context[key] !== "undefined") {
        genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
      }
      context[key] = reduceValueNode(value2);
      if (!pathAssigned(fullPath)) {
        assignedPaths.push(fullPath);
        valueAssignments.push(fullPath);
      }
    }
    function pathAssigned(path) {
      return assignedPaths.indexOf(path) !== -1;
    }
    function reduceValueNode(node2) {
      if (node2.type === "Array") {
        return reduceArrayWithTypeChecking(node2.value);
      } else if (node2.type === "InlineTable") {
        return reduceInlineTableNode(node2.value);
      } else {
        return node2.value;
      }
    }
    function reduceInlineTableNode(values) {
      var obj = Object.create(null);
      for (var i = 0;i < values.length; i++) {
        var val = values[i];
        if (val.value.type === "InlineTable") {
          obj[val.key] = reduceInlineTableNode(val.value.value);
        } else if (val.type === "InlineTableValue") {
          obj[val.key] = reduceValueNode(val.value);
        }
      }
      return obj;
    }
    function setPath(node2) {
      var path = node2.value;
      var quotedPath = path.map(quoteDottedString).join(".");
      var line = node2.line;
      var column = node2.column;
      if (pathAssigned(quotedPath)) {
        genError("Cannot redefine existing key '" + path + "'.", line, column);
      }
      assignedPaths.push(quotedPath);
      context = deepRef(data, path, Object.create(null), line, column);
      currentPath = path;
    }
    function addTableArray(node2) {
      var path = node2.value;
      var quotedPath = path.map(quoteDottedString).join(".");
      var line = node2.line;
      var column = node2.column;
      if (!pathAssigned(quotedPath)) {
        assignedPaths.push(quotedPath);
      }
      assignedPaths = assignedPaths.filter(function(p) {
        return p.indexOf(quotedPath) !== 0;
      });
      assignedPaths.push(quotedPath);
      context = deepRef(data, path, [], line, column);
      currentPath = quotedPath;
      if (context instanceof Array) {
        var newObj = Object.create(null);
        context.push(newObj);
        context = newObj;
      } else {
        genError("Cannot redefine existing key '" + path + "'.", line, column);
      }
    }
    function deepRef(start, keys, value2, line, column) {
      var traversed = [];
      var traversedPath = "";
      var path = keys.join(".");
      var ctx = start;
      for (var i = 0;i < keys.length; i++) {
        var key = keys[i];
        traversed.push(key);
        traversedPath = traversed.join(".");
        if (typeof ctx[key] === "undefined") {
          if (i === keys.length - 1) {
            ctx[key] = value2;
          } else {
            ctx[key] = Object.create(null);
          }
        } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
          genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
        }
        ctx = ctx[key];
        if (ctx instanceof Array && ctx.length && i < keys.length - 1) {
          ctx = ctx[ctx.length - 1];
        }
      }
      return ctx;
    }
    function reduceArrayWithTypeChecking(array) {
      var firstType = null;
      for (var i = 0;i < array.length; i++) {
        var node2 = array[i];
        if (firstType === null) {
          firstType = node2.type;
        } else {
          if (node2.type !== firstType) {
            genError("Cannot add value of type " + node2.type + " to array of type " + firstType + ".", node2.line, node2.column);
          }
        }
      }
      return array.map(reduceValueNode);
    }
    function quoteDottedString(str) {
      if (str.indexOf(".") > -1) {
        return "\"" + str + "\"";
      } else {
        return str;
      }
    }
  };
  module.exports = {
    compile
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/toml/index.js
var require_toml = __commonJS((exports, module) => {
  var parser2 = require_parser();
  var compiler = require_compiler();
  module.exports = {
    parse: function(input) {
      var nodes = parser2.parse(input.toString());
      return compiler.compile(nodes);
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var isCollection = function(node2) {
    if (node2 && typeof node2 === "object")
      switch (node2[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  };
  var isNode = function(node2) {
    if (node2 && typeof node2 === "object")
      switch (node2[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  };
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === ALIAS;
  var isDocument = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === DOC;
  var isMap = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === MAP;
  var isPair = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === PAIR;
  var isScalar = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SCALAR;
  var isSeq = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SEQ;
  var hasAnchor = (node2) => (isScalar(node2) || isCollection(node2)) && !!node2.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var visit = function(node2, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node2)) {
      const cd = visit_(null, node2.contents, visitor_, Object.freeze([node2]));
      if (cd === REMOVE)
        node2.contents = null;
    } else
      visit_(null, node2, visitor_, Object.freeze([]));
  };
  var visit_ = function(key, node2, visitor, path) {
    const ctrl = callVisitor(key, node2, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node2)) {
        path = Object.freeze(path.concat(node2));
        for (let i = 0;i < node2.items.length; ++i) {
          const ci = visit_(i, node2.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node2.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node2)) {
        path = Object.freeze(path.concat(node2));
        const ck = visit_("key", node2.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node2.key = null;
        const cv = visit_("value", node2.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node2.value = null;
      }
    }
    return ctrl;
  };
  async function visitAsync(node2, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node2)) {
      const cd = await visitAsync_(null, node2.contents, visitor_, Object.freeze([node2]));
      if (cd === REMOVE)
        node2.contents = null;
    } else
      await visitAsync_(null, node2, visitor_, Object.freeze([]));
  }
  async function visitAsync_(key, node2, visitor, path) {
    const ctrl = await callVisitor(key, node2, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node2)) {
        path = Object.freeze(path.concat(node2));
        for (let i = 0;i < node2.items.length; ++i) {
          const ci = await visitAsync_(i, node2.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node2.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node2)) {
        path = Object.freeze(path.concat(node2));
        const ck = await visitAsync_("key", node2.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node2.key = null;
        const cv = await visitAsync_("value", node2.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node2.value = null;
      }
    }
    return ctrl;
  }
  var initVisitor = function(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  };
  var callVisitor = function(key, node2, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node2, path);
    if (identity.isMap(node2))
      return visitor.Map?.(key, node2, path);
    if (identity.isSeq(node2))
      return visitor.Seq?.(key, node2, path);
    if (identity.isPair(node2))
      return visitor.Pair?.(key, node2, path);
    if (identity.isScalar(node2))
      return visitor.Scalar?.(key, node2, path);
    if (identity.isAlias(node2))
      return visitor.Alias?.(key, node2, path);
    return;
  };
  var replaceNode = function(key, path, node2) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node2;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node2;
      else
        parent.value = node2;
    } else if (identity.isDocument(parent)) {
      parent.contents = node2;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  };
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version2] = parts;
          if (version2 === "1.1" || version2 === "1.2") {
            this.yaml.version = version2;
            return true;
          } else {
            const isValid2 = /^\d+\.\d+$/.test(version2);
            onError(6, `Unsupported YAML version ${version2}`, isValid2);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node2) => {
          if (identity.isNode(node2) && node2.tag)
            tags[node2.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join("\n");
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var anchorIsValid = function(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  };
  var anchorNames = function(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node2) {
        if (node2.anchor)
          anchors.add(node2.anchor);
      }
    });
    return anchors;
  };
  var findNewAnchor = function(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  };
  var createNodeAnchors = function(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        if (!prevAnchors)
          prevAnchors = anchorNames(doc);
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  };
  var identity = require_identity();
  var visit = require_visit();
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  var applyReviver = function(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v12 = applyReviver(reviver, val, String(i), v0);
          if (v12 === undefined)
            delete val[i];
          else if (v12 !== v0)
            val[i] = v12;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v12 = applyReviver(reviver, val, k, v0);
          if (v12 === undefined)
            val.delete(k);
          else if (v12 !== v0)
            val.set(k, v12);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v12 = applyReviver(reviver, val, v0, v0);
          if (v12 === undefined)
            val.delete(v0);
          else if (v12 !== v0) {
            val.delete(v0);
            val.add(v12);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v12 = applyReviver(reviver, val, k, v0);
          if (v12 === undefined)
            delete val[k];
          else if (v12 !== v0)
            val[k] = v12;
        }
      }
    }
    return reviver.call(obj, key, val);
  };
  exports.applyReviver = applyReviver;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var toJS = function(value2, arg, ctx) {
    if (Array.isArray(value2))
      return value2.map((v, i) => toJS(v, String(i), ctx));
    if (value2 && typeof value2.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value2))
        return value2.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value2, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value2.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value2 === "bigint" && !ctx?.keep)
      return Number(value2);
    return value2;
  };
  var identity = require_identity();
  exports.toJS = toJS;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var getAliasCount = function(doc, node2, anchors2) {
    if (identity.isAlias(node2)) {
      const source = node2.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node2)) {
      let count = 0;
      for (const item of node2.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node2)) {
      const kc = getAliasCount(doc, node2.key, anchors2);
      const vc = getAliasCount(doc, node2.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  };
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc) {
      let found = undefined;
      visit.visit(doc, {
        Node: (_key, node2) => {
          if (node2 === this)
            return visit.visit.BREAK;
          if (node2.anchor === this.source)
            found = node2;
        }
      });
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (!data || data.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  exports.Alias = Alias;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value2) {
      super(identity.SCALAR);
      this.value = value2;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var findTagObject = function(value2, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value2) && !t.format);
  };
  var createNode = function(value2, tagName, ctx) {
    if (identity.isDocument(value2))
      value2 = value2.contents;
    if (identity.isNode(value2))
      return value2;
    if (identity.isPair(value2)) {
      const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value2);
      return map;
    }
    if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt !== "undefined" && value2 instanceof BigInt) {
      value2 = value2.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
      ref = sourceObjects.get(value2);
      if (ref) {
        if (!ref.anchor)
          ref.anchor = onAnchor(value2);
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value2, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value2, tagName, schema.tags);
    if (!tagObj) {
      if (value2 && typeof value2.toJSON === "function") {
        value2 = value2.toJSON();
      }
      if (!value2 || typeof value2 !== "object") {
        const node3 = new Scalar.Scalar(value2);
        if (ref)
          ref.node = node3;
        return node3;
      }
      tagObj = value2 instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value2)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node2 = tagObj?.createNode ? tagObj.createNode(ctx.schema, value2, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value2, ctx) : new Scalar.Scalar(value2);
    if (tagName)
      node2.tag = tagName;
    else if (!tagObj.default)
      node2.tag = tagObj.tag;
    if (ref)
      ref.node = node2;
    return node2;
  };
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  exports.createNode = createNode;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var collectionFromPath = function(schema, path, value2) {
    let v = value2;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  };
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value2) {
      if (isEmptyPath(path))
        this.add(value2);
      else {
        const [key, ...rest] = path;
        const node2 = this.get(key, true);
        if (identity.isCollection(node2))
          node2.addIn(rest, value2);
        else if (node2 === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value2));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node2 = this.get(key, true);
      if (identity.isCollection(node2))
        return node2.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node2 = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node2) ? node2.value : node2;
      else
        return identity.isCollection(node2) ? node2.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node2) => {
        if (!identity.isPair(node2))
          return false;
        const n = node2.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node2 = this.get(key, true);
      return identity.isCollection(node2) ? node2.hasIn(rest) : false;
    }
    setIn(path, value2) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value2);
      } else {
        const node2 = this.get(key, true);
        if (identity.isCollection(node2))
          node2.setIn(rest, value2);
        else if (node2 === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value2));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  Collection.maxFlowStringSingleLineLength = 60;
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var indentComment = function(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  };
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var foldFlowLines = function(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === "\n") {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i);
        end = i + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== "\n" && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `\n${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `\n${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  };
  var consumeMoreIndentedLines = function(text, i) {
    let ch = text[i + 1];
    while (ch === " " || ch === "\t") {
      do {
        ch = text[i += 1];
      } while (ch && ch !== "\n");
      ch = text[i + 1];
    }
    return i;
  };
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var lineLengthOverLimit = function(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === "\n") {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  };
  var doubleQuotedString = function(value2, ctx) {
    const json = JSON.stringify(value2);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + "\n\n";
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += "\n";
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  };
  var singleQuotedString = function(value2, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
      return doubleQuotedString(value2, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
    const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `\$&\n${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  };
  var quotedString = function(value2, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value2.includes('"');
      const hasSingle = value2.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value2, ctx);
  };
  var blockString = function({ comment, type, value: value2 }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
      return quotedString(value2, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
    if (!value2)
      return literal ? "|\n" : ">\n";
    let chomp;
    let endStart;
    for (endStart = value2.length;endStart > 0; --endStart) {
      const ch = value2[endStart - 1];
      if (ch !== "\n" && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value2.substring(endStart);
    const endNlPos = end.indexOf("\n");
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value2 === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value2 = value2.slice(0, -end.length);
      if (end[end.length - 1] === "\n")
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `\$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value2.length; ++startEnd) {
      const ch = value2[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === "\n")
        startNlPos = startEnd;
      else
        break;
    }
    let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value2 = value2.substring(start.length);
      start = start.replace(/\n+/g, `\$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (literal) {
      value2 = value2.replace(/\n+/g, `\$&${indent}`);
      return `${header}\n${indent}${start}${value2}${end}`;
    }
    value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `\$&${indent}`);
    const body = foldFlowLines.foldFlowLines(`${start}${value2}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
  };
  var plainString = function(item, ctx, onComment, onChompKeep) {
    const { type, value: value2 } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value2.includes("\n") || inFlow && /[[\]{},]/.test(value2)) {
      return quotedString(value2, ctx);
    }
    if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
      return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value2.includes("\n")) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value2)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value2, ctx);
      }
    }
    const str = value2.replace(/\n+/g, `\$&\n${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value2, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  };
  var stringifyString = function(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  };
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  exports.stringifyString = stringifyString;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringify.js
var require_stringify2 = __commonJS((exports) => {
  var createStringifyContext = function(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  };
  var getTagObject = function(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      const match = tags.filter((t) => t.identify?.(obj));
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? typeof obj;
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  };
  var stringifyProps = function(node2, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node2) || identity.isCollection(node2)) && node2.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node2.tag ? node2.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  };
  var stringify2 = function(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node2 = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    if (!tagObj)
      tagObj = getTagObject(ctx.doc.schema.tags, node2);
    const props = stringifyProps(node2, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node2, ctx, onComment, onChompKeep) : identity.isScalar(node2) ? stringifyString.stringifyString(node2, ctx, onComment, onChompKeep) : node2.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node2) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
  };
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var stringifyPair = function({ key, value: value2 }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key)) {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value2 == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}\n${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value2)) {
      vsb = !!value2.spaceBefore;
      vcb = value2.commentBefore;
      valueComment = value2.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value2 && typeof value2 === "object")
        value2 = doc.createNode(value2);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value2))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify2.stringify(value2, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? "\n" : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === "\n")
          ws = "\n\n";
      } else {
        ws += `\n${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value2)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf("\n");
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value2.flow ?? value2.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `\n${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === "\n") {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  };
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify2 = require_stringify2();
  var stringifyComment = require_stringifyComment();
  exports.stringifyPair = stringifyPair;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var debug = function(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  };
  var warn = function(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof process !== "undefined" && process.emitWarning)
        process.emitWarning(warning);
      else
        console.warn(warning);
    }
  };
  exports.debug = debug;
  exports.warn = warn;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var addPairToJSMap = function(ctx, map, { key, value: value2 }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
      value2 = identity.isAlias(value2) ? value2.resolve(ctx.doc) : value2;
      if (identity.isSeq(value2))
        for (const it of value2.items)
          mergeToJSMap(ctx, map, it);
      else if (Array.isArray(value2))
        for (const it of value2)
          mergeToJSMap(ctx, map, it);
      else
        mergeToJSMap(ctx, map, value2);
    } else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map instanceof Map) {
        map.set(jsKey, toJS.toJS(value2, jsKey, ctx));
      } else if (map instanceof Set) {
        map.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value2, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  };
  var mergeToJSMap = function(ctx, map, value2) {
    const source = ctx && identity.isAlias(value2) ? value2.resolve(ctx.doc) : value2;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value3] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value3);
      } else if (map instanceof Set) {
        map.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
        Object.defineProperty(map, key, {
          value: value3,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map;
  };
  var stringifyKey = function(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify2.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node2 of ctx.anchors.keys())
        strCtx.anchors.add(node2.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  };
  var log = require_log();
  var stringify2 = require_stringify2();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();
  var MERGE_KEY = "<<";
  var isMergeKey = (key) => key === MERGE_KEY || identity.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
  exports.addPairToJSMap = addPairToJSMap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createPair = function(key, value2, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value2, undefined, ctx);
    return new Pair(k, v);
  };
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();

  class Pair {
    constructor(key, value2 = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value2;
    }
    clone(schema) {
      let { key, value: value2 } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value2))
        value2 = value2.clone(schema);
      return new Pair(key, value2);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var stringifyCollection = function(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify3(collection, ctx, options);
  };
  var stringifyBlockCollection = function({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify2.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `\n${indent}${line}` : "\n";
      }
    }
    if (comment) {
      str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  };
  var stringifyFlowCollection = function({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment2 = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment2 = ik.comment;
        }
      }
      if (comment2)
        reqNewline = true;
      let str2 = stringify2.stringify(item, itemCtx, () => comment2 = null);
      if (i < items.length - 1)
        str2 += ",";
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
        reqNewline = true;
      lines.push(str2);
      linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0) {
      str = start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
      }
      if (reqNewline) {
        str = start;
        for (const line of lines)
          str += line ? `\n${indentStep}${indent}${line}` : "\n";
        str += `\n${indent}${end}`;
      } else {
        str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
    if (comment) {
      str += stringifyComment.lineComment(str, indent, commentString(comment));
      if (onComment)
        onComment();
    }
    return str;
  };
  var addCommentBefore = function({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  };
  var Collection = require_Collection();
  var identity = require_identity();
  var stringify2 = require_stringify2();
  var stringifyComment = require_stringifyComment();
  exports.stringifyCollection = stringifyCollection;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var findPair = function(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  };
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value2) => {
        if (typeof replacer === "function")
          value2 = replacer.call(obj, key, value2);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value2 !== undefined || keepUndefined)
          map.items.push(Pair.createPair(key, value2, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value2] of obj)
          add(key, value2);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map.items.sort(schema.sortMapEntries);
      }
      return map;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node2 = it?.value;
      return (!keepScalar && identity.isScalar(node2) ? node2.value : node2) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value2) {
      this.add(new Pair.Pair(key, value2), true);
    }
    toJSON(_, ctx, Type) {
      const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!identity.isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var asItemIndex = function(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  };
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value2) {
      this.items.push(value2);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value2) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value2))
        prev.value = value2;
      else
        this.items[idx] = value2;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  exports.YAMLSeq = YAMLSeq;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value2) => typeof value2 === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value2) => value2 == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value2) => typeof value2 === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value: value2 }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value2 === sv)
          return source;
      }
      return value2 ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  var stringifyNumber = function({ format: format3, minFractionDigits, tag, value: value2 }) {
    if (typeof value2 === "bigint")
      return String(value2);
    const num = typeof value2 === "number" ? value2 : Number(value2);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value2);
    if (!format3 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  };
  exports.stringifyNumber = stringifyNumber;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node2) {
      const num = Number(node2.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node2);
    }
  };
  var float = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node2 = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node2.minFractionDigits = str.length - dot - 1;
      return node2;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var intStringify = function(node2, radix, prefix) {
    const { value: value2 } = node2;
    if (intIdentify(value2) && value2 >= 0)
      return prefix + value2.toString(radix);
    return stringifyNumber.stringifyNumber(node2);
  };
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  var intOct = {
    identify: (value2) => intIdentify(value2) && value2 >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node2) => intStringify(node2, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value2) => intIdentify(value2) && value2 >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node2) => intStringify(node2, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var intIdentify = function(value2) {
    return typeof value2 === "bigint" || Number.isInteger(value2);
  };
  var Scalar = require_Scalar();
  var map = require_map();
  var seq = require_seq();
  var stringifyJSON = ({ value: value2 }) => JSON.stringify(value2);
  var jsonScalars = [
    {
      identify: (value2) => typeof value2 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value2) => value2 == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value2) => typeof value2 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value: value2 }) => intIdentify(value2) ? value2.toString() : JSON.stringify(value2)
    },
    {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value2) => value2 instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof Buffer === "function") {
        return Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value: value2 }, ctx, onComment, onChompKeep) {
      const buf = value2;
      let str;
      if (typeof Buffer === "function") {
        str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      if (!type)
        type = Scalar.Scalar.BLOCK_LITERAL;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var resolvePairs = function(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  };
  var createPairs = function(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value2;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value2 = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value2 = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value2, ctx));
      }
    return pairs2;
  };
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value2;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value2 = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value2);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value2) => value2 instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var boolStringify = function({ value: value2, source }, ctx) {
    const boolObj = value2 ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value2 ? ctx.options.trueStr : ctx.options.falseStr;
  };
  var Scalar = require_Scalar();
  var trueTag = {
    identify: (value2) => value2 === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value2) => value2 === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node2) {
      const num = Number(node2.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node2);
    }
  };
  var float = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node2 = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node2.minFractionDigits = f.length;
      }
      return node2;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var intResolve = function(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  };
  var intStringify = function(node2, radix, prefix) {
    const { value: value2 } = node2;
    if (intIdentify(value2)) {
      const str = value2.toString(radix);
      return value2 < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node2);
  };
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node2) => intStringify(node2, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node2) => intStringify(node2, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node2) => intStringify(node2, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value2) {
      if (typeof value2 !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value2) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value2) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value2 of iterable) {
          if (typeof replacer === "function")
            value2 = replacer.call(iterable, value2, value2);
          set2.items.push(Pair.createPair(value2, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value2) => value2 instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if (identity.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var parseSexagesimal = function(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  };
  var stringifySexagesimal = function(node2) {
    let { value: value2 } = node2;
    let num = (n) => n;
    if (typeof value2 === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value2) || !isFinite(value2))
      return stringifyNumber.stringifyNumber(node2);
    let sign = "";
    if (value2 < 0) {
      sign = "-";
      value2 *= num(-1);
    }
    const _60 = num(60);
    const parts = [value2 % _60];
    if (value2 < 60) {
      parts.unshift(0);
    } else {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2 % _60);
      if (value2 >= 60) {
        value2 = (value2 - parts[0]) / _60;
        parts.unshift(value2);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  };
  var stringifyNumber = require_stringifyNumber();
  var intTime = {
    identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value2) => value2 instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var getTags = function(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    return tags.map((tag) => {
      if (typeof tag !== "string")
        return tag;
      const tagObj = tagsByName[tag];
      if (tagObj)
        return tagObj;
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
  };
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.merge = !!merge;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var stringifyDocument = function(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify2.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify2.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes("\n")) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join("\n") + "\n";
  };
  var identity = require_identity();
  var stringify2 = require_stringify2();
  var stringifyComment = require_stringifyComment();
  exports.stringifyDocument = stringifyDocument;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var assertCollection = function(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  };
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value2, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version: version2 } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version2 = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version: version2 });
      this.setSchema(version2, options);
      this.contents = value2 === undefined ? null : this.createNode(value2, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value2) {
      if (assertCollection(this.contents))
        this.contents.add(value2);
    }
    addIn(path, value2) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value2);
    }
    createAlias(node2, name) {
      if (!node2.anchor) {
        const prev = anchors.anchorNames(this);
        node2.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node2.anchor);
    }
    createNode(value2, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value2 = replacer.call({ "": value2 }, "", value2);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node2 = createNode.createNode(value2, tag, ctx);
      if (flow && identity.isCollection(node2))
        node2.flow = true;
      setAnchors();
      return node2;
    }
    createPair(key, value2, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value2, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value2) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value2);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value2);
      }
    }
    setIn(path, value2) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value2;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value2);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value2);
      }
    }
    setSchema(version2, options = {}) {
      if (typeof version2 === "number")
        version2 = String(version2);
      let opt;
      switch (version2) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version2;
          else
            this.directives = new directives.Directives({ version: version2 });
          opt = { merge: false, resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version2);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  exports.Document = Document;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `\u2026
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end && end.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  var resolveProps = function(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      switch (token.type) {
        case "space":
          if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "\t")
            onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            hasNewlineAfterProp = true;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = false;
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      hasNewlineAfterProp,
      anchor,
      tag,
      end,
      start: start ?? end
    };
  };
  exports.resolveProps = resolveProps;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  var containsNewline = function(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes("\n"))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  };
  exports.containsNewline = containsNewline;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var flowIndentCheck = function(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  };
  var utilContainsNewline = require_util_contains_newline();
  exports.flowIndentCheck = flowIndentCheck;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var mapIncludes = function(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
    return items.some((pair) => isEqual(pair.key, search));
  };
  var identity = require_identity();
  exports.mapIncludes = mapIncludes;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var resolveBlockMap = function({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value: value2 } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += "\n" + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value2?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value2 ? composeNode(ctx, value2, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value2, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
  };
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  exports.resolveBlockMap = resolveBlockMap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var resolveBlockSeq = function({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value: value2 } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value2,
        offset,
        onError,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value2) {
          if (value2 && value2.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node2 = value2 ? composeNode(ctx, value2, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value2, onError);
      offset = node2.range[2];
      seq.items.push(node2);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  };
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  exports.resolveBlockSeq = resolveBlockSeq;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  var resolveEnd = function(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  };
  exports.resolveEnd = resolveEnd;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var resolveFlowCollection = function({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value: value2 } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value2) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += "\n" + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += "\n" + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value2 ? composeNode(ctx, value2, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value2))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value2,
          offset: keyNode.range[2],
          onError,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value2) {
          if ("source" in value2 && value2.source && value2.source[0] === ":")
            onError(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value2 ? composeNode(ctx, value2, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value2))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new YAMLMap.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += "\n" + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  };
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  exports.resolveFlowCollection = resolveFlowCollection;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var resolveCollection = function(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  };
  var composeCollection = function(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq" || !expType) {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt?.collection) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node2 = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node2.range = coll.range;
    node2.tag = tagName;
    if (tag?.format)
      node2.format = tag.format;
    return node2;
  };
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  exports.composeCollection = composeCollection;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var resolveBlockScalar = function(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value2 = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value2 += lines[i][0].slice(trimIndent) + "\n";
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value2 += sep + indent.slice(trimIndent) + content;
        sep = "\n";
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = "\n";
        else if (!prevMoreIndented && sep === "\n")
          sep = "\n\n";
        value2 += sep + indent.slice(trimIndent) + content;
        sep = "\n";
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === "\n")
          value2 += "\n";
        else
          sep = "\n";
      } else {
        value2 += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value2 += "\n" + lines[i][0].slice(trimIndent);
        if (value2[value2.length - 1] !== "\n")
          value2 += "\n";
        break;
      default:
        value2 += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end, end] };
  };
  var parseBlockScalarHeader = function({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  };
  var splitLines = function(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  };
  var Scalar = require_Scalar();
  exports.resolveBlockScalar = resolveBlockScalar;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var resolveFlowScalar = function(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value2;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value2 = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value2 = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value2 = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value: value2,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  };
  var plainValue = function(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  };
  var singleQuotedValue = function(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  };
  var foldLines = function(source) {
    let first, line;
    try {
      first = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy");
      line = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy");
    } catch (_) {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === "\n")
          res += sep;
        else
          sep = "\n";
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  };
  var doubleQuotedValue = function(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === "\n")
        continue;
      if (ch === "\n") {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === "\n") {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === "\n") {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  };
  var foldNewline = function(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === "\n" || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== "\n")
        break;
      if (ch === "\n")
        fold += "\n";
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  };
  var parseCharCode = function(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  };
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  var escapeCodes = {
    "0": "\0",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    v: "\v",
    N: "\x85",
    _: "\xA0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  exports.resolveFlowScalar = resolveFlowScalar;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var composeScalar = function(ctx, token, tagToken, onError) {
    const { value: value2, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value2, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value2, token, onError) : ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value2, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value2);
    }
    scalar.range = range;
    scalar.source = value2;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  };
  var findScalarTagByName = function(schema, value2, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value2))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  };
  var findScalarTagByTest = function({ directives, schema }, value2, token, onError) {
    const tag = schema.tags.find((tag2) => tag2.default && tag2.test?.test(value2)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value2)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  };
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  exports.composeScalar = composeScalar;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  var emptyScalarPosition = function(offset, before, pos) {
    if (before) {
      if (pos === null)
        pos = before.length;
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  };
  exports.emptyScalarPosition = emptyScalarPosition;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var composeNode = function(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node2;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node2 = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node2 = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node2.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node2 = composeCollection.composeCollection(CN, ctx, token, tag, onError);
        if (anchor)
          node2.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node2 = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node2.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (spaceBefore)
      node2.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node2.comment = comment;
      else
        node2.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node2.srcToken = token;
    return node2;
  };
  var composeEmptyNode = function(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node2 = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node2.anchor = anchor.source.substring(1);
      if (node2.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node2.spaceBefore = true;
    if (comment) {
      node2.comment = comment;
      node2.range[2] = end;
    }
    return node2;
  };
  var composeAlias = function({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  };
  var Alias = require_Alias();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var composeDoc = function(options, directives, { offset, start, value: value2, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value2 ?? end?.[0],
      offset,
      onError,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value2 ? composeNode.composeNode(ctx, value2, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  };
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  exports.composeDoc = composeDoc;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var getErrorPos = function(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  };
  var parsePrelude = function(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  };
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();

  class Composer3 {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}\n${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer3;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveAsScalar = function(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
      }
    }
    return null;
  };
  var createScalarToken = function(value2, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value: value2 }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: "\n" }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf("\n");
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + "\n";
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  };
  var setScalarValue = function(token, value2, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value: value2 }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  };
  var setBlockScalarValue = function(token, source) {
    const he = source.indexOf("\n");
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + "\n";
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  };
  var addEndtoBlockProps = function(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  };
  var setFlowScalarValue = function(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  };
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringifyToken = function(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  };
  var stringifyItem = function({ start, key, sep, value: value2 }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value2)
      res += stringifyToken(value2);
    return res;
  };
  var stringify2 = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  exports.stringify = stringify2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var visit = function(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  };
  var _visit = function(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  };
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  exports.visit = visit;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var prettyToken = function(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  };
  var tokenType = function(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case "\n":
      case "\r\n":
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  };
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var isEmpty = function(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case "\n":
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  };
  var cst = require_cst();
  var hexDigits = "0123456789ABCDEFabcdef".split("");
  var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
  var invalidFlowScalarChars = ",[]{}".split("");
  var invalidAnchorChars = " ,[]{}\n\r\t".split("");
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === "\n")
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === "\n";
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === "\n" || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf("\n", this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        const cs = line.indexOf("#");
        if (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t")
            dirEnd = cs - 1;
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if (s === "---" && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return "doc";
        } else if (s === "..." && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          return "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf("\n", this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf("\n", cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i = this.pos;ch = this.buffer[i]; ++i) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else
          this.indentNext += this.blockScalarIndent;
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf("\n", cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      if (!this.blockScalarKeep) {
        do {
          let i = nl - 1;
          let ch2 = this.buffer[i];
          if (ch2 === "\r")
            ch2 = this.buffer[--i];
          const lastChar = i;
          while (ch2 === " " || ch2 === "\t")
            ch2 = this.buffer[--i];
          if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
            nl = i;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && next === ",")
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === "\n") {
              i += 1;
              ch = "\n";
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
            break;
          if (ch === "\n") {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && invalidFlowScalarChars.includes(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.includes(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === "\n")
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === "\n")
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/parse/parser.js
var require_parser2 = __commonJS((exports) => {
  var includesToken = function(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  };
  var findNonEmptyIndex = function(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  };
  var isFlowToken = function(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  };
  var getPrevProps = function(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  };
  var getFirstKeyStartProps = function(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {
    }
    return prev.splice(i, prev.length);
  };
  var fixFlowSeqItems = function(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  };
  var cst = require_cst();
  var lexer = require_lexer();

  class Parser2 {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top2 = this.peek(1);
      if (this.type === "doc-end" && (!top2 || top2.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top2)
        return yield* this.stream();
      switch (top2.type) {
        case "document":
          return yield* this.document(top2);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top2);
        case "block-scalar":
          return yield* this.blockScalar(top2);
        case "block-map":
          return yield* this.blockMap(top2);
        case "block-seq":
          return yield* this.blockSequence(top2);
        case "flow-collection":
          return yield* this.flowCollection(top2);
        case "doc-end":
          return yield* this.documentEnd(top2);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top2 = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top2 ? top2.indent : 0;
        } else if (token.type === "flow-collection" && top2.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top2.type) {
          case "document":
            top2.value = token;
            break;
          case "block-scalar":
            top2.props.push(token);
            break;
          case "block-map": {
            const it = top2.items[top2.items.length - 1];
            if (it.value) {
              top2.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top2.items[top2.items.length - 1];
            if (it.value)
              top2.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top2.items[top2.items.length - 1];
            if (!it || it.value)
              top2.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top2.type === "document" || top2.type === "block-map" || top2.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top2.type === "document")
              top2.end = last.start;
            else
              top2.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf("\n", nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
              it.start.push(this.sourceToken);
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken] }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (includesToken(it.start, "explicit-key-ind")) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key, delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                map.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top2;
        do {
          yield* this.pop();
          top2 = this.peek(1);
        } while (top2 && top2.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf("\n") + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf("\n", nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var parseOptions = function(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  };
  var parseAllDocuments = function(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser2.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer5.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  };
  var parseDocument = function(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser2.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer5.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  };
  var parse2 = function(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  };
  var stringify2 = function(value2, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value2 === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    return new Document.Document(value2, _replacer, options).toString(options);
  };
  var composer5 = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log = require_log();
  var lineCounter = require_line_counter();
  var parser2 = require_parser2();
  exports.parse = parse2;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS((exports) => {
  var shallowEqual = function(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = shallowEqual;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS((exports) => {
  var deprecationWarning = function(oldName, newName, prefix = "") {
    if (warnings.has(oldName))
      return;
    warnings.add(oldName);
    const {
      internal,
      trace
    } = captureShortStackTrace(1, 2);
    if (internal) {
      return;
    }
    console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
  };
  var captureShortStackTrace = function(skip, length) {
    const {
      stackTraceLimit,
      prepareStackTrace
    } = Error;
    let stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function(err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace)
      return {
        internal: false,
        trace: ""
      };
    const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = deprecationWarning;
  var warnings = new Set;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS((exports) => {
  var isArrayExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ArrayExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isAssignmentExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "AssignmentExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBinaryExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BinaryExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isInterpreterDirective = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "InterpreterDirective")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDirective = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Directive")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDirectiveLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DirectiveLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBlockStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BlockStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBreakStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BreakStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isCallExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "CallExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isCatchClause = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "CatchClause")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isConditionalExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ConditionalExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isContinueStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ContinueStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDebuggerStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DebuggerStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDoWhileStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DoWhileStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEmptyStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EmptyStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExpressionStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExpressionStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFile = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "File")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isForInStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ForInStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isForStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ForStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFunctionDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "FunctionDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFunctionExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "FunctionExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isIdentifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Identifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isIfStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "IfStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isLabeledStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "LabeledStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isStringLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "StringLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNumericLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NumericLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNullLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NullLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBooleanLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BooleanLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isRegExpLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "RegExpLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isLogicalExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "LogicalExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isMemberExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "MemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNewExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NewExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isProgram = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Program")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectMethod = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isRestElement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "RestElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isReturnStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ReturnStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSequenceExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "SequenceExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isParenthesizedExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ParenthesizedExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSwitchCase = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "SwitchCase")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSwitchStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "SwitchStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isThisExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ThisExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isThrowStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ThrowStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTryStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TryStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isUnaryExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "UnaryExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isUpdateExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "UpdateExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isVariableDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "VariableDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isVariableDeclarator = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "VariableDeclarator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isWhileStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "WhileStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isWithStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "WithStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isAssignmentPattern = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "AssignmentPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isArrayPattern = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ArrayPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isArrowFunctionExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ArrowFunctionExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassBody = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportAllDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExportAllDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportDefaultDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExportDefaultDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportNamedDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExportNamedDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExportSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isForOfStatement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ForOfStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ImportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportDefaultSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ImportDefaultSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportNamespaceSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ImportNamespaceSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ImportSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ImportExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isMetaProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "MetaProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassMethod = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectPattern = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSpreadElement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "SpreadElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSuper = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Super")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTaggedTemplateExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TaggedTemplateExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTemplateElement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TemplateElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTemplateLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TemplateLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isYieldExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "YieldExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isAwaitExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "AwaitExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImport = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Import")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBigIntLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BigIntLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportNamespaceSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExportNamespaceSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isOptionalMemberExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "OptionalMemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isOptionalCallExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "OptionalCallExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassAccessorProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassAccessorProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassPrivateProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassPrivateProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassPrivateMethod = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassPrivateMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPrivateName = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "PrivateName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isStaticBlock = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "StaticBlock")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isAnyTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "AnyTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isArrayTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ArrayTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBooleanTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BooleanTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBooleanLiteralTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BooleanLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNullLiteralTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NullLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClassImplements = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ClassImplements")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareClass = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareClass")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareFunction = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareInterface = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareInterface")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareModule = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareModule")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareModuleExports = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareModuleExports")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareTypeAlias = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareTypeAlias")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareOpaqueType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareOpaqueType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareVariable = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareVariable")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareExportDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareExportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclareExportAllDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclareExportAllDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclaredPredicate = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DeclaredPredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExistsTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExistsTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFunctionTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "FunctionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFunctionTypeParam = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "FunctionTypeParam")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isGenericTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "GenericTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isInferredPredicate = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "InferredPredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isInterfaceExtends = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "InterfaceExtends")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isInterfaceDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "InterfaceDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isInterfaceTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "InterfaceTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isIntersectionTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "IntersectionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isMixedTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "MixedTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEmptyTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EmptyTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNullableTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NullableTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNumberLiteralTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NumberLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNumberTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "NumberTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectTypeInternalSlot = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectTypeInternalSlot")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectTypeCallProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectTypeCallProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectTypeIndexer = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectTypeIndexer")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectTypeProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectTypeProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectTypeSpreadProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ObjectTypeSpreadProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isOpaqueType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "OpaqueType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isQualifiedTypeIdentifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "QualifiedTypeIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isStringLiteralTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "StringLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isStringTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "StringTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSymbolTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "SymbolTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isThisTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ThisTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTupleTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TupleTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeofTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeofTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeAlias = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeAlias")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeCastExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeCastExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeParameter = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeParameter")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeParameterDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeParameterDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeParameterInstantiation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TypeParameterInstantiation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isUnionTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "UnionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isVariance = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Variance")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isVoidTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "VoidTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumBooleanBody = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumBooleanBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumNumberBody = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumNumberBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumStringBody = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumStringBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumSymbolBody = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumSymbolBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumBooleanMember = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumBooleanMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumNumberMember = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumNumberMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumStringMember = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumStringMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumDefaultedMember = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "EnumDefaultedMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isIndexedAccessType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "IndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isOptionalIndexedAccessType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "OptionalIndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXAttribute = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXClosingElement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXClosingElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXElement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXEmptyExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXEmptyExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXExpressionContainer = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXExpressionContainer")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXSpreadChild = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXSpreadChild")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXIdentifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXMemberExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXMemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXNamespacedName = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXNamespacedName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXOpeningElement = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXOpeningElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXSpreadAttribute = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXSpreadAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXText = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXText")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXFragment = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXOpeningFragment = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXOpeningFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSXClosingFragment = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "JSXClosingFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNoop = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Noop")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPlaceholder = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Placeholder")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isV8IntrinsicIdentifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "V8IntrinsicIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isArgumentPlaceholder = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ArgumentPlaceholder")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBindExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "BindExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportAttribute = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ImportAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDecorator = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "Decorator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDoExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DoExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportDefaultSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ExportDefaultSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isRecordExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "RecordExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTupleExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TupleExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDecimalLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "DecimalLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isModuleExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "ModuleExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTopicReference = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TopicReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPipelineTopicExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "PipelineTopicExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPipelineBareFunction = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "PipelineBareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPipelinePrimaryTopicReference = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "PipelinePrimaryTopicReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSParameterProperty = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSParameterProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSDeclareFunction = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSDeclareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSDeclareMethod = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSDeclareMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSQualifiedName = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSQualifiedName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSCallSignatureDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSCallSignatureDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSConstructSignatureDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSConstructSignatureDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSPropertySignature = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSPropertySignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSMethodSignature = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSMethodSignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSIndexSignature = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSIndexSignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSAnyKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSAnyKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSBooleanKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSBooleanKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSBigIntKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSBigIntKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSIntrinsicKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSIntrinsicKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSNeverKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSNeverKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSNullKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSNullKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSNumberKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSNumberKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSObjectKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSObjectKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSStringKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSStringKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSSymbolKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSSymbolKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSUndefinedKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSUndefinedKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSUnknownKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSUnknownKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSVoidKeyword = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSVoidKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSThisType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSThisType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSFunctionType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSFunctionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSConstructorType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSConstructorType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeReference = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypePredicate = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypePredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeQuery = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeQuery")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeLiteral = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSArrayType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSArrayType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTupleType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTupleType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSOptionalType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSOptionalType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSRestType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSRestType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSNamedTupleMember = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSNamedTupleMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSUnionType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSUnionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSIntersectionType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSIntersectionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSConditionalType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSConditionalType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSInferType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSInferType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSParenthesizedType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSParenthesizedType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeOperator = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeOperator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSIndexedAccessType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSIndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSMappedType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSMappedType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSLiteralType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSLiteralType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSExpressionWithTypeArguments = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSExpressionWithTypeArguments")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSInterfaceDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSInterfaceDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSInterfaceBody = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSInterfaceBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeAliasDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeAliasDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSInstantiationExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSInstantiationExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSAsExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSAsExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSSatisfiesExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSSatisfiesExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeAssertion = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeAssertion")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSEnumDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSEnumDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSEnumMember = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSEnumMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSModuleDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSModuleDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSModuleBlock = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSModuleBlock")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSImportType = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSImportType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSImportEqualsDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSImportEqualsDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSExternalModuleReference = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSExternalModuleReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSNonNullExpression = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSNonNullExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSExportAssignment = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSExportAssignment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSNamespaceExportDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSNamespaceExportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeParameterInstantiation = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeParameterInstantiation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeParameterDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeParameterDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeParameter = function(node2, opts) {
    if (!node2)
      return false;
    if (node2.type !== "TSTypeParameter")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isStandardized = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExpression = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBinary = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isScopable = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBlockParent = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isBlock = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isStatement = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTerminatorless = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isCompletionStatement = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isConditional = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isLoop = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isWhile = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExpressionWrapper = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFor = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isForXStatement = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFunction2 = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFunctionParent = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPureish = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Declaration")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPatternLike = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isLVal = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSEntityName = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Identifier")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isLiteral = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImmutable = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isUserWhitespacable = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isMethod = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isObjectMember = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isProperty = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isUnaryLike = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPattern = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Pattern")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isClass = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isImportOrExportDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isExportDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isModuleSpecifier = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isAccessor = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isPrivate = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFlow = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFlowType = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFlowBaseAnnotation = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFlowDeclaration = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isFlowPredicate = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumBody = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isEnumMember = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isJSX = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isMiscellaneous = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTypeScript = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSTypeElement = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSType = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isTSBaseType = function(node2, opts) {
    if (!node2)
      return false;
    switch (node2.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isNumberLiteral = function(node2, opts) {
    (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    if (!node2)
      return false;
    if (node2.type !== "NumberLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isRegexLiteral = function(node2, opts) {
    (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    if (!node2)
      return false;
    if (node2.type !== "RegexLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isRestProperty = function(node2, opts) {
    (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    if (!node2)
      return false;
    if (node2.type !== "RestProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isSpreadProperty = function(node2, opts) {
    (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    if (!node2)
      return false;
    if (node2.type !== "SpreadProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  };
  var isModuleDeclaration = function(node2, opts) {
    (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node2, opts);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAccessor = isAccessor;
  exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
  exports.isArgumentPlaceholder = isArgumentPlaceholder;
  exports.isArrayExpression = isArrayExpression;
  exports.isArrayPattern = isArrayPattern;
  exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
  exports.isArrowFunctionExpression = isArrowFunctionExpression;
  exports.isAssignmentExpression = isAssignmentExpression;
  exports.isAssignmentPattern = isAssignmentPattern;
  exports.isAwaitExpression = isAwaitExpression;
  exports.isBigIntLiteral = isBigIntLiteral;
  exports.isBinary = isBinary;
  exports.isBinaryExpression = isBinaryExpression;
  exports.isBindExpression = isBindExpression;
  exports.isBlock = isBlock;
  exports.isBlockParent = isBlockParent;
  exports.isBlockStatement = isBlockStatement;
  exports.isBooleanLiteral = isBooleanLiteral;
  exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  exports.isBreakStatement = isBreakStatement;
  exports.isCallExpression = isCallExpression;
  exports.isCatchClause = isCatchClause;
  exports.isClass = isClass;
  exports.isClassAccessorProperty = isClassAccessorProperty;
  exports.isClassBody = isClassBody;
  exports.isClassDeclaration = isClassDeclaration;
  exports.isClassExpression = isClassExpression;
  exports.isClassImplements = isClassImplements;
  exports.isClassMethod = isClassMethod;
  exports.isClassPrivateMethod = isClassPrivateMethod;
  exports.isClassPrivateProperty = isClassPrivateProperty;
  exports.isClassProperty = isClassProperty;
  exports.isCompletionStatement = isCompletionStatement;
  exports.isConditional = isConditional;
  exports.isConditionalExpression = isConditionalExpression;
  exports.isContinueStatement = isContinueStatement;
  exports.isDebuggerStatement = isDebuggerStatement;
  exports.isDecimalLiteral = isDecimalLiteral;
  exports.isDeclaration = isDeclaration;
  exports.isDeclareClass = isDeclareClass;
  exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
  exports.isDeclareFunction = isDeclareFunction;
  exports.isDeclareInterface = isDeclareInterface;
  exports.isDeclareModule = isDeclareModule;
  exports.isDeclareModuleExports = isDeclareModuleExports;
  exports.isDeclareOpaqueType = isDeclareOpaqueType;
  exports.isDeclareTypeAlias = isDeclareTypeAlias;
  exports.isDeclareVariable = isDeclareVariable;
  exports.isDeclaredPredicate = isDeclaredPredicate;
  exports.isDecorator = isDecorator;
  exports.isDirective = isDirective;
  exports.isDirectiveLiteral = isDirectiveLiteral;
  exports.isDoExpression = isDoExpression;
  exports.isDoWhileStatement = isDoWhileStatement;
  exports.isEmptyStatement = isEmptyStatement;
  exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  exports.isEnumBody = isEnumBody;
  exports.isEnumBooleanBody = isEnumBooleanBody;
  exports.isEnumBooleanMember = isEnumBooleanMember;
  exports.isEnumDeclaration = isEnumDeclaration;
  exports.isEnumDefaultedMember = isEnumDefaultedMember;
  exports.isEnumMember = isEnumMember;
  exports.isEnumNumberBody = isEnumNumberBody;
  exports.isEnumNumberMember = isEnumNumberMember;
  exports.isEnumStringBody = isEnumStringBody;
  exports.isEnumStringMember = isEnumStringMember;
  exports.isEnumSymbolBody = isEnumSymbolBody;
  exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
  exports.isExportAllDeclaration = isExportAllDeclaration;
  exports.isExportDeclaration = isExportDeclaration;
  exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
  exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
  exports.isExportNamedDeclaration = isExportNamedDeclaration;
  exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  exports.isExportSpecifier = isExportSpecifier;
  exports.isExpression = isExpression;
  exports.isExpressionStatement = isExpressionStatement;
  exports.isExpressionWrapper = isExpressionWrapper;
  exports.isFile = isFile;
  exports.isFlow = isFlow;
  exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
  exports.isFlowDeclaration = isFlowDeclaration;
  exports.isFlowPredicate = isFlowPredicate;
  exports.isFlowType = isFlowType;
  exports.isFor = isFor;
  exports.isForInStatement = isForInStatement;
  exports.isForOfStatement = isForOfStatement;
  exports.isForStatement = isForStatement;
  exports.isForXStatement = isForXStatement;
  exports.isFunction = isFunction2;
  exports.isFunctionDeclaration = isFunctionDeclaration;
  exports.isFunctionExpression = isFunctionExpression;
  exports.isFunctionParent = isFunctionParent;
  exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  exports.isFunctionTypeParam = isFunctionTypeParam;
  exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
  exports.isIdentifier = isIdentifier;
  exports.isIfStatement = isIfStatement;
  exports.isImmutable = isImmutable;
  exports.isImport = isImport;
  exports.isImportAttribute = isImportAttribute;
  exports.isImportDeclaration = isImportDeclaration;
  exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
  exports.isImportExpression = isImportExpression;
  exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
  exports.isImportSpecifier = isImportSpecifier;
  exports.isIndexedAccessType = isIndexedAccessType;
  exports.isInferredPredicate = isInferredPredicate;
  exports.isInterfaceDeclaration = isInterfaceDeclaration;
  exports.isInterfaceExtends = isInterfaceExtends;
  exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  exports.isInterpreterDirective = isInterpreterDirective;
  exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  exports.isJSX = isJSX;
  exports.isJSXAttribute = isJSXAttribute;
  exports.isJSXClosingElement = isJSXClosingElement;
  exports.isJSXClosingFragment = isJSXClosingFragment;
  exports.isJSXElement = isJSXElement;
  exports.isJSXEmptyExpression = isJSXEmptyExpression;
  exports.isJSXExpressionContainer = isJSXExpressionContainer;
  exports.isJSXFragment = isJSXFragment;
  exports.isJSXIdentifier = isJSXIdentifier;
  exports.isJSXMemberExpression = isJSXMemberExpression;
  exports.isJSXNamespacedName = isJSXNamespacedName;
  exports.isJSXOpeningElement = isJSXOpeningElement;
  exports.isJSXOpeningFragment = isJSXOpeningFragment;
  exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
  exports.isJSXSpreadChild = isJSXSpreadChild;
  exports.isJSXText = isJSXText;
  exports.isLVal = isLVal;
  exports.isLabeledStatement = isLabeledStatement;
  exports.isLiteral = isLiteral;
  exports.isLogicalExpression = isLogicalExpression;
  exports.isLoop = isLoop;
  exports.isMemberExpression = isMemberExpression;
  exports.isMetaProperty = isMetaProperty;
  exports.isMethod = isMethod;
  exports.isMiscellaneous = isMiscellaneous;
  exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
  exports.isModuleDeclaration = isModuleDeclaration;
  exports.isModuleExpression = isModuleExpression;
  exports.isModuleSpecifier = isModuleSpecifier;
  exports.isNewExpression = isNewExpression;
  exports.isNoop = isNoop;
  exports.isNullLiteral = isNullLiteral;
  exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
  exports.isNumberLiteral = isNumberLiteral;
  exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
  exports.isNumericLiteral = isNumericLiteral;
  exports.isObjectExpression = isObjectExpression;
  exports.isObjectMember = isObjectMember;
  exports.isObjectMethod = isObjectMethod;
  exports.isObjectPattern = isObjectPattern;
  exports.isObjectProperty = isObjectProperty;
  exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
  exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
  exports.isObjectTypeIndexer = isObjectTypeIndexer;
  exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  exports.isObjectTypeProperty = isObjectTypeProperty;
  exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  exports.isOpaqueType = isOpaqueType;
  exports.isOptionalCallExpression = isOptionalCallExpression;
  exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  exports.isOptionalMemberExpression = isOptionalMemberExpression;
  exports.isParenthesizedExpression = isParenthesizedExpression;
  exports.isPattern = isPattern;
  exports.isPatternLike = isPatternLike;
  exports.isPipelineBareFunction = isPipelineBareFunction;
  exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  exports.isPipelineTopicExpression = isPipelineTopicExpression;
  exports.isPlaceholder = isPlaceholder;
  exports.isPrivate = isPrivate;
  exports.isPrivateName = isPrivateName;
  exports.isProgram = isProgram;
  exports.isProperty = isProperty;
  exports.isPureish = isPureish;
  exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  exports.isRecordExpression = isRecordExpression;
  exports.isRegExpLiteral = isRegExpLiteral;
  exports.isRegexLiteral = isRegexLiteral;
  exports.isRestElement = isRestElement;
  exports.isRestProperty = isRestProperty;
  exports.isReturnStatement = isReturnStatement;
  exports.isScopable = isScopable;
  exports.isSequenceExpression = isSequenceExpression;
  exports.isSpreadElement = isSpreadElement;
  exports.isSpreadProperty = isSpreadProperty;
  exports.isStandardized = isStandardized;
  exports.isStatement = isStatement;
  exports.isStaticBlock = isStaticBlock;
  exports.isStringLiteral = isStringLiteral;
  exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  exports.isStringTypeAnnotation = isStringTypeAnnotation;
  exports.isSuper = isSuper;
  exports.isSwitchCase = isSwitchCase;
  exports.isSwitchStatement = isSwitchStatement;
  exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  exports.isTSAnyKeyword = isTSAnyKeyword;
  exports.isTSArrayType = isTSArrayType;
  exports.isTSAsExpression = isTSAsExpression;
  exports.isTSBaseType = isTSBaseType;
  exports.isTSBigIntKeyword = isTSBigIntKeyword;
  exports.isTSBooleanKeyword = isTSBooleanKeyword;
  exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  exports.isTSConditionalType = isTSConditionalType;
  exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  exports.isTSConstructorType = isTSConstructorType;
  exports.isTSDeclareFunction = isTSDeclareFunction;
  exports.isTSDeclareMethod = isTSDeclareMethod;
  exports.isTSEntityName = isTSEntityName;
  exports.isTSEnumDeclaration = isTSEnumDeclaration;
  exports.isTSEnumMember = isTSEnumMember;
  exports.isTSExportAssignment = isTSExportAssignment;
  exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  exports.isTSExternalModuleReference = isTSExternalModuleReference;
  exports.isTSFunctionType = isTSFunctionType;
  exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  exports.isTSImportType = isTSImportType;
  exports.isTSIndexSignature = isTSIndexSignature;
  exports.isTSIndexedAccessType = isTSIndexedAccessType;
  exports.isTSInferType = isTSInferType;
  exports.isTSInstantiationExpression = isTSInstantiationExpression;
  exports.isTSInterfaceBody = isTSInterfaceBody;
  exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  exports.isTSIntersectionType = isTSIntersectionType;
  exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  exports.isTSLiteralType = isTSLiteralType;
  exports.isTSMappedType = isTSMappedType;
  exports.isTSMethodSignature = isTSMethodSignature;
  exports.isTSModuleBlock = isTSModuleBlock;
  exports.isTSModuleDeclaration = isTSModuleDeclaration;
  exports.isTSNamedTupleMember = isTSNamedTupleMember;
  exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  exports.isTSNeverKeyword = isTSNeverKeyword;
  exports.isTSNonNullExpression = isTSNonNullExpression;
  exports.isTSNullKeyword = isTSNullKeyword;
  exports.isTSNumberKeyword = isTSNumberKeyword;
  exports.isTSObjectKeyword = isTSObjectKeyword;
  exports.isTSOptionalType = isTSOptionalType;
  exports.isTSParameterProperty = isTSParameterProperty;
  exports.isTSParenthesizedType = isTSParenthesizedType;
  exports.isTSPropertySignature = isTSPropertySignature;
  exports.isTSQualifiedName = isTSQualifiedName;
  exports.isTSRestType = isTSRestType;
  exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
  exports.isTSStringKeyword = isTSStringKeyword;
  exports.isTSSymbolKeyword = isTSSymbolKeyword;
  exports.isTSThisType = isTSThisType;
  exports.isTSTupleType = isTSTupleType;
  exports.isTSType = isTSType;
  exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  exports.isTSTypeAnnotation = isTSTypeAnnotation;
  exports.isTSTypeAssertion = isTSTypeAssertion;
  exports.isTSTypeElement = isTSTypeElement;
  exports.isTSTypeLiteral = isTSTypeLiteral;
  exports.isTSTypeOperator = isTSTypeOperator;
  exports.isTSTypeParameter = isTSTypeParameter;
  exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  exports.isTSTypePredicate = isTSTypePredicate;
  exports.isTSTypeQuery = isTSTypeQuery;
  exports.isTSTypeReference = isTSTypeReference;
  exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
  exports.isTSUnionType = isTSUnionType;
  exports.isTSUnknownKeyword = isTSUnknownKeyword;
  exports.isTSVoidKeyword = isTSVoidKeyword;
  exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
  exports.isTemplateElement = isTemplateElement;
  exports.isTemplateLiteral = isTemplateLiteral;
  exports.isTerminatorless = isTerminatorless;
  exports.isThisExpression = isThisExpression;
  exports.isThisTypeAnnotation = isThisTypeAnnotation;
  exports.isThrowStatement = isThrowStatement;
  exports.isTopicReference = isTopicReference;
  exports.isTryStatement = isTryStatement;
  exports.isTupleExpression = isTupleExpression;
  exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
  exports.isTypeAlias = isTypeAlias;
  exports.isTypeAnnotation = isTypeAnnotation;
  exports.isTypeCastExpression = isTypeCastExpression;
  exports.isTypeParameter = isTypeParameter;
  exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
  exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
  exports.isTypeScript = isTypeScript;
  exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  exports.isUnaryExpression = isUnaryExpression;
  exports.isUnaryLike = isUnaryLike;
  exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
  exports.isUpdateExpression = isUpdateExpression;
  exports.isUserWhitespacable = isUserWhitespacable;
  exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  exports.isVariableDeclaration = isVariableDeclaration;
  exports.isVariableDeclarator = isVariableDeclarator;
  exports.isVariance = isVariance;
  exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
  exports.isWhile = isWhile;
  exports.isWhileStatement = isWhileStatement;
  exports.isWithStatement = isWithStatement;
  exports.isYieldExpression = isYieldExpression;
  var _shallowEqual = require_shallowEqual();
  var _deprecationWarning = require_deprecationWarning();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS((exports) => {
  var matchesPattern = function(member, match, allowPartial) {
    if (!(0, _index.isMemberExpression)(member))
      return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node2;
    for (node2 = member;(0, _index.isMemberExpression)(node2); node2 = node2.object) {
      nodes.push(node2.property);
    }
    nodes.push(node2);
    if (nodes.length < parts.length)
      return false;
    if (!allowPartial && nodes.length > parts.length)
      return false;
    for (let i = 0, j = nodes.length - 1;i < parts.length; i++, j--) {
      const node3 = nodes[j];
      let value2;
      if ((0, _index.isIdentifier)(node3)) {
        value2 = node3.name;
      } else if ((0, _index.isStringLiteral)(node3)) {
        value2 = node3.value;
      } else if ((0, _index.isThisExpression)(node3)) {
        value2 = "this";
      } else {
        return false;
      }
      if (parts[i] !== value2)
        return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = matchesPattern;
  var _index = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS((exports) => {
  var buildMatchMemberExpression = function(match, allowPartial) {
    const parts = match.split(".");
    return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildMatchMemberExpression;
  var _matchesPattern = require_matchesPattern();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _buildMatchMemberExpression = require_buildMatchMemberExpression();
  var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
  var _default = exports.default = isReactComponent;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS((exports) => {
  var isCompatTag = function(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCompatTag;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS((exports, module) => {
  var FastObject = function(o) {
    if (fastProto !== null && typeof fastProto.property) {
      const result = fastProto;
      fastProto = FastObject.prototype = null;
      return result;
    }
    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject;
  };
  var fastProto = null;
  FastObject();
  module.exports = function toFastproperties(o) {
    return FastObject(o);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS((exports) => {
  var isType = function(nodeType, targetType) {
    if (nodeType === targetType)
      return true;
    if (nodeType == null)
      return false;
    if (_index.ALIAS_KEYS[targetType])
      return false;
    const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
      if (aliases[0] === nodeType)
        return true;
      for (const alias of aliases) {
        if (nodeType === alias)
          return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isType;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS((exports) => {
  var isPlaceholderType = function(placeholderType, targetType) {
    if (placeholderType === targetType)
      return true;
    const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) {
      for (const alias of aliases) {
        if (targetType === alias)
          return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPlaceholderType;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS((exports) => {
  var is = function(type, node2, opts) {
    if (!node2)
      return false;
    const matches = (0, _isType.default)(node2.type, type);
    if (!matches) {
      if (!opts && node2.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType.default)(node2.expectedNode, type);
      }
      return false;
    }
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node2, opts);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = is;
  var _shallowEqual = require_shallowEqual();
  var _isType = require_isType();
  var _isPlaceholderType = require_isPlaceholderType();
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS((exports) => {
  var isInAstralSet = function(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length;i < length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  };
  var isIdentifierStart = function(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  };
  var isIdentifierChar = function(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  };
  var isIdentifierName = function(name) {
    let isFirst = true;
    for (let i = 0;i < name.length; i++) {
      let cp = name.charCodeAt(i);
      if ((cp & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierName = isIdentifierName;
  exports.isIdentifierStart = isIdentifierStart;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS((exports) => {
  var isReservedWord = function(word, inModule) {
    return inModule && word === "await" || word === "enum";
  };
  var isStrictReservedWord = function(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  };
  var isStrictBindOnlyReservedWord = function(word) {
    return reservedWordsStrictBindSet.has(word);
  };
  var isStrictBindReservedWord = function(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  };
  var isKeyword = function(word) {
    return keywords.has(word);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isKeyword = isKeyword;
  exports.isReservedWord = isReservedWord;
  exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  exports.isStrictBindReservedWord = isStrictBindReservedWord;
  exports.isStrictReservedWord = isStrictReservedWord;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  var _identifier = require_identifier();
  var _keyword = require_keyword();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS((exports) => {
  var isValidIdentifier = function(name, reserved = true) {
    if (typeof name !== "string")
      return false;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValidIdentifier;
  var _helperValidatorIdentifier = require_lib();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-string-parser/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var readStringContents = function(type, input, pos, lineStart, curLine, errors2) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (;; ) {
      if (pos >= length) {
        errors2.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors2);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors2.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  };
  var isStringEnd = function(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  };
  var readEscapedChar = function(input, pos, lineStart, curLine, inTemplate, errors2) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors2));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({
          code,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors2));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors2.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors2.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  };
  var readHexChar = function(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors2) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors2, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors2.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  };
  var readInt = function(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors2, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len;i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors2.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors2.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors2.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  };
  var readCodePoint = function(input, pos, lineStart, curLine, throwOnInvalid, errors2) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors2));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors2.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors2));
    }
    return {
      code,
      pos
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.readCodePoint = readCodePoint;
  exports.readInt = readInt;
  exports.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = undefined;
  var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];
  var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
  var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
  var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
  var ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
  var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
  var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
  var INHERIT_KEYS = exports.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  var BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  var NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS((exports) => {
  var getType = function(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  };
  var validate2 = function(validate3) {
    return {
      validate: validate3
    };
  };
  var typeIs = function(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
  };
  var validateType = function(typeName) {
    return validate2(typeIs(typeName));
  };
  var validateOptional = function(validate3) {
    return {
      validate: validate3,
      optional: true
    };
  };
  var validateOptionalType = function(typeName) {
    return {
      validate: typeIs(typeName),
      optional: true
    };
  };
  var arrayOf = function(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  };
  var arrayOfType = function(typeName) {
    return arrayOf(typeIs(typeName));
  };
  var validateArrayOfType = function(typeName) {
    return validate2(arrayOfType(typeName));
  };
  var assertEach = function(callback) {
    function validator2(node2, key, val) {
      if (!Array.isArray(val))
        return;
      for (let i = 0;i < val.length; i++) {
        const subkey = `${key}[${i}]`;
        const v = val[i];
        callback(node2, subkey, v);
        if (process.env.BABEL_TYPES_8_BREAKING)
          (0, _validate.validateChild)(node2, subkey, v);
      }
    }
    validator2.each = callback;
    return validator2;
  };
  var assertOneOf = function(...values) {
    function validate3(node2, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
    }
    validate3.oneOf = values;
    return validate3;
  };
  var assertNodeType = function(...types) {
    function validate3(node2, key, val) {
      for (const type of types) {
        if ((0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node2, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? undefined : val.type)}`);
    }
    validate3.oneOfNodeTypes = types;
    return validate3;
  };
  var assertNodeOrValueType = function(...types) {
    function validate3(node2, key, val) {
      for (const type of types) {
        if (getType(val) === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node2, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? undefined : val.type)}`);
    }
    validate3.oneOfNodeOrValueTypes = types;
    return validate3;
  };
  var assertValueType = function(type) {
    function validate3(node2, key, val) {
      const valid = getType(val) === type;
      if (!valid) {
        throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
      }
    }
    validate3.type = type;
    return validate3;
  };
  var assertShape = function(shape) {
    function validate3(node2, key, val) {
      const errors2 = [];
      for (const property2 of Object.keys(shape)) {
        try {
          (0, _validate.validateField)(node2, property2, val[property2], shape[property2]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors2.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors2.length) {
        throw new TypeError(`Property ${key} of ${node2.type} expected to have the following:\n${errors2.join("\n")}`);
      }
    }
    validate3.shapeOf = shape;
    return validate3;
  };
  var assertOptionalChainStart = function() {
    function validate3(node2) {
      var _current;
      let current = node2;
      while (node2) {
        const {
          type
        } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional)
            return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional)
            return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${node2.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? undefined : _current.type}`);
    }
    return validate3;
  };
  var chain = function(...fns) {
    function validate3(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate3.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    return validate3;
  };
  var defineAliasedType = function(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$, _defined;
        if (opts.inherits)
          defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? undefined : _store$opts$inherits$.slice();
        (_defined = defined) != null || (defined = []);
        opts.aliases = defined;
      }
      const additional = aliases.filter((a) => !defined.includes(a));
      defined.unshift(...additional);
      defineType(type, opts);
    };
  };
  var defineType = function(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        const keys = Object.getOwnPropertyNames(inherits.fields);
        for (const key of keys) {
          const field = inherits.fields[key];
          const def = field.default;
          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) {
      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== undefined && builder.indexOf(key) === -1) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k of Object.keys(field)) {
        if (validFieldKeys.indexOf(k) === -1) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = undefined;
  exports.arrayOf = arrayOf;
  exports.arrayOfType = arrayOfType;
  exports.assertEach = assertEach;
  exports.assertNodeOrValueType = assertNodeOrValueType;
  exports.assertNodeType = assertNodeType;
  exports.assertOneOf = assertOneOf;
  exports.assertOptionalChainStart = assertOptionalChainStart;
  exports.assertShape = assertShape;
  exports.assertValueType = assertValueType;
  exports.chain = chain;
  exports.default = defineType;
  exports.defineAliasedType = defineAliasedType;
  exports.typeIs = typeIs;
  exports.validate = validate2;
  exports.validateArrayOfType = validateArrayOfType;
  exports.validateOptional = validateOptional;
  exports.validateOptionalType = validateOptionalType;
  exports.validateType = validateType;
  var _is = require_is();
  var _validate = require_validate2();
  var VISITOR_KEYS = exports.VISITOR_KEYS = {};
  var ALIAS_KEYS = exports.ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = exports.NODE_FIELDS = {};
  var BUILDER_KEYS = exports.BUILDER_KEYS = {};
  var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};
  var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
  var validFieldKeys = ["default", "optional", "deprecated", "validate"];
  var store = {};
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = undefined;
  var _is = require_is();
  var _isValidIdentifier = require_isValidIdentifier();
  var _helperValidatorIdentifier = require_lib();
  var _helperStringParser = require_lib2();
  var _index = require_constants();
  var _utils = require_utils();
  var defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertValueType)("string");
          }
          const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
          const pattern = (0, _utils.assertOneOf)("=");
          return function(node2, key, val) {
            const validator2 = (0, _is.default)("Pattern", node2.left) ? pattern : identifier;
            validator2(node2, key, val);
          };
        }()
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator2 = Object.assign(function(node2, key, val) {
            const validator3 = node2.operator === "in" ? inOp : expression;
            validator3(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator2;
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertOneOf)(true, false),
        optional: true
      }
    } : {}, {
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  var functionCommon = () => ({
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: false
    },
    async: {
      default: false
    }
  });
  exports.functionCommon = functionCommon;
  var functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  });
  exports.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return () => {
        };
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node2) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node2, "id", node2.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  var patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  exports.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _isValidIdentifier.default)(val, false)) {
            throw new TypeError(`"${val}" is not a valid identifier name`);
          }
        }, {
          type: "string"
        }))
      }
    }),
    validate(parent, key, node2) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const match = /\.(\w+)$/.exec(key);
      if (!match)
        return;
      const [, parentKey] = match;
      const nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp))
          return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
          return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp))
          return;
        if ((0, _is.default)("Method", parent, nonComp))
          return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent))
          return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, {
          imported: node2
        }))
          return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, {
          meta: node2
        }))
          return;
      }
      if (((0, _helperValidatorIdentifier.isKeyword)(node2.name) || (0, _helperValidatorIdentifier.isReservedWord)(node2.name, false)) && node2.name !== "this") {
        throw new TypeError(`"${node2.name}" is not a valid identifier`);
      }
    }
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node2, key, val) {
          if (1 / val < 0 || !Number.isFinite(val)) {
            const error = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${val}) instead.`);
            {
            }
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const invalid = /[^gimsuy]/.exec(val);
          if (invalid) {
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator2 = function(node2, key, val) {
            const validator3 = node2.computed ? computed : normal;
            validator3(node2, key, val);
          };
          validator2.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator2;
        }()
      },
      computed: {
        default: false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertOneOf)(true, false),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: (0, _utils.assertValueType)("string")
      },
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator2 = function(node2, key, val) {
            const validator3 = node2.computed ? computed : normal;
            validator3(node2, key, val);
          };
          validator2.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator2;
        }()
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator2 = Object.assign(function(node2, key, val) {
            const validator3 = node2.computed ? computed : normal;
            validator3(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator2;
        }()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && node2.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
        }, {
          type: "boolean"
        }), function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && !(0, _is.default)("Identifier", node2.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }),
        default: false
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      const expression = (0, _utils.assertNodeType)("Expression");
      return function(parent, key, node2) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const validator2 = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
        validator2(node2, "value", node2.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match)
        throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    }
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      consequent: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
      }
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node2) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!node2.handler && !node2.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(parent, key, node2) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      if (!(0, _is.default)("ForXStatement", parent, {
        left: node2
      }))
        return;
      if (node2.declarations.length !== 1) {
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
      }
    }
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("LVal");
          }
          const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
          const without = (0, _utils.assertNodeType)("Identifier");
          return function(node2, key, val) {
            const validator2 = node2.init ? normal : without;
            validator2(node2, key, val);
          };
        }()
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: function() {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node2) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node2, "id", node2.id);
        }
      };
    }()
  });
  defineType("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
      attributes: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      }
    }
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
  });
  defineType("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && node2.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && node2.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        })
      },
      attributes: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return sourced;
          return function(node2, key, val) {
            const validator2 = node2.source ? sourced : sourceless;
            validator2(node2, key, val);
          };
        }()))
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(node2, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node2, key, val);
            } else {
              lval(node2, key, val);
            }
          };
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  });
  defineType("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      options: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let property2;
          switch (val.name) {
            case "function":
              property2 = "sent";
              break;
            case "new":
              property2 = "target";
              break;
            case "import":
              property2 = "meta";
              break;
          }
          if (!(0, _is.default)("Identifier", node2.property, {
            name: property2
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, _utils.chain)(function() {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function(node2, key, val) {
          const validator2 = node2.computed ? computed : normal;
          validator2(node2, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node2) {
          const raw = node2.value.raw;
          let unterminatedCalled = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          };
          const {
            str,
            firstInvalidLoc
          } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
            unterminated() {
              unterminatedCalled = true;
            },
            strictNumericEscape: error,
            invalidEscapeSequence: error,
            numericSeparatorInEscapeSequence: error,
            unexpectedNumericSeparator: error,
            invalidDigit: error,
            invalidCodePoint: error
          });
          if (!unterminatedCalled)
            throw new Error("Invalid raw");
          node2.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        default: false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node2, key, val) {
          if (node2.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node2.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node2.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && !node2.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator2 = Object.assign(function(node2, key, val) {
            const validator3 = node2.computed ? computed : normal;
            validator3(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator2;
        }()
      },
      computed: {
        default: false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS(() => {
  var _utils = require_utils();
  var defineType = (0, _utils.defineAliasedType)("Flow");
  var defineInterfaceishType = (name) => {
    const isDeclareClass = name === "DeclareClass";
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: []
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: []
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: []
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS(() => {
  var _utils = require_utils();
  var defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = undefined;
  var _utils = require_utils();
  var PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length)
      PLACEHOLDERS_ALIAS[type] = alias;
  }
  var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS(() => {
  var _utils = require_utils();
  var _placeholders = require_placeholders();
  var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS(() => {
  var _utils = require_utils();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, _utils.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS(() => {
  var _utils = require_utils();
  var _core = require_core();
  var _is = require_is();
  var defineType = (0, _utils.defineAliasedType)("TypeScript");
  var bool = (0, _utils.assertValueType)("boolean");
  var tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  var signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    ["parameters"]: (0, _utils.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  });
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: {
      default: false
    },
    optional: (0, _utils.validateOptional)(bool)
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      abstract: (0, _utils.validateOptional)(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        default: false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeParameter: (0, _utils.validateType)("TSTypeParameter"),
      optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator2(parent, key, node2) {
            if ((0, _is.default)("UnaryExpression", node2)) {
              unaryOperator(node2, "operator", node2.operator);
              unaryExpression(node2, "argument", node2.argument);
            } else {
              literal(parent, key, node2);
            }
          }
          validator2.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator2;
        }()
      }
    }
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var TSTypeExpression = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression);
  defineType("TSSatisfiesExpression", TSTypeExpression);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      const: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      members: (0, _utils.validateArrayOfType)("TSEnumMember"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      global: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, _utils.validate)(bool),
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
      }
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      in: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      const: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEPRECATED_ALIASES = undefined;
  var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.BUILDER_KEYS;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_ALIASES", {
    enumerable: true,
    get: function() {
      return _deprecatedAliases.DEPRECATED_ALIASES;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.DEPRECATED_KEYS;
    }
  });
  Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.FLIPPED_ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
      return _utils.NODE_FIELDS;
    }
  });
  Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
      return _utils.NODE_PARENT_VALIDATIONS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS_ALIAS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  });
  exports.TYPES = undefined;
  Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.VISITOR_KEYS;
    }
  });
  var _toFastProperties = require_to_fast_properties();
  require_core();
  require_flow();
  require_jsx();
  require_misc();
  require_experimental();
  require_typescript();
  var _utils = require_utils();
  var _placeholders = require_placeholders();
  var _deprecatedAliases = require_deprecated_aliases();
  Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
    _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
  });
  _toFastProperties(_utils.VISITOR_KEYS);
  _toFastProperties(_utils.ALIAS_KEYS);
  _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
  _toFastProperties(_utils.NODE_FIELDS);
  _toFastProperties(_utils.BUILDER_KEYS);
  _toFastProperties(_utils.DEPRECATED_KEYS);
  _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
  _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
  var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/validate.js
var require_validate2 = __commonJS((exports) => {
  var validate2 = function(node2, key, val) {
    if (!node2)
      return;
    const fields = _index.NODE_FIELDS[node2.type];
    if (!fields)
      return;
    const field = fields[key];
    validateField(node2, key, val, field);
    validateChild(node2, key, val);
  };
  var validateField = function(node2, key, val, field) {
    if (!(field != null && field.validate))
      return;
    if (field.optional && val == null)
      return;
    field.validate(node2, key, val);
  };
  var validateChild = function(node2, key, val) {
    if (val == null)
      return;
    const validate3 = _index.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate3)
      return;
    validate3(node2, key, val);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = validate2;
  exports.validateChild = validateChild;
  exports.validateField = validateField;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/validateNode.js
var require_validateNode = __commonJS((exports) => {
  var validateNode = function(node2) {
    const keys = _index.BUILDER_KEYS[node2.type];
    for (const key of keys) {
      (0, _validate.default)(node2, key, node2[key]);
    }
    return node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = validateNode;
  var _validate = require_validate2();
  var _index = require_lib3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS((exports) => {
  var arrayExpression = function(elements = []) {
    return (0, _validateNode.default)({
      type: "ArrayExpression",
      elements
    });
  };
  var assignmentExpression = function(operator, left2, right2) {
    return (0, _validateNode.default)({
      type: "AssignmentExpression",
      operator,
      left: left2,
      right: right2
    });
  };
  var binaryExpression = function(operator, left2, right2) {
    return (0, _validateNode.default)({
      type: "BinaryExpression",
      operator,
      left: left2,
      right: right2
    });
  };
  var interpreterDirective = function(value2) {
    return (0, _validateNode.default)({
      type: "InterpreterDirective",
      value: value2
    });
  };
  var directive = function(value2) {
    return (0, _validateNode.default)({
      type: "Directive",
      value: value2
    });
  };
  var directiveLiteral = function(value2) {
    return (0, _validateNode.default)({
      type: "DirectiveLiteral",
      value: value2
    });
  };
  var blockStatement = function(body, directives = []) {
    return (0, _validateNode.default)({
      type: "BlockStatement",
      body,
      directives
    });
  };
  var breakStatement = function(label = null) {
    return (0, _validateNode.default)({
      type: "BreakStatement",
      label
    });
  };
  var callExpression = function(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "CallExpression",
      callee,
      arguments: _arguments
    });
  };
  var catchClause = function(param = null, body) {
    return (0, _validateNode.default)({
      type: "CatchClause",
      param,
      body
    });
  };
  var conditionalExpression = function(test, consequent, alternate) {
    return (0, _validateNode.default)({
      type: "ConditionalExpression",
      test,
      consequent,
      alternate
    });
  };
  var continueStatement = function(label = null) {
    return (0, _validateNode.default)({
      type: "ContinueStatement",
      label
    });
  };
  var debuggerStatement = function() {
    return {
      type: "DebuggerStatement"
    };
  };
  var doWhileStatement = function(test, body) {
    return (0, _validateNode.default)({
      type: "DoWhileStatement",
      test,
      body
    });
  };
  var emptyStatement = function() {
    return {
      type: "EmptyStatement"
    };
  };
  var expressionStatement = function(expression) {
    return (0, _validateNode.default)({
      type: "ExpressionStatement",
      expression
    });
  };
  var file = function(program2, comments = null, tokens = null) {
    return (0, _validateNode.default)({
      type: "File",
      program: program2,
      comments,
      tokens
    });
  };
  var forInStatement = function(left2, right2, body) {
    return (0, _validateNode.default)({
      type: "ForInStatement",
      left: left2,
      right: right2,
      body
    });
  };
  var forStatement = function(init = null, test = null, update = null, body) {
    return (0, _validateNode.default)({
      type: "ForStatement",
      init,
      test,
      update,
      body
    });
  };
  var functionDeclaration = function(id = null, params, body, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "FunctionDeclaration",
      id,
      params,
      body,
      generator,
      async
    });
  };
  var functionExpression = function(id = null, params, body, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "FunctionExpression",
      id,
      params,
      body,
      generator,
      async
    });
  };
  var identifier = function(name) {
    return (0, _validateNode.default)({
      type: "Identifier",
      name
    });
  };
  var ifStatement = function(test, consequent, alternate = null) {
    return (0, _validateNode.default)({
      type: "IfStatement",
      test,
      consequent,
      alternate
    });
  };
  var labeledStatement = function(label, body) {
    return (0, _validateNode.default)({
      type: "LabeledStatement",
      label,
      body
    });
  };
  var stringLiteral = function(value2) {
    return (0, _validateNode.default)({
      type: "StringLiteral",
      value: value2
    });
  };
  var numericLiteral = function(value2) {
    return (0, _validateNode.default)({
      type: "NumericLiteral",
      value: value2
    });
  };
  var nullLiteral = function() {
    return {
      type: "NullLiteral"
    };
  };
  var booleanLiteral = function(value2) {
    return (0, _validateNode.default)({
      type: "BooleanLiteral",
      value: value2
    });
  };
  var regExpLiteral = function(pattern, flags = "") {
    return (0, _validateNode.default)({
      type: "RegExpLiteral",
      pattern,
      flags
    });
  };
  var logicalExpression = function(operator, left2, right2) {
    return (0, _validateNode.default)({
      type: "LogicalExpression",
      operator,
      left: left2,
      right: right2
    });
  };
  var memberExpression = function(object, property2, computed = false, optional = null) {
    return (0, _validateNode.default)({
      type: "MemberExpression",
      object,
      property: property2,
      computed,
      optional
    });
  };
  var newExpression = function(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "NewExpression",
      callee,
      arguments: _arguments
    });
  };
  var program = function(body, directives = [], sourceType = "script", interpreter = null) {
    return (0, _validateNode.default)({
      type: "Program",
      body,
      directives,
      sourceType,
      interpreter,
      sourceFile: null
    });
  };
  var objectExpression = function(properties) {
    return (0, _validateNode.default)({
      type: "ObjectExpression",
      properties
    });
  };
  var objectMethod = function(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "ObjectMethod",
      kind,
      key,
      params,
      body,
      computed,
      generator,
      async
    });
  };
  var objectProperty = function(key, value2, computed = false, shorthand = false, decorators = null) {
    return (0, _validateNode.default)({
      type: "ObjectProperty",
      key,
      value: value2,
      computed,
      shorthand,
      decorators
    });
  };
  var restElement = function(argument) {
    return (0, _validateNode.default)({
      type: "RestElement",
      argument
    });
  };
  var returnStatement = function(argument = null) {
    return (0, _validateNode.default)({
      type: "ReturnStatement",
      argument
    });
  };
  var sequenceExpression = function(expressions) {
    return (0, _validateNode.default)({
      type: "SequenceExpression",
      expressions
    });
  };
  var parenthesizedExpression = function(expression) {
    return (0, _validateNode.default)({
      type: "ParenthesizedExpression",
      expression
    });
  };
  var switchCase = function(test = null, consequent) {
    return (0, _validateNode.default)({
      type: "SwitchCase",
      test,
      consequent
    });
  };
  var switchStatement = function(discriminant, cases) {
    return (0, _validateNode.default)({
      type: "SwitchStatement",
      discriminant,
      cases
    });
  };
  var thisExpression = function() {
    return {
      type: "ThisExpression"
    };
  };
  var throwStatement = function(argument) {
    return (0, _validateNode.default)({
      type: "ThrowStatement",
      argument
    });
  };
  var tryStatement = function(block, handler = null, finalizer = null) {
    return (0, _validateNode.default)({
      type: "TryStatement",
      block,
      handler,
      finalizer
    });
  };
  var unaryExpression = function(operator, argument, prefix = true) {
    return (0, _validateNode.default)({
      type: "UnaryExpression",
      operator,
      argument,
      prefix
    });
  };
  var updateExpression = function(operator, argument, prefix = false) {
    return (0, _validateNode.default)({
      type: "UpdateExpression",
      operator,
      argument,
      prefix
    });
  };
  var variableDeclaration = function(kind, declarations) {
    return (0, _validateNode.default)({
      type: "VariableDeclaration",
      kind,
      declarations
    });
  };
  var variableDeclarator = function(id, init = null) {
    return (0, _validateNode.default)({
      type: "VariableDeclarator",
      id,
      init
    });
  };
  var whileStatement = function(test, body) {
    return (0, _validateNode.default)({
      type: "WhileStatement",
      test,
      body
    });
  };
  var withStatement = function(object, body) {
    return (0, _validateNode.default)({
      type: "WithStatement",
      object,
      body
    });
  };
  var assignmentPattern = function(left2, right2) {
    return (0, _validateNode.default)({
      type: "AssignmentPattern",
      left: left2,
      right: right2
    });
  };
  var arrayPattern = function(elements) {
    return (0, _validateNode.default)({
      type: "ArrayPattern",
      elements
    });
  };
  var arrowFunctionExpression = function(params, body, async = false) {
    return (0, _validateNode.default)({
      type: "ArrowFunctionExpression",
      params,
      body,
      async,
      expression: null
    });
  };
  var classBody = function(body) {
    return (0, _validateNode.default)({
      type: "ClassBody",
      body
    });
  };
  var classExpression = function(id = null, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
      type: "ClassExpression",
      id,
      superClass,
      body,
      decorators
    });
  };
  var classDeclaration = function(id = null, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
      type: "ClassDeclaration",
      id,
      superClass,
      body,
      decorators
    });
  };
  var exportAllDeclaration = function(source) {
    return (0, _validateNode.default)({
      type: "ExportAllDeclaration",
      source
    });
  };
  var exportDefaultDeclaration = function(declaration) {
    return (0, _validateNode.default)({
      type: "ExportDefaultDeclaration",
      declaration
    });
  };
  var exportNamedDeclaration = function(declaration = null, specifiers = [], source = null) {
    return (0, _validateNode.default)({
      type: "ExportNamedDeclaration",
      declaration,
      specifiers,
      source
    });
  };
  var exportSpecifier = function(local, exported) {
    return (0, _validateNode.default)({
      type: "ExportSpecifier",
      local,
      exported
    });
  };
  var forOfStatement = function(left2, right2, body, _await = false) {
    return (0, _validateNode.default)({
      type: "ForOfStatement",
      left: left2,
      right: right2,
      body,
      await: _await
    });
  };
  var importDeclaration = function(specifiers, source) {
    return (0, _validateNode.default)({
      type: "ImportDeclaration",
      specifiers,
      source
    });
  };
  var importDefaultSpecifier = function(local) {
    return (0, _validateNode.default)({
      type: "ImportDefaultSpecifier",
      local
    });
  };
  var importNamespaceSpecifier = function(local) {
    return (0, _validateNode.default)({
      type: "ImportNamespaceSpecifier",
      local
    });
  };
  var importSpecifier = function(local, imported) {
    return (0, _validateNode.default)({
      type: "ImportSpecifier",
      local,
      imported
    });
  };
  var importExpression = function(source, options = null) {
    return (0, _validateNode.default)({
      type: "ImportExpression",
      source,
      options
    });
  };
  var metaProperty = function(meta, property2) {
    return (0, _validateNode.default)({
      type: "MetaProperty",
      meta,
      property: property2
    });
  };
  var classMethod = function(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "ClassMethod",
      kind,
      key,
      params,
      body,
      computed,
      static: _static,
      generator,
      async
    });
  };
  var objectPattern = function(properties) {
    return (0, _validateNode.default)({
      type: "ObjectPattern",
      properties
    });
  };
  var spreadElement = function(argument) {
    return (0, _validateNode.default)({
      type: "SpreadElement",
      argument
    });
  };
  var _super = function() {
    return {
      type: "Super"
    };
  };
  var taggedTemplateExpression = function(tag, quasi) {
    return (0, _validateNode.default)({
      type: "TaggedTemplateExpression",
      tag,
      quasi
    });
  };
  var templateElement = function(value2, tail = false) {
    return (0, _validateNode.default)({
      type: "TemplateElement",
      value: value2,
      tail
    });
  };
  var templateLiteral = function(quasis, expressions) {
    return (0, _validateNode.default)({
      type: "TemplateLiteral",
      quasis,
      expressions
    });
  };
  var yieldExpression = function(argument = null, delegate = false) {
    return (0, _validateNode.default)({
      type: "YieldExpression",
      argument,
      delegate
    });
  };
  var awaitExpression = function(argument) {
    return (0, _validateNode.default)({
      type: "AwaitExpression",
      argument
    });
  };
  var _import = function() {
    return {
      type: "Import"
    };
  };
  var bigIntLiteral = function(value2) {
    return (0, _validateNode.default)({
      type: "BigIntLiteral",
      value: value2
    });
  };
  var exportNamespaceSpecifier = function(exported) {
    return (0, _validateNode.default)({
      type: "ExportNamespaceSpecifier",
      exported
    });
  };
  var optionalMemberExpression = function(object, property2, computed = false, optional) {
    return (0, _validateNode.default)({
      type: "OptionalMemberExpression",
      object,
      property: property2,
      computed,
      optional
    });
  };
  var optionalCallExpression = function(callee, _arguments, optional) {
    return (0, _validateNode.default)({
      type: "OptionalCallExpression",
      callee,
      arguments: _arguments,
      optional
    });
  };
  var classProperty = function(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassProperty",
      key,
      value: value2,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    });
  };
  var classAccessorProperty = function(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassAccessorProperty",
      key,
      value: value2,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    });
  };
  var classPrivateProperty = function(key, value2 = null, decorators = null, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassPrivateProperty",
      key,
      value: value2,
      decorators,
      static: _static
    });
  };
  var classPrivateMethod = function(kind = "method", key, params, body, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassPrivateMethod",
      kind,
      key,
      params,
      body,
      static: _static
    });
  };
  var privateName = function(id) {
    return (0, _validateNode.default)({
      type: "PrivateName",
      id
    });
  };
  var staticBlock = function(body) {
    return (0, _validateNode.default)({
      type: "StaticBlock",
      body
    });
  };
  var anyTypeAnnotation = function() {
    return {
      type: "AnyTypeAnnotation"
    };
  };
  var arrayTypeAnnotation = function(elementType) {
    return (0, _validateNode.default)({
      type: "ArrayTypeAnnotation",
      elementType
    });
  };
  var booleanTypeAnnotation = function() {
    return {
      type: "BooleanTypeAnnotation"
    };
  };
  var booleanLiteralTypeAnnotation = function(value2) {
    return (0, _validateNode.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: value2
    });
  };
  var nullLiteralTypeAnnotation = function() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  };
  var classImplements = function(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "ClassImplements",
      id,
      typeParameters
    });
  };
  var declareClass = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareClass",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var declareFunction = function(id) {
    return (0, _validateNode.default)({
      type: "DeclareFunction",
      id
    });
  };
  var declareInterface = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareInterface",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var declareModule = function(id, body, kind = null) {
    return (0, _validateNode.default)({
      type: "DeclareModule",
      id,
      body,
      kind
    });
  };
  var declareModuleExports = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation2
    });
  };
  var declareTypeAlias = function(id, typeParameters = null, right2) {
    return (0, _validateNode.default)({
      type: "DeclareTypeAlias",
      id,
      typeParameters,
      right: right2
    });
  };
  var declareOpaqueType = function(id, typeParameters = null, supertype = null) {
    return (0, _validateNode.default)({
      type: "DeclareOpaqueType",
      id,
      typeParameters,
      supertype
    });
  };
  var declareVariable = function(id) {
    return (0, _validateNode.default)({
      type: "DeclareVariable",
      id
    });
  };
  var declareExportDeclaration = function(declaration = null, specifiers = null, source = null) {
    return (0, _validateNode.default)({
      type: "DeclareExportDeclaration",
      declaration,
      specifiers,
      source
    });
  };
  var declareExportAllDeclaration = function(source) {
    return (0, _validateNode.default)({
      type: "DeclareExportAllDeclaration",
      source
    });
  };
  var declaredPredicate = function(value2) {
    return (0, _validateNode.default)({
      type: "DeclaredPredicate",
      value: value2
    });
  };
  var existsTypeAnnotation = function() {
    return {
      type: "ExistsTypeAnnotation"
    };
  };
  var functionTypeAnnotation = function(typeParameters = null, params, rest = null, returnType) {
    return (0, _validateNode.default)({
      type: "FunctionTypeAnnotation",
      typeParameters,
      params,
      rest,
      returnType
    });
  };
  var functionTypeParam = function(name = null, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "FunctionTypeParam",
      name,
      typeAnnotation: typeAnnotation2
    });
  };
  var genericTypeAnnotation = function(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "GenericTypeAnnotation",
      id,
      typeParameters
    });
  };
  var inferredPredicate = function() {
    return {
      type: "InferredPredicate"
    };
  };
  var interfaceExtends = function(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "InterfaceExtends",
      id,
      typeParameters
    });
  };
  var interfaceDeclaration = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "InterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var interfaceTypeAnnotation = function(_extends = null, body) {
    return (0, _validateNode.default)({
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body
    });
  };
  var intersectionTypeAnnotation = function(types) {
    return (0, _validateNode.default)({
      type: "IntersectionTypeAnnotation",
      types
    });
  };
  var mixedTypeAnnotation = function() {
    return {
      type: "MixedTypeAnnotation"
    };
  };
  var emptyTypeAnnotation = function() {
    return {
      type: "EmptyTypeAnnotation"
    };
  };
  var nullableTypeAnnotation = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation2
    });
  };
  var numberLiteralTypeAnnotation = function(value2) {
    return (0, _validateNode.default)({
      type: "NumberLiteralTypeAnnotation",
      value: value2
    });
  };
  var numberTypeAnnotation = function() {
    return {
      type: "NumberTypeAnnotation"
    };
  };
  var objectTypeAnnotation = function(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    return (0, _validateNode.default)({
      type: "ObjectTypeAnnotation",
      properties,
      indexers,
      callProperties,
      internalSlots,
      exact
    });
  };
  var objectTypeInternalSlot = function(id, value2, optional, _static, method) {
    return (0, _validateNode.default)({
      type: "ObjectTypeInternalSlot",
      id,
      value: value2,
      optional,
      static: _static,
      method
    });
  };
  var objectTypeCallProperty = function(value2) {
    return (0, _validateNode.default)({
      type: "ObjectTypeCallProperty",
      value: value2,
      static: null
    });
  };
  var objectTypeIndexer = function(id = null, key, value2, variance2 = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeIndexer",
      id,
      key,
      value: value2,
      variance: variance2,
      static: null
    });
  };
  var objectTypeProperty = function(key, value2, variance2 = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeProperty",
      key,
      value: value2,
      variance: variance2,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  };
  var objectTypeSpreadProperty = function(argument) {
    return (0, _validateNode.default)({
      type: "ObjectTypeSpreadProperty",
      argument
    });
  };
  var opaqueType = function(id, typeParameters = null, supertype = null, impltype) {
    return (0, _validateNode.default)({
      type: "OpaqueType",
      id,
      typeParameters,
      supertype,
      impltype
    });
  };
  var qualifiedTypeIdentifier = function(id, qualification) {
    return (0, _validateNode.default)({
      type: "QualifiedTypeIdentifier",
      id,
      qualification
    });
  };
  var stringLiteralTypeAnnotation = function(value2) {
    return (0, _validateNode.default)({
      type: "StringLiteralTypeAnnotation",
      value: value2
    });
  };
  var stringTypeAnnotation = function() {
    return {
      type: "StringTypeAnnotation"
    };
  };
  var symbolTypeAnnotation = function() {
    return {
      type: "SymbolTypeAnnotation"
    };
  };
  var thisTypeAnnotation = function() {
    return {
      type: "ThisTypeAnnotation"
    };
  };
  var tupleTypeAnnotation = function(types) {
    return (0, _validateNode.default)({
      type: "TupleTypeAnnotation",
      types
    });
  };
  var typeofTypeAnnotation = function(argument) {
    return (0, _validateNode.default)({
      type: "TypeofTypeAnnotation",
      argument
    });
  };
  var typeAlias = function(id, typeParameters = null, right2) {
    return (0, _validateNode.default)({
      type: "TypeAlias",
      id,
      typeParameters,
      right: right2
    });
  };
  var typeAnnotation = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation2
    });
  };
  var typeCastExpression = function(expression, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TypeCastExpression",
      expression,
      typeAnnotation: typeAnnotation2
    });
  };
  var typeParameter = function(bound = null, _default = null, variance2 = null) {
    return (0, _validateNode.default)({
      type: "TypeParameter",
      bound,
      default: _default,
      variance: variance2,
      name: null
    });
  };
  var typeParameterDeclaration = function(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterDeclaration",
      params
    });
  };
  var typeParameterInstantiation = function(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterInstantiation",
      params
    });
  };
  var unionTypeAnnotation = function(types) {
    return (0, _validateNode.default)({
      type: "UnionTypeAnnotation",
      types
    });
  };
  var variance = function(kind) {
    return (0, _validateNode.default)({
      type: "Variance",
      kind
    });
  };
  var voidTypeAnnotation = function() {
    return {
      type: "VoidTypeAnnotation"
    };
  };
  var enumDeclaration = function(id, body) {
    return (0, _validateNode.default)({
      type: "EnumDeclaration",
      id,
      body
    });
  };
  var enumBooleanBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumBooleanBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    });
  };
  var enumNumberBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumNumberBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    });
  };
  var enumStringBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumStringBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    });
  };
  var enumSymbolBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumSymbolBody",
      members,
      hasUnknownMembers: null
    });
  };
  var enumBooleanMember = function(id) {
    return (0, _validateNode.default)({
      type: "EnumBooleanMember",
      id,
      init: null
    });
  };
  var enumNumberMember = function(id, init) {
    return (0, _validateNode.default)({
      type: "EnumNumberMember",
      id,
      init
    });
  };
  var enumStringMember = function(id, init) {
    return (0, _validateNode.default)({
      type: "EnumStringMember",
      id,
      init
    });
  };
  var enumDefaultedMember = function(id) {
    return (0, _validateNode.default)({
      type: "EnumDefaultedMember",
      id
    });
  };
  var indexedAccessType = function(objectType2, indexType) {
    return (0, _validateNode.default)({
      type: "IndexedAccessType",
      objectType: objectType2,
      indexType
    });
  };
  var optionalIndexedAccessType = function(objectType2, indexType) {
    return (0, _validateNode.default)({
      type: "OptionalIndexedAccessType",
      objectType: objectType2,
      indexType,
      optional: null
    });
  };
  var jsxAttribute = function(name, value2 = null) {
    return (0, _validateNode.default)({
      type: "JSXAttribute",
      name,
      value: value2
    });
  };
  var jsxClosingElement = function(name) {
    return (0, _validateNode.default)({
      type: "JSXClosingElement",
      name
    });
  };
  var jsxElement = function(openingElement, closingElement = null, children, selfClosing = null) {
    return (0, _validateNode.default)({
      type: "JSXElement",
      openingElement,
      closingElement,
      children,
      selfClosing
    });
  };
  var jsxEmptyExpression = function() {
    return {
      type: "JSXEmptyExpression"
    };
  };
  var jsxExpressionContainer = function(expression) {
    return (0, _validateNode.default)({
      type: "JSXExpressionContainer",
      expression
    });
  };
  var jsxSpreadChild = function(expression) {
    return (0, _validateNode.default)({
      type: "JSXSpreadChild",
      expression
    });
  };
  var jsxIdentifier = function(name) {
    return (0, _validateNode.default)({
      type: "JSXIdentifier",
      name
    });
  };
  var jsxMemberExpression = function(object, property2) {
    return (0, _validateNode.default)({
      type: "JSXMemberExpression",
      object,
      property: property2
    });
  };
  var jsxNamespacedName = function(namespace, name) {
    return (0, _validateNode.default)({
      type: "JSXNamespacedName",
      namespace,
      name
    });
  };
  var jsxOpeningElement = function(name, attributes, selfClosing = false) {
    return (0, _validateNode.default)({
      type: "JSXOpeningElement",
      name,
      attributes,
      selfClosing
    });
  };
  var jsxSpreadAttribute = function(argument) {
    return (0, _validateNode.default)({
      type: "JSXSpreadAttribute",
      argument
    });
  };
  var jsxText = function(value2) {
    return (0, _validateNode.default)({
      type: "JSXText",
      value: value2
    });
  };
  var jsxFragment = function(openingFragment, closingFragment, children) {
    return (0, _validateNode.default)({
      type: "JSXFragment",
      openingFragment,
      closingFragment,
      children
    });
  };
  var jsxOpeningFragment = function() {
    return {
      type: "JSXOpeningFragment"
    };
  };
  var jsxClosingFragment = function() {
    return {
      type: "JSXClosingFragment"
    };
  };
  var noop = function() {
    return {
      type: "Noop"
    };
  };
  var placeholder = function(expectedNode, name) {
    return (0, _validateNode.default)({
      type: "Placeholder",
      expectedNode,
      name
    });
  };
  var v8IntrinsicIdentifier = function(name) {
    return (0, _validateNode.default)({
      type: "V8IntrinsicIdentifier",
      name
    });
  };
  var argumentPlaceholder = function() {
    return {
      type: "ArgumentPlaceholder"
    };
  };
  var bindExpression = function(object, callee) {
    return (0, _validateNode.default)({
      type: "BindExpression",
      object,
      callee
    });
  };
  var importAttribute = function(key, value2) {
    return (0, _validateNode.default)({
      type: "ImportAttribute",
      key,
      value: value2
    });
  };
  var decorator = function(expression) {
    return (0, _validateNode.default)({
      type: "Decorator",
      expression
    });
  };
  var doExpression = function(body, async = false) {
    return (0, _validateNode.default)({
      type: "DoExpression",
      body,
      async
    });
  };
  var exportDefaultSpecifier = function(exported) {
    return (0, _validateNode.default)({
      type: "ExportDefaultSpecifier",
      exported
    });
  };
  var recordExpression = function(properties) {
    return (0, _validateNode.default)({
      type: "RecordExpression",
      properties
    });
  };
  var tupleExpression = function(elements = []) {
    return (0, _validateNode.default)({
      type: "TupleExpression",
      elements
    });
  };
  var decimalLiteral = function(value2) {
    return (0, _validateNode.default)({
      type: "DecimalLiteral",
      value: value2
    });
  };
  var moduleExpression = function(body) {
    return (0, _validateNode.default)({
      type: "ModuleExpression",
      body
    });
  };
  var topicReference = function() {
    return {
      type: "TopicReference"
    };
  };
  var pipelineTopicExpression = function(expression) {
    return (0, _validateNode.default)({
      type: "PipelineTopicExpression",
      expression
    });
  };
  var pipelineBareFunction = function(callee) {
    return (0, _validateNode.default)({
      type: "PipelineBareFunction",
      callee
    });
  };
  var pipelinePrimaryTopicReference = function() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  };
  var tsParameterProperty = function(parameter) {
    return (0, _validateNode.default)({
      type: "TSParameterProperty",
      parameter
    });
  };
  var tsDeclareFunction = function(id = null, typeParameters = null, params, returnType = null) {
    return (0, _validateNode.default)({
      type: "TSDeclareFunction",
      id,
      typeParameters,
      params,
      returnType
    });
  };
  var tsDeclareMethod = function(decorators = null, key, typeParameters = null, params, returnType = null) {
    return (0, _validateNode.default)({
      type: "TSDeclareMethod",
      decorators,
      key,
      typeParameters,
      params,
      returnType
    });
  };
  var tsQualifiedName = function(left2, right2) {
    return (0, _validateNode.default)({
      type: "TSQualifiedName",
      left: left2,
      right: right2
    });
  };
  var tsCallSignatureDeclaration = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsConstructSignatureDeclaration = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsPropertySignature = function(key, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSPropertySignature",
      key,
      typeAnnotation: typeAnnotation2,
      kind: null
    });
  };
  var tsMethodSignature = function(key, typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSMethodSignature",
      key,
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2,
      kind: null
    });
  };
  var tsIndexSignature = function(parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSIndexSignature",
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsAnyKeyword = function() {
    return {
      type: "TSAnyKeyword"
    };
  };
  var tsBooleanKeyword = function() {
    return {
      type: "TSBooleanKeyword"
    };
  };
  var tsBigIntKeyword = function() {
    return {
      type: "TSBigIntKeyword"
    };
  };
  var tsIntrinsicKeyword = function() {
    return {
      type: "TSIntrinsicKeyword"
    };
  };
  var tsNeverKeyword = function() {
    return {
      type: "TSNeverKeyword"
    };
  };
  var tsNullKeyword = function() {
    return {
      type: "TSNullKeyword"
    };
  };
  var tsNumberKeyword = function() {
    return {
      type: "TSNumberKeyword"
    };
  };
  var tsObjectKeyword = function() {
    return {
      type: "TSObjectKeyword"
    };
  };
  var tsStringKeyword = function() {
    return {
      type: "TSStringKeyword"
    };
  };
  var tsSymbolKeyword = function() {
    return {
      type: "TSSymbolKeyword"
    };
  };
  var tsUndefinedKeyword = function() {
    return {
      type: "TSUndefinedKeyword"
    };
  };
  var tsUnknownKeyword = function() {
    return {
      type: "TSUnknownKeyword"
    };
  };
  var tsVoidKeyword = function() {
    return {
      type: "TSVoidKeyword"
    };
  };
  var tsThisType = function() {
    return {
      type: "TSThisType"
    };
  };
  var tsFunctionType = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSFunctionType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsConstructorType = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSConstructorType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeReference = function(typeName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeReference",
      typeName,
      typeParameters
    });
  };
  var tsTypePredicate = function(parameterName, typeAnnotation2 = null, asserts = null) {
    return (0, _validateNode.default)({
      type: "TSTypePredicate",
      parameterName,
      typeAnnotation: typeAnnotation2,
      asserts
    });
  };
  var tsTypeQuery = function(exprName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeQuery",
      exprName,
      typeParameters
    });
  };
  var tsTypeLiteral = function(members) {
    return (0, _validateNode.default)({
      type: "TSTypeLiteral",
      members
    });
  };
  var tsArrayType = function(elementType) {
    return (0, _validateNode.default)({
      type: "TSArrayType",
      elementType
    });
  };
  var tsTupleType = function(elementTypes) {
    return (0, _validateNode.default)({
      type: "TSTupleType",
      elementTypes
    });
  };
  var tsOptionalType = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsRestType = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSRestType",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsNamedTupleMember = function(label, elementType, optional = false) {
    return (0, _validateNode.default)({
      type: "TSNamedTupleMember",
      label,
      elementType,
      optional
    });
  };
  var tsUnionType = function(types) {
    return (0, _validateNode.default)({
      type: "TSUnionType",
      types
    });
  };
  var tsIntersectionType = function(types) {
    return (0, _validateNode.default)({
      type: "TSIntersectionType",
      types
    });
  };
  var tsConditionalType = function(checkType, extendsType, trueType, falseType) {
    return (0, _validateNode.default)({
      type: "TSConditionalType",
      checkType,
      extendsType,
      trueType,
      falseType
    });
  };
  var tsInferType = function(typeParameter2) {
    return (0, _validateNode.default)({
      type: "TSInferType",
      typeParameter: typeParameter2
    });
  };
  var tsParenthesizedType = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeOperator = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation2,
      operator: null
    });
  };
  var tsIndexedAccessType = function(objectType2, indexType) {
    return (0, _validateNode.default)({
      type: "TSIndexedAccessType",
      objectType: objectType2,
      indexType
    });
  };
  var tsMappedType = function(typeParameter2, typeAnnotation2 = null, nameType = null) {
    return (0, _validateNode.default)({
      type: "TSMappedType",
      typeParameter: typeParameter2,
      typeAnnotation: typeAnnotation2,
      nameType
    });
  };
  var tsLiteralType = function(literal) {
    return (0, _validateNode.default)({
      type: "TSLiteralType",
      literal
    });
  };
  var tsExpressionWithTypeArguments = function(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSExpressionWithTypeArguments",
      expression,
      typeParameters
    });
  };
  var tsInterfaceDeclaration = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "TSInterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var tsInterfaceBody = function(body) {
    return (0, _validateNode.default)({
      type: "TSInterfaceBody",
      body
    });
  };
  var tsTypeAliasDeclaration = function(id, typeParameters = null, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSTypeAliasDeclaration",
      id,
      typeParameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsInstantiationExpression = function(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSInstantiationExpression",
      expression,
      typeParameters
    });
  };
  var tsAsExpression = function(expression, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSAsExpression",
      expression,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsSatisfiesExpression = function(expression, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSSatisfiesExpression",
      expression,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeAssertion = function(typeAnnotation2, expression) {
    return (0, _validateNode.default)({
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation2,
      expression
    });
  };
  var tsEnumDeclaration = function(id, members) {
    return (0, _validateNode.default)({
      type: "TSEnumDeclaration",
      id,
      members
    });
  };
  var tsEnumMember = function(id, initializer = null) {
    return (0, _validateNode.default)({
      type: "TSEnumMember",
      id,
      initializer
    });
  };
  var tsModuleDeclaration = function(id, body) {
    return (0, _validateNode.default)({
      type: "TSModuleDeclaration",
      id,
      body
    });
  };
  var tsModuleBlock = function(body) {
    return (0, _validateNode.default)({
      type: "TSModuleBlock",
      body
    });
  };
  var tsImportType = function(argument, qualifier = null, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSImportType",
      argument,
      qualifier,
      typeParameters
    });
  };
  var tsImportEqualsDeclaration = function(id, moduleReference) {
    return (0, _validateNode.default)({
      type: "TSImportEqualsDeclaration",
      id,
      moduleReference,
      isExport: null
    });
  };
  var tsExternalModuleReference = function(expression) {
    return (0, _validateNode.default)({
      type: "TSExternalModuleReference",
      expression
    });
  };
  var tsNonNullExpression = function(expression) {
    return (0, _validateNode.default)({
      type: "TSNonNullExpression",
      expression
    });
  };
  var tsExportAssignment = function(expression) {
    return (0, _validateNode.default)({
      type: "TSExportAssignment",
      expression
    });
  };
  var tsNamespaceExportDeclaration = function(id) {
    return (0, _validateNode.default)({
      type: "TSNamespaceExportDeclaration",
      id
    });
  };
  var tsTypeAnnotation = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeParameterInstantiation = function(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterInstantiation",
      params
    });
  };
  var tsTypeParameterDeclaration = function(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterDeclaration",
      params
    });
  };
  var tsTypeParameter = function(constraint = null, _default = null, name) {
    return (0, _validateNode.default)({
      type: "TSTypeParameter",
      constraint,
      default: _default,
      name
    });
  };
  var NumberLiteral = function(value2) {
    (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value2);
  };
  var RegexLiteral = function(pattern, flags = "") {
    (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  };
  var RestProperty = function(argument) {
    (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
  };
  var SpreadProperty = function(argument) {
    (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.anyTypeAnnotation = anyTypeAnnotation;
  exports.argumentPlaceholder = argumentPlaceholder;
  exports.arrayExpression = arrayExpression;
  exports.arrayPattern = arrayPattern;
  exports.arrayTypeAnnotation = arrayTypeAnnotation;
  exports.arrowFunctionExpression = arrowFunctionExpression;
  exports.assignmentExpression = assignmentExpression;
  exports.assignmentPattern = assignmentPattern;
  exports.awaitExpression = awaitExpression;
  exports.bigIntLiteral = bigIntLiteral;
  exports.binaryExpression = binaryExpression;
  exports.bindExpression = bindExpression;
  exports.blockStatement = blockStatement;
  exports.booleanLiteral = booleanLiteral;
  exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  exports.booleanTypeAnnotation = booleanTypeAnnotation;
  exports.breakStatement = breakStatement;
  exports.callExpression = callExpression;
  exports.catchClause = catchClause;
  exports.classAccessorProperty = classAccessorProperty;
  exports.classBody = classBody;
  exports.classDeclaration = classDeclaration;
  exports.classExpression = classExpression;
  exports.classImplements = classImplements;
  exports.classMethod = classMethod;
  exports.classPrivateMethod = classPrivateMethod;
  exports.classPrivateProperty = classPrivateProperty;
  exports.classProperty = classProperty;
  exports.conditionalExpression = conditionalExpression;
  exports.continueStatement = continueStatement;
  exports.debuggerStatement = debuggerStatement;
  exports.decimalLiteral = decimalLiteral;
  exports.declareClass = declareClass;
  exports.declareExportAllDeclaration = declareExportAllDeclaration;
  exports.declareExportDeclaration = declareExportDeclaration;
  exports.declareFunction = declareFunction;
  exports.declareInterface = declareInterface;
  exports.declareModule = declareModule;
  exports.declareModuleExports = declareModuleExports;
  exports.declareOpaqueType = declareOpaqueType;
  exports.declareTypeAlias = declareTypeAlias;
  exports.declareVariable = declareVariable;
  exports.declaredPredicate = declaredPredicate;
  exports.decorator = decorator;
  exports.directive = directive;
  exports.directiveLiteral = directiveLiteral;
  exports.doExpression = doExpression;
  exports.doWhileStatement = doWhileStatement;
  exports.emptyStatement = emptyStatement;
  exports.emptyTypeAnnotation = emptyTypeAnnotation;
  exports.enumBooleanBody = enumBooleanBody;
  exports.enumBooleanMember = enumBooleanMember;
  exports.enumDeclaration = enumDeclaration;
  exports.enumDefaultedMember = enumDefaultedMember;
  exports.enumNumberBody = enumNumberBody;
  exports.enumNumberMember = enumNumberMember;
  exports.enumStringBody = enumStringBody;
  exports.enumStringMember = enumStringMember;
  exports.enumSymbolBody = enumSymbolBody;
  exports.existsTypeAnnotation = existsTypeAnnotation;
  exports.exportAllDeclaration = exportAllDeclaration;
  exports.exportDefaultDeclaration = exportDefaultDeclaration;
  exports.exportDefaultSpecifier = exportDefaultSpecifier;
  exports.exportNamedDeclaration = exportNamedDeclaration;
  exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
  exports.exportSpecifier = exportSpecifier;
  exports.expressionStatement = expressionStatement;
  exports.file = file;
  exports.forInStatement = forInStatement;
  exports.forOfStatement = forOfStatement;
  exports.forStatement = forStatement;
  exports.functionDeclaration = functionDeclaration;
  exports.functionExpression = functionExpression;
  exports.functionTypeAnnotation = functionTypeAnnotation;
  exports.functionTypeParam = functionTypeParam;
  exports.genericTypeAnnotation = genericTypeAnnotation;
  exports.identifier = identifier;
  exports.ifStatement = ifStatement;
  exports.import = _import;
  exports.importAttribute = importAttribute;
  exports.importDeclaration = importDeclaration;
  exports.importDefaultSpecifier = importDefaultSpecifier;
  exports.importExpression = importExpression;
  exports.importNamespaceSpecifier = importNamespaceSpecifier;
  exports.importSpecifier = importSpecifier;
  exports.indexedAccessType = indexedAccessType;
  exports.inferredPredicate = inferredPredicate;
  exports.interfaceDeclaration = interfaceDeclaration;
  exports.interfaceExtends = interfaceExtends;
  exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
  exports.interpreterDirective = interpreterDirective;
  exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
  exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
  exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
  exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
  exports.jSXElement = exports.jsxElement = jsxElement;
  exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
  exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
  exports.jSXFragment = exports.jsxFragment = jsxFragment;
  exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
  exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
  exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
  exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
  exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
  exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
  exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
  exports.jSXText = exports.jsxText = jsxText;
  exports.labeledStatement = labeledStatement;
  exports.logicalExpression = logicalExpression;
  exports.memberExpression = memberExpression;
  exports.metaProperty = metaProperty;
  exports.mixedTypeAnnotation = mixedTypeAnnotation;
  exports.moduleExpression = moduleExpression;
  exports.newExpression = newExpression;
  exports.noop = noop;
  exports.nullLiteral = nullLiteral;
  exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  exports.nullableTypeAnnotation = nullableTypeAnnotation;
  exports.numberLiteral = NumberLiteral;
  exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  exports.numberTypeAnnotation = numberTypeAnnotation;
  exports.numericLiteral = numericLiteral;
  exports.objectExpression = objectExpression;
  exports.objectMethod = objectMethod;
  exports.objectPattern = objectPattern;
  exports.objectProperty = objectProperty;
  exports.objectTypeAnnotation = objectTypeAnnotation;
  exports.objectTypeCallProperty = objectTypeCallProperty;
  exports.objectTypeIndexer = objectTypeIndexer;
  exports.objectTypeInternalSlot = objectTypeInternalSlot;
  exports.objectTypeProperty = objectTypeProperty;
  exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
  exports.opaqueType = opaqueType;
  exports.optionalCallExpression = optionalCallExpression;
  exports.optionalIndexedAccessType = optionalIndexedAccessType;
  exports.optionalMemberExpression = optionalMemberExpression;
  exports.parenthesizedExpression = parenthesizedExpression;
  exports.pipelineBareFunction = pipelineBareFunction;
  exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  exports.pipelineTopicExpression = pipelineTopicExpression;
  exports.placeholder = placeholder;
  exports.privateName = privateName;
  exports.program = program;
  exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  exports.recordExpression = recordExpression;
  exports.regExpLiteral = regExpLiteral;
  exports.regexLiteral = RegexLiteral;
  exports.restElement = restElement;
  exports.restProperty = RestProperty;
  exports.returnStatement = returnStatement;
  exports.sequenceExpression = sequenceExpression;
  exports.spreadElement = spreadElement;
  exports.spreadProperty = SpreadProperty;
  exports.staticBlock = staticBlock;
  exports.stringLiteral = stringLiteral;
  exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  exports.stringTypeAnnotation = stringTypeAnnotation;
  exports.super = _super;
  exports.switchCase = switchCase;
  exports.switchStatement = switchStatement;
  exports.symbolTypeAnnotation = symbolTypeAnnotation;
  exports.taggedTemplateExpression = taggedTemplateExpression;
  exports.templateElement = templateElement;
  exports.templateLiteral = templateLiteral;
  exports.thisExpression = thisExpression;
  exports.thisTypeAnnotation = thisTypeAnnotation;
  exports.throwStatement = throwStatement;
  exports.topicReference = topicReference;
  exports.tryStatement = tryStatement;
  exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
  exports.tSArrayType = exports.tsArrayType = tsArrayType;
  exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
  exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
  exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
  exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
  exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
  exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
  exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
  exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
  exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
  exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
  exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
  exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
  exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  exports.tSImportType = exports.tsImportType = tsImportType;
  exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
  exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
  exports.tSInferType = exports.tsInferType = tsInferType;
  exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
  exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
  exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
  exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
  exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
  exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
  exports.tSMappedType = exports.tsMappedType = tsMappedType;
  exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
  exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
  exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
  exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
  exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
  exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
  exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
  exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
  exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
  exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
  exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
  exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
  exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
  exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
  exports.tSRestType = exports.tsRestType = tsRestType;
  exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
  exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
  exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
  exports.tSThisType = exports.tsThisType = tsThisType;
  exports.tSTupleType = exports.tsTupleType = tsTupleType;
  exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
  exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
  exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
  exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
  exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
  exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
  exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
  exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
  exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
  exports.tSUnionType = exports.tsUnionType = tsUnionType;
  exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
  exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
  exports.tupleExpression = tupleExpression;
  exports.tupleTypeAnnotation = tupleTypeAnnotation;
  exports.typeAlias = typeAlias;
  exports.typeAnnotation = typeAnnotation;
  exports.typeCastExpression = typeCastExpression;
  exports.typeParameter = typeParameter;
  exports.typeParameterDeclaration = typeParameterDeclaration;
  exports.typeParameterInstantiation = typeParameterInstantiation;
  exports.typeofTypeAnnotation = typeofTypeAnnotation;
  exports.unaryExpression = unaryExpression;
  exports.unionTypeAnnotation = unionTypeAnnotation;
  exports.updateExpression = updateExpression;
  exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  exports.variableDeclaration = variableDeclaration;
  exports.variableDeclarator = variableDeclarator;
  exports.variance = variance;
  exports.voidTypeAnnotation = voidTypeAnnotation;
  exports.whileStatement = whileStatement;
  exports.withStatement = withStatement;
  exports.yieldExpression = yieldExpression;
  var _validateNode = require_validateNode();
  var _deprecationWarning = require_deprecationWarning();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS((exports) => {
  var cleanJSXElementLiteralChild = function(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0;i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0;i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str)
      args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cleanJSXElementLiteralChild;
  var _index = require_generated2();
  var _index2 = require_lib3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS((exports) => {
  var buildChildren = function(node2) {
    const elements = [];
    for (let i = 0;i < node2.children.length; i++) {
      let child = node2.children[i];
      if ((0, _index.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _index.isJSXExpressionContainer)(child))
        child = child.expression;
      if ((0, _index.isJSXEmptyExpression)(child))
        continue;
      elements.push(child);
    }
    return elements;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildChildren;
  var _index = require_generated();
  var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS((exports) => {
  var isNode = function(node2) {
    return !!(node2 && _index.VISITOR_KEYS[node2.type]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNode;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS((exports) => {
  var assertNode = function(node2) {
    if (!(0, _isNode.default)(node2)) {
      var _node$type;
      const type = (_node$type = node2 == null ? undefined : node2.type) != null ? _node$type : JSON.stringify(node2);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertNode;
  var _isNode = require_isNode();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS((exports) => {
  var assert = function(type, node2, opts) {
    if (!(0, _is.default)(type, node2, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node2.type}".`);
    }
  };
  var assertArrayExpression = function(node2, opts) {
    assert("ArrayExpression", node2, opts);
  };
  var assertAssignmentExpression = function(node2, opts) {
    assert("AssignmentExpression", node2, opts);
  };
  var assertBinaryExpression = function(node2, opts) {
    assert("BinaryExpression", node2, opts);
  };
  var assertInterpreterDirective = function(node2, opts) {
    assert("InterpreterDirective", node2, opts);
  };
  var assertDirective = function(node2, opts) {
    assert("Directive", node2, opts);
  };
  var assertDirectiveLiteral = function(node2, opts) {
    assert("DirectiveLiteral", node2, opts);
  };
  var assertBlockStatement = function(node2, opts) {
    assert("BlockStatement", node2, opts);
  };
  var assertBreakStatement = function(node2, opts) {
    assert("BreakStatement", node2, opts);
  };
  var assertCallExpression = function(node2, opts) {
    assert("CallExpression", node2, opts);
  };
  var assertCatchClause = function(node2, opts) {
    assert("CatchClause", node2, opts);
  };
  var assertConditionalExpression = function(node2, opts) {
    assert("ConditionalExpression", node2, opts);
  };
  var assertContinueStatement = function(node2, opts) {
    assert("ContinueStatement", node2, opts);
  };
  var assertDebuggerStatement = function(node2, opts) {
    assert("DebuggerStatement", node2, opts);
  };
  var assertDoWhileStatement = function(node2, opts) {
    assert("DoWhileStatement", node2, opts);
  };
  var assertEmptyStatement = function(node2, opts) {
    assert("EmptyStatement", node2, opts);
  };
  var assertExpressionStatement = function(node2, opts) {
    assert("ExpressionStatement", node2, opts);
  };
  var assertFile = function(node2, opts) {
    assert("File", node2, opts);
  };
  var assertForInStatement = function(node2, opts) {
    assert("ForInStatement", node2, opts);
  };
  var assertForStatement = function(node2, opts) {
    assert("ForStatement", node2, opts);
  };
  var assertFunctionDeclaration = function(node2, opts) {
    assert("FunctionDeclaration", node2, opts);
  };
  var assertFunctionExpression = function(node2, opts) {
    assert("FunctionExpression", node2, opts);
  };
  var assertIdentifier = function(node2, opts) {
    assert("Identifier", node2, opts);
  };
  var assertIfStatement = function(node2, opts) {
    assert("IfStatement", node2, opts);
  };
  var assertLabeledStatement = function(node2, opts) {
    assert("LabeledStatement", node2, opts);
  };
  var assertStringLiteral = function(node2, opts) {
    assert("StringLiteral", node2, opts);
  };
  var assertNumericLiteral = function(node2, opts) {
    assert("NumericLiteral", node2, opts);
  };
  var assertNullLiteral = function(node2, opts) {
    assert("NullLiteral", node2, opts);
  };
  var assertBooleanLiteral = function(node2, opts) {
    assert("BooleanLiteral", node2, opts);
  };
  var assertRegExpLiteral = function(node2, opts) {
    assert("RegExpLiteral", node2, opts);
  };
  var assertLogicalExpression = function(node2, opts) {
    assert("LogicalExpression", node2, opts);
  };
  var assertMemberExpression = function(node2, opts) {
    assert("MemberExpression", node2, opts);
  };
  var assertNewExpression = function(node2, opts) {
    assert("NewExpression", node2, opts);
  };
  var assertProgram = function(node2, opts) {
    assert("Program", node2, opts);
  };
  var assertObjectExpression = function(node2, opts) {
    assert("ObjectExpression", node2, opts);
  };
  var assertObjectMethod = function(node2, opts) {
    assert("ObjectMethod", node2, opts);
  };
  var assertObjectProperty = function(node2, opts) {
    assert("ObjectProperty", node2, opts);
  };
  var assertRestElement = function(node2, opts) {
    assert("RestElement", node2, opts);
  };
  var assertReturnStatement = function(node2, opts) {
    assert("ReturnStatement", node2, opts);
  };
  var assertSequenceExpression = function(node2, opts) {
    assert("SequenceExpression", node2, opts);
  };
  var assertParenthesizedExpression = function(node2, opts) {
    assert("ParenthesizedExpression", node2, opts);
  };
  var assertSwitchCase = function(node2, opts) {
    assert("SwitchCase", node2, opts);
  };
  var assertSwitchStatement = function(node2, opts) {
    assert("SwitchStatement", node2, opts);
  };
  var assertThisExpression = function(node2, opts) {
    assert("ThisExpression", node2, opts);
  };
  var assertThrowStatement = function(node2, opts) {
    assert("ThrowStatement", node2, opts);
  };
  var assertTryStatement = function(node2, opts) {
    assert("TryStatement", node2, opts);
  };
  var assertUnaryExpression = function(node2, opts) {
    assert("UnaryExpression", node2, opts);
  };
  var assertUpdateExpression = function(node2, opts) {
    assert("UpdateExpression", node2, opts);
  };
  var assertVariableDeclaration = function(node2, opts) {
    assert("VariableDeclaration", node2, opts);
  };
  var assertVariableDeclarator = function(node2, opts) {
    assert("VariableDeclarator", node2, opts);
  };
  var assertWhileStatement = function(node2, opts) {
    assert("WhileStatement", node2, opts);
  };
  var assertWithStatement = function(node2, opts) {
    assert("WithStatement", node2, opts);
  };
  var assertAssignmentPattern = function(node2, opts) {
    assert("AssignmentPattern", node2, opts);
  };
  var assertArrayPattern = function(node2, opts) {
    assert("ArrayPattern", node2, opts);
  };
  var assertArrowFunctionExpression = function(node2, opts) {
    assert("ArrowFunctionExpression", node2, opts);
  };
  var assertClassBody = function(node2, opts) {
    assert("ClassBody", node2, opts);
  };
  var assertClassExpression = function(node2, opts) {
    assert("ClassExpression", node2, opts);
  };
  var assertClassDeclaration = function(node2, opts) {
    assert("ClassDeclaration", node2, opts);
  };
  var assertExportAllDeclaration = function(node2, opts) {
    assert("ExportAllDeclaration", node2, opts);
  };
  var assertExportDefaultDeclaration = function(node2, opts) {
    assert("ExportDefaultDeclaration", node2, opts);
  };
  var assertExportNamedDeclaration = function(node2, opts) {
    assert("ExportNamedDeclaration", node2, opts);
  };
  var assertExportSpecifier = function(node2, opts) {
    assert("ExportSpecifier", node2, opts);
  };
  var assertForOfStatement = function(node2, opts) {
    assert("ForOfStatement", node2, opts);
  };
  var assertImportDeclaration = function(node2, opts) {
    assert("ImportDeclaration", node2, opts);
  };
  var assertImportDefaultSpecifier = function(node2, opts) {
    assert("ImportDefaultSpecifier", node2, opts);
  };
  var assertImportNamespaceSpecifier = function(node2, opts) {
    assert("ImportNamespaceSpecifier", node2, opts);
  };
  var assertImportSpecifier = function(node2, opts) {
    assert("ImportSpecifier", node2, opts);
  };
  var assertImportExpression = function(node2, opts) {
    assert("ImportExpression", node2, opts);
  };
  var assertMetaProperty = function(node2, opts) {
    assert("MetaProperty", node2, opts);
  };
  var assertClassMethod = function(node2, opts) {
    assert("ClassMethod", node2, opts);
  };
  var assertObjectPattern = function(node2, opts) {
    assert("ObjectPattern", node2, opts);
  };
  var assertSpreadElement = function(node2, opts) {
    assert("SpreadElement", node2, opts);
  };
  var assertSuper = function(node2, opts) {
    assert("Super", node2, opts);
  };
  var assertTaggedTemplateExpression = function(node2, opts) {
    assert("TaggedTemplateExpression", node2, opts);
  };
  var assertTemplateElement = function(node2, opts) {
    assert("TemplateElement", node2, opts);
  };
  var assertTemplateLiteral = function(node2, opts) {
    assert("TemplateLiteral", node2, opts);
  };
  var assertYieldExpression = function(node2, opts) {
    assert("YieldExpression", node2, opts);
  };
  var assertAwaitExpression = function(node2, opts) {
    assert("AwaitExpression", node2, opts);
  };
  var assertImport = function(node2, opts) {
    assert("Import", node2, opts);
  };
  var assertBigIntLiteral = function(node2, opts) {
    assert("BigIntLiteral", node2, opts);
  };
  var assertExportNamespaceSpecifier = function(node2, opts) {
    assert("ExportNamespaceSpecifier", node2, opts);
  };
  var assertOptionalMemberExpression = function(node2, opts) {
    assert("OptionalMemberExpression", node2, opts);
  };
  var assertOptionalCallExpression = function(node2, opts) {
    assert("OptionalCallExpression", node2, opts);
  };
  var assertClassProperty = function(node2, opts) {
    assert("ClassProperty", node2, opts);
  };
  var assertClassAccessorProperty = function(node2, opts) {
    assert("ClassAccessorProperty", node2, opts);
  };
  var assertClassPrivateProperty = function(node2, opts) {
    assert("ClassPrivateProperty", node2, opts);
  };
  var assertClassPrivateMethod = function(node2, opts) {
    assert("ClassPrivateMethod", node2, opts);
  };
  var assertPrivateName = function(node2, opts) {
    assert("PrivateName", node2, opts);
  };
  var assertStaticBlock = function(node2, opts) {
    assert("StaticBlock", node2, opts);
  };
  var assertAnyTypeAnnotation = function(node2, opts) {
    assert("AnyTypeAnnotation", node2, opts);
  };
  var assertArrayTypeAnnotation = function(node2, opts) {
    assert("ArrayTypeAnnotation", node2, opts);
  };
  var assertBooleanTypeAnnotation = function(node2, opts) {
    assert("BooleanTypeAnnotation", node2, opts);
  };
  var assertBooleanLiteralTypeAnnotation = function(node2, opts) {
    assert("BooleanLiteralTypeAnnotation", node2, opts);
  };
  var assertNullLiteralTypeAnnotation = function(node2, opts) {
    assert("NullLiteralTypeAnnotation", node2, opts);
  };
  var assertClassImplements = function(node2, opts) {
    assert("ClassImplements", node2, opts);
  };
  var assertDeclareClass = function(node2, opts) {
    assert("DeclareClass", node2, opts);
  };
  var assertDeclareFunction = function(node2, opts) {
    assert("DeclareFunction", node2, opts);
  };
  var assertDeclareInterface = function(node2, opts) {
    assert("DeclareInterface", node2, opts);
  };
  var assertDeclareModule = function(node2, opts) {
    assert("DeclareModule", node2, opts);
  };
  var assertDeclareModuleExports = function(node2, opts) {
    assert("DeclareModuleExports", node2, opts);
  };
  var assertDeclareTypeAlias = function(node2, opts) {
    assert("DeclareTypeAlias", node2, opts);
  };
  var assertDeclareOpaqueType = function(node2, opts) {
    assert("DeclareOpaqueType", node2, opts);
  };
  var assertDeclareVariable = function(node2, opts) {
    assert("DeclareVariable", node2, opts);
  };
  var assertDeclareExportDeclaration = function(node2, opts) {
    assert("DeclareExportDeclaration", node2, opts);
  };
  var assertDeclareExportAllDeclaration = function(node2, opts) {
    assert("DeclareExportAllDeclaration", node2, opts);
  };
  var assertDeclaredPredicate = function(node2, opts) {
    assert("DeclaredPredicate", node2, opts);
  };
  var assertExistsTypeAnnotation = function(node2, opts) {
    assert("ExistsTypeAnnotation", node2, opts);
  };
  var assertFunctionTypeAnnotation = function(node2, opts) {
    assert("FunctionTypeAnnotation", node2, opts);
  };
  var assertFunctionTypeParam = function(node2, opts) {
    assert("FunctionTypeParam", node2, opts);
  };
  var assertGenericTypeAnnotation = function(node2, opts) {
    assert("GenericTypeAnnotation", node2, opts);
  };
  var assertInferredPredicate = function(node2, opts) {
    assert("InferredPredicate", node2, opts);
  };
  var assertInterfaceExtends = function(node2, opts) {
    assert("InterfaceExtends", node2, opts);
  };
  var assertInterfaceDeclaration = function(node2, opts) {
    assert("InterfaceDeclaration", node2, opts);
  };
  var assertInterfaceTypeAnnotation = function(node2, opts) {
    assert("InterfaceTypeAnnotation", node2, opts);
  };
  var assertIntersectionTypeAnnotation = function(node2, opts) {
    assert("IntersectionTypeAnnotation", node2, opts);
  };
  var assertMixedTypeAnnotation = function(node2, opts) {
    assert("MixedTypeAnnotation", node2, opts);
  };
  var assertEmptyTypeAnnotation = function(node2, opts) {
    assert("EmptyTypeAnnotation", node2, opts);
  };
  var assertNullableTypeAnnotation = function(node2, opts) {
    assert("NullableTypeAnnotation", node2, opts);
  };
  var assertNumberLiteralTypeAnnotation = function(node2, opts) {
    assert("NumberLiteralTypeAnnotation", node2, opts);
  };
  var assertNumberTypeAnnotation = function(node2, opts) {
    assert("NumberTypeAnnotation", node2, opts);
  };
  var assertObjectTypeAnnotation = function(node2, opts) {
    assert("ObjectTypeAnnotation", node2, opts);
  };
  var assertObjectTypeInternalSlot = function(node2, opts) {
    assert("ObjectTypeInternalSlot", node2, opts);
  };
  var assertObjectTypeCallProperty = function(node2, opts) {
    assert("ObjectTypeCallProperty", node2, opts);
  };
  var assertObjectTypeIndexer = function(node2, opts) {
    assert("ObjectTypeIndexer", node2, opts);
  };
  var assertObjectTypeProperty = function(node2, opts) {
    assert("ObjectTypeProperty", node2, opts);
  };
  var assertObjectTypeSpreadProperty = function(node2, opts) {
    assert("ObjectTypeSpreadProperty", node2, opts);
  };
  var assertOpaqueType = function(node2, opts) {
    assert("OpaqueType", node2, opts);
  };
  var assertQualifiedTypeIdentifier = function(node2, opts) {
    assert("QualifiedTypeIdentifier", node2, opts);
  };
  var assertStringLiteralTypeAnnotation = function(node2, opts) {
    assert("StringLiteralTypeAnnotation", node2, opts);
  };
  var assertStringTypeAnnotation = function(node2, opts) {
    assert("StringTypeAnnotation", node2, opts);
  };
  var assertSymbolTypeAnnotation = function(node2, opts) {
    assert("SymbolTypeAnnotation", node2, opts);
  };
  var assertThisTypeAnnotation = function(node2, opts) {
    assert("ThisTypeAnnotation", node2, opts);
  };
  var assertTupleTypeAnnotation = function(node2, opts) {
    assert("TupleTypeAnnotation", node2, opts);
  };
  var assertTypeofTypeAnnotation = function(node2, opts) {
    assert("TypeofTypeAnnotation", node2, opts);
  };
  var assertTypeAlias = function(node2, opts) {
    assert("TypeAlias", node2, opts);
  };
  var assertTypeAnnotation = function(node2, opts) {
    assert("TypeAnnotation", node2, opts);
  };
  var assertTypeCastExpression = function(node2, opts) {
    assert("TypeCastExpression", node2, opts);
  };
  var assertTypeParameter = function(node2, opts) {
    assert("TypeParameter", node2, opts);
  };
  var assertTypeParameterDeclaration = function(node2, opts) {
    assert("TypeParameterDeclaration", node2, opts);
  };
  var assertTypeParameterInstantiation = function(node2, opts) {
    assert("TypeParameterInstantiation", node2, opts);
  };
  var assertUnionTypeAnnotation = function(node2, opts) {
    assert("UnionTypeAnnotation", node2, opts);
  };
  var assertVariance = function(node2, opts) {
    assert("Variance", node2, opts);
  };
  var assertVoidTypeAnnotation = function(node2, opts) {
    assert("VoidTypeAnnotation", node2, opts);
  };
  var assertEnumDeclaration = function(node2, opts) {
    assert("EnumDeclaration", node2, opts);
  };
  var assertEnumBooleanBody = function(node2, opts) {
    assert("EnumBooleanBody", node2, opts);
  };
  var assertEnumNumberBody = function(node2, opts) {
    assert("EnumNumberBody", node2, opts);
  };
  var assertEnumStringBody = function(node2, opts) {
    assert("EnumStringBody", node2, opts);
  };
  var assertEnumSymbolBody = function(node2, opts) {
    assert("EnumSymbolBody", node2, opts);
  };
  var assertEnumBooleanMember = function(node2, opts) {
    assert("EnumBooleanMember", node2, opts);
  };
  var assertEnumNumberMember = function(node2, opts) {
    assert("EnumNumberMember", node2, opts);
  };
  var assertEnumStringMember = function(node2, opts) {
    assert("EnumStringMember", node2, opts);
  };
  var assertEnumDefaultedMember = function(node2, opts) {
    assert("EnumDefaultedMember", node2, opts);
  };
  var assertIndexedAccessType = function(node2, opts) {
    assert("IndexedAccessType", node2, opts);
  };
  var assertOptionalIndexedAccessType = function(node2, opts) {
    assert("OptionalIndexedAccessType", node2, opts);
  };
  var assertJSXAttribute = function(node2, opts) {
    assert("JSXAttribute", node2, opts);
  };
  var assertJSXClosingElement = function(node2, opts) {
    assert("JSXClosingElement", node2, opts);
  };
  var assertJSXElement = function(node2, opts) {
    assert("JSXElement", node2, opts);
  };
  var assertJSXEmptyExpression = function(node2, opts) {
    assert("JSXEmptyExpression", node2, opts);
  };
  var assertJSXExpressionContainer = function(node2, opts) {
    assert("JSXExpressionContainer", node2, opts);
  };
  var assertJSXSpreadChild = function(node2, opts) {
    assert("JSXSpreadChild", node2, opts);
  };
  var assertJSXIdentifier = function(node2, opts) {
    assert("JSXIdentifier", node2, opts);
  };
  var assertJSXMemberExpression = function(node2, opts) {
    assert("JSXMemberExpression", node2, opts);
  };
  var assertJSXNamespacedName = function(node2, opts) {
    assert("JSXNamespacedName", node2, opts);
  };
  var assertJSXOpeningElement = function(node2, opts) {
    assert("JSXOpeningElement", node2, opts);
  };
  var assertJSXSpreadAttribute = function(node2, opts) {
    assert("JSXSpreadAttribute", node2, opts);
  };
  var assertJSXText = function(node2, opts) {
    assert("JSXText", node2, opts);
  };
  var assertJSXFragment = function(node2, opts) {
    assert("JSXFragment", node2, opts);
  };
  var assertJSXOpeningFragment = function(node2, opts) {
    assert("JSXOpeningFragment", node2, opts);
  };
  var assertJSXClosingFragment = function(node2, opts) {
    assert("JSXClosingFragment", node2, opts);
  };
  var assertNoop = function(node2, opts) {
    assert("Noop", node2, opts);
  };
  var assertPlaceholder = function(node2, opts) {
    assert("Placeholder", node2, opts);
  };
  var assertV8IntrinsicIdentifier = function(node2, opts) {
    assert("V8IntrinsicIdentifier", node2, opts);
  };
  var assertArgumentPlaceholder = function(node2, opts) {
    assert("ArgumentPlaceholder", node2, opts);
  };
  var assertBindExpression = function(node2, opts) {
    assert("BindExpression", node2, opts);
  };
  var assertImportAttribute = function(node2, opts) {
    assert("ImportAttribute", node2, opts);
  };
  var assertDecorator = function(node2, opts) {
    assert("Decorator", node2, opts);
  };
  var assertDoExpression = function(node2, opts) {
    assert("DoExpression", node2, opts);
  };
  var assertExportDefaultSpecifier = function(node2, opts) {
    assert("ExportDefaultSpecifier", node2, opts);
  };
  var assertRecordExpression = function(node2, opts) {
    assert("RecordExpression", node2, opts);
  };
  var assertTupleExpression = function(node2, opts) {
    assert("TupleExpression", node2, opts);
  };
  var assertDecimalLiteral = function(node2, opts) {
    assert("DecimalLiteral", node2, opts);
  };
  var assertModuleExpression = function(node2, opts) {
    assert("ModuleExpression", node2, opts);
  };
  var assertTopicReference = function(node2, opts) {
    assert("TopicReference", node2, opts);
  };
  var assertPipelineTopicExpression = function(node2, opts) {
    assert("PipelineTopicExpression", node2, opts);
  };
  var assertPipelineBareFunction = function(node2, opts) {
    assert("PipelineBareFunction", node2, opts);
  };
  var assertPipelinePrimaryTopicReference = function(node2, opts) {
    assert("PipelinePrimaryTopicReference", node2, opts);
  };
  var assertTSParameterProperty = function(node2, opts) {
    assert("TSParameterProperty", node2, opts);
  };
  var assertTSDeclareFunction = function(node2, opts) {
    assert("TSDeclareFunction", node2, opts);
  };
  var assertTSDeclareMethod = function(node2, opts) {
    assert("TSDeclareMethod", node2, opts);
  };
  var assertTSQualifiedName = function(node2, opts) {
    assert("TSQualifiedName", node2, opts);
  };
  var assertTSCallSignatureDeclaration = function(node2, opts) {
    assert("TSCallSignatureDeclaration", node2, opts);
  };
  var assertTSConstructSignatureDeclaration = function(node2, opts) {
    assert("TSConstructSignatureDeclaration", node2, opts);
  };
  var assertTSPropertySignature = function(node2, opts) {
    assert("TSPropertySignature", node2, opts);
  };
  var assertTSMethodSignature = function(node2, opts) {
    assert("TSMethodSignature", node2, opts);
  };
  var assertTSIndexSignature = function(node2, opts) {
    assert("TSIndexSignature", node2, opts);
  };
  var assertTSAnyKeyword = function(node2, opts) {
    assert("TSAnyKeyword", node2, opts);
  };
  var assertTSBooleanKeyword = function(node2, opts) {
    assert("TSBooleanKeyword", node2, opts);
  };
  var assertTSBigIntKeyword = function(node2, opts) {
    assert("TSBigIntKeyword", node2, opts);
  };
  var assertTSIntrinsicKeyword = function(node2, opts) {
    assert("TSIntrinsicKeyword", node2, opts);
  };
  var assertTSNeverKeyword = function(node2, opts) {
    assert("TSNeverKeyword", node2, opts);
  };
  var assertTSNullKeyword = function(node2, opts) {
    assert("TSNullKeyword", node2, opts);
  };
  var assertTSNumberKeyword = function(node2, opts) {
    assert("TSNumberKeyword", node2, opts);
  };
  var assertTSObjectKeyword = function(node2, opts) {
    assert("TSObjectKeyword", node2, opts);
  };
  var assertTSStringKeyword = function(node2, opts) {
    assert("TSStringKeyword", node2, opts);
  };
  var assertTSSymbolKeyword = function(node2, opts) {
    assert("TSSymbolKeyword", node2, opts);
  };
  var assertTSUndefinedKeyword = function(node2, opts) {
    assert("TSUndefinedKeyword", node2, opts);
  };
  var assertTSUnknownKeyword = function(node2, opts) {
    assert("TSUnknownKeyword", node2, opts);
  };
  var assertTSVoidKeyword = function(node2, opts) {
    assert("TSVoidKeyword", node2, opts);
  };
  var assertTSThisType = function(node2, opts) {
    assert("TSThisType", node2, opts);
  };
  var assertTSFunctionType = function(node2, opts) {
    assert("TSFunctionType", node2, opts);
  };
  var assertTSConstructorType = function(node2, opts) {
    assert("TSConstructorType", node2, opts);
  };
  var assertTSTypeReference = function(node2, opts) {
    assert("TSTypeReference", node2, opts);
  };
  var assertTSTypePredicate = function(node2, opts) {
    assert("TSTypePredicate", node2, opts);
  };
  var assertTSTypeQuery = function(node2, opts) {
    assert("TSTypeQuery", node2, opts);
  };
  var assertTSTypeLiteral = function(node2, opts) {
    assert("TSTypeLiteral", node2, opts);
  };
  var assertTSArrayType = function(node2, opts) {
    assert("TSArrayType", node2, opts);
  };
  var assertTSTupleType = function(node2, opts) {
    assert("TSTupleType", node2, opts);
  };
  var assertTSOptionalType = function(node2, opts) {
    assert("TSOptionalType", node2, opts);
  };
  var assertTSRestType = function(node2, opts) {
    assert("TSRestType", node2, opts);
  };
  var assertTSNamedTupleMember = function(node2, opts) {
    assert("TSNamedTupleMember", node2, opts);
  };
  var assertTSUnionType = function(node2, opts) {
    assert("TSUnionType", node2, opts);
  };
  var assertTSIntersectionType = function(node2, opts) {
    assert("TSIntersectionType", node2, opts);
  };
  var assertTSConditionalType = function(node2, opts) {
    assert("TSConditionalType", node2, opts);
  };
  var assertTSInferType = function(node2, opts) {
    assert("TSInferType", node2, opts);
  };
  var assertTSParenthesizedType = function(node2, opts) {
    assert("TSParenthesizedType", node2, opts);
  };
  var assertTSTypeOperator = function(node2, opts) {
    assert("TSTypeOperator", node2, opts);
  };
  var assertTSIndexedAccessType = function(node2, opts) {
    assert("TSIndexedAccessType", node2, opts);
  };
  var assertTSMappedType = function(node2, opts) {
    assert("TSMappedType", node2, opts);
  };
  var assertTSLiteralType = function(node2, opts) {
    assert("TSLiteralType", node2, opts);
  };
  var assertTSExpressionWithTypeArguments = function(node2, opts) {
    assert("TSExpressionWithTypeArguments", node2, opts);
  };
  var assertTSInterfaceDeclaration = function(node2, opts) {
    assert("TSInterfaceDeclaration", node2, opts);
  };
  var assertTSInterfaceBody = function(node2, opts) {
    assert("TSInterfaceBody", node2, opts);
  };
  var assertTSTypeAliasDeclaration = function(node2, opts) {
    assert("TSTypeAliasDeclaration", node2, opts);
  };
  var assertTSInstantiationExpression = function(node2, opts) {
    assert("TSInstantiationExpression", node2, opts);
  };
  var assertTSAsExpression = function(node2, opts) {
    assert("TSAsExpression", node2, opts);
  };
  var assertTSSatisfiesExpression = function(node2, opts) {
    assert("TSSatisfiesExpression", node2, opts);
  };
  var assertTSTypeAssertion = function(node2, opts) {
    assert("TSTypeAssertion", node2, opts);
  };
  var assertTSEnumDeclaration = function(node2, opts) {
    assert("TSEnumDeclaration", node2, opts);
  };
  var assertTSEnumMember = function(node2, opts) {
    assert("TSEnumMember", node2, opts);
  };
  var assertTSModuleDeclaration = function(node2, opts) {
    assert("TSModuleDeclaration", node2, opts);
  };
  var assertTSModuleBlock = function(node2, opts) {
    assert("TSModuleBlock", node2, opts);
  };
  var assertTSImportType = function(node2, opts) {
    assert("TSImportType", node2, opts);
  };
  var assertTSImportEqualsDeclaration = function(node2, opts) {
    assert("TSImportEqualsDeclaration", node2, opts);
  };
  var assertTSExternalModuleReference = function(node2, opts) {
    assert("TSExternalModuleReference", node2, opts);
  };
  var assertTSNonNullExpression = function(node2, opts) {
    assert("TSNonNullExpression", node2, opts);
  };
  var assertTSExportAssignment = function(node2, opts) {
    assert("TSExportAssignment", node2, opts);
  };
  var assertTSNamespaceExportDeclaration = function(node2, opts) {
    assert("TSNamespaceExportDeclaration", node2, opts);
  };
  var assertTSTypeAnnotation = function(node2, opts) {
    assert("TSTypeAnnotation", node2, opts);
  };
  var assertTSTypeParameterInstantiation = function(node2, opts) {
    assert("TSTypeParameterInstantiation", node2, opts);
  };
  var assertTSTypeParameterDeclaration = function(node2, opts) {
    assert("TSTypeParameterDeclaration", node2, opts);
  };
  var assertTSTypeParameter = function(node2, opts) {
    assert("TSTypeParameter", node2, opts);
  };
  var assertStandardized = function(node2, opts) {
    assert("Standardized", node2, opts);
  };
  var assertExpression = function(node2, opts) {
    assert("Expression", node2, opts);
  };
  var assertBinary = function(node2, opts) {
    assert("Binary", node2, opts);
  };
  var assertScopable = function(node2, opts) {
    assert("Scopable", node2, opts);
  };
  var assertBlockParent = function(node2, opts) {
    assert("BlockParent", node2, opts);
  };
  var assertBlock = function(node2, opts) {
    assert("Block", node2, opts);
  };
  var assertStatement = function(node2, opts) {
    assert("Statement", node2, opts);
  };
  var assertTerminatorless = function(node2, opts) {
    assert("Terminatorless", node2, opts);
  };
  var assertCompletionStatement = function(node2, opts) {
    assert("CompletionStatement", node2, opts);
  };
  var assertConditional = function(node2, opts) {
    assert("Conditional", node2, opts);
  };
  var assertLoop = function(node2, opts) {
    assert("Loop", node2, opts);
  };
  var assertWhile = function(node2, opts) {
    assert("While", node2, opts);
  };
  var assertExpressionWrapper = function(node2, opts) {
    assert("ExpressionWrapper", node2, opts);
  };
  var assertFor = function(node2, opts) {
    assert("For", node2, opts);
  };
  var assertForXStatement = function(node2, opts) {
    assert("ForXStatement", node2, opts);
  };
  var assertFunction = function(node2, opts) {
    assert("Function", node2, opts);
  };
  var assertFunctionParent = function(node2, opts) {
    assert("FunctionParent", node2, opts);
  };
  var assertPureish = function(node2, opts) {
    assert("Pureish", node2, opts);
  };
  var assertDeclaration = function(node2, opts) {
    assert("Declaration", node2, opts);
  };
  var assertPatternLike = function(node2, opts) {
    assert("PatternLike", node2, opts);
  };
  var assertLVal = function(node2, opts) {
    assert("LVal", node2, opts);
  };
  var assertTSEntityName = function(node2, opts) {
    assert("TSEntityName", node2, opts);
  };
  var assertLiteral = function(node2, opts) {
    assert("Literal", node2, opts);
  };
  var assertImmutable = function(node2, opts) {
    assert("Immutable", node2, opts);
  };
  var assertUserWhitespacable = function(node2, opts) {
    assert("UserWhitespacable", node2, opts);
  };
  var assertMethod = function(node2, opts) {
    assert("Method", node2, opts);
  };
  var assertObjectMember = function(node2, opts) {
    assert("ObjectMember", node2, opts);
  };
  var assertProperty = function(node2, opts) {
    assert("Property", node2, opts);
  };
  var assertUnaryLike = function(node2, opts) {
    assert("UnaryLike", node2, opts);
  };
  var assertPattern = function(node2, opts) {
    assert("Pattern", node2, opts);
  };
  var assertClass = function(node2, opts) {
    assert("Class", node2, opts);
  };
  var assertImportOrExportDeclaration = function(node2, opts) {
    assert("ImportOrExportDeclaration", node2, opts);
  };
  var assertExportDeclaration = function(node2, opts) {
    assert("ExportDeclaration", node2, opts);
  };
  var assertModuleSpecifier = function(node2, opts) {
    assert("ModuleSpecifier", node2, opts);
  };
  var assertAccessor = function(node2, opts) {
    assert("Accessor", node2, opts);
  };
  var assertPrivate = function(node2, opts) {
    assert("Private", node2, opts);
  };
  var assertFlow = function(node2, opts) {
    assert("Flow", node2, opts);
  };
  var assertFlowType = function(node2, opts) {
    assert("FlowType", node2, opts);
  };
  var assertFlowBaseAnnotation = function(node2, opts) {
    assert("FlowBaseAnnotation", node2, opts);
  };
  var assertFlowDeclaration = function(node2, opts) {
    assert("FlowDeclaration", node2, opts);
  };
  var assertFlowPredicate = function(node2, opts) {
    assert("FlowPredicate", node2, opts);
  };
  var assertEnumBody = function(node2, opts) {
    assert("EnumBody", node2, opts);
  };
  var assertEnumMember = function(node2, opts) {
    assert("EnumMember", node2, opts);
  };
  var assertJSX = function(node2, opts) {
    assert("JSX", node2, opts);
  };
  var assertMiscellaneous = function(node2, opts) {
    assert("Miscellaneous", node2, opts);
  };
  var assertTypeScript = function(node2, opts) {
    assert("TypeScript", node2, opts);
  };
  var assertTSTypeElement = function(node2, opts) {
    assert("TSTypeElement", node2, opts);
  };
  var assertTSType = function(node2, opts) {
    assert("TSType", node2, opts);
  };
  var assertTSBaseType = function(node2, opts) {
    assert("TSBaseType", node2, opts);
  };
  var assertNumberLiteral = function(node2, opts) {
    (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    assert("NumberLiteral", node2, opts);
  };
  var assertRegexLiteral = function(node2, opts) {
    (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    assert("RegexLiteral", node2, opts);
  };
  var assertRestProperty = function(node2, opts) {
    (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    assert("RestProperty", node2, opts);
  };
  var assertSpreadProperty = function(node2, opts) {
    (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    assert("SpreadProperty", node2, opts);
  };
  var assertModuleDeclaration = function(node2, opts) {
    (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert("ModuleDeclaration", node2, opts);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertAccessor = assertAccessor;
  exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
  exports.assertArrayExpression = assertArrayExpression;
  exports.assertArrayPattern = assertArrayPattern;
  exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
  exports.assertAssignmentExpression = assertAssignmentExpression;
  exports.assertAssignmentPattern = assertAssignmentPattern;
  exports.assertAwaitExpression = assertAwaitExpression;
  exports.assertBigIntLiteral = assertBigIntLiteral;
  exports.assertBinary = assertBinary;
  exports.assertBinaryExpression = assertBinaryExpression;
  exports.assertBindExpression = assertBindExpression;
  exports.assertBlock = assertBlock;
  exports.assertBlockParent = assertBlockParent;
  exports.assertBlockStatement = assertBlockStatement;
  exports.assertBooleanLiteral = assertBooleanLiteral;
  exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  exports.assertBreakStatement = assertBreakStatement;
  exports.assertCallExpression = assertCallExpression;
  exports.assertCatchClause = assertCatchClause;
  exports.assertClass = assertClass;
  exports.assertClassAccessorProperty = assertClassAccessorProperty;
  exports.assertClassBody = assertClassBody;
  exports.assertClassDeclaration = assertClassDeclaration;
  exports.assertClassExpression = assertClassExpression;
  exports.assertClassImplements = assertClassImplements;
  exports.assertClassMethod = assertClassMethod;
  exports.assertClassPrivateMethod = assertClassPrivateMethod;
  exports.assertClassPrivateProperty = assertClassPrivateProperty;
  exports.assertClassProperty = assertClassProperty;
  exports.assertCompletionStatement = assertCompletionStatement;
  exports.assertConditional = assertConditional;
  exports.assertConditionalExpression = assertConditionalExpression;
  exports.assertContinueStatement = assertContinueStatement;
  exports.assertDebuggerStatement = assertDebuggerStatement;
  exports.assertDecimalLiteral = assertDecimalLiteral;
  exports.assertDeclaration = assertDeclaration;
  exports.assertDeclareClass = assertDeclareClass;
  exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  exports.assertDeclareFunction = assertDeclareFunction;
  exports.assertDeclareInterface = assertDeclareInterface;
  exports.assertDeclareModule = assertDeclareModule;
  exports.assertDeclareModuleExports = assertDeclareModuleExports;
  exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
  exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
  exports.assertDeclareVariable = assertDeclareVariable;
  exports.assertDeclaredPredicate = assertDeclaredPredicate;
  exports.assertDecorator = assertDecorator;
  exports.assertDirective = assertDirective;
  exports.assertDirectiveLiteral = assertDirectiveLiteral;
  exports.assertDoExpression = assertDoExpression;
  exports.assertDoWhileStatement = assertDoWhileStatement;
  exports.assertEmptyStatement = assertEmptyStatement;
  exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  exports.assertEnumBody = assertEnumBody;
  exports.assertEnumBooleanBody = assertEnumBooleanBody;
  exports.assertEnumBooleanMember = assertEnumBooleanMember;
  exports.assertEnumDeclaration = assertEnumDeclaration;
  exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
  exports.assertEnumMember = assertEnumMember;
  exports.assertEnumNumberBody = assertEnumNumberBody;
  exports.assertEnumNumberMember = assertEnumNumberMember;
  exports.assertEnumStringBody = assertEnumStringBody;
  exports.assertEnumStringMember = assertEnumStringMember;
  exports.assertEnumSymbolBody = assertEnumSymbolBody;
  exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  exports.assertExportAllDeclaration = assertExportAllDeclaration;
  exports.assertExportDeclaration = assertExportDeclaration;
  exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
  exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  exports.assertExportSpecifier = assertExportSpecifier;
  exports.assertExpression = assertExpression;
  exports.assertExpressionStatement = assertExpressionStatement;
  exports.assertExpressionWrapper = assertExpressionWrapper;
  exports.assertFile = assertFile;
  exports.assertFlow = assertFlow;
  exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  exports.assertFlowDeclaration = assertFlowDeclaration;
  exports.assertFlowPredicate = assertFlowPredicate;
  exports.assertFlowType = assertFlowType;
  exports.assertFor = assertFor;
  exports.assertForInStatement = assertForInStatement;
  exports.assertForOfStatement = assertForOfStatement;
  exports.assertForStatement = assertForStatement;
  exports.assertForXStatement = assertForXStatement;
  exports.assertFunction = assertFunction;
  exports.assertFunctionDeclaration = assertFunctionDeclaration;
  exports.assertFunctionExpression = assertFunctionExpression;
  exports.assertFunctionParent = assertFunctionParent;
  exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  exports.assertFunctionTypeParam = assertFunctionTypeParam;
  exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  exports.assertIdentifier = assertIdentifier;
  exports.assertIfStatement = assertIfStatement;
  exports.assertImmutable = assertImmutable;
  exports.assertImport = assertImport;
  exports.assertImportAttribute = assertImportAttribute;
  exports.assertImportDeclaration = assertImportDeclaration;
  exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  exports.assertImportExpression = assertImportExpression;
  exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
  exports.assertImportSpecifier = assertImportSpecifier;
  exports.assertIndexedAccessType = assertIndexedAccessType;
  exports.assertInferredPredicate = assertInferredPredicate;
  exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
  exports.assertInterfaceExtends = assertInterfaceExtends;
  exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  exports.assertInterpreterDirective = assertInterpreterDirective;
  exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  exports.assertJSX = assertJSX;
  exports.assertJSXAttribute = assertJSXAttribute;
  exports.assertJSXClosingElement = assertJSXClosingElement;
  exports.assertJSXClosingFragment = assertJSXClosingFragment;
  exports.assertJSXElement = assertJSXElement;
  exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
  exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
  exports.assertJSXFragment = assertJSXFragment;
  exports.assertJSXIdentifier = assertJSXIdentifier;
  exports.assertJSXMemberExpression = assertJSXMemberExpression;
  exports.assertJSXNamespacedName = assertJSXNamespacedName;
  exports.assertJSXOpeningElement = assertJSXOpeningElement;
  exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
  exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  exports.assertJSXSpreadChild = assertJSXSpreadChild;
  exports.assertJSXText = assertJSXText;
  exports.assertLVal = assertLVal;
  exports.assertLabeledStatement = assertLabeledStatement;
  exports.assertLiteral = assertLiteral;
  exports.assertLogicalExpression = assertLogicalExpression;
  exports.assertLoop = assertLoop;
  exports.assertMemberExpression = assertMemberExpression;
  exports.assertMetaProperty = assertMetaProperty;
  exports.assertMethod = assertMethod;
  exports.assertMiscellaneous = assertMiscellaneous;
  exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  exports.assertModuleDeclaration = assertModuleDeclaration;
  exports.assertModuleExpression = assertModuleExpression;
  exports.assertModuleSpecifier = assertModuleSpecifier;
  exports.assertNewExpression = assertNewExpression;
  exports.assertNoop = assertNoop;
  exports.assertNullLiteral = assertNullLiteral;
  exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  exports.assertNumberLiteral = assertNumberLiteral;
  exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  exports.assertNumericLiteral = assertNumericLiteral;
  exports.assertObjectExpression = assertObjectExpression;
  exports.assertObjectMember = assertObjectMember;
  exports.assertObjectMethod = assertObjectMethod;
  exports.assertObjectPattern = assertObjectPattern;
  exports.assertObjectProperty = assertObjectProperty;
  exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
  exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  exports.assertObjectTypeProperty = assertObjectTypeProperty;
  exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  exports.assertOpaqueType = assertOpaqueType;
  exports.assertOptionalCallExpression = assertOptionalCallExpression;
  exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
  exports.assertParenthesizedExpression = assertParenthesizedExpression;
  exports.assertPattern = assertPattern;
  exports.assertPatternLike = assertPatternLike;
  exports.assertPipelineBareFunction = assertPipelineBareFunction;
  exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
  exports.assertPlaceholder = assertPlaceholder;
  exports.assertPrivate = assertPrivate;
  exports.assertPrivateName = assertPrivateName;
  exports.assertProgram = assertProgram;
  exports.assertProperty = assertProperty;
  exports.assertPureish = assertPureish;
  exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  exports.assertRecordExpression = assertRecordExpression;
  exports.assertRegExpLiteral = assertRegExpLiteral;
  exports.assertRegexLiteral = assertRegexLiteral;
  exports.assertRestElement = assertRestElement;
  exports.assertRestProperty = assertRestProperty;
  exports.assertReturnStatement = assertReturnStatement;
  exports.assertScopable = assertScopable;
  exports.assertSequenceExpression = assertSequenceExpression;
  exports.assertSpreadElement = assertSpreadElement;
  exports.assertSpreadProperty = assertSpreadProperty;
  exports.assertStandardized = assertStandardized;
  exports.assertStatement = assertStatement;
  exports.assertStaticBlock = assertStaticBlock;
  exports.assertStringLiteral = assertStringLiteral;
  exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
  exports.assertSuper = assertSuper;
  exports.assertSwitchCase = assertSwitchCase;
  exports.assertSwitchStatement = assertSwitchStatement;
  exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  exports.assertTSAnyKeyword = assertTSAnyKeyword;
  exports.assertTSArrayType = assertTSArrayType;
  exports.assertTSAsExpression = assertTSAsExpression;
  exports.assertTSBaseType = assertTSBaseType;
  exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
  exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
  exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  exports.assertTSConditionalType = assertTSConditionalType;
  exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  exports.assertTSConstructorType = assertTSConstructorType;
  exports.assertTSDeclareFunction = assertTSDeclareFunction;
  exports.assertTSDeclareMethod = assertTSDeclareMethod;
  exports.assertTSEntityName = assertTSEntityName;
  exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
  exports.assertTSEnumMember = assertTSEnumMember;
  exports.assertTSExportAssignment = assertTSExportAssignment;
  exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
  exports.assertTSFunctionType = assertTSFunctionType;
  exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  exports.assertTSImportType = assertTSImportType;
  exports.assertTSIndexSignature = assertTSIndexSignature;
  exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
  exports.assertTSInferType = assertTSInferType;
  exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
  exports.assertTSInterfaceBody = assertTSInterfaceBody;
  exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  exports.assertTSIntersectionType = assertTSIntersectionType;
  exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  exports.assertTSLiteralType = assertTSLiteralType;
  exports.assertTSMappedType = assertTSMappedType;
  exports.assertTSMethodSignature = assertTSMethodSignature;
  exports.assertTSModuleBlock = assertTSModuleBlock;
  exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
  exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
  exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  exports.assertTSNeverKeyword = assertTSNeverKeyword;
  exports.assertTSNonNullExpression = assertTSNonNullExpression;
  exports.assertTSNullKeyword = assertTSNullKeyword;
  exports.assertTSNumberKeyword = assertTSNumberKeyword;
  exports.assertTSObjectKeyword = assertTSObjectKeyword;
  exports.assertTSOptionalType = assertTSOptionalType;
  exports.assertTSParameterProperty = assertTSParameterProperty;
  exports.assertTSParenthesizedType = assertTSParenthesizedType;
  exports.assertTSPropertySignature = assertTSPropertySignature;
  exports.assertTSQualifiedName = assertTSQualifiedName;
  exports.assertTSRestType = assertTSRestType;
  exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
  exports.assertTSStringKeyword = assertTSStringKeyword;
  exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
  exports.assertTSThisType = assertTSThisType;
  exports.assertTSTupleType = assertTSTupleType;
  exports.assertTSType = assertTSType;
  exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
  exports.assertTSTypeAssertion = assertTSTypeAssertion;
  exports.assertTSTypeElement = assertTSTypeElement;
  exports.assertTSTypeLiteral = assertTSTypeLiteral;
  exports.assertTSTypeOperator = assertTSTypeOperator;
  exports.assertTSTypeParameter = assertTSTypeParameter;
  exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  exports.assertTSTypePredicate = assertTSTypePredicate;
  exports.assertTSTypeQuery = assertTSTypeQuery;
  exports.assertTSTypeReference = assertTSTypeReference;
  exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  exports.assertTSUnionType = assertTSUnionType;
  exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
  exports.assertTSVoidKeyword = assertTSVoidKeyword;
  exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  exports.assertTemplateElement = assertTemplateElement;
  exports.assertTemplateLiteral = assertTemplateLiteral;
  exports.assertTerminatorless = assertTerminatorless;
  exports.assertThisExpression = assertThisExpression;
  exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
  exports.assertThrowStatement = assertThrowStatement;
  exports.assertTopicReference = assertTopicReference;
  exports.assertTryStatement = assertTryStatement;
  exports.assertTupleExpression = assertTupleExpression;
  exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  exports.assertTypeAlias = assertTypeAlias;
  exports.assertTypeAnnotation = assertTypeAnnotation;
  exports.assertTypeCastExpression = assertTypeCastExpression;
  exports.assertTypeParameter = assertTypeParameter;
  exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  exports.assertTypeScript = assertTypeScript;
  exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  exports.assertUnaryExpression = assertUnaryExpression;
  exports.assertUnaryLike = assertUnaryLike;
  exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  exports.assertUpdateExpression = assertUpdateExpression;
  exports.assertUserWhitespacable = assertUserWhitespacable;
  exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  exports.assertVariableDeclaration = assertVariableDeclaration;
  exports.assertVariableDeclarator = assertVariableDeclarator;
  exports.assertVariance = assertVariance;
  exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  exports.assertWhile = assertWhile;
  exports.assertWhileStatement = assertWhileStatement;
  exports.assertWithStatement = assertWithStatement;
  exports.assertYieldExpression = assertYieldExpression;
  var _is = require_is();
  var _deprecationWarning = require_deprecationWarning();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS((exports) => {
  var createTypeAnnotationBasedOnTypeof = function(type) {
    switch (type) {
      case "string":
        return (0, _index.stringTypeAnnotation)();
      case "number":
        return (0, _index.numberTypeAnnotation)();
      case "undefined":
        return (0, _index.voidTypeAnnotation)();
      case "boolean":
        return (0, _index.booleanTypeAnnotation)();
      case "function":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
      case "object":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
      case "symbol":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
      case "bigint":
        return (0, _index.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated2();
  var _default = exports.default = createTypeAnnotationBasedOnTypeof;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS((exports) => {
  var getQualifiedName = function(node2) {
    return (0, _index.isIdentifier)(node2) ? node2.name : `${node2.id.name}.${getQualifiedName(node2.qualification)}`;
  };
  var removeTypeDuplicates = function(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map;
    const bases = new Map;
    const typeGroups = new Set;
    const types = [];
    for (let i = 0;i < nodes.length; i++) {
      const node2 = nodes[i];
      if (!node2)
        continue;
      if (types.indexOf(node2) >= 0) {
        continue;
      }
      if ((0, _index.isAnyTypeAnnotation)(node2)) {
        return [node2];
      }
      if ((0, _index.isFlowBaseAnnotation)(node2)) {
        bases.set(node2.type, node2);
        continue;
      }
      if ((0, _index.isUnionTypeAnnotation)(node2)) {
        if (!typeGroups.has(node2.types)) {
          nodes.push(...node2.types);
          typeGroups.add(node2.types);
        }
        continue;
      }
      if ((0, _index.isGenericTypeAnnotation)(node2)) {
        const name = getQualifiedName(node2.id);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node2.typeParameters) {
              existing.typeParameters.params.push(...node2.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
            }
          } else {
            existing = node2.typeParameters;
          }
        } else {
          generics.set(name, node2);
        }
        continue;
      }
      types.push(node2);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeTypeDuplicates;
  var _index = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS((exports) => {
  var createFlowUnionType = function(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.unionTypeAnnotation)(flattened);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createFlowUnionType;
  var _index = require_generated2();
  var _removeTypeDuplicates = require_removeTypeDuplicates();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS((exports) => {
  var getQualifiedName = function(node2) {
    return (0, _index.isIdentifier)(node2) ? node2.name : `${node2.right.name}.${getQualifiedName(node2.left)}`;
  };
  var removeTypeDuplicates = function(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map;
    const bases = new Map;
    const typeGroups = new Set;
    const types = [];
    for (let i = 0;i < nodes.length; i++) {
      const node2 = nodes[i];
      if (!node2)
        continue;
      if (types.indexOf(node2) >= 0) {
        continue;
      }
      if ((0, _index.isTSAnyKeyword)(node2)) {
        return [node2];
      }
      if ((0, _index.isTSBaseType)(node2)) {
        bases.set(node2.type, node2);
        continue;
      }
      if ((0, _index.isTSUnionType)(node2)) {
        if (!typeGroups.has(node2.types)) {
          nodes.push(...node2.types);
          typeGroups.add(node2.types);
        }
        continue;
      }
      if ((0, _index.isTSTypeReference)(node2) && node2.typeParameters) {
        const name = getQualifiedName(node2.typeName);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node2.typeParameters) {
              existing.typeParameters.params.push(...node2.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
            }
          } else {
            existing = node2.typeParameters;
          }
        } else {
          generics.set(name, node2);
        }
        continue;
      }
      types.push(node2);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeTypeDuplicates;
  var _index = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS((exports) => {
  var createTSUnionType = function(typeAnnotations) {
    const types = typeAnnotations.map((type) => {
      return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.tsUnionType)(flattened);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createTSUnionType;
  var _index = require_generated2();
  var _removeTypeDuplicates = require_removeTypeDuplicates2();
  var _index2 = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.anyTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function() {
      return _index.argumentPlaceholder;
    }
  });
  Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function() {
      return _index.arrayExpression;
    }
  });
  Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function() {
      return _index.arrayPattern;
    }
  });
  Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.arrayTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function() {
      return _index.arrowFunctionExpression;
    }
  });
  Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function() {
      return _index.assignmentExpression;
    }
  });
  Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function() {
      return _index.assignmentPattern;
    }
  });
  Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function() {
      return _index.awaitExpression;
    }
  });
  Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function() {
      return _index.bigIntLiteral;
    }
  });
  Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function() {
      return _index.binaryExpression;
    }
  });
  Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function() {
      return _index.bindExpression;
    }
  });
  Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function() {
      return _index.blockStatement;
    }
  });
  Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function() {
      return _index.booleanLiteral;
    }
  });
  Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.booleanLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.booleanTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function() {
      return _index.breakStatement;
    }
  });
  Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function() {
      return _index.callExpression;
    }
  });
  Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function() {
      return _index.catchClause;
    }
  });
  Object.defineProperty(exports, "ClassAccessorProperty", {
    enumerable: true,
    get: function() {
      return _index.classAccessorProperty;
    }
  });
  Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function() {
      return _index.classBody;
    }
  });
  Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function() {
      return _index.classDeclaration;
    }
  });
  Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function() {
      return _index.classExpression;
    }
  });
  Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function() {
      return _index.classImplements;
    }
  });
  Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function() {
      return _index.classMethod;
    }
  });
  Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function() {
      return _index.classPrivateMethod;
    }
  });
  Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function() {
      return _index.classPrivateProperty;
    }
  });
  Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function() {
      return _index.classProperty;
    }
  });
  Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function() {
      return _index.conditionalExpression;
    }
  });
  Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function() {
      return _index.continueStatement;
    }
  });
  Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function() {
      return _index.debuggerStatement;
    }
  });
  Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function() {
      return _index.decimalLiteral;
    }
  });
  Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function() {
      return _index.declareClass;
    }
  });
  Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function() {
      return _index.declareExportAllDeclaration;
    }
  });
  Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function() {
      return _index.declareExportDeclaration;
    }
  });
  Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function() {
      return _index.declareFunction;
    }
  });
  Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function() {
      return _index.declareInterface;
    }
  });
  Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function() {
      return _index.declareModule;
    }
  });
  Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function() {
      return _index.declareModuleExports;
    }
  });
  Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function() {
      return _index.declareOpaqueType;
    }
  });
  Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function() {
      return _index.declareTypeAlias;
    }
  });
  Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function() {
      return _index.declareVariable;
    }
  });
  Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function() {
      return _index.declaredPredicate;
    }
  });
  Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function() {
      return _index.decorator;
    }
  });
  Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function() {
      return _index.directive;
    }
  });
  Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function() {
      return _index.directiveLiteral;
    }
  });
  Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function() {
      return _index.doExpression;
    }
  });
  Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function() {
      return _index.doWhileStatement;
    }
  });
  Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function() {
      return _index.emptyStatement;
    }
  });
  Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.emptyTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function() {
      return _index.enumBooleanBody;
    }
  });
  Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function() {
      return _index.enumBooleanMember;
    }
  });
  Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function() {
      return _index.enumDeclaration;
    }
  });
  Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function() {
      return _index.enumDefaultedMember;
    }
  });
  Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function() {
      return _index.enumNumberBody;
    }
  });
  Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function() {
      return _index.enumNumberMember;
    }
  });
  Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function() {
      return _index.enumStringBody;
    }
  });
  Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function() {
      return _index.enumStringMember;
    }
  });
  Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function() {
      return _index.enumSymbolBody;
    }
  });
  Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.existsTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function() {
      return _index.exportAllDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function() {
      return _index.exportDefaultDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function() {
      return _index.exportDefaultSpecifier;
    }
  });
  Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function() {
      return _index.exportNamedDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
      return _index.exportNamespaceSpecifier;
    }
  });
  Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function() {
      return _index.exportSpecifier;
    }
  });
  Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function() {
      return _index.expressionStatement;
    }
  });
  Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
      return _index.file;
    }
  });
  Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function() {
      return _index.forInStatement;
    }
  });
  Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function() {
      return _index.forOfStatement;
    }
  });
  Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function() {
      return _index.forStatement;
    }
  });
  Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function() {
      return _index.functionDeclaration;
    }
  });
  Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function() {
      return _index.functionExpression;
    }
  });
  Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.functionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function() {
      return _index.functionTypeParam;
    }
  });
  Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.genericTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
      return _index.identifier;
    }
  });
  Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function() {
      return _index.ifStatement;
    }
  });
  Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function() {
      return _index.import;
    }
  });
  Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function() {
      return _index.importAttribute;
    }
  });
  Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function() {
      return _index.importDeclaration;
    }
  });
  Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function() {
      return _index.importDefaultSpecifier;
    }
  });
  Object.defineProperty(exports, "ImportExpression", {
    enumerable: true,
    get: function() {
      return _index.importExpression;
    }
  });
  Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
      return _index.importNamespaceSpecifier;
    }
  });
  Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function() {
      return _index.importSpecifier;
    }
  });
  Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function() {
      return _index.indexedAccessType;
    }
  });
  Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function() {
      return _index.inferredPredicate;
    }
  });
  Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function() {
      return _index.interfaceDeclaration;
    }
  });
  Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function() {
      return _index.interfaceExtends;
    }
  });
  Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.interfaceTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function() {
      return _index.interpreterDirective;
    }
  });
  Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.intersectionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function() {
      return _index.jsxAttribute;
    }
  });
  Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function() {
      return _index.jsxClosingElement;
    }
  });
  Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function() {
      return _index.jsxClosingFragment;
    }
  });
  Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function() {
      return _index.jsxElement;
    }
  });
  Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function() {
      return _index.jsxEmptyExpression;
    }
  });
  Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function() {
      return _index.jsxExpressionContainer;
    }
  });
  Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function() {
      return _index.jsxFragment;
    }
  });
  Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function() {
      return _index.jsxIdentifier;
    }
  });
  Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function() {
      return _index.jsxMemberExpression;
    }
  });
  Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function() {
      return _index.jsxNamespacedName;
    }
  });
  Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function() {
      return _index.jsxOpeningElement;
    }
  });
  Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function() {
      return _index.jsxOpeningFragment;
    }
  });
  Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function() {
      return _index.jsxSpreadAttribute;
    }
  });
  Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function() {
      return _index.jsxSpreadChild;
    }
  });
  Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function() {
      return _index.jsxText;
    }
  });
  Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function() {
      return _index.labeledStatement;
    }
  });
  Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function() {
      return _index.logicalExpression;
    }
  });
  Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function() {
      return _index.memberExpression;
    }
  });
  Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function() {
      return _index.metaProperty;
    }
  });
  Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.mixedTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function() {
      return _index.moduleExpression;
    }
  });
  Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function() {
      return _index.newExpression;
    }
  });
  Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function() {
      return _index.noop;
    }
  });
  Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function() {
      return _index.nullLiteral;
    }
  });
  Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.nullLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.nullableTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function() {
      return _index.numberLiteral;
    }
  });
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.numberLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.numberTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function() {
      return _index.numericLiteral;
    }
  });
  Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function() {
      return _index.objectExpression;
    }
  });
  Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function() {
      return _index.objectMethod;
    }
  });
  Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function() {
      return _index.objectPattern;
    }
  });
  Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function() {
      return _index.objectProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.objectTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function() {
      return _index.objectTypeCallProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function() {
      return _index.objectTypeIndexer;
    }
  });
  Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function() {
      return _index.objectTypeInternalSlot;
    }
  });
  Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function() {
      return _index.objectTypeProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function() {
      return _index.objectTypeSpreadProperty;
    }
  });
  Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function() {
      return _index.opaqueType;
    }
  });
  Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function() {
      return _index.optionalCallExpression;
    }
  });
  Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function() {
      return _index.optionalIndexedAccessType;
    }
  });
  Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function() {
      return _index.optionalMemberExpression;
    }
  });
  Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function() {
      return _index.parenthesizedExpression;
    }
  });
  Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function() {
      return _index.pipelineBareFunction;
    }
  });
  Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function() {
      return _index.pipelinePrimaryTopicReference;
    }
  });
  Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function() {
      return _index.pipelineTopicExpression;
    }
  });
  Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function() {
      return _index.placeholder;
    }
  });
  Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function() {
      return _index.privateName;
    }
  });
  Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function() {
      return _index.program;
    }
  });
  Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function() {
      return _index.qualifiedTypeIdentifier;
    }
  });
  Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function() {
      return _index.recordExpression;
    }
  });
  Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function() {
      return _index.regExpLiteral;
    }
  });
  Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function() {
      return _index.regexLiteral;
    }
  });
  Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function() {
      return _index.restElement;
    }
  });
  Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function() {
      return _index.restProperty;
    }
  });
  Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function() {
      return _index.returnStatement;
    }
  });
  Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function() {
      return _index.sequenceExpression;
    }
  });
  Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function() {
      return _index.spreadElement;
    }
  });
  Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function() {
      return _index.spreadProperty;
    }
  });
  Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function() {
      return _index.staticBlock;
    }
  });
  Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function() {
      return _index.stringLiteral;
    }
  });
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.stringLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.stringTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function() {
      return _index.super;
    }
  });
  Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function() {
      return _index.switchCase;
    }
  });
  Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function() {
      return _index.switchStatement;
    }
  });
  Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.symbolTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsAnyKeyword;
    }
  });
  Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function() {
      return _index.tsArrayType;
    }
  });
  Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function() {
      return _index.tsAsExpression;
    }
  });
  Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsBigIntKeyword;
    }
  });
  Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsBooleanKeyword;
    }
  });
  Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsCallSignatureDeclaration;
    }
  });
  Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function() {
      return _index.tsConditionalType;
    }
  });
  Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsConstructSignatureDeclaration;
    }
  });
  Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function() {
      return _index.tsConstructorType;
    }
  });
  Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function() {
      return _index.tsDeclareFunction;
    }
  });
  Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function() {
      return _index.tsDeclareMethod;
    }
  });
  Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsEnumDeclaration;
    }
  });
  Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function() {
      return _index.tsEnumMember;
    }
  });
  Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function() {
      return _index.tsExportAssignment;
    }
  });
  Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function() {
      return _index.tsExpressionWithTypeArguments;
    }
  });
  Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function() {
      return _index.tsExternalModuleReference;
    }
  });
  Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function() {
      return _index.tsFunctionType;
    }
  });
  Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsImportEqualsDeclaration;
    }
  });
  Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function() {
      return _index.tsImportType;
    }
  });
  Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function() {
      return _index.tsIndexSignature;
    }
  });
  Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function() {
      return _index.tsIndexedAccessType;
    }
  });
  Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function() {
      return _index.tsInferType;
    }
  });
  Object.defineProperty(exports, "TSInstantiationExpression", {
    enumerable: true,
    get: function() {
      return _index.tsInstantiationExpression;
    }
  });
  Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function() {
      return _index.tsInterfaceBody;
    }
  });
  Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsInterfaceDeclaration;
    }
  });
  Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function() {
      return _index.tsIntersectionType;
    }
  });
  Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsIntrinsicKeyword;
    }
  });
  Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function() {
      return _index.tsLiteralType;
    }
  });
  Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function() {
      return _index.tsMappedType;
    }
  });
  Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function() {
      return _index.tsMethodSignature;
    }
  });
  Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function() {
      return _index.tsModuleBlock;
    }
  });
  Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsModuleDeclaration;
    }
  });
  Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function() {
      return _index.tsNamedTupleMember;
    }
  });
  Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsNamespaceExportDeclaration;
    }
  });
  Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsNeverKeyword;
    }
  });
  Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function() {
      return _index.tsNonNullExpression;
    }
  });
  Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsNullKeyword;
    }
  });
  Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsNumberKeyword;
    }
  });
  Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsObjectKeyword;
    }
  });
  Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function() {
      return _index.tsOptionalType;
    }
  });
  Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function() {
      return _index.tsParameterProperty;
    }
  });
  Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function() {
      return _index.tsParenthesizedType;
    }
  });
  Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function() {
      return _index.tsPropertySignature;
    }
  });
  Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function() {
      return _index.tsQualifiedName;
    }
  });
  Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function() {
      return _index.tsRestType;
    }
  });
  Object.defineProperty(exports, "TSSatisfiesExpression", {
    enumerable: true,
    get: function() {
      return _index.tsSatisfiesExpression;
    }
  });
  Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsStringKeyword;
    }
  });
  Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsSymbolKeyword;
    }
  });
  Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function() {
      return _index.tsThisType;
    }
  });
  Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function() {
      return _index.tsTupleType;
    }
  });
  Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsTypeAliasDeclaration;
    }
  });
  Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.tsTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function() {
      return _index.tsTypeAssertion;
    }
  });
  Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function() {
      return _index.tsTypeLiteral;
    }
  });
  Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function() {
      return _index.tsTypeOperator;
    }
  });
  Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function() {
      return _index.tsTypeParameter;
    }
  });
  Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsTypeParameterDeclaration;
    }
  });
  Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function() {
      return _index.tsTypeParameterInstantiation;
    }
  });
  Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function() {
      return _index.tsTypePredicate;
    }
  });
  Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function() {
      return _index.tsTypeQuery;
    }
  });
  Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function() {
      return _index.tsTypeReference;
    }
  });
  Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsUndefinedKeyword;
    }
  });
  Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function() {
      return _index.tsUnionType;
    }
  });
  Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsUnknownKeyword;
    }
  });
  Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsVoidKeyword;
    }
  });
  Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function() {
      return _index.taggedTemplateExpression;
    }
  });
  Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function() {
      return _index.templateElement;
    }
  });
  Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function() {
      return _index.templateLiteral;
    }
  });
  Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function() {
      return _index.thisExpression;
    }
  });
  Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.thisTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function() {
      return _index.throwStatement;
    }
  });
  Object.defineProperty(exports, "TopicReference", {
    enumerable: true,
    get: function() {
      return _index.topicReference;
    }
  });
  Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function() {
      return _index.tryStatement;
    }
  });
  Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function() {
      return _index.tupleExpression;
    }
  });
  Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.tupleTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function() {
      return _index.typeAlias;
    }
  });
  Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.typeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function() {
      return _index.typeCastExpression;
    }
  });
  Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function() {
      return _index.typeParameter;
    }
  });
  Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function() {
      return _index.typeParameterDeclaration;
    }
  });
  Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function() {
      return _index.typeParameterInstantiation;
    }
  });
  Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.typeofTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function() {
      return _index.unaryExpression;
    }
  });
  Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.unionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function() {
      return _index.updateExpression;
    }
  });
  Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function() {
      return _index.v8IntrinsicIdentifier;
    }
  });
  Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function() {
      return _index.variableDeclaration;
    }
  });
  Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function() {
      return _index.variableDeclarator;
    }
  });
  Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function() {
      return _index.variance;
    }
  });
  Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.voidTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function() {
      return _index.whileStatement;
    }
  });
  Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function() {
      return _index.withStatement;
    }
  });
  Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function() {
      return _index.yieldExpression;
    }
  });
  var _index = require_generated2();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS((exports) => {
  var buildUndefinedNode = function() {
    return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildUndefinedNode = buildUndefinedNode;
  var _index = require_generated2();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS((exports) => {
  var cloneIfNode = function(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  };
  var cloneIfNodeOrArray = function(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map((node2) => cloneIfNode(node2, deep, withoutLoc, commentsCache));
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  };
  var cloneNode = function(node2, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node2, deep, withoutLoc, new Map);
  };
  var cloneNodeInternal = function(node2, deep = true, withoutLoc = false, commentsCache) {
    if (!node2)
      return node2;
    const {
      type
    } = node2;
    const newNode = {
      type: node2.type
    };
    if ((0, _index2.isIdentifier)(node2)) {
      newNode.name = node2.name;
      if (has(node2, "optional") && typeof node2.optional === "boolean") {
        newNode.optional = node2.optional;
      }
      if (has(node2, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node2.typeAnnotation, true, withoutLoc, commentsCache) : node2.typeAnnotation;
      }
    } else if (!has(_index.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_index.NODE_FIELDS[type])) {
        if (has(node2, field)) {
          if (deep) {
            newNode[field] = (0, _index2.isFile)(node2) && field === "comments" ? maybeCloneComments(node2.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node2[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node2[field];
          }
        }
      }
    }
    if (has(node2, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node2.loc;
      }
    }
    if (has(node2, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node2.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (has(node2, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node2.innerComments, deep, withoutLoc, commentsCache);
    }
    if (has(node2, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node2.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (has(node2, "extra")) {
      newNode.extra = Object.assign({}, node2.extra);
    }
    return newNode;
  };
  var maybeCloneComments = function(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
      return comments;
    }
    return comments.map((comment) => {
      const cache = commentsCache.get(comment);
      if (cache)
        return cache;
      const {
        type,
        value: value2,
        loc
      } = comment;
      const ret = {
        type,
        value: value2,
        loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneNode;
  var _index = require_definitions();
  var _index2 = require_generated();
  var has = Function.call.bind(Object.prototype.hasOwnProperty);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS((exports) => {
  var clone = function(node2) {
    return (0, _cloneNode.default)(node2, false);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = clone;
  var _cloneNode = require_cloneNode();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS((exports) => {
  var cloneDeep = function(node2) {
    return (0, _cloneNode.default)(node2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneDeep;
  var _cloneNode = require_cloneNode();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS((exports) => {
  var cloneDeepWithoutLoc = function(node2) {
    return (0, _cloneNode.default)(node2, true, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneDeepWithoutLoc;
  var _cloneNode = require_cloneNode();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS((exports) => {
  var cloneWithoutLoc = function(node2) {
    return (0, _cloneNode.default)(node2, false, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneWithoutLoc;
  var _cloneNode = require_cloneNode();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS((exports) => {
  var addComments = function(node2, type, comments) {
    if (!comments || !node2)
      return node2;
    const key = `${type}Comments`;
    if (node2[key]) {
      if (type === "leading") {
        node2[key] = comments.concat(node2[key]);
      } else {
        node2[key].push(...comments);
      }
    } else {
      node2[key] = comments;
    }
    return node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addComments;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS((exports) => {
  var addComment = function(node2, type, content, line) {
    return (0, _addComments.default)(node2, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addComment;
  var _addComments = require_addComments();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS((exports) => {
  var inherit = function(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inherit;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS((exports) => {
  var inheritInnerComments = function(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritInnerComments;
  var _inherit = require_inherit();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS((exports) => {
  var inheritLeadingComments = function(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritLeadingComments;
  var _inherit = require_inherit();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS((exports) => {
  var inheritTrailingComments = function(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritTrailingComments;
  var _inherit = require_inherit();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS((exports) => {
  var inheritsComments = function(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritsComments;
  var _inheritTrailingComments = require_inheritTrailingComments();
  var _inheritLeadingComments = require_inheritLeadingComments();
  var _inheritInnerComments = require_inheritInnerComments();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS((exports) => {
  var removeComments = function(node2) {
    _index.COMMENT_KEYS.forEach((key) => {
      node2[key] = null;
    });
    return node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeComments;
  var _index = require_constants();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = undefined;
  var _index = require_definitions();
  var STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
  var EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
  var BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
  var SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
  var BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
  var BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
  var STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
  var TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  var CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
  var LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
  var WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
  var EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  var FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
  var FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
  var FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
  var FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
  var PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
  var DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
  var PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
  var LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
  var TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
  var LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
  var IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
  var USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  var METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
  var OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
  var PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
  var UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
  var PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
  var CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
  var IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
  var EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  var ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
  var PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
  var FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
  var FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
  var FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  var ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
  var ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
  var JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
  var MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  var TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
  var TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  var TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
  var TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
  var MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS((exports) => {
  var toBlock = function(node2, parent) {
    if ((0, _index.isBlockStatement)(node2)) {
      return node2;
    }
    let blockNodes = [];
    if ((0, _index.isEmptyStatement)(node2)) {
      blockNodes = [];
    } else {
      if (!(0, _index.isStatement)(node2)) {
        if ((0, _index.isFunction)(parent)) {
          node2 = (0, _index2.returnStatement)(node2);
        } else {
          node2 = (0, _index2.expressionStatement)(node2);
        }
      }
      blockNodes = [node2];
    }
    return (0, _index2.blockStatement)(blockNodes);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBlock;
  var _index = require_generated();
  var _index2 = require_generated2();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS((exports) => {
  var ensureBlock = function(node2, key = "body") {
    const result = (0, _toBlock.default)(node2[key], node2);
    node2[key] = result;
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ensureBlock;
  var _toBlock = require_toBlock();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS((exports) => {
  var toIdentifier = function(input) {
    input = input + "";
    let name = "";
    for (const c of input) {
      name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }
    return name || "_";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toIdentifier;
  var _isValidIdentifier = require_isValidIdentifier();
  var _helperValidatorIdentifier = require_lib();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS((exports) => {
  var toBindingIdentifierName = function(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments")
      name = "_" + name;
    return name;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBindingIdentifierName;
  var _toIdentifier = require_toIdentifier();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS((exports) => {
  var toComputedKey = function(node2, key = node2.key || node2.property) {
    if (!node2.computed && (0, _index.isIdentifier)(key))
      key = (0, _index2.stringLiteral)(key.name);
    return key;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toComputedKey;
  var _index = require_generated();
  var _index2 = require_generated2();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS((exports) => {
  var toExpression = function(node2) {
    if ((0, _index.isExpressionStatement)(node2)) {
      node2 = node2.expression;
    }
    if ((0, _index.isExpression)(node2)) {
      return node2;
    }
    if ((0, _index.isClass)(node2)) {
      node2.type = "ClassExpression";
    } else if ((0, _index.isFunction)(node2)) {
      node2.type = "FunctionExpression";
    }
    if (!(0, _index.isExpression)(node2)) {
      throw new Error(`cannot turn ${node2.type} to an expression`);
    }
    return node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated();
  var _default = exports.default = toExpression;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS((exports) => {
  var traverseFast = function(node2, enter, opts) {
    if (!node2)
      return;
    const keys = _index.VISITOR_KEYS[node2.type];
    if (!keys)
      return;
    opts = opts || {};
    enter(node2, opts);
    for (const key of keys) {
      const subNode = node2[key];
      if (Array.isArray(subNode)) {
        for (const node3 of subNode) {
          traverseFast(node3, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = traverseFast;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS((exports) => {
  var removeProperties = function(node2, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) {
      if (node2[key] != null)
        node2[key] = undefined;
    }
    for (const key of Object.keys(node2)) {
      if (key[0] === "_" && node2[key] != null)
        node2[key] = undefined;
    }
    const symbols = Object.getOwnPropertySymbols(node2);
    for (const sym of symbols) {
      node2[sym] = null;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeProperties;
  var _index = require_constants();
  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS((exports) => {
  var removePropertiesDeep = function(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removePropertiesDeep;
  var _traverseFast = require_traverseFast();
  var _removeProperties = require_removeProperties();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS((exports) => {
  var toKeyAlias = function(node2, key = node2.key) {
    let alias;
    if (node2.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if ((0, _index.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _index.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    }
    if (node2.computed) {
      alias = `[${alias}]`;
    }
    if (node2.static) {
      alias = `static:${alias}`;
    }
    return alias;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toKeyAlias;
  var _index = require_generated();
  var _cloneNode = require_cloneNode();
  var _removePropertiesDeep = require_removePropertiesDeep();
  toKeyAlias.uid = 0;
  toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS((exports) => {
  var toStatement = function(node2, ignore) {
    if ((0, _index.isStatement)(node2)) {
      return node2;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _index.isClass)(node2)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _index.isFunction)(node2)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _index.isAssignmentExpression)(node2)) {
      return (0, _index2.expressionStatement)(node2);
    }
    if (mustHaveId && !node2.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node2.type} to a statement`);
      }
    }
    node2.type = newType;
    return node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated();
  var _index2 = require_generated2();
  var _default = exports.default = toStatement;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS((exports) => {
  var isRegExp = function(value2) {
    return objectToString(value2) === "[object RegExp]";
  };
  var isPlainObject = function(value2) {
    if (typeof value2 !== "object" || value2 === null || Object.prototype.toString.call(value2) !== "[object Object]") {
      return false;
    }
    const proto = Object.getPrototypeOf(value2);
    return proto === null || Object.getPrototypeOf(proto) === null;
  };
  var valueToNode = function(value2) {
    if (value2 === undefined) {
      return (0, _index.identifier)("undefined");
    }
    if (value2 === true || value2 === false) {
      return (0, _index.booleanLiteral)(value2);
    }
    if (value2 === null) {
      return (0, _index.nullLiteral)();
    }
    if (typeof value2 === "string") {
      return (0, _index.stringLiteral)(value2);
    }
    if (typeof value2 === "number") {
      let result;
      if (Number.isFinite(value2)) {
        result = (0, _index.numericLiteral)(Math.abs(value2));
      } else {
        let numerator;
        if (Number.isNaN(value2)) {
          numerator = (0, _index.numericLiteral)(0);
        } else {
          numerator = (0, _index.numericLiteral)(1);
        }
        result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
      }
      if (value2 < 0 || Object.is(value2, -0)) {
        result = (0, _index.unaryExpression)("-", result);
      }
      return result;
    }
    if (isRegExp(value2)) {
      const pattern = value2.source;
      const flags = value2.toString().match(/\/([a-z]+|)$/)[1];
      return (0, _index.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value2)) {
      return (0, _index.arrayExpression)(value2.map(valueToNode));
    }
    if (isPlainObject(value2)) {
      const props = [];
      for (const key of Object.keys(value2)) {
        let nodeKey;
        if ((0, _isValidIdentifier.default)(key)) {
          nodeKey = (0, _index.identifier)(key);
        } else {
          nodeKey = (0, _index.stringLiteral)(key);
        }
        props.push((0, _index.objectProperty)(nodeKey, valueToNode(value2[key])));
      }
      return (0, _index.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _isValidIdentifier = require_isValidIdentifier();
  var _index = require_generated2();
  var _default = exports.default = valueToNode;
  var objectToString = Function.call.bind(Object.prototype.toString);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS((exports) => {
  var appendToMemberExpression = function(member, append, computed = false) {
    member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = appendToMemberExpression;
  var _index = require_generated2();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS((exports) => {
  var inherits = function(child, parent) {
    if (!child || !parent)
      return child;
    for (const key of _index.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (const key of _index.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }
    (0, _inheritsComments.default)(child, parent);
    return child;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inherits;
  var _index = require_constants();
  var _inheritsComments = require_inheritsComments();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS((exports) => {
  var prependToMemberExpression = function(member, prepend) {
    if ((0, _index2.isSuper)(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = (0, _index.memberExpression)(prepend, member.object);
    return member;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prependToMemberExpression;
  var _index = require_generated2();
  var _index2 = require_lib3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS((exports) => {
  var getBindingIdentifiers = function(node2, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node2);
    const ids = Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id)
        continue;
      if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id))) {
        continue;
      }
      const keys = getBindingIdentifiers.keys[id.type];
      if ((0, _index.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
        if ((0, _index.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _index.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _index.isFunctionExpression)(id)) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          const nodes = id[key];
          if (nodes) {
            Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
          }
        }
      }
    }
    return ids;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getBindingIdentifiers;
  var _index = require_generated();
  getBindingIdentifiers.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS((exports) => {
  var getOuterBindingIdentifiers = function(node2, duplicates) {
    return (0, _getBindingIdentifiers.default)(node2, duplicates, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _default = exports.default = getOuterBindingIdentifiers;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS((exports) => {
  var traverse = function(node2, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    const {
      enter,
      exit
    } = handlers;
    traverseSimpleImpl(node2, enter, exit, state, []);
  };
  var traverseSimpleImpl = function(node2, enter, exit, state, ancestors) {
    const keys = _index.VISITOR_KEYS[node2.type];
    if (!keys)
      return;
    if (enter)
      enter(node2, ancestors, state);
    for (const key of keys) {
      const subNode = node2[key];
      if (Array.isArray(subNode)) {
        for (let i = 0;i < subNode.length; i++) {
          const child = subNode[i];
          if (!child)
            continue;
          ancestors.push({
            node: node2,
            key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node2,
          key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit)
      exit(node2, ancestors, state);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = traverse;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS((exports) => {
  var isBinding = function(node2, parent, grandparent) {
    if (grandparent && node2.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) {
      for (let i = 0;i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
          if (val.indexOf(node2) >= 0)
            return true;
        } else {
          if (val === node2)
            return true;
        }
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBinding;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS((exports) => {
  var isLet = function(node2) {
    return (0, _index.isVariableDeclaration)(node2) && (node2.kind !== "var" || node2[_index2.BLOCK_SCOPED_SYMBOL]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLet;
  var _index = require_generated();
  var _index2 = require_constants();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS((exports) => {
  var isBlockScoped = function(node2) {
    return (0, _index.isFunctionDeclaration)(node2) || (0, _index.isClassDeclaration)(node2) || (0, _isLet.default)(node2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBlockScoped;
  var _index = require_generated();
  var _isLet = require_isLet();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS((exports) => {
  var isImmutable = function(node2) {
    if ((0, _isType.default)(node2.type, "Immutable"))
      return true;
    if ((0, _index.isIdentifier)(node2)) {
      if (node2.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isImmutable;
  var _isType = require_isType();
  var _index = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS((exports) => {
  var isNodesEquivalent = function(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _index.VISITOR_KEYS[a.type];
    for (const field of fields) {
      const val_a = a[field];
      const val_b = b[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (let i = 0;i < val_a.length; i++) {
          if (!isNodesEquivalent(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (const key of Object.keys(val_a)) {
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent(val_a, val_b)) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNodesEquivalent;
  var _index = require_definitions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS((exports) => {
  var isReferenced = function(node2, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node2) {
          return !!parent.computed;
        }
        return parent.object === node2;
      case "JSXMemberExpression":
        return parent.object === node2;
      case "VariableDeclarator":
        return parent.init === node2;
      case "ArrowFunctionExpression":
        return parent.body === node2;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node2;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node2;
      case "AssignmentExpression":
        return parent.right === node2;
      case "AssignmentPattern":
        return parent.right === node2;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node2;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node2;
      case "TSEnumMember":
        return parent.id !== node2;
      case "TSPropertySignature":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isReferenced;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS((exports) => {
  var isScope = function(node2, parent) {
    if ((0, _index.isBlockStatement)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return false;
    }
    if ((0, _index.isPattern)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return true;
    }
    return (0, _index.isScopable)(node2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isScope;
  var _index = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS((exports) => {
  var isSpecifierDefault = function(specifier) {
    return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSpecifierDefault;
  var _index = require_generated();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS((exports) => {
  var isValidES3Identifier = function(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValidES3Identifier;
  var _isValidIdentifier = require_isValidIdentifier();
  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS((exports) => {
  var isVar = function(node2) {
    return (0, _index.isVariableDeclaration)(node2, {
      kind: "var"
    }) && !node2[_index2.BLOCK_SCOPED_SYMBOL];
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVar;
  var _index = require_generated();
  var _index2 = require_constants();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS((exports) => {
  var gatherSequenceExpressions = function(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node2 of nodes) {
      if (!(0, _index.isEmptyStatement)(node2)) {
        ensureLastUndefined = false;
      }
      if ((0, _index.isExpression)(node2)) {
        exprs.push(node2);
      } else if ((0, _index.isExpressionStatement)(node2)) {
        exprs.push(node2.expression);
      } else if ((0, _index.isVariableDeclaration)(node2)) {
        if (node2.kind !== "var")
          return;
        for (const declar of node2.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node2.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
          }
          if (declar.init) {
            exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _index.isIfStatement)(node2)) {
        const consequent = node2.consequent ? gatherSequenceExpressions([node2.consequent], scope, declars) : scope.buildUndefinedNode();
        const alternate = node2.alternate ? gatherSequenceExpressions([node2.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate)
          return;
        exprs.push((0, _index2.conditionalExpression)(node2.test, consequent, alternate));
      } else if ((0, _index.isBlockStatement)(node2)) {
        const body = gatherSequenceExpressions(node2.body, scope, declars);
        if (!body)
          return;
        exprs.push(body);
      } else if ((0, _index.isEmptyStatement)(node2)) {
        if (nodes.indexOf(node2) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _index2.sequenceExpression)(exprs);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gatherSequenceExpressions;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _index = require_generated();
  var _index2 = require_generated2();
  var _cloneNode = require_cloneNode();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS((exports) => {
  var toSequenceExpression = function(nodes, scope) {
    if (!(nodes != null && nodes.length))
      return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result)
      return;
    for (const declar of declars) {
      scope.push(declar);
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toSequenceExpression;
  var _gatherSequenceExpressions = require_gatherSequenceExpressions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/types/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true,
    __internal__deprecationWarning: true
  };
  Object.defineProperty(exports, "__internal__deprecationWarning", {
    enumerable: true,
    get: function() {
      return _deprecationWarning.default;
    }
  });
  Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
      return _addComment.default;
    }
  });
  Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
      return _addComments.default;
    }
  });
  Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
      return _appendToMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
      return _assertNode.default;
    }
  });
  Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
      return _buildMatchMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
      return _clone.default;
    }
  });
  Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
      return _cloneDeep.default;
    }
  });
  Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
      return _cloneDeepWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
      return _cloneNode.default;
    }
  });
  Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
      return _cloneWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
      return _createTSUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
      return _createTypeAnnotationBasedOnTypeof.default;
    }
  });
  Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
      return _ensureBlock.default;
    }
  });
  Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
      return _getBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
      return _getOuterBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
      return _inheritInnerComments.default;
    }
  });
  Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
      return _inheritLeadingComments.default;
    }
  });
  Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
      return _inheritTrailingComments.default;
    }
  });
  Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
      return _inherits.default;
    }
  });
  Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
      return _inheritsComments.default;
    }
  });
  Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
      return _is.default;
    }
  });
  Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
      return _isBinding.default;
    }
  });
  Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
      return _isBlockScoped.default;
    }
  });
  Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
      return _isImmutable.default;
    }
  });
  Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
      return _isLet.default;
    }
  });
  Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
      return _isNode.default;
    }
  });
  Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
      return _isNodesEquivalent.default;
    }
  });
  Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
      return _isPlaceholderType.default;
    }
  });
  Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
      return _isReferenced.default;
    }
  });
  Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
      return _isScope.default;
    }
  });
  Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
      return _isSpecifierDefault.default;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _isType.default;
    }
  });
  Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
      return _isValidES3Identifier.default;
    }
  });
  Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
      return _isValidIdentifier.default;
    }
  });
  Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
      return _isVar.default;
    }
  });
  Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
      return _matchesPattern.default;
    }
  });
  Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
      return _prependToMemberExpression.default;
    }
  });
  exports.react = undefined;
  Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
      return _removeComments.default;
    }
  });
  Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
      return _removeProperties.default;
    }
  });
  Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
      return _removePropertiesDeep.default;
    }
  });
  Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
      return _removeTypeDuplicates.default;
    }
  });
  Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
      return _shallowEqual.default;
    }
  });
  Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
      return _toBindingIdentifierName.default;
    }
  });
  Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
      return _toBlock.default;
    }
  });
  Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
      return _toComputedKey.default;
    }
  });
  Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
      return _toExpression.default;
    }
  });
  Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
      return _toIdentifier.default;
    }
  });
  Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
      return _toKeyAlias.default;
    }
  });
  Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
      return _toStatement.default;
    }
  });
  Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
      return _traverse.default;
    }
  });
  Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
      return _traverseFast.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
      return _valueToNode.default;
    }
  });
  var _isReactComponent = require_isReactComponent();
  var _isCompatTag = require_isCompatTag();
  var _buildChildren = require_buildChildren();
  var _assertNode = require_assertNode();
  var _index = require_generated3();
  Object.keys(_index).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index[key];
      }
    });
  });
  var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
  var _createFlowUnionType = require_createFlowUnionType();
  var _createTSUnionType = require_createTSUnionType();
  var _index2 = require_generated2();
  Object.keys(_index2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index2[key];
      }
    });
  });
  var _uppercase = require_uppercase();
  Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _uppercase[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _uppercase[key];
      }
    });
  });
  var _productions = require_productions();
  Object.keys(_productions).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _productions[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _productions[key];
      }
    });
  });
  var _cloneNode = require_cloneNode();
  var _clone = require_clone();
  var _cloneDeep = require_cloneDeep();
  var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
  var _cloneWithoutLoc = require_cloneWithoutLoc();
  var _addComment = require_addComment();
  var _addComments = require_addComments();
  var _inheritInnerComments = require_inheritInnerComments();
  var _inheritLeadingComments = require_inheritLeadingComments();
  var _inheritsComments = require_inheritsComments();
  var _inheritTrailingComments = require_inheritTrailingComments();
  var _removeComments = require_removeComments();
  var _index3 = require_generated4();
  Object.keys(_index3).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index3[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index3[key];
      }
    });
  });
  var _index4 = require_constants();
  Object.keys(_index4).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index4[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index4[key];
      }
    });
  });
  var _ensureBlock = require_ensureBlock();
  var _toBindingIdentifierName = require_toBindingIdentifierName();
  var _toBlock = require_toBlock();
  var _toComputedKey = require_toComputedKey();
  var _toExpression = require_toExpression();
  var _toIdentifier = require_toIdentifier();
  var _toKeyAlias = require_toKeyAlias();
  var _toStatement = require_toStatement();
  var _valueToNode = require_valueToNode();
  var _index5 = require_definitions();
  Object.keys(_index5).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index5[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index5[key];
      }
    });
  });
  var _appendToMemberExpression = require_appendToMemberExpression();
  var _inherits = require_inherits();
  var _prependToMemberExpression = require_prependToMemberExpression();
  var _removeProperties = require_removeProperties();
  var _removePropertiesDeep = require_removePropertiesDeep();
  var _removeTypeDuplicates = require_removeTypeDuplicates();
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
  var _traverse = require_traverse();
  Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _traverse[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _traverse[key];
      }
    });
  });
  var _traverseFast = require_traverseFast();
  var _shallowEqual = require_shallowEqual();
  var _is = require_is();
  var _isBinding = require_isBinding();
  var _isBlockScoped = require_isBlockScoped();
  var _isImmutable = require_isImmutable();
  var _isLet = require_isLet();
  var _isNode = require_isNode();
  var _isNodesEquivalent = require_isNodesEquivalent();
  var _isPlaceholderType = require_isPlaceholderType();
  var _isReferenced = require_isReferenced();
  var _isScope = require_isScope();
  var _isSpecifierDefault = require_isSpecifierDefault();
  var _isType = require_isType();
  var _isValidES3Identifier = require_isValidES3Identifier();
  var _isValidIdentifier = require_isValidIdentifier();
  var _isVar = require_isVar();
  var _matchesPattern = require_matchesPattern();
  var _validate = require_validate2();
  var _buildMatchMemberExpression = require_buildMatchMemberExpression();
  var _index6 = require_generated();
  Object.keys(_index6).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index6[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index6[key];
      }
    });
  });
  var _deprecationWarning = require_deprecationWarning();
  var react = exports.react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
  };
  {
    exports.toSequenceExpression = require_toSequenceExpression().default;
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/parser/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var _objectWithoutPropertiesLoose = function(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0;i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  };
  var createPositionWithColumnOffset = function(position, columnOffset) {
    const {
      line,
      column,
      index
    } = position;
    return new Position(line, column + columnOffset, index + columnOffset);
  };
  var defineHidden = function(obj, key, value2) {
    Object.defineProperty(obj, key, {
      enumerable: false,
      configurable: true,
      value: value2
    });
  };
  var toParseErrorConstructor = function(_ref) {
    let {
      toMessage
    } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    return function constructor({
      loc,
      details
    }) {
      const error = new SyntaxError;
      Object.assign(error, properties, {
        loc,
        pos: loc.index
      });
      if ("missingPlugin" in details) {
        Object.assign(error, {
          missingPlugin: details.missingPlugin
        });
      }
      defineHidden(error, "clone", function clone(overrides = {}) {
        var _overrides$loc;
        const {
          line,
          column,
          index
        } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
        return constructor({
          loc: new Position(line, column, index),
          details: Object.assign({}, details, overrides.details)
        });
      });
      defineHidden(error, "details", details);
      Object.defineProperty(error, "message", {
        configurable: true,
        get() {
          const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
          this.message = message;
          return message;
        },
        set(value2) {
          Object.defineProperty(this, "message", {
            value: value2,
            writable: true
          });
        }
      });
      return error;
    };
  };
  var ParseErrorEnum = function(argument, syntaxPlugin) {
    if (Array.isArray(argument)) {
      return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    }
    const ParseErrorConstructors = {};
    for (const reasonCode of Object.keys(argument)) {
      const template = argument[reasonCode];
      const _ref2 = typeof template === "string" ? {
        message: () => template
      } : typeof template === "function" ? {
        message: template
      } : template, {
        message
      } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
      const toMessage = typeof message === "string" ? () => message : message;
      ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode,
        toMessage
      }, syntaxPlugin ? {
        syntaxPlugin
      } : {}, rest));
    }
    return ParseErrorConstructors;
  };
  var toESTreeLocation = function(node2) {
    node2.loc.start && toUnenumerable(node2.loc.start, "index");
    node2.loc.end && toUnenumerable(node2.loc.end, "index");
    return node2;
  };
  var createKeyword = function(name, options = {}) {
    options.keyword = name;
    const token = createToken(name, options);
    keywords$1.set(name, token);
    return token;
  };
  var createBinop = function(name, binop) {
    return createToken(name, {
      beforeExpr,
      binop
    });
  };
  var createToken = function(name, options = {}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
    tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
    tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
    tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
    tokenTypes.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
  };
  var createKeywordLike = function(name, options = {}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    ++tokenTypeCounter;
    keywords$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
    tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
    tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
    tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
    tokenTypes.push(new ExportedTokenType("name", options));
    return tokenTypeCounter;
  };
  var tokenIsIdentifier = function(token) {
    return token >= 93 && token <= 132;
  };
  var tokenKeywordOrIdentifierIsKeyword = function(token) {
    return token <= 92;
  };
  var tokenIsKeywordOrIdentifier = function(token) {
    return token >= 58 && token <= 132;
  };
  var tokenIsLiteralPropertyName = function(token) {
    return token >= 58 && token <= 136;
  };
  var tokenComesBeforeExpression = function(token) {
    return tokenBeforeExprs[token];
  };
  var tokenCanStartExpression = function(token) {
    return tokenStartsExprs[token];
  };
  var tokenIsAssignment = function(token) {
    return token >= 29 && token <= 33;
  };
  var tokenIsFlowInterfaceOrTypeOrOpaque = function(token) {
    return token >= 129 && token <= 131;
  };
  var tokenIsLoop = function(token) {
    return token >= 90 && token <= 92;
  };
  var tokenIsKeyword = function(token) {
    return token >= 58 && token <= 92;
  };
  var tokenIsOperator = function(token) {
    return token >= 39 && token <= 59;
  };
  var tokenIsPostfix = function(token) {
    return token === 34;
  };
  var tokenIsPrefix = function(token) {
    return tokenPrefixes[token];
  };
  var tokenIsTSTypeOperator = function(token) {
    return token >= 121 && token <= 123;
  };
  var tokenIsTSDeclarationStart = function(token) {
    return token >= 124 && token <= 130;
  };
  var tokenLabelName = function(token) {
    return tokenLabels[token];
  };
  var tokenOperatorPrecedence = function(token) {
    return tokenBinops[token];
  };
  var tokenIsRightAssociative = function(token) {
    return token === 57;
  };
  var tokenIsTemplate = function(token) {
    return token >= 24 && token <= 25;
  };
  var getExportedToken = function(token) {
    return tokenTypes[token];
  };
  var isInAstralSet = function(code2, set) {
    let pos = 65536;
    for (let i = 0, length = set.length;i < length; i += 2) {
      pos += set[i];
      if (pos > code2)
        return false;
      pos += set[i + 1];
      if (pos >= code2)
        return true;
    }
    return false;
  };
  var isIdentifierStart = function(code2) {
    if (code2 < 65)
      return code2 === 36;
    if (code2 <= 90)
      return true;
    if (code2 < 97)
      return code2 === 95;
    if (code2 <= 122)
      return true;
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    return isInAstralSet(code2, astralIdentifierStartCodes);
  };
  var isIdentifierChar = function(code2) {
    if (code2 < 48)
      return code2 === 36;
    if (code2 < 58)
      return true;
    if (code2 < 65)
      return false;
    if (code2 <= 90)
      return true;
    if (code2 < 97)
      return code2 === 95;
    if (code2 <= 122)
      return true;
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  };
  var isReservedWord = function(word, inModule) {
    return inModule && word === "await" || word === "enum";
  };
  var isStrictReservedWord = function(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  };
  var isStrictBindOnlyReservedWord = function(word) {
    return reservedWordsStrictBindSet.has(word);
  };
  var isStrictBindReservedWord = function(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  };
  var isKeyword = function(word) {
    return keywords.has(word);
  };
  var isIteratorStart = function(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
  };
  var canBeReservedWord = function(word) {
    return reservedWordLikeSet.has(word);
  };
  var setTrailingComments = function(node2, comments) {
    if (node2.trailingComments === undefined) {
      node2.trailingComments = comments;
    } else {
      node2.trailingComments.unshift(...comments);
    }
  };
  var setLeadingComments = function(node2, comments) {
    if (node2.leadingComments === undefined) {
      node2.leadingComments = comments;
    } else {
      node2.leadingComments.unshift(...comments);
    }
  };
  var setInnerComments = function(node2, comments) {
    if (node2.innerComments === undefined) {
      node2.innerComments = comments;
    } else {
      node2.innerComments.unshift(...comments);
    }
  };
  var adjustInnerComments = function(node2, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    while (lastElement === null && i > 0) {
      lastElement = elements[--i];
    }
    if (lastElement === null || lastElement.start > commentWS.start) {
      setInnerComments(node2, commentWS.comments);
    } else {
      setTrailingComments(lastElement, commentWS.comments);
    }
  };
  var isNewLine = function(code2) {
    switch (code2) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  };
  var isWhitespace = function(code2) {
    switch (code2) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  };
  var readStringContents = function(type, input, pos, lineStart, curLine, errors2) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (;; ) {
      if (pos >= length) {
        errors2.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors2);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors2.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  };
  var isStringEnd = function(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  };
  var readEscapedChar = function(input, pos, lineStart, curLine, inTemplate, errors2) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code2;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors2));
        return res(code2 === null ? null : String.fromCharCode(code2));
      }
      case 117: {
        let code2;
        ({
          code: code2,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors2));
        return res(code2 === null ? null : String.fromCodePoint(code2));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors2.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors2.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  };
  var readHexChar = function(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors2) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors2, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors2.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  };
  var readInt = function(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors2, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len;i < e; ++i) {
      const code2 = input.charCodeAt(pos);
      let val;
      if (code2 === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors2.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors2.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10;
      } else if (code2 >= 65) {
        val = code2 - 65 + 10;
      } else if (_isDigit(code2)) {
        val = code2 - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors2.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  };
  var readCodePoint = function(input, pos, lineStart, curLine, throwOnInvalid, errors2) {
    const ch = input.charCodeAt(pos);
    let code2;
    if (ch === 123) {
      ++pos;
      ({
        code: code2,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors2));
      ++pos;
      if (code2 !== null && code2 > 1114111) {
        if (throwOnInvalid) {
          errors2.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code: code2,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors2));
    }
    return {
      code: code2,
      pos
    };
  };
  var buildPosition = function(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
  };
  var newParameterDeclarationScope = function() {
    return new ExpressionScope(3);
  };
  var newArrowHeadScope = function() {
    return new ArrowHeadParsingScope(1);
  };
  var newAsyncArrowScope = function() {
    return new ArrowHeadParsingScope(2);
  };
  var newExpressionScope = function() {
    return new ExpressionScope;
  };
  var functionFlags = function(isAsync2, isGenerator) {
    return (isAsync2 ? 2 : 0) | (isGenerator ? 1 : 0);
  };
  var clonePlaceholder = function(node2) {
    return cloneIdentifier(node2);
  };
  var cloneIdentifier = function(node2) {
    const {
      type,
      start,
      end,
      loc,
      range,
      extra,
      name
    } = node2;
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.name = name;
    if (type === "Placeholder") {
      cloned.expectedNode = node2.expectedNode;
    }
    return cloned;
  };
  var cloneStringLiteral = function(node2) {
    const {
      type,
      start,
      end,
      loc,
      range,
      extra
    } = node2;
    if (type === "Placeholder") {
      return clonePlaceholder(node2);
    }
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    if (node2.raw !== undefined) {
      cloned.raw = node2.raw;
    } else {
      cloned.extra = extra;
    }
    cloned.value = node2.value;
    return cloned;
  };
  var isEsModuleType = function(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  };
  var hasTypeImportKind = function(node2) {
    return node2.importKind === "type" || node2.importKind === "typeof";
  };
  var partition = function(list, test) {
    const list1 = [];
    const list2 = [];
    for (let i = 0;i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }
    return [list1, list2];
  };
  var isFragment = function(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  };
  var getQualifiedJSXName = function(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    throw new Error("Node had unexpected type: " + object.type);
  };
  var nonNull = function(x) {
    if (x == null) {
      throw new Error(`Unexpected ${x} value.`);
    }
    return x;
  };
  var assert = function(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  };
  var keywordTypeFromName = function(value2) {
    switch (value2) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  };
  var tsIsAccessModifier = function(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  };
  var tsIsVarianceAnnotations = function(modifier) {
    return modifier === "in" || modifier === "out";
  };
  var isPossiblyLiteralEnum = function(expression) {
    if (expression.type !== "MemberExpression")
      return false;
    const {
      computed,
      property: property2
    } = expression;
    if (computed && property2.type !== "StringLiteral" && (property2.type !== "TemplateLiteral" || property2.expressions.length > 0)) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  };
  var isValidAmbientConstInitializer = function(expression, estree2) {
    var _expression$extra;
    const {
      type
    } = expression;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
      return false;
    }
    if (estree2) {
      if (type === "Literal") {
        const {
          value: value2
        } = expression;
        if (typeof value2 === "string" || typeof value2 === "boolean") {
          return true;
        }
      }
    } else {
      if (type === "StringLiteral" || type === "BooleanLiteral") {
        return true;
      }
    }
    if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
      return true;
    }
    if (type === "TemplateLiteral" && expression.expressions.length === 0) {
      return true;
    }
    if (isPossiblyLiteralEnum(expression)) {
      return true;
    }
    return false;
  };
  var isNumber = function(expression, estree2) {
    if (estree2) {
      return expression.type === "Literal" && (typeof expression.value === "number" || ("bigint" in expression));
    }
    return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
  };
  var isNegativeNumber = function(expression, estree2) {
    if (expression.type === "UnaryExpression") {
      const {
        operator,
        argument
      } = expression;
      if (operator === "-" && isNumber(argument, estree2)) {
        return true;
      }
    }
    return false;
  };
  var isUncomputedMemberExpressionChain = function(expression) {
    if (expression.type === "Identifier")
      return true;
    if (expression.type !== "MemberExpression" || expression.computed) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  };
  var hasPlugin = function(plugins, expectedConfig) {
    const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
    const expectedKeys = Object.keys(expectedOptions);
    const expectedOptionsIsEmpty = expectedKeys.length === 0;
    return plugins.some((p) => {
      if (typeof p === "string") {
        return expectedOptionsIsEmpty && p === expectedName;
      } else {
        const [pluginName, pluginOptions] = p;
        if (pluginName !== expectedName) {
          return false;
        }
        for (const key of expectedKeys) {
          if (pluginOptions[key] !== expectedOptions[key]) {
            return false;
          }
        }
        return true;
      }
    });
  };
  var getPluginOption = function(plugins, name, option) {
    const plugin = plugins.find((plugin2) => {
      if (Array.isArray(plugin2)) {
        return plugin2[0] === name;
      } else {
        return plugin2 === name;
      }
    });
    if (plugin && Array.isArray(plugin) && plugin.length > 1) {
      return plugin[1][option];
    }
    return null;
  };
  var validatePlugins = function(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }
      const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
      if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      }
      const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
      if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
        throw new Error("'allowCallParenthesized' must be a boolean.");
      }
    }
    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }
    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }
    if (hasPlugin(plugins, "pipelineOperator")) {
      const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
      if (!PIPELINE_PROPOSALS.includes(proposal)) {
        const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
      }
      const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (proposal === "hack") {
        if (hasPlugin(plugins, "placeholders")) {
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        }
        if (hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        }
        const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
        if (!TOPIC_TOKENS.includes(topicToken)) {
          const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
        }
        if (topicToken === "#" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      } else if (proposal === "smart" && tupleSyntaxIsHash) {
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
    }
    if (hasPlugin(plugins, "moduleAttributes")) {
      {
        if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
          throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
        }
        const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
        if (moduleAttributesVersionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
      }
    }
    if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    }
    if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
    }
    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
      const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
    if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    }
  };
  var getOptions = function(opts) {
    if (opts == null) {
      return Object.assign({}, defaultOptions);
    }
    if (opts.annexB != null && opts.annexB !== false) {
      throw new Error("The `annexB` option can only be set to `false`.");
    }
    const options = {};
    for (const key of Object.keys(defaultOptions)) {
      var _opts$key;
      options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];
    }
    return options;
  };
  var babel7CompatTokens = function(tokens, input) {
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i];
      const {
        type
      } = token;
      if (typeof type === "number") {
        {
          if (type === 138) {
            const {
              loc,
              start,
              value: value2,
              end
            } = token;
            const hashEndPos = start + 1;
            const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value: value2,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            }));
            i++;
            continue;
          }
          if (tokenIsTemplate(type)) {
            const {
              loc,
              start,
              value: value2,
              end
            } = token;
            const backquoteEnd = start + 1;
            const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
            let startToken;
            if (input.charCodeAt(start) === 96) {
              startToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            } else {
              startToken = new Token({
                type: getExportedToken(8),
                value: "}",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            }
            let templateValue, templateElementEnd, templateElementEndLoc, endToken;
            if (type === 24) {
              templateElementEnd = end - 1;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
              templateValue = value2 === null ? null : value2.slice(1, -1);
              endToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            } else {
              templateElementEnd = end - 2;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
              templateValue = value2 === null ? null : value2.slice(1, -2);
              endToken = new Token({
                type: getExportedToken(23),
                value: "${",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            }
            tokens.splice(i, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken);
            i += 2;
            continue;
          }
        }
        token.type = getExportedToken(type);
      }
    }
    return tokens;
  };
  var pluginsMap = function(plugins) {
    const pluginMap = new Map;
    for (const plugin of plugins) {
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      if (!pluginMap.has(name))
        pluginMap.set(name, options || {});
    }
    return pluginMap;
  };
  var parse2 = function(input, options) {
    var _options;
    if (((_options = options) == null ? undefined : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);
      try {
        options.sourceType = "module";
        const parser3 = getParser(options, input);
        const ast = parser3.parse();
        if (parser3.sawUnambiguousESM) {
          return ast;
        }
        if (parser3.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {
          }
        } else {
          ast.program.sourceType = "script";
        }
        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {
        }
        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  };
  var parseExpression = function(input, options) {
    const parser3 = getParser(options, input);
    if (parser3.options.strictMode) {
      parser3.state.strict = true;
    }
    return parser3.getExpression();
  };
  var generateExportedTokenTypes = function(internalTokenTypes) {
    const tokenTypes2 = {};
    for (const typeName of Object.keys(internalTokenTypes)) {
      tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    }
    return tokenTypes2;
  };
  var getParser = function(options, input) {
    let cls = Parser2;
    if (options != null && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }
    return new cls(options, input);
  };
  var getParserClass = function(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
    const key = pluginList.join("/");
    let cls = parserClassCache[key];
    if (!cls) {
      cls = Parser2;
      for (const plugin of pluginList) {
        cls = mixinPlugins[plugin](cls);
      }
      parserClassCache[key] = cls;
    }
    return cls;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  class Position {
    constructor(line, col, index) {
      this.line = undefined;
      this.column = undefined;
      this.index = undefined;
      this.line = line;
      this.column = col;
      this.index = index;
    }
  }

  class SourceLocation {
    constructor(start, end) {
      this.start = undefined;
      this.end = undefined;
      this.filename = undefined;
      this.identifierName = undefined;
      this.start = start;
      this.end = end;
    }
  }
  var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var ModuleErrors = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code
    }
  };
  var NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  };
  var toNodeDescription = ({
    type,
    prefix: prefix2
  }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
  var StandardErrors = {
    AccessorIsGenerator: ({
      kind
    }) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind
    }) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName
    }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: ({
      phase
    }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName,
      exportName
    }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type
    }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type
    }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: ({
      importName
    }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: ({
      maxArgumentCount
    }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix
    }) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord
    }) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({
      identifierName
    }) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({
      ancestor
    }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({
      ancestor
    }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor
    }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected
    }) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName
    }) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName
    }) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin
    }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key
    }) => `Duplicate key "${key}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode
    }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName
    }) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName
    }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName
    }) => `Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword
    }) => `Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord
    }) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected,
      unexpected
    }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target,
      onlyValidPropertyName
    }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName
    }) => `Identifier '${identifierName}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  };
  var StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName
    }) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName
    }) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };
  var UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var PipelineOperatorErrors = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token
    }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type
    }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
      type
    })}; please wrap it in parentheses.`,
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  };
  var _excluded$1 = ["toMessage"];
  var _excluded2$1 = ["message"];
  var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
  var {
    defineProperty
  } = Object;
  var toUnenumerable = (object, key) => defineProperty(object, key, {
    enumerable: false,
    value: object[key]
  });
  var estree = (superClass) => class ESTreeParserMixin extends superClass {
    parse() {
      const file = toESTreeLocation(super.parse());
      if (this.options.tokens) {
        file.tokens = file.tokens.map(toESTreeLocation);
      }
      return file;
    }
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {
      }
      const node2 = this.estreeParseLiteral(regex);
      node2.regex = {
        pattern,
        flags
      };
      return node2;
    }
    parseBigIntLiteral(value2) {
      let bigInt;
      try {
        bigInt = BigInt(value2);
      } catch (_unused) {
        bigInt = null;
      }
      const node2 = this.estreeParseLiteral(bigInt);
      node2.bigint = String(node2.value || value2);
      return node2;
    }
    parseDecimalLiteral(value2) {
      const decimal = null;
      const node2 = this.estreeParseLiteral(decimal);
      node2.decimal = String(node2.value || value2);
      return node2;
    }
    estreeParseLiteral(value2) {
      return this.parseLiteral(value2, "Literal");
    }
    parseStringLiteral(value2) {
      return this.estreeParseLiteral(value2);
    }
    parseNumericLiteral(value2) {
      return this.estreeParseLiteral(value2);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(value2) {
      return this.estreeParseLiteral(value2);
    }
    directiveToStmt(directive) {
      const expression = directive.value;
      delete directive.value;
      expression.type = "Literal";
      expression.raw = expression.extra.raw;
      expression.value = expression.extra.expressionValue;
      const stmt = directive;
      stmt.type = "ExpressionStatement";
      stmt.expression = expression;
      stmt.directive = expression.extra.rawValue;
      delete expression.extra;
      return stmt;
    }
    initFunction(node2, isAsync2) {
      super.initFunction(node2, isAsync2);
      node2.expression = false;
    }
    checkDeclaration(node2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        this.checkDeclaration(node2.value);
      } else {
        super.checkDeclaration(node2);
      }
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr;
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }
    parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
      super.parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse);
      const directiveStatements = node2.directives.map((d) => this.directiveToStmt(d));
      node2.body = directiveStatements.concat(node2.body);
      delete node2.directives;
    }
    pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync2, isConstructor, allowsDirectSuper, "ClassMethod", true);
      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }
      classBody.body.push(method);
    }
    parsePrivateName() {
      const node2 = super.parsePrivateName();
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return node2;
        }
      }
      return this.convertPrivateNameToPrivateIdentifier(node2);
    }
    convertPrivateNameToPrivateIdentifier(node2) {
      const name = super.getPrivateNameSV(node2);
      node2 = node2;
      delete node2.id;
      node2.name = name;
      node2.type = "PrivateIdentifier";
      return node2;
    }
    isPrivateName(node2) {
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.isPrivateName(node2);
        }
      }
      return node2.type === "PrivateIdentifier";
    }
    getPrivateNameSV(node2) {
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.getPrivateNameSV(node2);
        }
      }
      return node2.name;
    }
    parseLiteral(value2, type) {
      const node2 = super.parseLiteral(value2, type);
      node2.raw = node2.extra.raw;
      delete node2.extra;
      return node2;
    }
    parseFunctionBody(node2, allowExpression, isMethod = false) {
      super.parseFunctionBody(node2, allowExpression, isMethod);
      node2.expression = node2.body.type !== "BlockStatement";
    }
    parseMethod(node2, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode();
      funcNode.kind = node2.kind;
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope);
      funcNode.type = "FunctionExpression";
      delete funcNode.kind;
      node2.value = funcNode;
      if (type === "ClassPrivateMethod") {
        node2.computed = false;
      }
      return this.finishNode(node2, "MethodDefinition");
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
      }
      propertyNode.type = "PropertyDefinition";
      return propertyNode;
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
      }
      propertyNode.type = "PropertyDefinition";
      propertyNode.computed = false;
      return propertyNode;
    }
    parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor) {
      const node2 = super.parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor);
      if (node2) {
        node2.type = "Property";
        if (node2.kind === "method") {
          node2.kind = "init";
        }
        node2.shorthand = false;
      }
      return node2;
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      const node2 = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (node2) {
        node2.kind = "init";
        node2.type = "Property";
      }
      return node2;
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    }
    isAssignable(node2, isBinding) {
      if (node2 != null && this.isObjectProperty(node2)) {
        return this.isAssignable(node2.value, isBinding);
      }
      return super.isAssignable(node2, isBinding);
    }
    toAssignable(node2, isLHS = false) {
      if (node2 != null && this.isObjectProperty(node2)) {
        const {
          key,
          value: value2
        } = node2;
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
        }
        this.toAssignable(value2, isLHS);
      } else {
        super.toAssignable(node2, isLHS);
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.kind === "get" || prop.kind === "set") {
        this.raise(Errors.PatternHasAccessor, {
          at: prop.key
        });
      } else if (prop.method) {
        this.raise(Errors.PatternHasMethod, {
          at: prop.key
        });
      } else {
        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
      }
    }
    finishCallExpression(unfinished, optional) {
      const node2 = super.finishCallExpression(unfinished, optional);
      if (node2.callee.type === "Import") {
        node2.type = "ImportExpression";
        node2.source = node2.arguments[0];
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var _node$arguments$, _node$arguments$2;
          node2.options = (_node$arguments$ = node2.arguments[1]) != null ? _node$arguments$ : null;
          node2.attributes = (_node$arguments$2 = node2.arguments[1]) != null ? _node$arguments$2 : null;
        }
        delete node2.arguments;
        delete node2.callee;
      }
      return node2;
    }
    toReferencedArguments(node2) {
      if (node2.type === "ImportExpression") {
        return;
      }
      super.toReferencedArguments(node2);
    }
    parseExport(unfinished, decorators) {
      const exportStartLoc = this.state.lastTokStartLoc;
      const node2 = super.parseExport(unfinished, decorators);
      switch (node2.type) {
        case "ExportAllDeclaration":
          node2.exported = null;
          break;
        case "ExportNamedDeclaration":
          if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
            node2.type = "ExportAllDeclaration";
            node2.exported = node2.specifiers[0].exported;
            delete node2.specifiers;
          }
        case "ExportDefaultDeclaration":
          {
            var _declaration$decorato;
            const {
              declaration
            } = node2;
            if ((declaration == null ? undefined : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? undefined : _declaration$decorato.length) > 0 && declaration.start === node2.start) {
              this.resetStartLocation(node2, exportStartLoc);
            }
          }
          break;
      }
      return node2;
    }
    parseSubscript(base, startLoc, noCalls, state) {
      const node2 = super.parseSubscript(base, startLoc, noCalls, state);
      if (state.optionalChainMember) {
        if (node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") {
          node2.type = node2.type.substring(8);
        }
        if (state.stop) {
          const chain = this.startNodeAtNode(node2);
          chain.expression = node2;
          return this.finishNode(chain, "ChainExpression");
        }
      } else if (node2.type === "MemberExpression" || node2.type === "CallExpression") {
        node2.optional = false;
      }
      return node2;
    }
    isOptionalMemberExpression(node2) {
      if (node2.type === "ChainExpression") {
        return node2.expression.type === "MemberExpression";
      }
      return super.isOptionalMemberExpression(node2);
    }
    hasPropertyAsPrivateName(node2) {
      if (node2.type === "ChainExpression") {
        node2 = node2.expression;
      }
      return super.hasPropertyAsPrivateName(node2);
    }
    isObjectProperty(node2) {
      return node2.type === "Property" && node2.kind === "init" && !node2.method;
    }
    isObjectMethod(node2) {
      return node2.method || node2.kind === "get" || node2.kind === "set";
    }
    finishNodeAt(node2, type, endLoc) {
      return toESTreeLocation(super.finishNodeAt(node2, type, endLoc));
    }
    resetStartLocation(node2, startLoc) {
      super.resetStartLocation(node2, startLoc);
      toESTreeLocation(node2);
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node2, endLoc);
      toESTreeLocation(node2);
    }
  };

  class TokContext {
    constructor(token, preserveSpace) {
      this.token = undefined;
      this.preserveSpace = undefined;
      this.token = token;
      this.preserveSpace = !!preserveSpace;
    }
  }
  var types = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", true)
  };
  {
    types.template = new TokContext("`", true);
  }
  var beforeExpr = true;
  var startsExpr = true;
  var isLoop = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;

  class ExportedTokenType {
    constructor(label, conf = {}) {
      this.label = undefined;
      this.keyword = undefined;
      this.beforeExpr = undefined;
      this.startsExpr = undefined;
      this.rightAssociative = undefined;
      this.isLoop = undefined;
      this.isAssign = undefined;
      this.prefix = undefined;
      this.postfix = undefined;
      this.binop = undefined;
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      {
        this.updateContext = null;
      }
    }
  }
  var keywords$1 = new Map;
  var tokenTypeCounter = -1;
  var tokenTypes = [];
  var tokenLabels = [];
  var tokenBinops = [];
  var tokenBeforeExprs = [];
  var tokenStartsExprs = [];
  var tokenPrefixes = [];
  var tt = {
    bracketL: createToken("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: createToken("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: createToken("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: createToken("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: createToken("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
      beforeExpr
    }),
    semi: createToken(";", {
      beforeExpr
    }),
    colon: createToken(":", {
      beforeExpr
    }),
    doubleColon: createToken("::", {
      beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
      beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
      beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
      beforeExpr
    }),
    backQuote: createToken("`", {
      startsExpr
    }),
    dollarBraceL: createToken("${", {
      beforeExpr,
      startsExpr
    }),
    templateTail: createToken("...`", {
      startsExpr
    }),
    templateNonTail: createToken("...${", {
      beforeExpr,
      startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
      startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
      beforeExpr,
      isAssign
    }),
    assign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    xorAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    moduloAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: createToken("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: createToken("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: createToken("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    doubleCaret: createToken("^^", {
      startsExpr
    }),
    doubleAt: createToken("@@", {
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: createToken("%", {
      binop: 10,
      startsExpr
    }),
    star: createToken("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _for: createKeyword("for", {
      isLoop
    }),
    _while: createKeyword("while", {
      isLoop
    }),
    _as: createKeywordLike("as", {
      startsExpr
    }),
    _assert: createKeywordLike("assert", {
      startsExpr
    }),
    _async: createKeywordLike("async", {
      startsExpr
    }),
    _await: createKeywordLike("await", {
      startsExpr
    }),
    _defer: createKeywordLike("defer", {
      startsExpr
    }),
    _from: createKeywordLike("from", {
      startsExpr
    }),
    _get: createKeywordLike("get", {
      startsExpr
    }),
    _let: createKeywordLike("let", {
      startsExpr
    }),
    _meta: createKeywordLike("meta", {
      startsExpr
    }),
    _of: createKeywordLike("of", {
      startsExpr
    }),
    _sent: createKeywordLike("sent", {
      startsExpr
    }),
    _set: createKeywordLike("set", {
      startsExpr
    }),
    _source: createKeywordLike("source", {
      startsExpr
    }),
    _static: createKeywordLike("static", {
      startsExpr
    }),
    _using: createKeywordLike("using", {
      startsExpr
    }),
    _yield: createKeywordLike("yield", {
      startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
      startsExpr
    }),
    _checks: createKeywordLike("checks", {
      startsExpr
    }),
    _exports: createKeywordLike("exports", {
      startsExpr
    }),
    _global: createKeywordLike("global", {
      startsExpr
    }),
    _implements: createKeywordLike("implements", {
      startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
      startsExpr
    }),
    _infer: createKeywordLike("infer", {
      startsExpr
    }),
    _is: createKeywordLike("is", {
      startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
      startsExpr
    }),
    _proto: createKeywordLike("proto", {
      startsExpr
    }),
    _require: createKeywordLike("require", {
      startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
      startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
      startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
      startsExpr
    }),
    _unique: createKeywordLike("unique", {
      startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
      startsExpr
    }),
    _declare: createKeywordLike("declare", {
      startsExpr
    }),
    _enum: createKeywordLike("enum", {
      startsExpr
    }),
    _module: createKeywordLike("module", {
      startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
      startsExpr
    }),
    _interface: createKeywordLike("interface", {
      startsExpr
    }),
    _type: createKeywordLike("type", {
      startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
      startsExpr
    }),
    name: createToken("name", {
      startsExpr
    }),
    string: createToken("string", {
      startsExpr
    }),
    num: createToken("num", {
      startsExpr
    }),
    bigint: createToken("bigint", {
      startsExpr
    }),
    decimal: createToken("decimal", {
      startsExpr
    }),
    regexp: createToken("regexp", {
      startsExpr
    }),
    privateName: createToken("#name", {
      startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
      beforeExpr: true
    }),
    jsxTagStart: createToken("jsxTagStart", {
      startsExpr: true
    }),
    jsxTagEnd: createToken("jsxTagEnd"),
    placeholder: createToken("%%", {
      startsExpr: true
    })
  };
  {
    tokenTypes[8].updateContext = (context) => {
      context.pop();
    };
    tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
      context.push(types.brace);
    };
    tokenTypes[22].updateContext = (context) => {
      if (context[context.length - 1] === types.template) {
        context.pop();
      } else {
        context.push(types.template);
      }
    };
    tokenTypes[142].updateContext = (context) => {
      context.push(types.j_expr, types.j_oTag);
    };
  }
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);

  class Scope {
    constructor(flags) {
      this.var = new Set;
      this.lexical = new Set;
      this.functions = new Set;
      this.flags = flags;
    }
  }

  class ScopeHandler {
    constructor(parser3, inModule) {
      this.parser = undefined;
      this.scopeStack = [];
      this.inModule = undefined;
      this.undefinedExports = new Map;
      this.parser = parser3;
      this.inModule = inModule;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & 64) > 0 && (flags & 2) === 0;
    }
    get inStaticBlock() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 128) {
          return true;
        }
        if (flags & (387 | 64)) {
          return false;
        }
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      const scope = this.scopeStack.pop();
      return scope.flags;
    }
    treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
    }
    declareName(name, bindingType, loc) {
      let scope = this.currentScope();
      if (bindingType & 8 || bindingType & 16) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        if (bindingType & 16) {
          scope.functions.add(name);
        } else {
          scope.lexical.add(name);
        }
        if (bindingType & 8) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & 4) {
        for (let i = this.scopeStack.length - 1;i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          scope.var.add(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & 387)
            break;
        }
      }
      if (this.parser.inModule && scope.flags & 1) {
        this.undefinedExports.delete(name);
      }
    }
    maybeExportDefined(scope, name) {
      if (this.parser.inModule && scope.flags & 1) {
        this.undefinedExports.delete(name);
      }
    }
    checkRedeclarationInScope(scope, name, bindingType, loc) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.parser.raise(Errors.VarRedeclaration, {
          at: loc,
          identifierName: name
        });
      }
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & 1))
        return false;
      if (bindingType & 8) {
        return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
      }
      if (bindingType & 16) {
        return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
      }
      return scope.lexical.has(name) && !(scope.flags & 8 && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      const topLevelScope = this.scopeStack[0];
      if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
        this.undefinedExports.set(name, id.loc.start);
      }
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 387) {
          return flags;
        }
      }
    }
    currentThisScopeFlags() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & (387 | 64) && !(flags & 4)) {
          return flags;
        }
      }
    }
  }

  class FlowScope extends Scope {
    constructor(...args) {
      super(...args);
      this.declareFunctions = new Set;
    }
  }

  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }
    declareName(name, bindingType, loc) {
      const scope = this.currentScope();
      if (bindingType & 2048) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }
      super.declareName(name, bindingType, loc);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (super.isRedeclaredInScope(scope, name, bindingType))
        return true;
      if (bindingType & 2048) {
        return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
      }
      return false;
    }
    checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        super.checkLocalExport(id);
      }
    }
  }

  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(pluginConfig) {
      if (typeof pluginConfig === "string") {
        return this.plugins.has(pluginConfig);
      } else {
        const [pluginName, pluginOptions] = pluginConfig;
        if (!this.hasPlugin(pluginName)) {
          return false;
        }
        const actualOptions = this.plugins.get(pluginName);
        for (const key of Object.keys(pluginOptions)) {
          if ((actualOptions == null ? undefined : actualOptions[key]) !== pluginOptions[key]) {
            return false;
          }
        }
        return true;
      }
    }
    getPluginOption(plugin, name) {
      var _this$plugins$get;
      return (_this$plugins$get = this.plugins.get(plugin)) == null ? undefined : _this$plugins$get[name];
    }
  }

  class CommentsParser extends BaseParser {
    addComment(comment) {
      if (this.filename)
        comment.loc.filename = this.filename;
      this.state.comments.push(comment);
    }
    processComment(node2) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0)
        return;
      let i = commentStackLength - 1;
      const lastCommentWS = commentStack[i];
      if (lastCommentWS.start === node2.end) {
        lastCommentWS.leadingNode = node2;
        i--;
      }
      const {
        start: nodeStart
      } = node2;
      for (;i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        if (commentEnd > nodeStart) {
          commentWS.containingNode = node2;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node2;
          }
          break;
        }
      }
    }
    finalizeComment(commentWS) {
      const {
        comments
      } = commentWS;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments);
        }
        if (commentWS.trailingNode !== null) {
          setLeadingComments(commentWS.trailingNode, comments);
        }
      } else {
        const {
          containingNode: node2,
          start: commentStart
        } = commentWS;
        if (this.input.charCodeAt(commentStart - 1) === 44) {
          switch (node2.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node2, node2.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node2, node2.arguments, commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node2, node2.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node2, node2.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node2, node2.specifiers, commentWS);
              break;
            default: {
              setInnerComments(node2, comments);
            }
          }
        } else {
          setInnerComments(node2, comments);
        }
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack
      } = this.state;
      for (let i = commentStack.length - 1;i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node2) {
      const {
        commentStack
      } = this.state;
      const {
        length
      } = commentStack;
      if (length === 0)
        return;
      const commentWS = commentStack[length - 1];
      if (commentWS.leadingNode === node2) {
        commentWS.leadingNode = null;
      }
    }
    resetPreviousIdentifierLeadingComments(node2) {
      const {
        commentStack
      } = this.state;
      const {
        length
      } = commentStack;
      if (length === 0)
        return;
      if (commentStack[length - 1].trailingNode === node2) {
        commentStack[length - 1].trailingNode = null;
      } else if (length >= 2 && commentStack[length - 2].trailingNode === node2) {
        commentStack[length - 2].trailingNode = null;
      }
    }
    takeSurroundingComments(node2, start, end) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0)
        return;
      let i = commentStackLength - 1;
      for (;i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        const commentStart = commentWS.start;
        if (commentStart === end) {
          commentWS.leadingNode = node2;
        } else if (commentEnd === start) {
          commentWS.trailingNode = node2;
        } else if (commentEnd < start) {
          break;
        }
      }
    }
  }
  var lineBreak = /\r\n?|[\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");

  class State {
    constructor() {
      this.strict = undefined;
      this.curLine = undefined;
      this.lineStart = undefined;
      this.startLoc = undefined;
      this.endLoc = undefined;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.maybeInArrowParameters = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.hasFlowComment = false;
      this.isAmbientContext = false;
      this.inAbstractClass = false;
      this.inDisallowConditionalTypesContext = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.comments = [];
      this.commentStack = [];
      this.pos = 0;
      this.type = 139;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.context = [types.brace];
      this.canStartJSXElement = true;
      this.containsEsc = false;
      this.firstInvalidTemplateEscapePos = null;
      this.strictErrors = new Map;
      this.tokensLength = 0;
    }
    init({
      strictMode,
      sourceType,
      startLine,
      startColumn
    }) {
      this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
      this.curLine = startLine;
      this.lineStart = -startColumn;
      this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
    }
    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(skipArrays) {
      const state = new State;
      const keys = Object.keys(this);
      for (let i = 0, length = keys.length;i < length; i++) {
        const key = keys[i];
        let val = this[key];
        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }
        state[key] = val;
      }
      return state;
    }
  }
  var _isDigit = function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  var _excluded = ["at"];
  var _excluded2 = ["at"];
  var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);

  class Token {
    constructor(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  }

  class Tokenizer extends CommentsParser {
    constructor(options, input) {
      super();
      this.isLookahead = undefined;
      this.tokens = [];
      this.errorHandlers_readInt = {
        invalidDigit: (pos, lineStart, curLine, radix) => {
          if (!this.options.errorRecovery)
            return false;
          this.raise(Errors.InvalidDigit, {
            at: buildPosition(pos, lineStart, curLine),
            radix
          });
          return true;
        },
        numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
      };
      this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
      });
      this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (pos, lineStart, curLine) => {
          this.recordStrictModeErrors(Errors.StrictNumericEscape, {
            at: buildPosition(pos, lineStart, curLine)
          });
        },
        unterminated: (pos, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedString, {
            at: buildPosition(pos - 1, lineStart, curLine)
          });
        }
      });
      this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: (pos, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedTemplate, {
            at: buildPosition(pos, lineStart, curLine)
          });
        }
      });
      this.state = new State;
      this.state.init(options);
      this.input = input;
      this.length = input.length;
      this.isLookahead = false;
    }
    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes();
      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
    match(type) {
      return this.state.type === type;
    }
    createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        context: [this.curContext()],
        inType: state.inType,
        startLoc: state.startLoc,
        lastTokEndLoc: state.lastTokEndLoc,
        curLine: state.curLine,
        lineStart: state.lineStart,
        curPosition: state.curPosition
      };
    }
    lookahead() {
      const old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(pos) {
      skipWhiteSpaceInLine.lastIndex = pos;
      return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(pos) {
      let cp = this.input.charCodeAt(pos);
      if ((cp & 64512) === 55296 && ++pos < this.input.length) {
        const trail = this.input.charCodeAt(pos);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      return cp;
    }
    setStrict(strict) {
      this.state.strict = strict;
      if (strict) {
        this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
          at
        }));
        this.state.strictErrors.clear();
      }
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead)
        this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(commentEnd) {
      let startLoc;
      if (!this.isLookahead)
        startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf(commentEnd, start + 2);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, {
          at: this.state.curPosition()
        });
      }
      this.state.pos = end + commentEnd.length;
      lineBreakG.lastIndex = start + 2;
      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }
      if (this.isLookahead)
        return;
      const comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start,
        end: end + commentEnd.length,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(comment);
      return comment;
    }
    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      if (!this.isLookahead)
        startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }
      if (this.isLookahead)
        return;
      const end = this.state.pos;
      const value2 = this.input.slice(start + startSkip, end);
      const comment = {
        type: "CommentLine",
        value: value2,
        start,
        end,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(comment);
      return comment;
    }
    skipSpace() {
      const spaceStart = this.state.pos;
      const comments = [];
      loop:
        while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.options.annexB) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.options.annexB) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
      if (comments.length > 0) {
        const end = this.state.pos;
        const commentWhitespace = {
          start: spaceStart,
          end,
          comments,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    }
    finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) {
        this.updateContext(prevType);
      }
    }
    replaceToken(type) {
      this.state.type = type;
      this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }
      const nextPos = this.state.pos + 1;
      const next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57) {
        throw this.raise(Errors.UnexpectedDigitAfterHash, {
          at: this.state.curPosition()
        });
      }
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");
        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
            at: this.state.curPosition()
          });
        }
        this.state.pos += 2;
        if (next === 123) {
          this.finishToken(7);
        } else {
          this.finishToken(1);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(138, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(138, this.readWord1());
      } else {
        this.finishOp(27, 1);
      }
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }
      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(21);
      } else {
        ++this.state.pos;
        this.finishToken(16);
      }
    }
    readToken_slash() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(31, 2);
      } else {
        this.finishOp(56, 1);
      }
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33)
        return false;
      const start = this.state.pos;
      this.state.pos += 1;
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
      const value2 = this.input.slice(start + 2, this.state.pos);
      this.finishToken(28, value2);
      return true;
    }
    readToken_mult_modulo(code2) {
      let type = code2 === 42 ? 55 : 54;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = 57;
      }
      if (next === 61 && !this.state.inType) {
        width++;
        type = code2 === 37 ? 33 : 30;
      }
      this.finishOp(type, width);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(code2 === 124 ? 41 : 42, 2);
        }
        return;
      }
      if (code2 === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          this.finishToken(4);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(code2 === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61 && !this.state.inType) {
        this.finishOp(32, 2);
      } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        this.finishOp(37, 2);
        const lookaheadCh = this.input.codePointAt(this.state.pos);
        if (lookaheadCh === 94) {
          this.unexpected();
        }
      } else {
        this.finishOp(44, 1);
      }
    }
    readToken_atSign() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }])) {
        this.finishOp(38, 2);
      } else {
        this.finishOp(26, 1);
      }
    }
    readToken_plus_min(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.finishOp(34, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(30, 2);
      } else {
        this.finishOp(53, 1);
      }
    }
    readToken_lt() {
      const {
        pos
      } = this.state;
      const next = this.input.charCodeAt(pos + 1);
      if (next === 60) {
        if (this.input.charCodeAt(pos + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos
      } = this.state;
      const next = this.input.charCodeAt(pos + 1);
      if (next === 62) {
        const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(pos + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }
        this.finishOp(52, size);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code2 === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(19);
        return;
      }
      this.finishOp(code2 === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);
      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(40, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(18);
      } else {
        ++this.state.pos;
        this.finishToken(17);
      }
    }
    getTokenFromCode(code2) {
      switch (code2) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos;
          this.finishToken(10);
          return;
        case 41:
          ++this.state.pos;
          this.finishToken(11);
          return;
        case 59:
          ++this.state.pos;
          this.finishToken(13);
          return;
        case 44:
          ++this.state.pos;
          this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(2);
          } else {
            ++this.state.pos;
            this.finishToken(0);
          }
          return;
        case 93:
          ++this.state.pos;
          this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(6);
          } else {
            ++this.state.pos;
            this.finishToken(5);
          }
          return;
        case 125:
          ++this.state.pos;
          this.finishToken(8);
          return;
        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(15, 2);
          } else {
            ++this.state.pos;
            this.finishToken(14);
          }
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(code2);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code2);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code2);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code2);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code2);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code2)) {
            this.readWord(code2);
            return;
          }
      }
      throw this.raise(Errors.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(code2)
      });
    }
    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
    readRegexp() {
      const startLoc = this.state.startLoc;
      const start = this.state.start + 1;
      let escaped, inClass;
      let {
        pos
      } = this.state;
      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(Errors.UnterminatedRegExp, {
            at: createPositionWithColumnOffset(startLoc, 1)
          });
        }
        const ch = this.input.charCodeAt(pos);
        if (isNewLine(ch)) {
          throw this.raise(Errors.UnterminatedRegExp, {
            at: createPositionWithColumnOffset(startLoc, 1)
          });
        }
        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }
          escaped = ch === 92;
        }
      }
      const content = this.input.slice(start, pos);
      ++pos;
      let mods = "";
      const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
      while (pos < this.length) {
        const cp = this.codePointAtPos(pos);
        const char = String.fromCharCode(cp);
        if (VALID_REGEX_FLAGS.has(cp)) {
          if (cp === 118) {
            if (mods.includes("u")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, {
                at: nextPos()
              });
            }
          } else if (cp === 117) {
            if (mods.includes("v")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, {
                at: nextPos()
              });
            }
          }
          if (mods.includes(char)) {
            this.raise(Errors.DuplicateRegExpFlags, {
              at: nextPos()
            });
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(Errors.MalformedRegExpFlags, {
            at: nextPos()
          });
        } else {
          break;
        }
        ++pos;
        mods += char;
      }
      this.state.pos = pos;
      this.finishToken(137, {
        pattern: content,
        flags: mods
      });
    }
    readInt(radix, len, forceLen = false, allowNumSeparator = true) {
      const {
        n,
        pos
      } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
      this.state.pos = pos;
      return n;
    }
    readRadixNumber(radix) {
      const startLoc = this.state.curPosition();
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);
      if (val == null) {
        this.raise(Errors.InvalidDigit, {
          at: createPositionWithColumnOffset(startLoc, 2),
          radix
        });
      }
      const next = this.input.charCodeAt(this.state.pos);
      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(Errors.InvalidDecimal, {
          at: startLoc
        });
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, {
          at: this.state.curPosition()
        });
      }
      if (isBigInt) {
        const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, str);
        return;
      }
      this.finishToken(134, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos;
      const startLoc = this.state.curPosition();
      let isFloat = false;
      let isBigInt = false;
      let isDecimal = false;
      let hasExponent = false;
      let isOctal = false;
      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(Errors.InvalidNumber, {
          at: this.state.curPosition()
        });
      }
      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
          at: startLoc
        });
        if (!this.state.strict) {
          const underscorePos = integer.indexOf("_");
          if (underscorePos > 0) {
            this.raise(Errors.ZeroDigitNumericSeparator, {
              at: createPositionWithColumnOffset(startLoc, underscorePos)
            });
          }
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      let next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);
        if (next === 43 || next === 45) {
          ++this.state.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(Errors.InvalidOrMissingExponent, {
            at: startLoc
          });
        }
        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(Errors.InvalidBigIntLiteral, {
            at: startLoc
          });
        }
        ++this.state.pos;
        isBigInt = true;
      }
      if (next === 109) {
        this.expectPlugin("decimal", this.state.curPosition());
        if (hasExponent || hasLeadingZero) {
          this.raise(Errors.InvalidDecimal, {
            at: startLoc
          });
        }
        ++this.state.pos;
        isDecimal = true;
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, {
          at: this.state.curPosition()
        });
      }
      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(135, str);
        return;
      }
      if (isDecimal) {
        this.finishToken(136, str);
        return;
      }
      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(134, val);
    }
    readCodePoint(throwOnInvalid) {
      const {
        code: code2,
        pos
      } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
      this.state.pos = pos;
      return code2;
    }
    readString(quote) {
      const {
        str,
        pos,
        curLine,
        lineStart
      } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      this.finishToken(133, str);
    }
    readTemplateContinuation() {
      if (!this.match(8)) {
        this.unexpected(null, 8);
      }
      this.state.pos--;
      this.readTemplateToken();
    }
    readTemplateToken() {
      const opening = this.input[this.state.pos];
      const {
        str,
        firstInvalidLoc,
        pos,
        curLine,
        lineStart
      } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      if (firstInvalidLoc) {
        this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
      }
      if (this.input.codePointAt(pos) === 96) {
        this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
      } else {
        this.state.pos++;
        this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
      }
    }
    recordStrictModeErrors(toParseError, {
      at
    }) {
      const index = at.index;
      if (this.state.strict && !this.state.strictErrors.has(index)) {
        this.raise(toParseError, {
          at
        });
      } else {
        this.state.strictErrors.set(index, [toParseError, at]);
      }
    }
    readWord1(firstCode) {
      this.state.containsEsc = false;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 65535 ? 1 : 2;
      }
      while (this.state.pos < this.length) {
        const ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.curPosition();
          const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, {
              at: this.state.curPosition()
            });
            chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const esc = this.readCodePoint(true);
          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(Errors.EscapedCharNotAnIdentifier, {
                at: escStart
              });
            }
            word += String.fromCodePoint(esc);
          }
          chunkStart = this.state.pos;
        } else {
          break;
        }
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
      const word = this.readWord1(firstCode);
      const type = keywords$1.get(word);
      if (type !== undefined) {
        this.finishToken(type, tokenLabelName(type));
      } else {
        this.finishToken(132, word);
      }
    }
    checkKeywordEscapes() {
      const {
        type
      } = this.state;
      if (tokenIsKeyword(type) && this.state.containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, {
          at: this.state.startLoc,
          reservedWord: tokenLabelName(type)
        });
      }
    }
    raise(toParseError, raiseProperties) {
      const {
        at
      } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
      const loc = at instanceof Position ? at : at.loc.start;
      const error = toParseError({
        loc,
        details
      });
      if (!this.options.errorRecovery)
        throw error;
      if (!this.isLookahead)
        this.state.errors.push(error);
      return error;
    }
    raiseOverwrite(toParseError, raiseProperties) {
      const {
        at
      } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
      const loc = at instanceof Position ? at : at.loc.start;
      const pos = loc.index;
      const errors2 = this.state.errors;
      for (let i = errors2.length - 1;i >= 0; i--) {
        const error = errors2[i];
        if (error.loc.index === pos) {
          return errors2[i] = toParseError({
            loc,
            details
          });
        }
        if (error.loc.index < pos)
          break;
      }
      return this.raise(toParseError, raiseProperties);
    }
    updateContext(prevType) {
    }
    unexpected(loc, type) {
      throw this.raise(Errors.UnexpectedToken, {
        expected: type ? tokenLabelName(type) : null,
        at: loc != null ? loc : this.state.startLoc
      });
    }
    expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName)) {
        return true;
      }
      throw this.raise(Errors.MissingPlugin, {
        at: loc != null ? loc : this.state.startLoc,
        missingPlugin: [pluginName]
      });
    }
    expectOnePlugin(pluginNames) {
      if (!pluginNames.some((name) => this.hasPlugin(name))) {
        throw this.raise(Errors.MissingOneOfPlugins, {
          at: this.state.startLoc,
          missingPlugin: pluginNames
        });
      }
    }
    errorBuilder(error) {
      return (pos, lineStart, curLine) => {
        this.raise(error, {
          at: buildPosition(pos, lineStart, curLine)
        });
      };
    }
  }

  class ClassScope {
    constructor() {
      this.privateNames = new Set;
      this.loneAccessors = new Map;
      this.undefinedPrivateNames = new Map;
    }
  }

  class ClassScopeHandler {
    constructor(parser3) {
      this.parser = undefined;
      this.stack = [];
      this.undefinedPrivateNames = new Map;
      this.parser = parser3;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope);
    }
    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();
      for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, loc);
          }
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name
          });
        }
      }
    }
    declarePrivateName(name, elementType, loc) {
      const {
        privateNames,
        loneAccessors,
        undefinedPrivateNames
      } = this.current();
      let redefined = privateNames.has(name);
      if (elementType & 3) {
        const accessor = redefined && loneAccessors.get(name);
        if (accessor) {
          const oldStatic = accessor & 4;
          const newStatic = elementType & 4;
          const oldKind = accessor & 3;
          const newKind = elementType & 3;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined)
            loneAccessors.delete(name);
        } else if (!redefined) {
          loneAccessors.set(name, elementType);
        }
      }
      if (redefined) {
        this.parser.raise(Errors.PrivateNameRedeclaration, {
          at: loc,
          identifierName: name
        });
      }
      privateNames.add(name);
      undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, loc) {
      let classScope;
      for (classScope of this.stack) {
        if (classScope.privateNames.has(name))
          return;
      }
      if (classScope) {
        classScope.undefinedPrivateNames.set(name, loc);
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, {
          at: loc,
          identifierName: name
        });
      }
    }
  }

  class ExpressionScope {
    constructor(type = 0) {
      this.type = type;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }

  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type) {
      super(type);
      this.declarationErrors = new Map;
    }
    recordDeclarationError(ParsingErrorClass, {
      at
    }) {
      const index = at.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at]);
    }
    clearDeclarationError(index) {
      this.declarationErrors.delete(index);
    }
    iterateErrors(iterator) {
      this.declarationErrors.forEach(iterator);
    }
  }

  class ExpressionScopeHandler {
    constructor(parser3) {
      this.parser = undefined;
      this.stack = [new ExpressionScope];
      this.parser = parser3;
    }
    enter(scope) {
      this.stack.push(scope);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(toParseError, {
      at: node2
    }) {
      const origin = {
        at: node2.loc.start
      };
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];
      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(toParseError, origin);
        } else {
          return;
        }
        scope = stack[--i];
      }
      this.parser.raise(toParseError, origin);
    }
    recordArrowParameterBindingError(error, {
      at: node2
    }) {
      const {
        stack
      } = this;
      const scope = stack[stack.length - 1];
      const origin = {
        at: node2.loc.start
      };
      if (scope.isCertainlyParameterDeclaration()) {
        this.parser.raise(error, origin);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(error, origin);
      } else {
        return;
      }
    }
    recordAsyncArrowParametersError({
      at
    }) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];
      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === 2) {
          scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
            at
          });
        }
        scope = stack[--i];
      }
    }
    validateAsPattern() {
      const {
        stack
      } = this;
      const currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration())
        return;
      currentScope.iterateErrors(([toParseError, loc]) => {
        this.parser.raise(toParseError, {
          at: loc
        });
        let i = stack.length - 2;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(loc.index);
          scope = stack[--i];
        }
      });
    }
  }

  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }

  class UtilParser extends Tokenizer {
    addExtra(node2, key, value2, enumerable = true) {
      if (!node2)
        return;
      const extra = node2.extra = node2.extra || {};
      if (enumerable) {
        extra[key] = value2;
      } else {
        Object.defineProperty(extra, key, {
          enumerable,
          value: value2
        });
      }
    }
    isContextual(token) {
      return this.state.type === token && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      if (this.input.slice(nameStart, nameEnd) === name) {
        const nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(token) {
      if (this.isContextual(token)) {
        this.next();
        return true;
      }
      return false;
    }
    expectContextual(token, toParseError) {
      if (!this.eatContextual(token)) {
        if (toParseError != null) {
          throw this.raise(toParseError, {
            at: this.state.startLoc
          });
        }
        this.unexpected(null, token);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
      return skipWhiteSpaceToLineBreak.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = true) {
      if (allowAsi ? this.isLineTerminator() : this.eat(13))
        return;
      this.raise(Errors.MissingSemicolon, {
        at: this.state.lastTokEndLoc
      });
    }
    expect(type, loc) {
      this.eat(type) || this.unexpected(loc, type);
    }
    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node2 = fn((node3 = null) => {
          abortSignal.node = node3;
          throw abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node: node2,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState
          };
        }
        return {
          node: node2,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;
        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState
          };
        }
        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState
          };
        }
        throw error;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors)
        return false;
      const {
        shorthandAssignLoc,
        doubleProtoLoc,
        privateKeyLoc,
        optionalParametersLoc
      } = refExpressionErrors;
      const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
      if (!andThrow) {
        return hasErrors;
      }
      if (shorthandAssignLoc != null) {
        this.raise(Errors.InvalidCoverInitializedName, {
          at: shorthandAssignLoc
        });
      }
      if (doubleProtoLoc != null) {
        this.raise(Errors.DuplicateProto, {
          at: doubleProtoLoc
        });
      }
      if (privateKeyLoc != null) {
        this.raise(Errors.UnexpectedPrivateField, {
          at: privateKeyLoc
        });
      }
      if (optionalParametersLoc != null) {
        this.unexpected(optionalParametersLoc);
      }
    }
    isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node2) {
      return node2.type === "PrivateName";
    }
    getPrivateNameSV(node2) {
      return node2.id.name;
    }
    hasPropertyAsPrivateName(node2) {
      return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
    }
    isObjectProperty(node2) {
      return node2.type === "ObjectProperty";
    }
    isObjectMethod(node2) {
      return node2.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set;
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope;
      const ScopeHandler2 = this.getScopeHandler();
      this.scope = new ScopeHandler2(this, inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler;
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      const oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this);
      return () => {
        this.state.labels = oldLabels;
        this.exportedIdentifiers = oldExportedIdentifiers;
        this.inModule = oldInModule;
        this.scope = oldScope;
        this.prodParam = oldProdParam;
        this.classScope = oldClassScope;
        this.expressionScope = oldExpressionScope;
      };
    }
    enterInitialScopes() {
      let paramFlags = 0;
      if (this.inModule) {
        paramFlags |= 2;
      }
      this.scope.enter(1);
      this.prodParam.enter(paramFlags);
    }
    checkDestructuringPrivate(refExpressionErrors) {
      const {
        privateKeyLoc
      } = refExpressionErrors;
      if (privateKeyLoc !== null) {
        this.expectPlugin("destructuringPrivate", privateKeyLoc);
      }
    }
  }

  class ExpressionErrors {
    constructor() {
      this.shorthandAssignLoc = null;
      this.doubleProtoLoc = null;
      this.privateKeyLoc = null;
      this.optionalParametersLoc = null;
    }
  }

  class Node {
    constructor(parser3, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser3 != null && parser3.options.ranges)
        this.range = [pos, 0];
      if (parser3 != null && parser3.filename)
        this.loc.filename = parser3.filename;
    }
  }
  var NodePrototype = Node.prototype;
  {
    NodePrototype.__clone = function() {
      const newNode = new Node(undefined, this.start, this.loc.start);
      const keys = Object.keys(this);
      for (let i = 0, length = keys.length;i < length; i++) {
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }
      return newNode;
    };
  }

  class NodeUtils extends UtilParser {
    startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(loc) {
      return new Node(this, loc.index, loc);
    }
    startNodeAtNode(type) {
      return this.startNodeAt(type.loc.start);
    }
    finishNode(node2, type) {
      return this.finishNodeAt(node2, type, this.state.lastTokEndLoc);
    }
    finishNodeAt(node2, type, endLoc) {
      node2.type = type;
      node2.end = endLoc.index;
      node2.loc.end = endLoc;
      if (this.options.ranges)
        node2.range[1] = endLoc.index;
      if (this.options.attachComment)
        this.processComment(node2);
      return node2;
    }
    resetStartLocation(node2, startLoc) {
      node2.start = startLoc.index;
      node2.loc.start = startLoc;
      if (this.options.ranges)
        node2.range[0] = startLoc.index;
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      node2.end = endLoc.index;
      node2.loc.end = endLoc;
      if (this.options.ranges)
        node2.range[1] = endLoc.index;
    }
    resetStartLocationFromNode(node2, locationNode) {
      this.resetStartLocation(node2, locationNode.loc.start);
    }
  }
  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = ParseErrorEnum`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType
    }) => `Cannot overwrite reserved type ${reservedType}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName,
      enumName
    }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    EnumDuplicateMemberName: ({
      memberName,
      enumName
    }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    EnumInconsistentMemberValues: ({
      enumName
    }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType,
      enumName
    }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName,
      memberName,
      explicitType
    }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName,
      memberName
    }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName,
      memberName
    }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    EnumInvalidMemberName: ({
      enumName,
      memberName,
      suggestion
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName,
      memberName
    }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType
    }) => `Unexpected reserved type ${reservedType}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind,
      suggestion
    }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  var exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (superClass) => class FlowParserMixin extends superClass {
    constructor(...args) {
      super(...args);
      this.flowPragma = undefined;
    }
    getScopeHandler() {
      return FlowScopeHandler;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(type, val) {
      if (type !== 133 && type !== 13 && type !== 28) {
        if (this.flowPragma === undefined) {
          this.flowPragma = null;
        }
      }
      super.finishToken(type, val);
    }
    addComment(comment) {
      if (this.flowPragma === undefined) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (!matches)
          ;
        else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }
      super.addComment(comment);
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || 14);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }
    flowParsePredicate() {
      const node2 = this.startNode();
      const moduloLoc = this.state.startLoc;
      this.next();
      this.expectContextual(110);
      if (this.state.lastTokStart > moduloLoc.index + 1) {
        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
          at: moduloLoc
        });
      }
      if (this.eat(10)) {
        node2.value = super.parseExpression();
        this.expect(11);
        return this.finishNode(node2, "DeclaredPredicate");
      } else {
        return this.finishNode(node2, "InferredPredicate");
      }
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(14);
      let type = null;
      let predicate = null;
      if (this.match(54)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;
        if (this.match(54)) {
          predicate = this.flowParsePredicate();
        }
      }
      return [type, predicate];
    }
    flowParseDeclareClass(node2) {
      this.next();
      this.flowParseInterfaceish(node2, true);
      return this.finishNode(node2, "DeclareClass");
    }
    flowParseDeclareFunction(node2) {
      this.next();
      const id = node2.id = this.parseIdentifier();
      const typeNode = this.startNode();
      const typeContainer = this.startNode();
      if (this.match(47)) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }
      this.expect(10);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      typeNode.this = tmp._this;
      this.expect(11);
      [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.resetEndLocation(id);
      this.semicolon();
      this.scope.declareName(node2.id.name, 2048, node2.id.loc.start);
      return this.finishNode(node2, "DeclareFunction");
    }
    flowParseDeclare(node2, insideModule) {
      if (this.match(80)) {
        return this.flowParseDeclareClass(node2);
      } else if (this.match(68)) {
        return this.flowParseDeclareFunction(node2);
      } else if (this.match(74)) {
        return this.flowParseDeclareVariable(node2);
      } else if (this.eatContextual(127)) {
        if (this.match(16)) {
          return this.flowParseDeclareModuleExports(node2);
        } else {
          if (insideModule) {
            this.raise(FlowErrors.NestedDeclareModule, {
              at: this.state.lastTokStartLoc
            });
          }
          return this.flowParseDeclareModule(node2);
        }
      } else if (this.isContextual(130)) {
        return this.flowParseDeclareTypeAlias(node2);
      } else if (this.isContextual(131)) {
        return this.flowParseDeclareOpaqueType(node2);
      } else if (this.isContextual(129)) {
        return this.flowParseDeclareInterface(node2);
      } else if (this.match(82)) {
        return this.flowParseDeclareExportDeclaration(node2, insideModule);
      } else {
        this.unexpected();
      }
    }
    flowParseDeclareVariable(node2) {
      this.next();
      node2.id = this.flowParseTypeAnnotatableIdentifier(true);
      this.scope.declareName(node2.id.name, 5, node2.id.loc.start);
      this.semicolon();
      return this.finishNode(node2, "DeclareVariable");
    }
    flowParseDeclareModule(node2) {
      this.scope.enter(0);
      if (this.match(133)) {
        node2.id = super.parseExprAtom();
      } else {
        node2.id = this.parseIdentifier();
      }
      const bodyNode = node2.body = this.startNode();
      const body = bodyNode.body = [];
      this.expect(5);
      while (!this.match(8)) {
        let bodyNode2 = this.startNode();
        if (this.match(83)) {
          this.next();
          if (!this.isContextual(130) && !this.match(87)) {
            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
              at: this.state.lastTokStartLoc
            });
          }
          super.parseImport(bodyNode2);
        } else {
          this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
          bodyNode2 = this.flowParseDeclare(bodyNode2, true);
        }
        body.push(bodyNode2);
      }
      this.scope.exit();
      this.expect(8);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      body.forEach((bodyElement) => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
              at: bodyElement
            });
          }
          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.raise(FlowErrors.DuplicateDeclareModuleExports, {
              at: bodyElement
            });
          }
          if (kind === "ES") {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
              at: bodyElement
            });
          }
          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node2.kind = kind || "CommonJS";
      return this.finishNode(node2, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(node2, insideModule) {
      this.expect(82);
      if (this.eat(65)) {
        if (this.match(68) || this.match(80)) {
          node2.declaration = this.flowParseDeclare(this.startNode());
        } else {
          node2.declaration = this.flowParseType();
          this.semicolon();
        }
        node2.default = true;
        return this.finishNode(node2, "DeclareExportDeclaration");
      } else {
        if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
          const label = this.state.value;
          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
            at: this.state.startLoc,
            unsupportedExportKind: label,
            suggestion: exportSuggestions[label]
          });
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
          node2.declaration = this.flowParseDeclare(this.startNode());
          node2.default = false;
          return this.finishNode(node2, "DeclareExportDeclaration");
        } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
          node2 = this.parseExport(node2, null);
          if (node2.type === "ExportNamedDeclaration") {
            node2.type = "ExportDeclaration";
            node2.default = false;
            delete node2.exportKind;
          }
          node2.type = "Declare" + node2.type;
          return node2;
        }
      }
      this.unexpected();
    }
    flowParseDeclareModuleExports(node2) {
      this.next();
      this.expectContextual(111);
      node2.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node2, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(node2) {
      this.next();
      const finished = this.flowParseTypeAlias(node2);
      finished.type = "DeclareTypeAlias";
      return finished;
    }
    flowParseDeclareOpaqueType(node2) {
      this.next();
      const finished = this.flowParseOpaqueType(node2, true);
      finished.type = "DeclareOpaqueType";
      return finished;
    }
    flowParseDeclareInterface(node2) {
      this.next();
      this.flowParseInterfaceish(node2, false);
      return this.finishNode(node2, "DeclareInterface");
    }
    flowParseInterfaceish(node2, isClass) {
      node2.id = this.flowParseRestrictedIdentifier(!isClass, true);
      this.scope.declareName(node2.id.name, isClass ? 17 : 8201, node2.id.loc.start);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node2.typeParameters = null;
      }
      node2.extends = [];
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(12));
      }
      if (isClass) {
        node2.implements = [];
        node2.mixins = [];
        if (this.eatContextual(117)) {
          do {
            node2.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        if (this.eatContextual(113)) {
          do {
            node2.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
      }
      node2.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const node2 = this.startNode();
      node2.id = this.flowParseQualifiedTypeIdentifier();
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node2.typeParameters = null;
      }
      return this.finishNode(node2, "InterfaceExtends");
    }
    flowParseInterface(node2) {
      this.flowParseInterfaceish(node2, false);
      return this.finishNode(node2, "InterfaceDeclaration");
    }
    checkNotUnderscore(word) {
      if (word === "_") {
        this.raise(FlowErrors.UnexpectedReservedUnderscore, {
          at: this.state.startLoc
        });
      }
    }
    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word))
        return;
      this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
        at: startLoc,
        reservedType: word
      });
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.startLoc, declaration);
      return this.parseIdentifier(liberal);
    }
    flowParseTypeAlias(node2) {
      node2.id = this.flowParseRestrictedIdentifier(false, true);
      this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node2.typeParameters = null;
      }
      node2.right = this.flowParseTypeInitialiser(29);
      this.semicolon();
      return this.finishNode(node2, "TypeAlias");
    }
    flowParseOpaqueType(node2, declare) {
      this.expectContextual(130);
      node2.id = this.flowParseRestrictedIdentifier(true, true);
      this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node2.typeParameters = null;
      }
      node2.supertype = null;
      if (this.match(14)) {
        node2.supertype = this.flowParseTypeInitialiser(14);
      }
      node2.impltype = null;
      if (!declare) {
        node2.impltype = this.flowParseTypeInitialiser(29);
      }
      this.semicolon();
      return this.finishNode(node2, "OpaqueType");
    }
    flowParseTypeParameter(requireDefault = false) {
      const nodeStartLoc = this.state.startLoc;
      const node2 = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node2.name = ident.name;
      node2.variance = variance;
      node2.bound = ident.typeAnnotation;
      if (this.match(29)) {
        this.eat(29);
        node2.default = this.flowParseType();
      } else {
        if (requireDefault) {
          this.raise(FlowErrors.MissingTypeParamDefault, {
            at: nodeStartLoc
          });
        }
      }
      return this.finishNode(node2, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType;
      const node2 = this.startNode();
      node2.params = [];
      this.state.inType = true;
      if (this.match(47) || this.match(142)) {
        this.next();
      } else {
        this.unexpected();
      }
      let defaultRequired = false;
      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node2.params.push(typeParameter);
        if (typeParameter.default) {
          defaultRequired = true;
        }
        if (!this.match(48)) {
          this.expect(12);
        }
      } while (!this.match(48));
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node2, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const node2 = this.startNode();
      const oldInType = this.state.inType;
      node2.params = [];
      this.state.inType = true;
      this.expect(47);
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = false;
      while (!this.match(48)) {
        node2.params.push(this.flowParseType());
        if (!this.match(48)) {
          this.expect(12);
        }
      }
      this.state.noAnonFunctionType = oldNoAnonFunctionType;
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node2, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node2 = this.startNode();
      const oldInType = this.state.inType;
      node2.params = [];
      this.state.inType = true;
      this.expect(47);
      while (!this.match(48)) {
        node2.params.push(this.flowParseTypeOrImplicitInstantiation());
        if (!this.match(48)) {
          this.expect(12);
        }
      }
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node2, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const node2 = this.startNode();
      this.expectContextual(129);
      node2.extends = [];
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
      node2.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      });
      return this.finishNode(node2, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(node2, isStatic, variance) {
      node2.static = isStatic;
      if (this.lookahead().type === 14) {
        node2.id = this.flowParseObjectPropertyKey();
        node2.key = this.flowParseTypeInitialiser();
      } else {
        node2.id = null;
        node2.key = this.flowParseType();
      }
      this.expect(3);
      node2.value = this.flowParseTypeInitialiser();
      node2.variance = variance;
      return this.finishNode(node2, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(node2, isStatic) {
      node2.static = isStatic;
      node2.id = this.flowParseObjectPropertyKey();
      this.expect(3);
      this.expect(3);
      if (this.match(47) || this.match(10)) {
        node2.method = true;
        node2.optional = false;
        node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
      } else {
        node2.method = false;
        if (this.eat(17)) {
          node2.optional = true;
        }
        node2.value = this.flowParseTypeInitialiser();
      }
      return this.finishNode(node2, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(node2) {
      node2.params = [];
      node2.rest = null;
      node2.typeParameters = null;
      node2.this = null;
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.expect(10);
      if (this.match(78)) {
        node2.this = this.flowParseFunctionTypeParam(true);
        node2.this.name = null;
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      while (!this.match(11) && !this.match(21)) {
        node2.params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      if (this.eat(21)) {
        node2.rest = this.flowParseFunctionTypeParam(false);
      }
      this.expect(11);
      node2.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node2, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(node2, isStatic) {
      const valueNode = this.startNode();
      node2.static = isStatic;
      node2.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node2, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      let inexact = false;
      if (allowExact && this.match(6)) {
        this.expect(6);
        endDelim = 9;
        exact = true;
      } else {
        this.expect(5);
        endDelim = 8;
        exact = false;
      }
      nodeStart.exact = exact;
      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStartLoc = null;
        let inexactStartLoc = null;
        const node2 = this.startNode();
        if (allowProto && this.isContextual(118)) {
          const lookahead = this.lookahead();
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next();
            protoStartLoc = this.state.startLoc;
            allowStatic = false;
          }
        }
        if (allowStatic && this.isContextual(106)) {
          const lookahead = this.lookahead();
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next();
            isStatic = true;
          }
        }
        const variance = this.flowParseVariance();
        if (this.eat(0)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (this.eat(0)) {
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic));
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
          }
        } else if (this.match(10) || this.match(47)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
        } else {
          let kind = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const lookahead = this.lookahead();
            if (tokenIsLiteralPropertyName(lookahead.type)) {
              kind = this.state.value;
              this.next();
            }
          }
          const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
          if (propOrInexact === null) {
            inexact = true;
            inexactStartLoc = this.state.lastTokStartLoc;
          } else {
            nodeStart.properties.push(propOrInexact);
          }
        }
        this.flowObjectTypeSemicolon();
        if (inexactStartLoc && !this.match(8) && !this.match(9)) {
          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
            at: inexactStartLoc
          });
        }
      }
      this.expect(endDelim);
      if (allowSpread) {
        nodeStart.inexact = inexact;
      }
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }
    flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
      if (this.eat(21)) {
        const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(FlowErrors.InexactInsideNonObject, {
              at: this.state.lastTokStartLoc
            });
          } else if (!allowInexact) {
            this.raise(FlowErrors.InexactInsideExact, {
              at: this.state.lastTokStartLoc
            });
          }
          if (variance) {
            this.raise(FlowErrors.InexactVariance, {
              at: variance
            });
          }
          return null;
        }
        if (!allowSpread) {
          this.raise(FlowErrors.UnexpectedSpreadType, {
            at: this.state.lastTokStartLoc
          });
        }
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }
        if (variance) {
          this.raise(FlowErrors.SpreadVariance, {
            at: variance
          });
        }
        node2.argument = this.flowParseType();
        return this.finishNode(node2, "ObjectTypeSpreadProperty");
      } else {
        node2.key = this.flowParseObjectPropertyKey();
        node2.static = isStatic;
        node2.proto = protoStartLoc != null;
        node2.kind = kind;
        let optional = false;
        if (this.match(47) || this.match(10)) {
          node2.method = true;
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node2);
          }
          if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              at: node2.value.this
            });
          }
        } else {
          if (kind !== "init")
            this.unexpected();
          node2.method = false;
          if (this.eat(17)) {
            optional = true;
          }
          node2.value = this.flowParseTypeInitialiser();
          node2.variance = variance;
        }
        node2.optional = optional;
        return this.finishNode(node2, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(property2) {
      const paramCount = property2.kind === "get" ? 0 : 1;
      const length = property2.value.params.length + (property2.value.rest ? 1 : 0);
      if (property2.value.this) {
        this.raise(property2.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
          at: property2.value.this
        });
      }
      if (length !== paramCount) {
        this.raise(property2.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
          at: property2
        });
      }
      if (property2.kind === "set" && property2.value.rest) {
        this.raise(Errors.BadSetterRestParameter, {
          at: property2
        });
      }
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
        this.unexpected();
      }
    }
    flowParseQualifiedTypeIdentifier(startLoc, id) {
      var _startLoc;
      (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
      let node2 = id || this.flowParseRestrictedIdentifier(true);
      while (this.eat(16)) {
        const node22 = this.startNodeAt(startLoc);
        node22.qualification = node2;
        node22.id = this.flowParseRestrictedIdentifier(true);
        node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
      }
      return node2;
    }
    flowParseGenericType(startLoc, id) {
      const node2 = this.startNodeAt(startLoc);
      node2.typeParameters = null;
      node2.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation();
      }
      return this.finishNode(node2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const node2 = this.startNode();
      this.expect(87);
      node2.argument = this.flowParsePrimaryType();
      return this.finishNode(node2, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const node2 = this.startNode();
      node2.types = [];
      this.expect(0);
      while (this.state.pos < this.length && !this.match(3)) {
        node2.types.push(this.flowParseType());
        if (this.match(3))
          break;
        this.expect(12);
      }
      this.expect(3);
      return this.finishNode(node2, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(first) {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node2 = this.startNode();
      const lh = this.lookahead();
      const isThis = this.state.type === 78;
      if (lh.type === 14 || lh.type === 17) {
        if (isThis && !first) {
          this.raise(FlowErrors.ThisParamMustBeFirst, {
            at: node2
          });
        }
        name = this.parseIdentifier(isThis);
        if (this.eat(17)) {
          optional = true;
          if (isThis) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              at: node2
            });
          }
        }
        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }
      node2.name = name;
      node2.optional = optional;
      node2.typeAnnotation = typeAnnotation;
      return this.finishNode(node2, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(type) {
      const node2 = this.startNodeAt(type.loc.start);
      node2.name = null;
      node2.optional = false;
      node2.typeAnnotation = type;
      return this.finishNode(node2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null;
      let _this = null;
      if (this.match(78)) {
        _this = this.flowParseFunctionTypeParam(true);
        _this.name = null;
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      while (!this.match(11) && !this.match(21)) {
        params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      if (this.eat(21)) {
        rest = this.flowParseFunctionTypeParam(false);
      }
      return {
        params,
        rest,
        _this
      };
    }
    flowIdentToTypeAnnotation(startLoc, node2, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node2, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node2, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node2, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node2, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node2, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node2, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(node2, "SymbolTypeAnnotation");
        default:
          this.checkNotUnderscore(id.name);
          return this.flowParseGenericType(startLoc, id);
      }
    }
    flowParsePrimaryType() {
      const startLoc = this.state.startLoc;
      const node2 = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case 0:
          this.state.noAnonFunctionType = false;
          type = this.flowParseTupleType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          return type;
        case 47:
          node2.typeParameters = this.flowParseTypeParameterDeclaration();
          this.expect(10);
          tmp = this.flowParseFunctionTypeParams();
          node2.params = tmp.params;
          node2.rest = tmp.rest;
          node2.this = tmp._this;
          this.expect(11);
          this.expect(19);
          node2.returnType = this.flowParseType();
          return this.finishNode(node2, "FunctionTypeAnnotation");
        case 10:
          this.next();
          if (!this.match(11) && !this.match(21)) {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              const token = this.lookahead().type;
              isGroupedType = token !== 17 && token !== 14;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
              this.expect(11);
              return type;
            } else {
              this.eat(12);
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }
          node2.params = tmp.params;
          node2.rest = tmp.rest;
          node2.this = tmp._this;
          this.expect(11);
          this.expect(19);
          node2.returnType = this.flowParseType();
          node2.typeParameters = null;
          return this.finishNode(node2, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          node2.value = this.match(85);
          this.next();
          return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            this.next();
            if (this.match(134)) {
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node2);
            }
            if (this.match(135)) {
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node2);
            }
            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
              at: this.state.startLoc
            });
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          this.next();
          return this.finishNode(node2, "VoidTypeAnnotation");
        case 84:
          this.next();
          return this.finishNode(node2, "NullLiteralTypeAnnotation");
        case 78:
          this.next();
          return this.finishNode(node2, "ThisTypeAnnotation");
        case 55:
          this.next();
          return this.finishNode(node2, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (tokenIsKeyword(this.state.type)) {
            const label = tokenLabelName(this.state.type);
            this.next();
            return super.createIdentifier(node2, label);
          } else if (tokenIsIdentifier(this.state.type)) {
            if (this.isContextual(129)) {
              return this.flowParseInterfaceType();
            }
            return this.flowIdentToTypeAnnotation(startLoc, node2, this.parseIdentifier());
          }
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();
      let seenOptionalIndexedAccess = false;
      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
        const node2 = this.startNodeAt(startLoc);
        const optional = this.eat(18);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
        this.expect(0);
        if (!optional && this.match(3)) {
          node2.elementType = type;
          this.next();
          type = this.finishNode(node2, "ArrayTypeAnnotation");
        } else {
          node2.objectType = type;
          node2.indexType = this.flowParseType();
          this.expect(3);
          if (seenOptionalIndexedAccess) {
            node2.optional = optional;
            type = this.finishNode(node2, "OptionalIndexedAccessType");
          } else {
            type = this.finishNode(node2, "IndexedAccessType");
          }
        }
      }
      return type;
    }
    flowParsePrefixType() {
      const node2 = this.startNode();
      if (this.eat(17)) {
        node2.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node2, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node2 = this.startNodeAt(param.loc.start);
        node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node2.rest = null;
        node2.this = null;
        node2.returnType = this.flowParseType();
        node2.typeParameters = null;
        return this.finishNode(node2, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType() {
      const node2 = this.startNode();
      this.eat(45);
      const type = this.flowParseAnonFunctionWithoutParens();
      node2.types = [type];
      while (this.eat(45)) {
        node2.types.push(this.flowParseAnonFunctionWithoutParens());
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const node2 = this.startNode();
      this.eat(43);
      const type = this.flowParseIntersectionType();
      node2.types = [type];
      while (this.eat(43)) {
        node2.types.push(this.flowParseIntersectionType());
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, "UnionTypeAnnotation");
    }
    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      return type;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const startLoc = this.state.startLoc;
        const node2 = this.parseIdentifier();
        return this.flowParseGenericType(startLoc, node2);
      } else {
        return this.flowParseType();
      }
    }
    flowParseTypeAnnotation() {
      const node2 = this.startNode();
      node2.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node2, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      if (this.match(14)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(ident);
      }
      return ident;
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation;
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
      return node2.expression;
    }
    flowParseVariance() {
      let variance = null;
      if (this.match(53)) {
        variance = this.startNode();
        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }
        this.next();
        return this.finishNode(variance, "Variance");
      }
      return variance;
    }
    parseFunctionBody(node2, allowExpressionBody, isMethod = false) {
      if (allowExpressionBody) {
        this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod));
        return;
      }
      super.parseFunctionBody(node2, false, isMethod);
    }
    parseFunctionBodyAndFinish(node2, type, isMethod = false) {
      if (this.match(14)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
        node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(node2, type, isMethod);
    }
    parseStatementLike(flags) {
      if (this.state.strict && this.isContextual(129)) {
        const lookahead = this.lookahead();
        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
          const node2 = this.startNode();
          this.next();
          return this.flowParseInterface(node2);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        const node2 = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node2);
      }
      const stmt = super.parseStatementLike(flags);
      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }
      return stmt;
    }
    parseExpressionStatement(node2, expr, decorators) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
            return this.flowParseDeclare(node2);
          }
        } else if (tokenIsIdentifier(this.state.type)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node2);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node2);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node2, false);
          }
        }
      }
      return super.parseExpressionStatement(node2, expr, decorators);
    }
    shouldParseExportDeclaration() {
      const {
        type
      } = this.state;
      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
        return !this.state.containsEsc;
      }
      return super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type
      } = this.state;
      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
        return this.state.containsEsc;
      }
      return super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        const node2 = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node2);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.match(17))
        return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors);
          return expr;
        }
      }
      this.expect(17);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node2 = this.startNodeAt(startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;
          for (let i = 0;i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        if (failed && valid.length > 1) {
          this.raise(FlowErrors.AmbiguousConditionalArrow, {
            at: state.startLoc
          });
        }
        if (failed && valid.length === 1) {
          this.state = state;
          noArrowAt.push(valid[0].start);
          this.state.noArrowAt = noArrowAt;
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
      }
      this.getArrowLikeExpressions(consequent, true);
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(14);
      node2.test = expr;
      node2.consequent = consequent;
      node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(undefined, undefined));
      return this.finishNode(node2, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn();
      const failed = !this.match(14);
      this.state.noArrowParamsConversionAt.pop();
      return {
        consequent,
        failed
      };
    }
    getArrowLikeExpressions(node2, disallowInvalid) {
      const stack = [node2];
      const arrows = [];
      while (stack.length !== 0) {
        const node3 = stack.pop();
        if (node3.type === "ArrowFunctionExpression") {
          if (node3.typeParameters || !node3.returnType) {
            this.finishArrowValidation(node3);
          } else {
            arrows.push(node3);
          }
          stack.push(node3.body);
        } else if (node3.type === "ConditionalExpression") {
          stack.push(node3.consequent);
          stack.push(node3.alternate);
        }
      }
      if (disallowInvalid) {
        arrows.forEach((node3) => this.finishArrowValidation(node3));
        return [arrows, []];
      }
      return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)));
    }
    finishArrowValidation(node2) {
      var _node$extra;
      this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? undefined : _node$extra.trailingCommaLoc, false);
      this.scope.enter(2 | 4);
      super.checkParams(node2, false, true);
      this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(node2, parse3) {
      let result;
      if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse3();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse3();
      }
      return result;
    }
    parseParenItem(node2, startLoc) {
      node2 = super.parseParenItem(node2, startLoc);
      if (this.eat(17)) {
        node2.optional = true;
        this.resetEndLocation(node2);
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        typeCastNode.expression = node2;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return node2;
    }
    assertModuleNodeAllowed(node2) {
      if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
        return;
      }
      super.assertModuleNodeAllowed(node2);
    }
    parseExportDeclaration(node2) {
      if (this.isContextual(130)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        if (this.match(5)) {
          node2.specifiers = this.parseExportSpecifiers(true);
          super.parseExportFrom(node2);
          return null;
        } else {
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual(131)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual(129)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        node2.exportKind = "value";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(declarationNode);
      } else {
        return super.parseExportDeclaration(node2);
      }
    }
    eatExportStar(node2) {
      if (super.eatExportStar(node2))
        return true;
      if (this.isContextual(130) && this.lookahead().type === 55) {
        node2.exportKind = "type";
        this.next();
        this.next();
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node2) {
      const {
        startLoc
      } = this.state;
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
      if (hasNamespace && node2.exportKind === "type") {
        this.unexpected(startLoc);
      }
      return hasNamespace;
    }
    parseClassId(node2, isStatement, optionalId) {
      super.parseClassId(node2, isStatement, optionalId);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }
    parseClassMember(classBody, member, state) {
      const {
        startLoc
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        member.declare = true;
      }
      super.parseClassMember(classBody, member, state);
      if (member.declare) {
        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
          this.raise(FlowErrors.DeclareClassElement, {
            at: startLoc
          });
        } else if (member.value) {
          this.raise(FlowErrors.DeclareClassFieldInitializer, {
            at: member.value
          });
        }
      }
    }
    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }
    readIterator() {
      const word = super.readWord1();
      const fullWord = "@@" + word;
      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(Errors.InvalidIdentifier, {
          at: this.state.curPosition(),
          identifierName: fullWord
        });
      }
      this.finishToken(132, fullWord);
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 123 && next === 124) {
        this.finishOp(6, 2);
      } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
        this.finishOp(code2 === 62 ? 48 : 47, 1);
      } else if (this.state.inType && code2 === 63) {
        if (next === 46) {
          this.finishOp(18, 2);
        } else {
          this.finishOp(17, 1);
        }
      } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
        this.state.pos += 2;
        this.readIterator();
      } else {
        super.getTokenFromCode(code2);
      }
    }
    isAssignable(node2, isBinding) {
      if (node2.type === "TypeCastExpression") {
        return this.isAssignable(node2.expression, isBinding);
      } else {
        return super.isAssignable(node2, isBinding);
      }
    }
    toAssignable(node2, isLHS = false) {
      if (!isLHS && node2.type === "AssignmentExpression" && node2.left.type === "TypeCastExpression") {
        node2.left = this.typeCastToParameter(node2.left);
      }
      super.toAssignable(node2, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0;i < exprList.length; i++) {
        const expr = exprList[i];
        if ((expr == null ? undefined : expr.type) === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0;i < exprList.length; i++) {
        var _expr$extra;
        const expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
          this.raise(FlowErrors.TypeCastInPattern, {
            at: expr.typeAnnotation
          });
        }
      }
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node2.elements);
      }
      return node2;
    }
    isValidLVal(type, isParenthesized, binding) {
      return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
    }
    parseClassProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassProperty(node2);
    }
    parseClassPrivateProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassPrivateProperty(node2);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start);
      }
      delete method.variance;
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper);
      if (method.params && isConstructor) {
        const params = method.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, {
            at: method
          });
        }
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, {
            at: method
          });
        }
      }
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync2) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start);
      }
      delete method.variance;
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync2);
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2);
      if (node2.superClass && this.match(47)) {
        node2.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual(113)) {
        this.next();
        const implemented = node2.implements = [];
        do {
          const node3 = this.startNode();
          node3.id = this.flowParseRestrictedIdentifier(true);
          if (this.match(47)) {
            node3.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node3.typeParameters = null;
          }
          implemented.push(this.finishNode(node3, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length > 0) {
        const param = params[0];
        if (this.isThisParam(param) && method.kind === "get") {
          this.raise(FlowErrors.GetterMayNotHaveThisParam, {
            at: param
          });
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.SetterMayNotHaveThisParam, {
            at: param
          });
        }
      }
    }
    parsePropertyNamePrefixOperator(node2) {
      node2.variance = this.flowParseVariance();
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.loc.start);
      }
      delete prop.variance;
      let typeParameters;
      if (this.match(47) && !isAccessor) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(10))
          this.unexpected();
      }
      const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors);
      if (typeParameters) {
        (result.value || result).typeParameters = typeParameters;
      }
      return result;
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(17)) {
        if (param.type !== "Identifier") {
          this.raise(FlowErrors.PatternIsOptional, {
            at: param
          });
        }
        if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamMayNotBeOptional, {
            at: param
          });
        }
        param.optional = true;
      }
      if (this.match(14)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamAnnotationRequired, {
          at: param
        });
      }
      if (this.match(29) && this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamNoDefault, {
          at: param
        });
      }
      this.resetEndLocation(param);
      return param;
    }
    parseMaybeDefault(startLoc, left2) {
      const node2 = super.parseMaybeDefault(startLoc, left2);
      if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
        this.raise(FlowErrors.TypeBeforeInitializer, {
          at: node2.typeAnnotation
        });
      }
      return node2;
    }
    checkImportReflection(node2) {
      super.checkImportReflection(node2);
      if (node2.module && node2.importKind !== "value") {
        this.raise(FlowErrors.ImportReflectionHasImportType, {
          at: node2.specifiers[0].loc.start
        });
      }
    }
    parseImportSpecifierLocal(node2, specifier, type) {
      specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
      node2.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport))
        return true;
      if (this.isContextual(130)) {
        if (!isExport)
          return true;
        const ch = this.lookaheadCharCode();
        return ch === 123 || ch === 42;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      super.applyImportPhase(node2, isExport, phase, loc);
      if (isExport) {
        if (!phase && this.match(65)) {
          return;
        }
        node2.exportKind = phase === "type" ? phase : "value";
      } else {
        if (phase === "type" && this.match(55))
          this.unexpected();
        node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      const firstIdent = specifier.imported;
      let specifierTypeKind = null;
      if (firstIdent.type === "Identifier") {
        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }
      }
      let isBinding = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = cloneIdentifier(as_ident);
        } else {
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;
        } else {
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, {
              at: specifier,
              importName: firstIdent.value
            });
          }
          specifier.imported = firstIdent;
          specifier.importKind = null;
        }
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = cloneIdentifier(specifier.imported);
        }
      }
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      if (isInTypeOnlyImport && specifierIsTypeImport) {
        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
          at: specifier
        });
      }
      if (isInTypeOnlyImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
      }
      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(node2, isConstructor) {
      const kind = node2.kind;
      if (kind !== "get" && kind !== "set" && this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.parseFunctionParams(node2, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (this.match(14)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node2, call) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node2.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node2, call);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;
      let state = null;
      let jsx2;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        state = this.state.clone();
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx2.error)
          return jsx2.node;
        const {
          context
        } = this.state;
        const currentContext = context[context.length - 1];
        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
          context.pop();
        }
      }
      if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
        var _jsx2, _jsx3;
        state = state || this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _arrowExpression$extr;
          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            this.resetStartLocationFromNode(result, typeParameters);
            return result;
          });
          if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
            abort();
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
          if (expr.type !== "ArrowFunctionExpression")
            abort();
          expr.typeParameters = typeParameters;
          this.resetStartLocationFromNode(expr, typeParameters);
          return arrowExpression2;
        }, state);
        let arrowExpression = null;
        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                at: typeParameters
              });
            }
            return arrow.node;
          }
          arrowExpression = arrow.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrowExpression) {
          this.state = arrow.failState;
          return arrowExpression;
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown)
          throw jsx2.error;
        if (arrow.thrown)
          throw arrow.error;
        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
          at: typeParameters
        });
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon())
            this.unexpected();
          if (!this.match(19))
            this.unexpected();
          return typeNode;
        });
        if (result.thrown)
          return null;
        if (result.error)
          this.state = result.failState;
        node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(node2);
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params);
    }
    setArrowFunctionParameters(node2, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        node2.params = params;
      } else {
        super.setArrowFunctionParameters(node2, params);
      }
    }
    checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        return;
      }
      for (let i = 0;i < node2.params.length; i++) {
        if (this.isThisParam(node2.params[i]) && i > 0) {
          this.raise(FlowErrors.ThisParamMustBeFirst, {
            at: node2.params[i]
          });
        }
      }
      super.checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged);
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(base, startLoc, noCalls) {
      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
        this.next();
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base;
        node2.arguments = super.parseCallExpressionArguments(11, false);
        base = this.finishNode(node2, "CallExpression");
      } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
        const state = this.state.clone();
        const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
        if (!arrow.error && !arrow.aborted)
          return arrow.node;
        const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
        if (result.node && !result.error)
          return result.node;
        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }
        if (result.node) {
          this.state = result.failState;
          return result.node;
        }
        throw arrow.error || result.error;
      }
      return super.parseSubscripts(base, startLoc, noCalls);
    }
    parseSubscript(base, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true;
        if (noCalls) {
          subscriptState.stop = true;
          return base;
        }
        this.next();
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base;
        node2.typeArguments = this.flowParseTypeParameterInstantiation();
        this.expect(10);
        node2.arguments = this.parseCallExpressionArguments(11, false);
        node2.optional = true;
        return this.finishCallExpression(node2, true);
      } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base;
        const result = this.tryParse(() => {
          node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
          this.expect(10);
          node2.arguments = super.parseCallExpressionArguments(11, false);
          if (subscriptState.optionalChainMember) {
            node2.optional = false;
          }
          return this.finishCallExpression(node2, subscriptState.optionalChainMember);
        });
        if (result.node) {
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
      }
      return super.parseSubscript(base, startLoc, noCalls, subscriptState);
    }
    parseNewCallee(node2) {
      super.parseNewCallee(node2);
      let targs = null;
      if (this.shouldParseTypes() && this.match(47)) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      }
      node2.typeArguments = targs;
    }
    parseAsyncArrowWithTypeParameters(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      this.parseFunctionParams(node2, false);
      if (!this.parseArrow(node2))
        return;
      return super.parseArrowExpression(node2, undefined, true);
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code2);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(code2);
    }
    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);
      if (this.state.hasFlowComment) {
        this.raise(FlowErrors.UnterminatedFlowComment, {
          at: this.state.curPosition()
        });
      }
      return fileNode;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          throw this.raise(FlowErrors.NestedFlowComment, {
            at: this.state.startLoc
          });
        }
        this.hasFlowCommentCompletion();
        const commentSkip = this.skipFlowComment();
        if (commentSkip) {
          this.state.pos += commentSkip;
          this.state.hasFlowComment = true;
        }
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;
      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++;
      }
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2;
      }
      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
        return shiftToFirstNonWhiteSpace + 12;
      }
      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace;
      }
      return false;
    }
    hasFlowCommentCompletion() {
      const end = this.input.indexOf("*/", this.state.pos);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, {
          at: this.state.curPosition()
        });
      }
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, {
      enumName,
      memberName
    }) {
      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
        at: loc,
        memberName,
        enumName
      });
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
        at: loc
      }, enumContext));
    }
    flowEnumErrorNumberMemberNotInitialized(loc, {
      enumName,
      memberName
    }) {
      this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
        at: loc,
        enumName,
        memberName
      });
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(node2, {
      enumName
    }) {
      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {
        at: node2,
        enumName
      });
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc;
      const endOfInit = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          const literal = this.parseNumericLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "number",
              loc: literal.loc.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        case 133: {
          const literal = this.parseStringLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "string",
              loc: literal.loc.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        case 85:
        case 86: {
          const literal = this.parseBooleanLiteral(this.match(85));
          if (endOfInit()) {
            return {
              type: "boolean",
              loc: literal.loc.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        default:
          return {
            type: "invalid",
            loc: startLoc
          };
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc;
      const id = this.parseIdentifier(true);
      const init = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc
      };
      return {
        id,
        init
      };
    }
    flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
      const {
        explicitType
      } = context;
      if (explicitType === null) {
        return;
      }
      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(loc, context);
      }
    }
    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = new Set;
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = false;
      while (!this.match(8)) {
        if (this.eat(21)) {
          hasUnknownMembers = true;
          break;
        }
        const memberNode = this.startNode();
        const {
          id,
          init
        } = this.flowEnumMemberRaw();
        const memberName = id.name;
        if (memberName === "") {
          continue;
        }
        if (/^[a-z]/.test(memberName)) {
          this.raise(FlowErrors.EnumInvalidMemberName, {
            at: id,
            memberName,
            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
            enumName
          });
        }
        if (seenNames.has(memberName)) {
          this.raise(FlowErrors.EnumDuplicateMemberName, {
            at: id,
            memberName,
            enumName
          });
        }
        seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        memberNode.id = id;
        switch (init.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
            memberNode.init = init.value;
            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
            memberNode.init = init.value;
            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
            memberNode.init = init.value;
            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }
          case "invalid": {
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
          }
          case "none": {
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                break;
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
          }
        }
        if (!this.match(8)) {
          this.expect(12);
        }
      }
      return {
        members,
        hasUnknownMembers
      };
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers;
      } else if (defaultedMembers.length === 0) {
        return initializedMembers;
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        }
        return defaultedMembers;
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        }
        return initializedMembers;
      }
    }
    flowEnumParseExplicitType({
      enumName
    }) {
      if (!this.eatContextual(102))
        return null;
      if (!tokenIsIdentifier(this.state.type)) {
        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
          at: this.state.startLoc,
          enumName
        });
      }
      const {
        value: value2
      } = this.state;
      this.next();
      if (value2 !== "boolean" && value2 !== "number" && value2 !== "string" && value2 !== "symbol") {
        this.raise(FlowErrors.EnumInvalidExplicitType, {
          at: this.state.startLoc,
          enumName,
          invalidEnumType: value2
        });
      }
      return value2;
    }
    flowEnumBody(node2, id) {
      const enumName = id.name;
      const nameLoc = id.loc.start;
      const explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(5);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      node2.hasUnknownMembers = hasUnknownMembers;
      switch (explicitType) {
        case "boolean":
          node2.explicitType = true;
          node2.members = members.booleanMembers;
          this.expect(8);
          return this.finishNode(node2, "EnumBooleanBody");
        case "number":
          node2.explicitType = true;
          node2.members = members.numberMembers;
          this.expect(8);
          return this.finishNode(node2, "EnumNumberBody");
        case "string":
          node2.explicitType = true;
          node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(8);
          return this.finishNode(node2, "EnumStringBody");
        case "symbol":
          node2.members = members.defaultedMembers;
          this.expect(8);
          return this.finishNode(node2, "EnumSymbolBody");
        default: {
          const empty = () => {
            node2.members = [];
            this.expect(8);
            return this.finishNode(node2, "EnumStringBody");
          };
          node2.explicitType = false;
          const boolsLen = members.booleanMembers.length;
          const numsLen = members.numberMembers.length;
          const strsLen = members.stringMembers.length;
          const defaultedLen = members.defaultedMembers.length;
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty();
          } else if (!boolsLen && !numsLen) {
            node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node2, "EnumStringBody");
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node2.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node2.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumNumberBody");
          } else {
            this.raise(FlowErrors.EnumInconsistentMemberValues, {
              at: nameLoc,
              enumName
            });
            return empty();
          }
        }
      }
    }
    flowParseEnumDeclaration(node2) {
      const id = this.parseIdentifier();
      node2.id = id;
      node2.body = this.flowEnumBody(this.startNode(), id);
      return this.finishNode(node2, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(node2) {
      return node2.type === "TypeCastExpression" ? node2.expression : node2;
    }
  };
  var entities = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };
  var JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName
    }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected,
      HTMLEntity
    }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  var jsx = (superClass) => class JSXParserMixin extends superClass {
    jsxReadToken() {
      let out = "";
      let chunkStart = this.state.pos;
      for (;; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(JsxErrors.UnterminatedJsxContent, {
            at: this.state.startLoc
          });
        }
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.canStartJSXElement) {
                ++this.state.pos;
                this.finishToken(142);
              } else {
                super.getTokenFromCode(ch);
              }
              return;
            }
            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(141, out);
            return;
          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }
    jsxReadString(quote) {
      let out = "";
      let chunkStart = ++this.state.pos;
      for (;; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(Errors.UnterminatedString, {
            at: this.state.startLoc
          });
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote)
          break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(133, out);
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let radix = 10;
        if (this.codePointAtPos(this.state.pos) === 120) {
          radix = 16;
          ++this.state.pos;
        }
        const codePoint = this.readInt(radix, undefined, false, "bail");
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
          ++this.state.pos;
          return String.fromCodePoint(codePoint);
        }
      } else {
        let count = 0;
        let semi = false;
        while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
          ++this.state.pos;
        }
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos);
          const entity = entities[desc];
          ++this.state.pos;
          if (entity) {
            return entity;
          }
        }
      }
      this.state.pos = startPos;
      return "&";
    }
    jsxReadWord() {
      let ch;
      const start = this.state.pos;
      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === 45);
      this.finishToken(140, this.input.slice(start, this.state.pos));
    }
    jsxParseIdentifier() {
      const node2 = this.startNode();
      if (this.match(140)) {
        node2.name = this.state.value;
      } else if (tokenIsKeyword(this.state.type)) {
        node2.name = tokenLabelName(this.state.type);
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node2, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(14))
        return name;
      const node2 = this.startNodeAt(startLoc);
      node2.namespace = name;
      node2.name = this.jsxParseIdentifier();
      return this.finishNode(node2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const startLoc = this.state.startLoc;
      let node2 = this.jsxParseNamespacedName();
      if (node2.type === "JSXNamespacedName") {
        return node2;
      }
      while (this.eat(16)) {
        const newNode = this.startNodeAt(startLoc);
        newNode.object = node2;
        newNode.property = this.jsxParseIdentifier();
        node2 = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node2;
    }
    jsxParseAttributeValue() {
      let node2;
      switch (this.state.type) {
        case 5:
          node2 = this.startNode();
          this.setContext(types.brace);
          this.next();
          node2 = this.jsxParseExpressionContainer(node2, types.j_oTag);
          if (node2.expression.type === "JSXEmptyExpression") {
            this.raise(JsxErrors.AttributeIsEmpty, {
              at: node2
            });
          }
          return node2;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(JsxErrors.UnsupportedJsxValue, {
            at: this.state.startLoc
          });
      }
    }
    jsxParseEmptyExpression() {
      const node2 = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(node2) {
      this.next();
      node2.expression = this.parseExpression();
      this.setContext(types.j_expr);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node2, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(node2, previousContext) {
      if (this.match(8)) {
        node2.expression = this.jsxParseEmptyExpression();
      } else {
        const expression = this.parseExpression();
        node2.expression = expression;
      }
      this.setContext(previousContext);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node2, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const node2 = this.startNode();
      if (this.match(5)) {
        this.setContext(types.brace);
        this.next();
        this.expect(21);
        node2.argument = this.parseMaybeAssignAllowIn();
        this.setContext(types.j_oTag);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node2, "JSXSpreadAttribute");
      }
      node2.name = this.jsxParseNamespacedName();
      node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node2, "JSXAttribute");
    }
    jsxParseOpeningElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      if (this.eat(143)) {
        return this.finishNode(node2, "JSXOpeningFragment");
      }
      node2.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node2);
    }
    jsxParseOpeningElementAfterName(node2) {
      const attributes = [];
      while (!this.match(56) && !this.match(143)) {
        attributes.push(this.jsxParseAttribute());
      }
      node2.attributes = attributes;
      node2.selfClosing = this.eat(56);
      this.expect(143);
      return this.finishNode(node2, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      if (this.eat(143)) {
        return this.finishNode(node2, "JSXClosingFragment");
      }
      node2.name = this.jsxParseElementName();
      this.expect(143);
      return this.finishNode(node2, "JSXClosingElement");
    }
    jsxParseElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents:
          for (;; ) {
            switch (this.state.type) {
              case 142:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 141:
                children.push(this.parseExprAtom());
                break;
              case 5: {
                const node3 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node3));
                } else {
                  children.push(this.jsxParseExpressionContainer(node3, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
        if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
          this.raise(JsxErrors.MissingClosingTagFragment, {
            at: closingElement
          });
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(JsxErrors.MissingClosingTagElement, {
            at: closingElement,
            openingTagName: getQualifiedJSXName(openingElement.name)
          });
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(JsxErrors.MissingClosingTagElement, {
              at: closingElement,
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          }
        }
      }
      if (isFragment(openingElement)) {
        node2.openingFragment = openingElement;
        node2.closingFragment = closingElement;
      } else {
        node2.openingElement = openingElement;
        node2.closingElement = closingElement;
      }
      node2.children = children;
      if (this.match(47)) {
        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
          at: this.state.startLoc
        });
      }
      return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
    }
    jsxParseElement() {
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startLoc);
    }
    setContext(newContext) {
      const {
        context
      } = this.state;
      context[context.length - 1] = newContext;
    }
    parseExprAtom(refExpressionErrors) {
      if (this.match(141)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(142)) {
        return this.jsxParseElement();
      } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
        this.replaceToken(142);
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refExpressionErrors);
      }
    }
    skipSpace() {
      const curContext = this.curContext();
      if (!curContext.preserveSpace)
        super.skipSpace();
    }
    getTokenFromCode(code2) {
      const context = this.curContext();
      if (context === types.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (context === types.j_oTag || context === types.j_cTag) {
        if (isIdentifierStart(code2)) {
          this.jsxReadWord();
          return;
        }
        if (code2 === 62) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
          this.jsxReadString(code2);
          return;
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos;
        this.finishToken(142);
        return;
      }
      super.getTokenFromCode(code2);
    }
    updateContext(prevType) {
      const {
        context,
        type
      } = this.state;
      if (type === 56 && prevType === 142) {
        context.splice(-2, 2, types.j_cTag);
        this.state.canStartJSXElement = false;
      } else if (type === 142) {
        context.push(types.j_oTag);
      } else if (type === 143) {
        const out = context[context.length - 1];
        if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
          context.pop();
          this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
        } else {
          this.setContext(types.j_expr);
          this.state.canStartJSXElement = true;
        }
      } else {
        this.state.canStartJSXElement = tokenComesBeforeExpression(type);
      }
    }
  };

  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args);
      this.types = new Set;
      this.enums = new Set;
      this.constEnums = new Set;
      this.classes = new Set;
      this.exportOnlyBindings = new Set;
    }
  }

  class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args) {
      super(...args);
      this.importsStack = [];
    }
    createScope(flags) {
      this.importsStack.push(new Set);
      return new TypeScriptScope(flags);
    }
    enter(flags) {
      if (flags == 256) {
        this.importsStack.push(new Set);
      }
      super.enter(flags);
    }
    exit() {
      const flags = super.exit();
      if (flags == 256) {
        this.importsStack.pop();
      }
      return flags;
    }
    hasImport(name, allowShadow) {
      const len = this.importsStack.length;
      if (this.importsStack[len - 1].has(name)) {
        return true;
      }
      if (!allowShadow && len > 1) {
        for (let i = 0;i < len - 1; i++) {
          if (this.importsStack[i].has(name))
            return true;
        }
      }
      return false;
    }
    declareName(name, bindingType, loc) {
      if (bindingType & 4096) {
        if (this.hasImport(name, true)) {
          this.parser.raise(Errors.VarRedeclaration, {
            at: loc,
            identifierName: name
          });
        }
        this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }
      const scope = this.currentScope();
      if (bindingType & 1024) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.add(name);
        return;
      }
      super.declareName(name, bindingType, loc);
      if (bindingType & 2) {
        if (!(bindingType & 1)) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
        }
        scope.types.add(name);
      }
      if (bindingType & 256)
        scope.enums.add(name);
      if (bindingType & 512) {
        scope.constEnums.add(name);
      }
      if (bindingType & 128)
        scope.classes.add(name);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.has(name)) {
        if (bindingType & 256) {
          const isConst = !!(bindingType & 512);
          const wasConst = scope.constEnums.has(name);
          return isConst !== wasConst;
        }
        return true;
      }
      if (bindingType & 128 && scope.classes.has(name)) {
        if (scope.lexical.has(name)) {
          return !!(bindingType & 1);
        } else {
          return false;
        }
      }
      if (bindingType & 2 && scope.types.has(name)) {
        return true;
      }
      return super.isRedeclaredInScope(scope, name, bindingType);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      if (this.hasImport(name))
        return;
      const len = this.scopeStack.length;
      for (let i = len - 1;i >= 0; i--) {
        const scope = this.scopeStack[i];
        if (scope.types.has(name) || scope.exportOnlyBindings.has(name))
          return;
      }
      super.checkLocalExport(id);
    }
  }
  var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
  var unwrapParenthesizedExpression = (node2) => {
    return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
  };

  class LValParser extends NodeUtils {
    toAssignable(node2, isLHS = false) {
      var _node$extra, _node$extra3;
      let parenthesized = undefined;
      if (node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node2);
        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
              at: node2
            });
          } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
            this.raise(Errors.InvalidParenthesizedAssignment, {
              at: node2
            });
          }
        } else {
          this.raise(Errors.InvalidParenthesizedAssignment, {
            at: node2
          });
        }
      }
      switch (node2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node2.type = "ObjectPattern";
          for (let i = 0, length = node2.properties.length, last = length - 1;i < length; i++) {
            var _node$extra2;
            const prop = node2.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
            if (isLast && prop.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, {
                at: node2.extra.trailingCommaLoc
              });
            }
          }
          break;
        case "ObjectProperty": {
          const {
            key,
            value: value2
          } = node2;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value2, isLHS);
          break;
        }
        case "SpreadElement": {
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        }
        case "ArrayExpression":
          node2.type = "ArrayPattern";
          this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? undefined : _node$extra3.trailingCommaLoc, isLHS);
          break;
        case "AssignmentExpression":
          if (node2.operator !== "=") {
            this.raise(Errors.MissingEqInAssignment, {
              at: node2.left.loc.end
            });
          }
          node2.type = "AssignmentPattern";
          delete node2.operator;
          this.toAssignable(node2.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
          at: prop.key
        });
      } else if (prop.type === "SpreadElement") {
        prop.type = "RestElement";
        const arg = prop.argument;
        this.checkToRestConversion(arg, false);
        this.toAssignable(arg, isLHS);
        if (!isLast) {
          this.raise(Errors.RestTrailingComma, {
            at: prop
          });
        }
      } else {
        this.toAssignable(prop, isLHS);
      }
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      const end = exprList.length - 1;
      for (let i = 0;i <= end; i++) {
        const elt = exprList[i];
        if (!elt)
          continue;
        if (elt.type === "SpreadElement") {
          elt.type = "RestElement";
          const arg = elt.argument;
          this.checkToRestConversion(arg, true);
          this.toAssignable(arg, isLHS);
        } else {
          this.toAssignable(elt, isLHS);
        }
        if (elt.type === "RestElement") {
          if (i < end) {
            this.raise(Errors.RestTrailingComma, {
              at: elt
            });
          } else if (trailingCommaLoc) {
            this.raise(Errors.RestTrailingComma, {
              at: trailingCommaLoc
            });
          }
        }
      }
    }
    isAssignable(node2, isBinding) {
      switch (node2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const last = node2.properties.length - 1;
          return node2.properties.every((prop, i) => {
            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
          });
        }
        case "ObjectProperty":
          return this.isAssignable(node2.value);
        case "SpreadElement":
          return this.isAssignable(node2.argument);
        case "ArrayExpression":
          return node2.elements.every((element) => element === null || this.isAssignable(element));
        case "AssignmentExpression":
          return node2.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node2.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;
        default:
          return false;
      }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (const expr of exprList) {
        if ((expr == null ? undefined : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }
    parseSpread(refExpressionErrors) {
      const node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
      return this.finishNode(node2, "SpreadElement");
    }
    parseRestBinding() {
      const node2 = this.startNode();
      this.next();
      node2.argument = this.parseBindingAtom();
      return this.finishNode(node2, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const node2 = this.startNode();
          this.next();
          node2.elements = this.parseBindingList(3, 93, 1);
          return this.finishNode(node2, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, flags) {
      const allowEmpty = flags & 1;
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
        }
        if (allowEmpty && this.match(12)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(21)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
          if (!this.checkCommaAfterRest(closeCharCode)) {
            this.expect(close);
            break;
          }
        } else {
          const decorators = [];
          if (this.match(26) && this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedParameterDecorator, {
              at: this.state.startLoc
            });
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
          elts.push(this.parseAssignableListItem(flags, decorators));
        }
      }
      return elts;
    }
    parseBindingRestProperty(prop) {
      this.next();
      prop.argument = this.parseIdentifier();
      this.checkCommaAfterRest(125);
      return this.finishNode(prop, "RestElement");
    }
    parseBindingProperty() {
      const prop = this.startNode();
      const {
        type,
        startLoc
      } = this.state;
      if (type === 21) {
        return this.parseBindingRestProperty(prop);
      } else if (type === 138) {
        this.expectPlugin("destructuringPrivate", startLoc);
        this.classScope.usePrivateName(this.state.value, startLoc);
        prop.key = this.parsePrivateName();
      } else {
        this.parsePropertyName(prop);
      }
      prop.method = false;
      return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    }
    parseAssignableListItem(flags, decorators) {
      const left2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left2, flags);
      const elt = this.parseMaybeDefault(left2.loc.start, left2);
      if (decorators.length) {
        left2.decorators = decorators;
      }
      return elt;
    }
    parseAssignableListItemTypes(param, flags) {
      return param;
    }
    parseMaybeDefault(startLoc, left2) {
      var _startLoc, _left;
      (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
      left2 = (_left = left2) != null ? _left : this.parseBindingAtom();
      if (!this.eat(29))
        return left2;
      const node2 = this.startNodeAt(startLoc);
      node2.left = left2;
      node2.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node2, "AssignmentPattern");
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return getOwn$1({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, type);
    }
    isOptionalMemberExpression(expression) {
      return expression.type === "OptionalMemberExpression";
    }
    checkLVal(expression, {
      in: ancestor,
      binding = 64,
      checkClashes = false,
      strictModeChanged = false,
      hasParenthesizedAncestor = false
    }) {
      var _expression$extra;
      const type = expression.type;
      if (this.isObjectMethod(expression))
        return;
      const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
      if (isOptionalMemberExpression || type === "MemberExpression") {
        if (isOptionalMemberExpression) {
          this.expectPlugin("optionalChainingAssign", expression.loc.start);
          if (ancestor.type !== "AssignmentExpression") {
            this.raise(Errors.InvalidLhsOptionalChaining, {
              at: expression,
              ancestor
            });
          }
        }
        if (binding !== 64) {
          this.raise(Errors.InvalidPropertyBindingPattern, {
            at: expression
          });
        }
        return;
      }
      if (type === "Identifier") {
        this.checkIdentifier(expression, binding, strictModeChanged);
        const {
          name
        } = expression;
        if (checkClashes) {
          if (checkClashes.has(name)) {
            this.raise(Errors.ParamDupe, {
              at: expression
            });
          } else {
            checkClashes.add(name);
          }
        }
        return;
      }
      const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
      if (validity === true)
        return;
      if (validity === false) {
        const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, {
          at: expression,
          ancestor
        });
        return;
      }
      const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
      const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
        type
      } : ancestor;
      for (const child of [].concat(expression[key])) {
        if (child) {
          this.checkLVal(child, {
            in: nextAncestor,
            binding,
            checkClashes,
            strictModeChanged,
            hasParenthesizedAncestor: isParenthesizedExpression
          });
        }
      }
    }
    checkIdentifier(at, bindingType, strictModeChanged = false) {
      if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
        if (bindingType === 64) {
          this.raise(Errors.StrictEvalArguments, {
            at,
            referenceName: at.name
          });
        } else {
          this.raise(Errors.StrictEvalArgumentsBinding, {
            at,
            bindingName: at.name
          });
        }
      }
      if (bindingType & 8192 && at.name === "let") {
        this.raise(Errors.LetInLexicalBinding, {
          at
        });
      }
      if (!(bindingType & 64)) {
        this.declareNameFromIdentifier(at, bindingType);
      }
    }
    declareNameFromIdentifier(identifier, binding) {
      this.scope.declareName(identifier.name, binding, identifier.loc.start);
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node2.expression, allowPattern);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern)
            break;
        default:
          this.raise(Errors.InvalidRestAssignmentPattern, {
            at: node2
          });
      }
    }
    checkCommaAfterRest(close) {
      if (!this.match(12)) {
        return false;
      }
      this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
        at: this.state.startLoc
      });
      return true;
    }
  }
  var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
  var TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({
      methodName
    }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName
    }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind
    }) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier
    }) => `Accessibility modifier already seen.`,
    DuplicateModifier: ({
      modifier
    }) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({
      token
    }) => `'${token}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers
    }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier
    }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier
    }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({
      orderedModifiers
    }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier
    }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName
    }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
  });
  var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
    constructor(...args) {
      super(...args);
      this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
      this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      });
      this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }
    tsIsIdentifier() {
      return tokenIsIdentifier(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      this.next();
      return this.tsTokenCanFollowModifier();
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
      if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
        return;
      }
      const modifier = this.state.value;
      if (allowedModifiers.indexOf(modifier) !== -1) {
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
          return;
        }
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }
      }
      return;
    }
    tsParseModifiers({
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors.InvalidModifierOnTypeMember
    }, modified) {
      const enforceOrder = (loc, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(TSErrors.InvalidModifiersOrder, {
            at: loc,
            orderedModifiers: [before, after]
          });
        }
      };
      const incompatible = (loc, modifier, mod1, mod2) => {
        if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
          this.raise(TSErrors.IncompatibleModifiers, {
            at: loc,
            modifiers: [mod1, mod2]
          });
        }
      };
      for (;; ) {
        const {
          startLoc
        } = this.state;
        const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
        if (!modifier)
          break;
        if (tsIsAccessModifier(modifier)) {
          if (modified.accessibility) {
            this.raise(TSErrors.DuplicateAccessibilityModifier, {
              at: startLoc,
              modifier
            });
          } else {
            enforceOrder(startLoc, modifier, modifier, "override");
            enforceOrder(startLoc, modifier, modifier, "static");
            enforceOrder(startLoc, modifier, modifier, "readonly");
            modified.accessibility = modifier;
          }
        } else if (tsIsVarianceAnnotations(modifier)) {
          if (modified[modifier]) {
            this.raise(TSErrors.DuplicateModifier, {
              at: startLoc,
              modifier
            });
          }
          modified[modifier] = true;
          enforceOrder(startLoc, modifier, "in", "out");
        } else {
          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(TSErrors.DuplicateModifier, {
              at: startLoc,
              modifier
            });
          } else {
            enforceOrder(startLoc, modifier, "static", "readonly");
            enforceOrder(startLoc, modifier, "static", "override");
            enforceOrder(startLoc, modifier, "override", "readonly");
            enforceOrder(startLoc, modifier, "abstract", "override");
            incompatible(startLoc, modifier, "declare", "override");
            incompatible(startLoc, modifier, "static", "abstract");
          }
          modified[modifier] = true;
        }
        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(errorTemplate, {
            at: startLoc,
            modifier
          });
        }
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(kind, parseElement) {
      const result = [];
      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement());
      }
      return result;
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = [];
      let trailingCommaPos = -1;
      for (;; ) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        trailingCommaPos = -1;
        const element = parseElement();
        if (element == null) {
          return;
        }
        result.push(element);
        if (this.eat(12)) {
          trailingCommaPos = this.state.lastTokStart;
          continue;
        }
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        if (expectSuccess) {
          this.expect(12);
        }
        return;
      }
      if (refTrailingCommaPos) {
        refTrailingCommaPos.value = trailingCommaPos;
      }
      return result;
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(0);
        } else {
          this.expect(47);
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
      if (bracket) {
        this.expect(3);
      } else {
        this.expect(48);
      }
      return result;
    }
    tsParseImportType() {
      const node2 = this.startNode();
      this.expect(83);
      this.expect(10);
      if (!this.match(133)) {
        this.raise(TSErrors.UnsupportedImportTypeArgument, {
          at: this.state.startLoc
        });
      }
      node2.argument = super.parseExprAtom();
      this.expect(11);
      if (this.eat(16)) {
        node2.qualifier = this.tsParseEntityName();
      }
      if (this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node2, "TSImportType");
    }
    tsParseEntityName(allowReservedWords = true) {
      let entity = this.parseIdentifier(allowReservedWords);
      while (this.eat(16)) {
        const node2 = this.startNodeAtNode(entity);
        node2.left = entity;
        node2.right = this.parseIdentifier(allowReservedWords);
        entity = this.finishNode(node2, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference() {
      const node2 = this.startNode();
      node2.typeName = this.tsParseEntityName();
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node2, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs) {
      this.next();
      const node2 = this.startNodeAtNode(lhs);
      node2.parameterName = lhs;
      node2.typeAnnotation = this.tsParseTypeAnnotation(false);
      node2.asserts = false;
      return this.finishNode(node2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "TSThisType");
    }
    tsParseTypeQuery() {
      const node2 = this.startNode();
      this.expect(87);
      if (this.match(83)) {
        node2.exprName = this.tsParseImportType();
      } else {
        node2.exprName = this.tsParseEntityName();
      }
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node2, "TSTypeQuery");
    }
    tsParseTypeParameter(parseModifiers) {
      const node2 = this.startNode();
      parseModifiers(node2);
      node2.name = this.tsParseTypeParameterName();
      node2.constraint = this.tsEatThenParseType(81);
      node2.default = this.tsEatThenParseType(29);
      return this.finishNode(node2, "TSTypeParameter");
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47)) {
        return this.tsParseTypeParameters(parseModifiers);
      }
    }
    tsParseTypeParameters(parseModifiers) {
      const node2 = this.startNode();
      if (this.match(47) || this.match(142)) {
        this.next();
      } else {
        this.unexpected();
      }
      const refTrailingCommaPos = {
        value: -1
      };
      node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
      if (node2.params.length === 0) {
        this.raise(TSErrors.EmptyTypeParameters, {
          at: node2
        });
      }
      if (refTrailingCommaPos.value !== -1) {
        this.addExtra(node2, "trailingComma", refTrailingCommaPos.value);
      }
      return this.finishNode(node2, "TSTypeParameterDeclaration");
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19;
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";
      signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      this.expect(10);
      signature[paramsKey] = this.tsParseBindingListForSignature();
      if (returnTokenRequired) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (this.match(returnToken)) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }
    tsParseBindingListForSignature() {
      const list = super.parseBindingList(11, 41, 2);
      for (const pattern of list) {
        const {
          type
        } = pattern;
        if (type === "AssignmentPattern" || type === "TSParameterProperty") {
          this.raise(TSErrors.UnsupportedSignatureParameterKind, {
            at: pattern,
            type
          });
        }
      }
      return list;
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(12) && !this.isLineTerminator()) {
        this.expect(13);
      }
    }
    tsParseSignatureMember(kind, node2) {
      this.tsFillSignature(14, node2);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node2, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next();
      if (tokenIsIdentifier(this.state.type)) {
        this.next();
        return this.match(14);
      }
      return false;
    }
    tsTryParseIndexSignature(node2) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return;
      }
      this.expect(0);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation();
      this.resetEndLocation(id);
      this.expect(3);
      node2.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        node2.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node2, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(node2, readonly) {
      if (this.eat(17))
        node2.optional = true;
      const nodeAny = node2;
      if (this.match(10) || this.match(47)) {
        if (readonly) {
          this.raise(TSErrors.ReadonlyForMethodSignature, {
            at: node2
          });
        }
        const method = nodeAny;
        if (method.kind && this.match(47)) {
          this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
            at: this.state.curPosition()
          });
        }
        this.tsFillSignature(14, method);
        this.tsParseTypeMemberSemicolon();
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        if (method.kind === "get") {
          if (method[paramsKey].length > 0) {
            this.raise(Errors.BadGetterArity, {
              at: this.state.curPosition()
            });
            if (this.isThisParam(method[paramsKey][0])) {
              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition()
              });
            }
          }
        } else if (method.kind === "set") {
          if (method[paramsKey].length !== 1) {
            this.raise(Errors.BadSetterArity, {
              at: this.state.curPosition()
            });
          } else {
            const firstParameter = method[paramsKey][0];
            if (this.isThisParam(firstParameter)) {
              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition()
              });
            }
            if (firstParameter.type === "Identifier" && firstParameter.optional) {
              this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                at: this.state.curPosition()
              });
            }
            if (firstParameter.type === "RestElement") {
              this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                at: this.state.curPosition()
              });
            }
          }
          if (method[returnTypeKey]) {
            this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
              at: method[returnTypeKey]
            });
          }
        } else {
          method.kind = "method";
        }
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property2 = nodeAny;
        if (readonly)
          property2.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          property2.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property2, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const node2 = this.startNode();
      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
      }
      if (this.match(77)) {
        const id = this.startNode();
        this.next();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
        } else {
          node2.key = this.createIdentifier(id, "new");
          return this.tsParsePropertyOrMethodSignature(node2, false);
        }
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, node2);
      const idx = this.tsTryParseIndexSignature(node2);
      if (idx) {
        return idx;
      }
      super.parsePropertyName(node2);
      if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
        node2.kind = node2.key.name;
        super.parsePropertyName(node2);
      }
      return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
    }
    tsParseTypeLiteral() {
      const node2 = this.startNode();
      node2.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node2, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      this.expect(8);
      return members;
    }
    tsIsStartOfMappedType() {
      this.next();
      if (this.eat(53)) {
        return this.isContextual(122);
      }
      if (this.isContextual(122)) {
        this.next();
      }
      if (!this.match(0)) {
        return false;
      }
      this.next();
      if (!this.tsIsIdentifier()) {
        return false;
      }
      this.next();
      return this.match(58);
    }
    tsParseMappedTypeParameter() {
      const node2 = this.startNode();
      node2.name = this.tsParseTypeParameterName();
      node2.constraint = this.tsExpectThenParseType(58);
      return this.finishNode(node2, "TSTypeParameter");
    }
    tsParseMappedType() {
      const node2 = this.startNode();
      this.expect(5);
      if (this.match(53)) {
        node2.readonly = this.state.value;
        this.next();
        this.expectContextual(122);
      } else if (this.eatContextual(122)) {
        node2.readonly = true;
      }
      this.expect(0);
      node2.typeParameter = this.tsParseMappedTypeParameter();
      node2.nameType = this.eatContextual(93) ? this.tsParseType() : null;
      this.expect(3);
      if (this.match(53)) {
        node2.optional = this.state.value;
        this.next();
        this.expect(17);
      } else if (this.eat(17)) {
        node2.optional = true;
      }
      node2.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(8);
      return this.finishNode(node2, "TSMappedType");
    }
    tsParseTupleType() {
      const node2 = this.startNode();
      node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let seenOptionalElement = false;
      node2.elementTypes.forEach((elementNode) => {
        const {
          type
        } = elementNode;
        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
          this.raise(TSErrors.OptionalTypeBeforeRequired, {
            at: elementNode
          });
        }
        seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
      });
      return this.finishNode(node2, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        startLoc
      } = this.state;
      const rest = this.eat(21);
      let labeled;
      let label;
      let optional;
      let type;
      const isWord = tokenIsKeywordOrIdentifier(this.state.type);
      const chAfterWord = isWord ? this.lookaheadCharCode() : null;
      if (chAfterWord === 58) {
        labeled = true;
        optional = false;
        label = this.parseIdentifier(true);
        this.expect(14);
        type = this.tsParseType();
      } else if (chAfterWord === 63) {
        optional = true;
        const startLoc2 = this.state.startLoc;
        const wordName = this.state.value;
        const typeOrLabel = this.tsParseNonArrayType();
        if (this.lookaheadCharCode() === 58) {
          labeled = true;
          label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
          this.expect(17);
          this.expect(14);
          type = this.tsParseType();
        } else {
          labeled = false;
          type = typeOrLabel;
          this.expect(17);
        }
      } else {
        type = this.tsParseType();
        optional = this.eat(17);
        labeled = this.eat(14);
      }
      if (labeled) {
        let labeledNode;
        if (label) {
          labeledNode = this.startNodeAtNode(label);
          labeledNode.optional = optional;
          labeledNode.label = label;
          labeledNode.elementType = type;
          if (this.eat(17)) {
            labeledNode.optional = true;
            this.raise(TSErrors.TupleOptionalAfterType, {
              at: this.state.lastTokStartLoc
            });
          }
        } else {
          labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          this.raise(TSErrors.InvalidTupleMemberLabel, {
            at: type
          });
          labeledNode.label = type;
          labeledNode.elementType = this.tsParseType();
        }
        type = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type);
        optionalTypeNode.typeAnnotation = type;
        type = this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      if (rest) {
        const restNode = this.startNodeAt(startLoc);
        restNode.typeAnnotation = type;
        type = this.finishNode(restNode, "TSRestType");
      }
      return type;
    }
    tsParseParenthesizedType() {
      const node2 = this.startNode();
      this.expect(10);
      node2.typeAnnotation = this.tsParseType();
      this.expect(11);
      return this.finishNode(node2, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(type, abstract) {
      const node2 = this.startNode();
      if (type === "TSConstructorType") {
        node2.abstract = !!abstract;
        if (abstract)
          this.next();
        this.next();
      }
      this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2));
      return this.finishNode(node2, type);
    }
    tsParseLiteralTypeNode() {
      const node2 = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          node2.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(node2, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const node2 = this.startNode();
      node2.literal = super.parseTemplate(false);
      return this.finishNode(node2, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      if (this.state.inType)
        return this.tsParseType();
      return super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword);
      } else {
        return thisKeyword;
      }
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const node2 = this.startNode();
            const nextToken = this.lookahead();
            if (nextToken.type !== 134 && nextToken.type !== 135) {
              this.unexpected();
            }
            node2.literal = this.parseMaybeUnary();
            return this.finishNode(node2, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type) || type === 88 || type === 84) {
            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, nodeType);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType();
      while (!this.hasPrecedingLineBreak() && this.eat(0)) {
        if (this.match(3)) {
          const node2 = this.startNodeAtNode(type);
          node2.elementType = type;
          this.expect(3);
          type = this.finishNode(node2, "TSArrayType");
        } else {
          const node2 = this.startNodeAtNode(type);
          node2.objectType = type;
          node2.indexType = this.tsParseType();
          this.expect(3);
          type = this.finishNode(node2, "TSIndexedAccessType");
        }
      }
      return type;
    }
    tsParseTypeOperator() {
      const node2 = this.startNode();
      const operator = this.state.value;
      this.next();
      node2.operator = operator;
      node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
      if (operator === "readonly") {
        this.tsCheckTypeAnnotationForReadOnly(node2);
      }
      return this.finishNode(node2, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(node2) {
      switch (node2.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(TSErrors.UnexpectedReadonly, {
            at: node2
          });
      }
    }
    tsParseInferType() {
      const node2 = this.startNode();
      this.expectContextual(115);
      const typeParameter = this.startNode();
      typeParameter.name = this.tsParseTypeParameterName();
      typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
      node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node2, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
          return constraint;
        }
      }
    }
    tsParseTypeOperatorOrHigher() {
      const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
      return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node2 = this.startNode();
      const hasLeadingOperator = this.eat(operator);
      const types2 = [];
      do {
        types2.push(parseConstituentType());
      } while (this.eat(operator));
      if (types2.length === 1 && !hasLeadingOperator) {
        return types2[0];
      }
      node2.types = types2;
      return this.finishNode(node2, kind);
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      if (this.match(47)) {
        return true;
      }
      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier(this.state.type) || this.match(78)) {
        this.next();
        return true;
      }
      if (this.match(5)) {
        const {
          errors: errors2
        } = this.state;
        const previousErrorCount = errors2.length;
        try {
          this.parseObjectLike(8, true);
          return errors2.length === previousErrorCount;
        } catch (_unused) {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: errors2
        } = this.state;
        const previousErrorCount = errors2.length;
        try {
          super.parseBindingList(3, 93, 1);
          return errors2.length === previousErrorCount;
        } catch (_unused2) {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      this.next();
      if (this.match(11) || this.match(21)) {
        return true;
      }
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
          return true;
        }
        if (this.match(11)) {
          this.next();
          if (this.match(19)) {
            return true;
          }
        }
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node2 = this.startNode();
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
          if (thisTypePredicate.type === "TSThisType") {
            node2.parameterName = thisTypePredicate;
            node2.asserts = true;
            node2.typeAnnotation = null;
            thisTypePredicate = this.finishNode(node2, "TSTypePredicate");
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node2);
            thisTypePredicate.asserts = true;
          }
          t.typeAnnotation = thisTypePredicate;
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t);
          }
          node2.parameterName = this.parseIdentifier();
          node2.asserts = asserts;
          node2.typeAnnotation = null;
          t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const type = this.tsParseTypeAnnotation(false);
        node2.parameterName = typePredicateVariable;
        node2.typeAnnotation = type;
        node2.asserts = asserts;
        t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) {
        return this.tsParseTypeOrTypePredicateAnnotation(14);
      }
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) {
        return this.tsParseTypeAnnotation();
      }
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109) {
        return false;
      }
      const containsEsc = this.state.containsEsc;
      this.next();
      if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
        return false;
      }
      if (containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, {
          at: this.state.lastTokStartLoc,
          reservedWord: "asserts"
        });
      }
      return true;
    }
    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
      this.tsInType(() => {
        if (eatColon)
          this.expect(14);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      assert(this.state.inType);
      const type = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
        return type;
      }
      const node2 = this.startNodeAtNode(type);
      node2.checkType = type;
      node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
      this.expect(17);
      node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
      this.expect(14);
      node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
      return this.finishNode(node2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }
      if (this.match(77)) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
      }
      return this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
        this.raise(TSErrors.ReservedTypeAssertion, {
          at: this.state.startLoc
        });
      }
      const node2 = this.startNode();
      node2.typeAnnotation = this.tsInType(() => {
        this.next();
        return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
      });
      this.expect(48);
      node2.expression = this.parseMaybeUnary();
      return this.finishNode(node2, "TSTypeAssertion");
    }
    tsParseHeritageClause(token) {
      const originalStartLoc = this.state.startLoc;
      const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const node2 = this.startNode();
        node2.expression = this.tsParseEntityName();
        if (this.match(47)) {
          node2.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node2, "TSExpressionWithTypeArguments");
      });
      if (!delimitedList.length) {
        this.raise(TSErrors.EmptyHeritageClauseType, {
          at: originalStartLoc,
          token
        });
      }
      return delimitedList;
    }
    tsParseInterfaceDeclaration(node2, properties = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(129);
      if (properties.declare)
        node2.declare = true;
      if (tokenIsIdentifier(this.state.type)) {
        node2.id = this.parseIdentifier();
        this.checkIdentifier(node2.id, 130);
      } else {
        node2.id = null;
        this.raise(TSErrors.MissingInterfaceName, {
          at: this.state.startLoc
        });
      }
      node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (this.eat(81)) {
        node2.extends = this.tsParseHeritageClause("extends");
      }
      const body = this.startNode();
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
      node2.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node2, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(node2) {
      node2.id = this.parseIdentifier();
      this.checkIdentifier(node2.id, 2);
      node2.typeAnnotation = this.tsInType(() => {
        node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
        this.expect(29);
        if (this.isContextual(114) && this.lookahead().type !== 16) {
          const node3 = this.startNode();
          this.next();
          return this.finishNode(node3, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      });
      this.semicolon();
      return this.finishNode(node2, "TSTypeAliasDeclaration");
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];
      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsEatThenParseType(token) {
      if (this.match(token)) {
        return this.tsNextThenParseType();
      }
    }
    tsExpectThenParseType(token) {
      return this.tsInType(() => {
        this.expect(token);
        return this.tsParseType();
      });
    }
    tsNextThenParseType() {
      return this.tsInType(() => {
        this.next();
        return this.tsParseType();
      });
    }
    tsParseEnumMember() {
      const node2 = this.startNode();
      node2.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
      if (this.eat(29)) {
        node2.initializer = super.parseMaybeAssignAllowIn();
      }
      return this.finishNode(node2, "TSEnumMember");
    }
    tsParseEnumDeclaration(node2, properties = {}) {
      if (properties.const)
        node2.const = true;
      if (properties.declare)
        node2.declare = true;
      this.expectContextual(126);
      node2.id = this.parseIdentifier();
      this.checkIdentifier(node2.id, node2.const ? 8971 : 8459);
      this.expect(5);
      node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
      this.expect(8);
      return this.finishNode(node2, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const node2 = this.startNode();
      this.scope.enter(0);
      this.expect(5);
      super.parseBlockOrModuleBlockBody(node2.body = [], undefined, true, 8);
      this.scope.exit();
      return this.finishNode(node2, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(node2, nested = false) {
      node2.id = this.parseIdentifier();
      if (!nested) {
        this.checkIdentifier(node2.id, 1024);
      }
      if (this.eat(16)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, true);
        node2.body = inner;
      } else {
        this.scope.enter(256);
        this.prodParam.enter(0);
        node2.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      }
      return this.finishNode(node2, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(node2) {
      if (this.isContextual(112)) {
        node2.global = true;
        node2.id = this.parseIdentifier();
      } else if (this.match(133)) {
        node2.id = super.parseStringLiteral(this.state.value);
      } else {
        this.unexpected();
      }
      if (this.match(5)) {
        this.scope.enter(256);
        this.prodParam.enter(0);
        node2.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, isExport) {
      node2.isExport = isExport || false;
      node2.id = maybeDefaultIdentifier || this.parseIdentifier();
      this.checkIdentifier(node2.id, 4096);
      this.expect(29);
      const moduleReference = this.tsParseModuleReference();
      if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
        this.raise(TSErrors.ImportAliasHasImportType, {
          at: moduleReference
        });
      }
      node2.moduleReference = moduleReference;
      this.semicolon();
      return this.finishNode(node2, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const node2 = this.startNode();
      this.expectContextual(119);
      this.expect(10);
      if (!this.match(133)) {
        this.unexpected();
      }
      node2.expression = super.parseExprAtom();
      this.expect(11);
      this.sawUnambiguousESM = true;
      return this.finishNode(node2, "TSExternalModuleReference");
    }
    tsLookAhead(f) {
      const state = this.state.clone();
      const res = f();
      this.state = state;
      return res;
    }
    tsTryParseAndCatch(f) {
      const result = this.tryParse((abort) => f() || abort());
      if (result.aborted || !result.node)
        return;
      if (result.error)
        this.state = result.failState;
      return result.node;
    }
    tsTryParse(f) {
      const state = this.state.clone();
      const result = f();
      if (result !== undefined && result !== false) {
        return result;
      }
      this.state = state;
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return;
      }
      let startType = this.state.type;
      let kind;
      if (this.isContextual(100)) {
        startType = 74;
        kind = "let";
      }
      return this.tsInAmbientContext(() => {
        switch (startType) {
          case 68:
            nany.declare = true;
            return super.parseFunctionStatement(nany, false, false);
          case 80:
            nany.declare = true;
            return this.parseClass(nany, true, false);
          case 126:
            return this.tsParseEnumDeclaration(nany, {
              declare: true
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          case 75:
          case 74:
            if (!this.match(75) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.state.value, true);
            }
            this.expect(75);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          case 129: {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result)
              return result;
          }
          default:
            if (tokenIsIdentifier(startType)) {
              return this.tsParseDeclaration(nany, this.state.value, true, null);
            }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    }
    tsParseExpressionStatement(node2, expr, decorators) {
      switch (expr.name) {
        case "declare": {
          const declaration = this.tsTryParseDeclare(node2);
          if (declaration) {
            declaration.declare = true;
          }
          return declaration;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256);
            this.prodParam.enter(0);
            const mod = node2;
            mod.global = true;
            mod.id = expr;
            mod.body = this.tsParseModuleBlock();
            this.scope.exit();
            this.prodParam.exit();
            return this.finishNode(mod, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(node2, expr.name, false, decorators);
      }
    }
    tsParseDeclaration(node2, value2, next, decorators) {
      switch (value2) {
        case "abstract":
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
            return this.tsParseAbstractDeclaration(node2, decorators);
          }
          break;
        case "module":
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(133)) {
              return this.tsParseAmbientExternalModuleDeclaration(node2);
            } else if (tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node2);
            }
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseModuleOrNamespaceDeclaration(node2);
          }
          break;
        case "type":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseTypeAliasDeclaration(node2);
          }
          break;
      }
    }
    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak())
          return false;
        this.next();
        return true;
      }
      return !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(startLoc) {
      if (!this.match(47))
        return;
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const res = this.tsTryParseAndCatch(() => {
        const node2 = this.startNodeAt(startLoc);
        node2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        super.parseFunctionParams(node2);
        node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(19);
        return node2;
      });
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      if (!res)
        return;
      return super.parseArrowExpression(res, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() !== 47)
        return;
      return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const node2 = this.startNode();
      node2.params = this.tsInType(() => this.tsInNoContext(() => {
        this.expect(47);
        return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      }));
      if (node2.params.length === 0) {
        this.raise(TSErrors.EmptyTypeArguments, {
          at: node2
        });
      } else if (!this.state.inType && this.curContext() === types.brace) {
        this.reScan_lt_gt();
      }
      this.expect(48);
      return this.finishNode(node2, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart(this.state.type);
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart())
        return false;
      return super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(flags, decorators) {
      const startLoc = this.state.startLoc;
      const modified = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, modified);
      const accessibility = modified.accessibility;
      const override = modified.override;
      const readonly = modified.readonly;
      if (!(flags & 4) && (accessibility || readonly || override)) {
        this.raise(TSErrors.UnexpectedParameterModifier, {
          at: startLoc
        });
      }
      const left2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left2, flags);
      const elt = this.parseMaybeDefault(left2.loc.start, left2);
      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startLoc);
        if (decorators.length) {
          pp.decorators = decorators;
        }
        if (accessibility)
          pp.accessibility = accessibility;
        if (readonly)
          pp.readonly = readonly;
        if (override)
          pp.override = override;
        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          this.raise(TSErrors.UnsupportedParameterPropertyKind, {
            at: pp
          });
        }
        pp.parameter = elt;
        return this.finishNode(pp, "TSParameterProperty");
      }
      if (decorators.length) {
        left2.decorators = decorators;
      }
      return elt;
    }
    isSimpleParameter(node2) {
      return node2.type === "TSParameterProperty" && super.isSimpleParameter(node2.parameter) || super.isSimpleParameter(node2);
    }
    tsDisallowOptionalPattern(node2) {
      for (const param of node2.params) {
        if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
          this.raise(TSErrors.PatternIsOptional, {
            at: param
          });
        }
      }
    }
    setArrowFunctionParameters(node2, params, trailingCommaLoc) {
      super.setArrowFunctionParameters(node2, params, trailingCommaLoc);
      this.tsDisallowOptionalPattern(node2);
    }
    parseFunctionBodyAndFinish(node2, type, isMethod = false) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
      }
      const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
      if (bodilessType && !this.match(5) && this.isLineTerminator()) {
        return this.finishNode(node2, bodilessType);
      }
      if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
        this.raise(TSErrors.DeclareFunctionHasImplementation, {
          at: node2
        });
        if (node2.declare) {
          return super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod);
        }
      }
      this.tsDisallowOptionalPattern(node2);
      return super.parseFunctionBodyAndFinish(node2, type, isMethod);
    }
    registerFunctionStatementId(node2) {
      if (!node2.body && node2.id) {
        this.checkIdentifier(node2.id, 1024);
      } else {
        super.registerFunctionStatementId(node2);
      }
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node2) => {
        if ((node2 == null ? undefined : node2.type) === "TSTypeCastExpression") {
          this.raise(TSErrors.UnexpectedTypeAnnotation, {
            at: node2.typeAnnotation
          });
        }
      });
    }
    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList);
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      if (node2.type === "ArrayExpression") {
        this.tsCheckForInvalidTypeCasts(node2.elements);
      }
      return node2;
    }
    parseSubscript(base, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false;
        this.next();
        const nonNullExpression = this.startNodeAt(startLoc);
        nonNullExpression.expression = base;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      let isOptionalCall = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls) {
          state.stop = true;
          return base;
        }
        state.optionalChainMember = isOptionalCall = true;
        this.next();
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc;
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
            if (asyncArrowFn) {
              return asyncArrowFn;
            }
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (!typeArguments)
            return;
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition();
            return;
          }
          if (tokenIsTemplate(this.state.type)) {
            const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
            result2.typeParameters = typeArguments;
            return result2;
          }
          if (!noCalls && this.eat(10)) {
            const node3 = this.startNodeAt(startLoc);
            node3.callee = base;
            node3.arguments = this.parseCallExpressionArguments(11, false);
            this.tsCheckForInvalidTypeCasts(node3.arguments);
            node3.typeParameters = typeArguments;
            if (state.optionalChainMember) {
              node3.optional = isOptionalCall;
            }
            return this.finishCallExpression(node3, state.optionalChainMember);
          }
          const tokenType = this.state.type;
          if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
            return;
          }
          const node2 = this.startNodeAt(startLoc);
          node2.expression = base;
          node2.typeParameters = typeArguments;
          return this.finishNode(node2, "TSInstantiationExpression");
        });
        if (missingParenErrorLoc) {
          this.unexpected(missingParenErrorLoc, 10);
        }
        if (result) {
          if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
              at: this.state.startLoc
            });
          }
          return result;
        }
      }
      return super.parseSubscript(base, startLoc, noCalls, state);
    }
    parseNewCallee(node2) {
      var _callee$extra;
      super.parseNewCallee(node2);
      const {
        callee
      } = node2;
      if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
        node2.typeParameters = callee.typeParameters;
        node2.callee = callee.expression;
      }
    }
    parseExprOp(left2, leftStartLoc, minPrec) {
      let isSatisfies;
      if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
        const node2 = this.startNodeAt(leftStartLoc);
        node2.expression = left2;
        node2.typeAnnotation = this.tsInType(() => {
          this.next();
          if (this.match(75)) {
            if (isSatisfies) {
              this.raise(Errors.UnexpectedKeyword, {
                at: this.state.startLoc,
                keyword: "const"
              });
            }
            return this.tsParseTypeReference();
          }
          return this.tsParseType();
        });
        this.finishNode(node2, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
        this.reScan_lt_gt();
        return this.parseExprOp(node2, leftStartLoc, minPrec);
      }
      return super.parseExprOp(left2, leftStartLoc, minPrec);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (!this.state.isAmbientContext) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
      }
    }
    checkImportReflection(node2) {
      super.checkImportReflection(node2);
      if (node2.module && node2.importKind !== "value") {
        this.raise(TSErrors.ImportReflectionHasImportType, {
          at: node2.specifiers[0].loc.start
        });
      }
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport))
        return true;
      if (this.isContextual(130)) {
        const ch = this.lookaheadCharCode();
        return isExport ? ch === 123 || ch === 42 : ch !== 61;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      super.applyImportPhase(node2, isExport, phase, loc);
      if (isExport) {
        node2.exportKind = phase === "type" ? "type" : "value";
      } else {
        node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
    }
    parseImport(node2) {
      if (this.match(133)) {
        node2.importKind = "value";
        return super.parseImport(node2);
      }
      let importNode;
      if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
        node2.importKind = "value";
        return this.tsParseImportEqualsDeclaration(node2);
      } else if (this.isContextual(130)) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
        if (this.lookaheadCharCode() === 61) {
          return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier);
        } else {
          importNode = super.parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier);
        }
      } else {
        importNode = super.parseImport(node2);
      }
      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
          at: importNode
        });
      }
      return importNode;
    }
    parseExport(node2, decorators) {
      if (this.match(83)) {
        this.next();
        let maybeDefaultIdentifier = null;
        if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
          maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
        } else {
          node2.importKind = "value";
        }
        return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, true);
      } else if (this.eat(29)) {
        const assign = node2;
        assign.expression = super.parseExpression();
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const decl = node2;
        this.expectContextual(128);
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        return super.parseExport(node2, decorators);
      }
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next();
        cls.abstract = true;
        return this.parseClass(cls, true, true);
      }
      if (this.match(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result)
          return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(node2, kind, allowMissingInitializer = false) {
      const {
        isAmbientContext
      } = this.state;
      const declaration = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext);
      if (!isAmbientContext)
        return declaration;
      for (const {
        id,
        init
      } of declaration.declarations) {
        if (!init)
          continue;
        if (kind !== "const" || !!id.typeAnnotation) {
          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
            at: init
          });
        } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
          this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
            at: init
          });
        }
      }
      return declaration;
    }
    parseStatementContent(flags, decorators) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const node2 = this.startNode();
        this.expect(75);
        return this.tsParseEnumDeclaration(node2, {
          const: true
        });
      }
      if (this.isContextual(126)) {
        return this.tsParseEnumDeclaration(this.startNode());
      }
      if (this.isContextual(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result)
          return result;
      }
      return super.parseStatementContent(flags, decorators);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => {
        if (tsIsAccessModifier(modifier)) {
          return member.accessibility === modifier;
        }
        return !!member[modifier];
      });
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(classBody, member, state) {
      const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: modifiers,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }, member);
      const callParseClassMemberWithIsStatic = () => {
        if (this.tsIsStartOfStaticBlocks()) {
          this.next();
          this.next();
          if (this.tsHasSomeModifiers(member, modifiers)) {
            this.raise(TSErrors.StaticBlockCannotHaveModifier, {
              at: this.state.curPosition()
            });
          }
          super.parseClassStaticBlock(classBody, member);
        } else {
          this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
        }
      };
      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic);
      } else {
        callParseClassMemberWithIsStatic();
      }
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);
      if (idx) {
        classBody.body.push(idx);
        if (member.abstract) {
          this.raise(TSErrors.IndexSignatureHasAbstract, {
            at: member
          });
        }
        if (member.accessibility) {
          this.raise(TSErrors.IndexSignatureHasAccessibility, {
            at: member,
            modifier: member.accessibility
          });
        }
        if (member.declare) {
          this.raise(TSErrors.IndexSignatureHasDeclare, {
            at: member
          });
        }
        if (member.override) {
          this.raise(TSErrors.IndexSignatureHasOverride, {
            at: member
          });
        }
        return;
      }
      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
          at: member
        });
      }
      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(TSErrors.OverrideNotInSubClass, {
            at: member
          });
        }
      }
      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(17);
      if (optional)
        methodOrProp.optional = true;
      if (methodOrProp.readonly && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasReadonly, {
          at: methodOrProp
        });
      }
      if (methodOrProp.declare && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasDeclare, {
          at: methodOrProp
        });
      }
    }
    parseExpressionStatement(node2, expr, decorators) {
      const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr, decorators) : undefined;
      return decl || super.parseExpressionStatement(node2, expr, decorators);
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart())
        return true;
      return super.shouldParseExportDeclaration();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(17)) {
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      }
      const result = this.tryParse(() => super.parseConditional(expr, startLoc));
      if (!result.node) {
        if (result.error) {
          super.setOptionalParametersError(refExpressionErrors, result.error);
        }
        return expr;
      }
      if (result.error)
        this.state = result.failState;
      return result.node;
    }
    parseParenItem(node2, startLoc) {
      node2 = super.parseParenItem(node2, startLoc);
      if (this.eat(17)) {
        node2.optional = true;
        this.resetEndLocation(node2);
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        typeCastNode.expression = node2;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node2;
    }
    parseExportDeclaration(node2) {
      if (!this.state.isAmbientContext && this.isContextual(125)) {
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node2));
      }
      const startLoc = this.state.startLoc;
      const isDeclare = this.eatContextual(125);
      if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
          at: this.state.startLoc
        });
      }
      const isIdentifier = tokenIsIdentifier(this.state.type);
      const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node2);
      if (!declaration)
        return null;
      if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
        node2.exportKind = "type";
      }
      if (isDeclare) {
        this.resetStartLocation(declaration, startLoc);
        declaration.declare = true;
      }
      return declaration;
    }
    parseClassId(node2, isStatement, optionalId, bindingType) {
      if ((!isStatement || optionalId) && this.isContextual(113)) {
        return;
      }
      super.parseClassId(node2, isStatement, optionalId, node2.declare ? 1024 : 8331);
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (typeParameters)
        node2.typeParameters = typeParameters;
    }
    parseClassPropertyAnnotation(node2) {
      if (!node2.optional) {
        if (this.eat(35)) {
          node2.definite = true;
        } else if (this.eat(17)) {
          node2.optional = true;
        }
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        node2.typeAnnotation = type;
    }
    parseClassProperty(node2) {
      this.parseClassPropertyAnnotation(node2);
      if (this.state.isAmbientContext && !(node2.readonly && !node2.typeAnnotation) && this.match(29)) {
        this.raise(TSErrors.DeclareClassFieldHasInitializer, {
          at: this.state.startLoc
        });
      }
      if (node2.abstract && this.match(29)) {
        const {
          key
        } = node2;
        this.raise(TSErrors.AbstractPropertyHasInitializer, {
          at: this.state.startLoc,
          propertyName: key.type === "Identifier" && !node2.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
        });
      }
      return super.parseClassProperty(node2);
    }
    parseClassPrivateProperty(node2) {
      if (node2.abstract) {
        this.raise(TSErrors.PrivateElementHasAbstract, {
          at: node2
        });
      }
      if (node2.accessibility) {
        this.raise(TSErrors.PrivateElementHasAccessibility, {
          at: node2,
          modifier: node2.accessibility
        });
      }
      this.parseClassPropertyAnnotation(node2);
      return super.parseClassPrivateProperty(node2);
    }
    parseClassAccessorProperty(node2) {
      this.parseClassPropertyAnnotation(node2);
      if (node2.optional) {
        this.raise(TSErrors.AccessorCannotBeOptional, {
          at: node2
        });
      }
      return super.parseClassAccessorProperty(node2);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters && isConstructor) {
        this.raise(TSErrors.ConstructorHasTypeParameters, {
          at: typeParameters
        });
      }
      const {
        declare = false,
        kind
      } = method;
      if (declare && (kind === "get" || kind === "set")) {
        this.raise(TSErrors.DeclareAccessor, {
          at: method,
          kind
        });
      }
      if (typeParameters)
        method.typeParameters = typeParameters;
      super.pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper);
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync2) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters)
        method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync2);
    }
    declareClassPrivateMethodInScope(node2, kind) {
      if (node2.type === "TSDeclareMethod")
        return;
      if (node2.type === "MethodDefinition" && !node2.value.body)
        return;
      super.declareClassPrivateMethodInScope(node2, kind);
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2);
      if (node2.superClass && (this.match(47) || this.match(51))) {
        node2.superTypeParameters = this.tsParseTypeArgumentsInExpression();
      }
      if (this.eatContextual(113)) {
        node2.implements = this.tsParseHeritageClause("implements");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters)
        prop.typeParameters = typeParameters;
      return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors);
    }
    parseFunctionParams(node2, isConstructor) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters)
        node2.typeParameters = typeParameters;
      super.parseFunctionParams(node2, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
        decl.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        decl.id.typeAnnotation = type;
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node2, call) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeAnnotation();
      }
      return super.parseAsyncArrowFromCallExpression(node2, call);
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
      let state;
      let jsx2;
      let typeCast;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        state = this.state.clone();
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx2.error)
          return jsx2.node;
        const {
          context
        } = this.state;
        const currentContext = context[context.length - 1];
        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
          context.pop();
        }
      }
      if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      if (!state || state === this.state)
        state = this.state.clone();
      let typeParameters;
      const arrow = this.tryParse((abort) => {
        var _expr$extra, _typeParameters;
        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          abort();
        }
        if (((_typeParameters = typeParameters) == null ? undefined : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters);
        }
        expr.typeParameters = typeParameters;
        return expr;
      }, state);
      if (!arrow.error && !arrow.aborted) {
        if (typeParameters)
          this.reportReservedArrowTypeParam(typeParameters);
        return arrow.node;
      }
      if (!jsx2) {
        assert(!this.hasPlugin("jsx"));
        typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!typeCast.error)
          return typeCast.node;
      }
      if ((_jsx2 = jsx2) != null && _jsx2.node) {
        this.state = jsx2.failState;
        return jsx2.node;
      }
      if (arrow.node) {
        this.state = arrow.failState;
        if (typeParameters)
          this.reportReservedArrowTypeParam(typeParameters);
        return arrow.node;
      }
      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState;
        return typeCast.node;
      }
      throw ((_jsx3 = jsx2) == null ? undefined : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? undefined : _typeCast2.error);
    }
    reportReservedArrowTypeParam(node2) {
      var _node$extra;
      if (node2.params.length === 1 && !node2.params[0].constraint && !((_node$extra = node2.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
        this.raise(TSErrors.ReservedArrowTypeParam, {
          at: node2
        });
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      if (!this.hasPlugin("jsx") && this.match(47)) {
        return this.tsParseTypeAssertion();
      }
      return super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          if (this.canInsertSemicolon() || !this.match(19))
            abort();
          return returnType;
        });
        if (result.aborted)
          return;
        if (!result.thrown) {
          if (result.error)
            this.state = result.failState;
          node2.returnType = result.node;
        }
      }
      return super.parseArrow(node2);
    }
    parseAssignableListItemTypes(param, flags) {
      if (!(flags & 2))
        return param;
      if (this.eat(17)) {
        param.optional = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        param.typeAnnotation = type;
      this.resetEndLocation(param);
      return param;
    }
    isAssignable(node2, isBinding) {
      switch (node2.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(node2.expression, isBinding);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(node2, isBinding);
      }
    }
    toAssignable(node2, isLHS = false) {
      switch (node2.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(node2, isLHS);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          if (isLHS) {
            this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
              at: node2
            });
          } else {
            this.raise(TSErrors.UnexpectedTypeCastInParameter, {
              at: node2
            });
          }
          this.toAssignable(node2.expression, isLHS);
          break;
        case "AssignmentExpression":
          if (!isLHS && node2.left.type === "TSTypeCastExpression") {
            node2.left = this.typeCastToParameter(node2.left);
          }
        default:
          super.toAssignable(node2, isLHS);
      }
    }
    toAssignableParenthesizedExpression(node2, isLHS) {
      switch (node2.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(node2.expression, isLHS);
          break;
        default:
          super.toAssignable(node2, isLHS);
      }
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(node2.expression, false);
          break;
        default:
          super.checkToRestConversion(node2, allowPattern);
      }
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return getOwn({
        TSTypeCastExpression: true,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
        TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
        TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
      }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    }
    parseBindingAtom() {
      if (this.state.type === 78) {
        return this.parseIdentifier(true);
      }
      return super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          call.typeParameters = typeArguments;
          return call;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(expr);
    }
    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
        this.next();
        return false;
      }
      return super.checkCommaAfterRest(close);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(startLoc, left2) {
      const node2 = super.parseMaybeDefault(startLoc, left2);
      if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
        this.raise(TSErrors.TypeAnnotationAfterAssign, {
          at: node2.typeAnnotation
        });
      }
      return node2;
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (code2 === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(code2);
    }
    reScan_lt_gt() {
      const {
        type
      } = this.state;
      if (type === 47) {
        this.state.pos -= 1;
        this.readToken_lt();
      } else if (type === 48) {
        this.state.pos -= 1;
        this.readToken_gt();
      }
    }
    reScan_lt() {
      const {
        type
      } = this.state;
      if (type === 51) {
        this.state.pos -= 2;
        this.finishOp(47, 1);
        return 47;
      }
      return type;
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0;i < exprList.length; i++) {
        const expr = exprList[i];
        if ((expr == null ? undefined : expr.type) === "TSTypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation;
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
      return node2.expression;
    }
    shouldParseArrow(params) {
      if (this.match(14)) {
        return params.every((expr) => this.isAssignable(expr, true));
      }
      return super.shouldParseArrow(params);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(node2) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        if (typeArguments)
          node2.typeParameters = typeArguments;
      }
      return super.jsxParseOpeningElementAfterName(node2);
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const firstParam = params[0];
      const hasContextParam = firstParam && this.isThisParam(firstParam);
      return hasContextParam ? baseCount + 1 : baseCount;
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam();
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        param.typeAnnotation = type;
        this.resetEndLocation(param);
      }
      return param;
    }
    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext;
      }
    }
    parseClass(node2, isStatement, optionalId) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node2.abstract;
      try {
        return super.parseClass(node2, isStatement, optionalId);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }
    tsParseAbstractDeclaration(node2, decorators) {
      if (this.match(80)) {
        node2.abstract = true;
        return this.maybeTakeDecorators(decorators, this.parseClass(node2, true, false));
      } else if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) {
          node2.abstract = true;
          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
            at: node2
          });
          return this.tsParseInterfaceDeclaration(node2);
        }
      } else {
        this.unexpected(null, 80);
      }
    }
    parseMethod(node2, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope) {
      const method = super.parseMethod(node2, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope);
      if (method.abstract) {
        const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
        if (hasBody) {
          const {
            key
          } = method;
          this.raise(TSErrors.AbstractMethodHasImplementation, {
            at: method,
            methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
          });
        }
      }
      return method;
    }
    tsParseTypeParameterName() {
      const typeName = this.parseIdentifier();
      return typeName.name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.parse();
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.getExpression();
    }
    parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
      if (!isString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport);
        return this.finishNode(node2, "ExportSpecifier");
      }
      node2.exportKind = "value";
      return super.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly);
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (!importedIsString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
        return this.finishNode(specifier, "ImportSpecifier");
      }
      specifier.importKind = "value";
      return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
    }
    parseTypeOnlyImportExportSpecifier(node2, isImport, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport ? "imported" : "local";
      const rightOfAsKey = isImport ? "local" : "exported";
      let leftOfAs = node2[leftOfAsKey];
      let rightOfAs;
      let hasTypeSpecifier = false;
      let canParseAsKeyword = true;
      const loc = leftOfAs.loc.start;
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier();
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier();
          if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            canParseAsKeyword = false;
          } else {
            rightOfAs = secondAs;
            canParseAsKeyword = false;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          canParseAsKeyword = false;
          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        } else {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        hasTypeSpecifier = true;
        if (isImport) {
          leftOfAs = this.parseIdentifier(true);
          if (!this.isContextual(93)) {
            this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
          }
        } else {
          leftOfAs = this.parseModuleExportName();
        }
      }
      if (hasTypeSpecifier && isInTypeOnlyImportExport) {
        this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
          at: loc
        });
      }
      node2[leftOfAsKey] = leftOfAs;
      node2[rightOfAsKey] = rightOfAs;
      const kindKey = isImport ? "importKind" : "exportKind";
      node2[kindKey] = hasTypeSpecifier ? "type" : "value";
      if (canParseAsKeyword && this.eatContextual(93)) {
        node2[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
      }
      if (!node2[rightOfAsKey]) {
        node2[rightOfAsKey] = cloneIdentifier(node2[leftOfAsKey]);
      }
      if (isImport) {
        this.checkIdentifier(node2[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
      }
    }
  };
  var PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(144)) {
        const node2 = this.startNode();
        this.next();
        this.assertNoSpace();
        node2.name = super.parseIdentifier(true);
        this.assertNoSpace();
        this.expect(144);
        return this.finishPlaceholder(node2, expectedNode);
      }
    }
    finishPlaceholder(node2, expectedNode) {
      const isFinished = !!(node2.expectedNode && node2.type === "Placeholder");
      node2.expectedNode = expectedNode;
      return isFinished ? node2 : this.finishNode(node2, "Placeholder");
    }
    getTokenFromCode(code2) {
      if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        this.finishOp(144, 2);
      } else {
        super.getTokenFromCode(code2);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
    }
    parseIdentifier(liberal) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word !== undefined) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
      }
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(type, isParenthesized, binding) {
      return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
    }
    toAssignable(node2, isLHS) {
      if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
        node2.expectedNode = "Pattern";
      } else {
        super.toAssignable(node2, isLHS);
      }
    }
    chStartsBindingIdentifier(ch, pos) {
      if (super.chStartsBindingIdentifier(ch, pos)) {
        return true;
      }
      const nextToken = this.lookahead();
      if (nextToken.type === 144) {
        return true;
      }
      return false;
    }
    verifyBreakContinue(node2, isBreak) {
      if (node2.label && node2.label.type === "Placeholder")
        return;
      super.verifyBreakContinue(node2, isBreak);
    }
    parseExpressionStatement(node2, expr) {
      var _expr$extra;
      if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
        return super.parseExpressionStatement(node2, expr);
      }
      if (this.match(14)) {
        const stmt = node2;
        stmt.label = this.finishPlaceholder(expr, "Identifier");
        this.next();
        stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
        return this.finishNode(stmt, "LabeledStatement");
      }
      this.semicolon();
      node2.name = expr.name;
      return this.finishPlaceholder(node2, "Statement");
    }
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    parseFunctionId(requireId) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
    }
    parseClass(node2, isStatement, optionalId) {
      const type = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const oldStrict = this.state.strict;
      const placeholder = this.parsePlaceholder("Identifier");
      if (placeholder) {
        if (this.match(81) || this.match(144) || this.match(5)) {
          node2.id = placeholder;
        } else if (optionalId || !isStatement) {
          node2.id = null;
          node2.body = this.finishPlaceholder(placeholder, "ClassBody");
          return this.finishNode(node2, type);
        } else {
          throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
            at: this.state.startLoc
          });
        }
      } else {
        this.parseClassId(node2, isStatement, optionalId);
      }
      super.parseClassSuper(node2);
      node2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node2.superClass, oldStrict);
      return this.finishNode(node2, type);
    }
    parseExport(node2, decorators) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder)
        return super.parseExport(node2, decorators);
      if (!this.isContextual(98) && !this.match(12)) {
        node2.specifiers = [];
        node2.source = null;
        node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
        return this.finishNode(node2, "ExportNamedDeclaration");
      }
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = placeholder;
      node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return super.parseExport(node2, decorators);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart();
        if (this.isUnparsedContextual(next, "from")) {
          if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
            return true;
          }
        }
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
      var _specifiers;
      if ((_specifiers = node2.specifiers) != null && _specifiers.length) {
        return true;
      }
      return super.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
    }
    checkExport(node2) {
      const {
        specifiers
      } = node2;
      if (specifiers != null && specifiers.length) {
        node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder");
      }
      super.checkExport(node2);
      node2.specifiers = specifiers;
    }
    parseImport(node2) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder)
        return super.parseImport(node2);
      node2.specifiers = [];
      if (!this.isContextual(98) && !this.match(12)) {
        node2.source = this.finishPlaceholder(placeholder, "StringLiteral");
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      }
      const specifier = this.startNodeAtNode(placeholder);
      specifier.local = placeholder;
      node2.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
      if (this.eat(12)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node2);
        if (!hasStarImport)
          this.parseNamedImportSpecifiers(node2);
      }
      this.expectContextual(98);
      node2.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      if (this.state.start > this.state.lastTokEndLoc.index) {
        this.raise(PlaceholderErrors.UnexpectedSpace, {
          at: this.state.lastTokEndLoc
        });
      }
    }
  };
  var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc;
        const node2 = this.startNode();
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          const name = this.parseIdentifierName();
          const identifier = this.createIdentifier(node2, name);
          identifier.type = "V8IntrinsicIdentifier";
          if (this.match(10)) {
            return identifier;
          }
        }
        this.unexpected(v8IntrinsicStartLoc);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
  };
  var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
  var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
  var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  var mixinPlugins = {
    estree,
    jsx,
    flow,
    typescript,
    v8intrinsic,
    placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);
  var defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowNewTargetOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createImportExpressions: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true,
    annexB: true
  };

  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }
      const key = prop.key;
      const name = key.type === "Identifier" ? key.name : key.value;
      if (name === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, {
            at: key
          });
          return;
        }
        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProtoLoc === null) {
              refExpressionErrors.doubleProtoLoc = key.loc.start;
            }
          } else {
            this.raise(Errors.DuplicateProto, {
              at: key
            });
          }
        }
        protoRef.used = true;
      }
    }
    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
    getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      const expr = this.parseExpression();
      if (!this.match(139)) {
        this.unexpected();
      }
      this.finalizeRemainingComments();
      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }
      return expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(12)) {
        const node2 = this.startNodeAt(startLoc);
        node2.expressions = [expr];
        while (this.eat(12)) {
          node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }
        this.toReferencedList(node2.expressions);
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$loc;
      refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? undefined : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startLoc = this.state.startLoc;
      if (this.isContextual(108)) {
        if (this.prodParam.hasYield) {
          let left3 = this.parseYield();
          if (afterLeftParse) {
            left3 = afterLeftParse.call(this, left3, startLoc);
          }
          return left3;
        }
      }
      let ownExpressionErrors;
      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors;
        ownExpressionErrors = true;
      }
      const {
        type
      } = this.state;
      if (type === 10 || tokenIsIdentifier(type)) {
        this.state.potentialArrowAt = this.state.start;
      }
      let left2 = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse) {
        left2 = afterLeftParse.call(this, left2, startLoc);
      }
      if (tokenIsAssignment(this.state.type)) {
        const node2 = this.startNodeAt(startLoc);
        const operator = this.state.value;
        node2.operator = operator;
        if (this.match(29)) {
          this.toAssignable(left2, true);
          node2.left = left2;
          const startIndex = startLoc.index;
          if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
            refExpressionErrors.doubleProtoLoc = null;
          }
          if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
            refExpressionErrors.shorthandAssignLoc = null;
          }
          if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
            this.checkDestructuringPrivate(refExpressionErrors);
            refExpressionErrors.privateKeyLoc = null;
          }
        } else {
          node2.left = left2;
        }
        this.next();
        node2.right = this.parseMaybeAssign();
        this.checkLVal(left2, {
          in: this.finishNode(node2, "AssignmentExpression")
        });
        return node2;
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      return left2;
    }
    parseMaybeConditional(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        const node2 = this.startNodeAt(startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssignAllowIn();
        this.expect(14);
        node2.alternate = this.parseMaybeAssign();
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    parseExprOps(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseExprOp(expr, startLoc, -1);
    }
    parseExprOp(left2, leftStartLoc, minPrec) {
      if (this.isPrivateName(left2)) {
        const value2 = this.getPrivateNameSV(left2);
        if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
          this.raise(Errors.PrivateInExpectedIn, {
            at: left2,
            identifierName: value2
          });
        }
        this.classScope.usePrivateName(value2, left2.loc.start);
      }
      const op = this.state.type;
      if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
        let prec = tokenOperatorPrecedence(op);
        if (prec > minPrec) {
          if (op === 39) {
            this.expectPlugin("pipelineOperator");
            if (this.state.inFSharpPipelineDirectBody) {
              return left2;
            }
            this.checkPipelineAtInfixOperator(left2, leftStartLoc);
          }
          const node2 = this.startNodeAt(leftStartLoc);
          node2.left = left2;
          node2.operator = this.state.value;
          const logical = op === 41 || op === 42;
          const coalesce = op === 40;
          if (coalesce) {
            prec = tokenOperatorPrecedence(42);
          }
          this.next();
          if (op === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }])) {
            if (this.state.type === 96 && this.prodParam.hasAwait) {
              throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                at: this.state.startLoc
              });
            }
          }
          node2.right = this.parseExprOpRightExpr(op, prec);
          const finishedNode = this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          const nextOp = this.state.type;
          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
            throw this.raise(Errors.MixingCoalesceWithLogical, {
              at: this.state.startLoc
            });
          }
          return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
        }
      }
      return left2;
    }
    parseExprOpRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      switch (op) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                return this.parseHackPipeBody();
              });
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, {
                    at: this.state.startLoc
                  });
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }
        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
    parseExprOpBaseRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    parseHackPipeBody() {
      var _body$extra;
      const {
        startLoc
      } = this.state;
      const body = this.parseMaybeAssign();
      const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
      if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
        this.raise(Errors.PipeUnparenthesizedBody, {
          at: startLoc,
          type: body.type
        });
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipeTopicUnused, {
          at: startLoc
        });
      }
      return body;
    }
    checkExponentialAfterUnary(node2) {
      if (this.match(57)) {
        this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
          at: node2.argument
        });
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startLoc = this.state.startLoc;
      const isAwait = this.isContextual(96);
      if (isAwait && this.isAwaitAllowed()) {
        this.next();
        const expr2 = this.parseAwait(startLoc);
        if (!sawUnary)
          this.checkExponentialAfterUnary(expr2);
        return expr2;
      }
      const update = this.match(34);
      const node2 = this.startNode();
      if (tokenIsPrefix(this.state.type)) {
        node2.operator = this.state.value;
        node2.prefix = true;
        if (this.match(72)) {
          this.expectPlugin("throwExpressions");
        }
        const isDelete = this.match(89);
        this.next();
        node2.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);
        if (this.state.strict && isDelete) {
          const arg = node2.argument;
          if (arg.type === "Identifier") {
            this.raise(Errors.StrictDelete, {
              at: node2
            });
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(Errors.DeletePrivateField, {
              at: node2
            });
          }
        }
        if (!update) {
          if (!sawUnary) {
            this.checkExponentialAfterUnary(node2);
          }
          return this.finishNode(node2, "UnaryExpression");
        }
      }
      const expr = this.parseUpdate(node2, update, refExpressionErrors);
      if (isAwait) {
        const {
          type
        } = this.state;
        const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
        if (startsExpr2 && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
            at: startLoc
          });
          return this.parseAwait(startLoc);
        }
      }
      return expr;
    }
    parseUpdate(node2, update, refExpressionErrors) {
      if (update) {
        const updateExpressionNode = node2;
        this.checkLVal(updateExpressionNode.argument, {
          in: this.finishNode(updateExpressionNode, "UpdateExpression")
        });
        return node2;
      }
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false))
        return expr;
      while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
        const node3 = this.startNodeAt(startLoc);
        node3.operator = this.state.value;
        node3.prefix = false;
        node3.argument = expr;
        this.next();
        this.checkLVal(expr, {
          in: expr = this.finishNode(node3, "UpdateExpression")
        });
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseSubscripts(expr, startLoc);
    }
    parseSubscripts(base, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };
      do {
        base = this.parseSubscript(base, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);
      return base;
    }
    parseSubscript(base, startLoc, noCalls, state) {
      const {
        type
      } = this.state;
      if (!noCalls && type === 15) {
        return this.parseBind(base, startLoc, noCalls, state);
      } else if (tokenIsTemplate(type)) {
        return this.parseTaggedTemplateExpression(base, startLoc, state);
      }
      let optional = false;
      if (type === 18) {
        if (noCalls) {
          this.raise(Errors.OptionalChainingNoNew, {
            at: this.state.startLoc
          });
          if (this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }
        }
        state.optionalChainMember = optional = true;
        this.next();
      }
      if (!noCalls && this.match(10)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
      } else {
        const computed = this.eat(0);
        if (computed || optional || this.eat(16)) {
          return this.parseMember(base, startLoc, state, computed, optional);
        } else {
          state.stop = true;
          return base;
        }
      }
    }
    parseMember(base, startLoc, state, computed, optional) {
      const node2 = this.startNodeAt(startLoc);
      node2.object = base;
      node2.computed = computed;
      if (computed) {
        node2.property = this.parseExpression();
        this.expect(3);
      } else if (this.match(138)) {
        if (base.type === "Super") {
          this.raise(Errors.SuperPrivateField, {
            at: startLoc
          });
        }
        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
        node2.property = this.parsePrivateName();
      } else {
        node2.property = this.parseIdentifier(true);
      }
      if (state.optionalChainMember) {
        node2.optional = optional;
        return this.finishNode(node2, "OptionalMemberExpression");
      } else {
        return this.finishNode(node2, "MemberExpression");
      }
    }
    parseBind(base, startLoc, noCalls, state) {
      const node2 = this.startNodeAt(startLoc);
      node2.object = base;
      this.next();
      node2.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      const node2 = this.startNodeAt(startLoc);
      node2.callee = base;
      const {
        maybeAsyncArrow,
        optionalChainMember
      } = state;
      if (maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors;
      }
      if (optionalChainMember) {
        node2.optional = optional;
      }
      if (optional) {
        node2.arguments = this.parseCallExpressionArguments(11);
      } else {
        node2.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node2, refExpressionErrors);
      }
      let finishedNode = this.finishCallExpression(node2, optionalChainMember);
      if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
      } else {
        if (maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }
        this.toReferencedArguments(finishedNode);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return finishedNode;
    }
    toReferencedArguments(node2, isParenthesizedExpr) {
      this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base, startLoc, state) {
      const node2 = this.startNodeAt(startLoc);
      node2.tag = base;
      node2.quasi = this.parseTemplate(true);
      if (state.optionalChainMember) {
        this.raise(Errors.OptionalChainingNoTemplate, {
          at: startLoc
        });
      }
      return this.finishNode(node2, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      if (!this.hasPlugin("importAssertions")) {
        this.expectPlugin("importAttributes");
      }
    }
    finishCallExpression(node2, optional) {
      if (node2.callee.type === "Import") {
        if (node2.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectImportAttributesPlugin();
            }
          }
        }
        if (node2.arguments.length === 0 || node2.arguments.length > 2) {
          this.raise(Errors.ImportCallArity, {
            at: node2,
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        } else {
          for (const arg of node2.arguments) {
            if (arg.type === "SpreadElement") {
              this.raise(Errors.ImportCallSpreadArgument, {
                at: arg
              });
            }
          }
        }
      }
      return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(Errors.ImportCallArgumentTrailingComma, {
                at: this.state.lastTokStartLoc
              });
            }
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node2, call) {
      var _call$extra;
      this.resetPreviousNodeTrailingComments(call);
      this.expect(19);
      this.parseArrowExpression(node2, call.arguments, true, (_call$extra = call.extra) == null ? undefined : _call$extra.trailingCommaLoc);
      if (call.innerComments) {
        setInnerComments(node2, call.innerComments);
      }
      if (call.callee.trailingComments) {
        setInnerComments(node2, call.callee.trailingComments);
      }
      return node2;
    }
    parseNoCallExpr() {
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    }
    parseExprAtom(refExpressionErrors) {
      let node2;
      let decorators = null;
      const {
        type
      } = this.state;
      switch (type) {
        case 79:
          return this.parseSuper();
        case 83:
          node2 = this.startNode();
          this.next();
          if (this.match(16)) {
            return this.parseImportMetaProperty(node2);
          }
          if (this.match(10)) {
            if (this.options.createImportExpressions) {
              return this.parseImportCall(node2);
            } else {
              return this.finishNode(node2, "Import");
            }
          } else {
            this.raise(Errors.UnsupportedImport, {
              at: this.state.lastTokStartLoc
            });
            return this.finishNode(node2, "Import");
          }
        case 78:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case 90: {
          return this.parseDo(this.startNode(), false);
        }
        case 56:
        case 31: {
          this.readRegexp();
          return this.parseRegExpLiteral(this.state.value);
        }
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        case 2:
        case 1: {
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        }
        case 0: {
          return this.parseArrayLike(3, true, false, refExpressionErrors);
        }
        case 6:
        case 7: {
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        }
        case 5: {
          return this.parseObjectLike(8, false, false, refExpressionErrors);
        }
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          decorators = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          node2 = this.startNode();
          this.next();
          node2.object = null;
          const callee = node2.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression") {
            return this.finishNode(node2, "BindExpression");
          } else {
            throw this.raise(Errors.UnsupportedBind, {
              at: callee
            });
          }
        }
        case 138: {
          this.raise(Errors.PrivateInExpectedIn, {
            at: this.state.startLoc,
            identifierName: this.state.value
          });
          return this.parsePrivateName();
        }
        case 33: {
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        }
        case 32: {
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        }
        case 37:
        case 38: {
          return this.parseTopicReference("hack");
        }
        case 44:
        case 54:
        case 27: {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            return this.parseTopicReference(pipeProposal);
          }
          this.unexpected();
          break;
        }
        case 47: {
          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
          } else {
            this.unexpected();
          }
          break;
        }
        default:
          if (tokenIsIdentifier(type)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
              return this.parseModuleExpression();
            }
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            const containsEsc = this.state.containsEsc;
            const id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: type2
              } = this.state;
              if (type2 === 68) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
              } else if (tokenIsIdentifier(type2)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (type2 === 90) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }
            if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }
            return id;
          } else {
            this.unexpected();
          }
      }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
      if (pipeProposal) {
        this.state.type = topicTokenType;
        this.state.value = topicTokenValue;
        this.state.pos--;
        this.state.end--;
        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
        return this.parseTopicReference(pipeProposal);
      } else {
        this.unexpected();
      }
    }
    parseTopicReference(pipeProposal) {
      const node2 = this.startNode();
      const startLoc = this.state.startLoc;
      const tokenType = this.state.type;
      this.next();
      return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType);
    }
    finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        if (!this.topicReferenceIsAllowedInCurrentContext()) {
          this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
            at: startLoc
          });
        }
        this.registerTopicReference();
        return this.finishNode(node2, nodeType);
      } else {
        throw this.raise(Errors.PipeTopicUnconfiguredToken, {
          at: startLoc,
          token: tokenLabelName(tokenType)
        });
      }
    }
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack": {
          return this.hasPlugin(["pipelineOperator", {
            topicToken: tokenLabelName(tokenType)
          }]);
        }
        case "smart":
          return tokenType === 27;
        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, {
            at: startLoc
          });
      }
    }
    parseAsyncArrowUnaryFunction(node2) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      this.prodParam.exit();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.LineTerminatorBeforeArrow, {
          at: this.state.curPosition()
        });
      }
      this.expect(19);
      return this.parseArrowExpression(node2, params, true);
    }
    parseDo(node2, isAsync2) {
      this.expectPlugin("doExpressions");
      if (isAsync2) {
        this.expectPlugin("asyncDoExpressions");
      }
      node2.async = isAsync2;
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];
      if (isAsync2) {
        this.prodParam.enter(2);
        node2.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node2.body = this.parseBlock();
      }
      this.state.labels = oldLabels;
      return this.finishNode(node2, "DoExpression");
    }
    parseSuper() {
      const node2 = this.startNode();
      this.next();
      if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(Errors.SuperNotAllowed, {
          at: node2
        });
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(Errors.UnexpectedSuper, {
          at: node2
        });
      }
      if (!this.match(10) && !this.match(0) && !this.match(16)) {
        this.raise(Errors.UnsupportedSuper, {
          at: node2
        });
      }
      return this.finishNode(node2, "Super");
    }
    parsePrivateName() {
      const node2 = this.startNode();
      const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
      const name = this.state.value;
      this.next();
      node2.id = this.createIdentifier(id, name);
      return this.finishNode(node2, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const node2 = this.startNode();
      this.next();
      if (this.prodParam.hasYield && this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
        this.next();
        if (this.match(103)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
        return this.parseMetaProperty(node2, meta, "sent");
      }
      return this.parseFunction(node2);
    }
    parseMetaProperty(node2, meta, propertyName) {
      node2.meta = meta;
      const containsEsc = this.state.containsEsc;
      node2.property = this.parseIdentifier(true);
      if (node2.property.name !== propertyName || containsEsc) {
        this.raise(Errors.UnsupportedMetaProperty, {
          at: node2.property,
          target: meta.name,
          onlyValidPropertyName: propertyName
        });
      }
      return this.finishNode(node2, "MetaProperty");
    }
    parseImportMetaProperty(node2) {
      const id = this.createIdentifier(this.startNodeAtNode(node2), "import");
      this.next();
      if (this.isContextual(101)) {
        if (!this.inModule) {
          this.raise(Errors.ImportMetaOutsideModule, {
            at: id
          });
        }
        this.sawUnambiguousESM = true;
      } else if (this.isContextual(105) || this.isContextual(97)) {
        const isSource = this.isContextual(105);
        if (!isSource)
          this.unexpected();
        this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
        if (!this.options.createImportExpressions) {
          throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {
            at: this.state.startLoc,
            phase: this.state.value
          });
        }
        this.next();
        node2.phase = isSource ? "source" : "defer";
        return this.parseImportCall(node2);
      }
      return this.parseMetaProperty(node2, id, "meta");
    }
    parseLiteralAtNode(value2, type, node2) {
      this.addExtra(node2, "rawValue", value2);
      this.addExtra(node2, "raw", this.input.slice(node2.start, this.state.end));
      node2.value = value2;
      this.next();
      return this.finishNode(node2, type);
    }
    parseLiteral(value2, type) {
      const node2 = this.startNode();
      return this.parseLiteralAtNode(value2, type, node2);
    }
    parseStringLiteral(value2) {
      return this.parseLiteral(value2, "StringLiteral");
    }
    parseNumericLiteral(value2) {
      return this.parseLiteral(value2, "NumericLiteral");
    }
    parseBigIntLiteral(value2) {
      return this.parseLiteral(value2, "BigIntLiteral");
    }
    parseDecimalLiteral(value2) {
      return this.parseLiteral(value2, "DecimalLiteral");
    }
    parseRegExpLiteral(value2) {
      const node2 = this.parseLiteral(value2.value, "RegExpLiteral");
      node2.pattern = value2.pattern;
      node2.flags = value2.flags;
      return node2;
    }
    parseBooleanLiteral(value2) {
      const node2 = this.startNode();
      node2.value = value2;
      this.next();
      return this.finishNode(node2, "BooleanLiteral");
    }
    parseNullLiteral() {
      const node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors;
      let first = true;
      let spreadStartLoc;
      let optionalCommaStartLoc;
      while (!this.match(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
          if (this.match(11)) {
            optionalCommaStartLoc = this.state.startLoc;
            break;
          }
        }
        if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStartLoc = this.state.startLoc;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
          if (!this.checkCommaAfterRest(41)) {
            break;
          }
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startLoc);
      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }
      this.expressionScope.exit();
      if (!exprList.length) {
        this.unexpected(this.state.lastTokStartLoc);
      }
      if (optionalCommaStartLoc)
        this.unexpected(optionalCommaStartLoc);
      if (spreadStartLoc)
        this.unexpected(spreadStartLoc);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        this.resetEndLocation(val, innerEndLoc);
      } else {
        val = exprList[0];
      }
      return this.wrapParenthesis(startLoc, val);
    }
    wrapParenthesis(startLoc, expression) {
      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(expression, "parenthesized", true);
        this.addExtra(expression, "parenStart", startLoc.index);
        this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
        return expression;
      }
      const parenExpression = this.startNodeAt(startLoc);
      parenExpression.expression = expression;
      return this.finishNode(parenExpression, "ParenthesizedExpression");
    }
    shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
    parseArrow(node2) {
      if (this.eat(19)) {
        return node2;
      }
    }
    parseParenItem(node2, startLoc) {
      return node2;
    }
    parseNewOrNewTarget() {
      const node2 = this.startNode();
      this.next();
      if (this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node2, meta, "target");
        if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
          this.raise(Errors.UnexpectedNewTarget, {
            at: metaProp
          });
        }
        return metaProp;
      }
      return this.parseNew(node2);
    }
    parseNew(node2) {
      this.parseNewCallee(node2);
      if (this.eat(10)) {
        const args = this.parseExprList(11);
        this.toReferencedList(args);
        node2.arguments = args;
      } else {
        node2.arguments = [];
      }
      return this.finishNode(node2, "NewExpression");
    }
    parseNewCallee(node2) {
      const isImport = this.match(83);
      const callee = this.parseNoCallExpr();
      node2.callee = callee;
      if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
        this.raise(Errors.ImportCallNotNewExpression, {
          at: callee
        });
      }
    }
    parseTemplateElement(isTagged) {
      const {
        start,
        startLoc,
        end,
        value: value2
      } = this.state;
      const elemStart = start + 1;
      const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
      if (value2 === null) {
        if (!isTagged) {
          this.raise(Errors.InvalidEscapeSequenceTemplate, {
            at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
          });
        }
      }
      const isTail = this.match(24);
      const endOffset = isTail ? -1 : -2;
      const elemEnd = end + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
        cooked: value2 === null ? null : value2.slice(1, endOffset)
      };
      elem.tail = isTail;
      this.next();
      const finishedNode = this.finishNode(elem, "TemplateElement");
      this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
      return finishedNode;
    }
    parseTemplate(isTagged) {
      const node2 = this.startNode();
      node2.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      node2.quasis = [curElt];
      while (!curElt.tail) {
        node2.expressions.push(this.parseTemplateSubstitution());
        this.readTemplateContinuation();
        node2.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }
      return this.finishNode(node2, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const propHash = Object.create(null);
      let first = true;
      const node2 = this.startNode();
      node2.properties = [];
      this.next();
      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            this.addTrailingCommaExtraToNode(node2);
            break;
          }
        }
        let prop;
        if (isPattern) {
          prop = this.parseBindingProperty();
        } else {
          prop = this.parsePropertyDefinition(refExpressionErrors);
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }
        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(Errors.InvalidRecordProperty, {
            at: prop
          });
        }
        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }
        node2.properties.push(prop);
      }
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = "ObjectExpression";
      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }
      return this.finishNode(node2, type);
    }
    addTrailingCommaExtraToNode(node2) {
      this.addExtra(node2, "trailingComma", this.state.lastTokStart);
      this.addExtra(node2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(refExpressionErrors) {
      let decorators = [];
      if (this.match(26)) {
        if (this.hasPlugin("decorators")) {
          this.raise(Errors.UnsupportedPropertyDecorator, {
            at: this.state.startLoc
          });
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator());
        }
      }
      const prop = this.startNode();
      let isAsync2 = false;
      let isAccessor = false;
      let startLoc;
      if (this.match(21)) {
        if (decorators.length)
          this.unexpected();
        return this.parseSpread();
      }
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      prop.method = false;
      if (refExpressionErrors) {
        startLoc = this.state.startLoc;
      }
      let isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      const containsEsc = this.state.containsEsc;
      const key = this.parsePropertyName(prop, refExpressionErrors);
      if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const keyName = key.name;
        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync2 = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(55);
          this.parsePropertyName(prop);
        }
        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;
          if (this.match(55)) {
            isGenerator = true;
            this.raise(Errors.AccessorIsGenerator, {
              at: this.state.curPosition(),
              kind: keyName
            });
            this.next();
          }
          this.parsePropertyName(prop);
        }
      }
      return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync2, false, isAccessor, refExpressionErrors);
    }
    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
      return method.params;
    }
    checkGetterSetterParams(method) {
      var _params;
      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length !== paramCount) {
        this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
          at: method
        });
      }
      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? undefined : _params.type) === "RestElement") {
        this.raise(Errors.BadSetterRestParameter, {
          at: method
        });
      }
    }
    parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor) {
      if (isAccessor) {
        const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(finishedProp);
        return finishedProp;
      }
      if (isAsync2 || isGenerator || this.match(10)) {
        if (isPattern)
          this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync2, false, false, "ObjectMethod");
      }
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;
      if (this.eat(14)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }
      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        } else if (this.match(29)) {
          const shorthandAssignLoc = this.state.startLoc;
          if (refExpressionErrors != null) {
            if (refExpressionErrors.shorthandAssignLoc === null) {
              refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
            }
          } else {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        } else {
          prop.value = cloneIdentifier(prop.key);
        }
        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors) {
      const node2 = this.parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (!node2)
        this.unexpected();
      return node2;
    }
    parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(3);
      } else {
        const {
          type,
          value: value2
        } = this.state;
        let key;
        if (tokenIsKeywordOrIdentifier(type)) {
          key = this.parseIdentifier(true);
        } else {
          switch (type) {
            case 134:
              key = this.parseNumericLiteral(value2);
              break;
            case 133:
              key = this.parseStringLiteral(value2);
              break;
            case 135:
              key = this.parseBigIntLiteral(value2);
              break;
            case 136:
              key = this.parseDecimalLiteral(value2);
              break;
            case 138: {
              const privateKeyLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.privateKeyLoc === null) {
                  refExpressionErrors.privateKeyLoc = privateKeyLoc;
                }
              } else {
                this.raise(Errors.UnexpectedPrivateField, {
                  at: privateKeyLoc
                });
              }
              key = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        }
        prop.key = key;
        if (type !== 138) {
          prop.computed = false;
        }
      }
      return prop.key;
    }
    initFunction(node2, isAsync2) {
      node2.id = null;
      node2.generator = false;
      node2.async = isAsync2;
    }
    parseMethod(node2, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope = false) {
      this.initFunction(node2, isAsync2);
      node2.generator = isGenerator;
      this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
      this.prodParam.enter(functionFlags(isAsync2, node2.generator));
      this.parseFunctionParams(node2, isConstructor);
      const finishedNode = this.parseFunctionBodyAndFinish(node2, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return finishedNode;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node2, params, isAsync2, trailingCommaLoc) {
      this.scope.enter(2 | 4);
      let flags = functionFlags(isAsync2, false);
      if (!this.match(5) && this.prodParam.hasIn) {
        flags |= 8;
      }
      this.prodParam.enter(flags);
      this.initFunction(node2, isAsync2);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node2, params, trailingCommaLoc);
      }
      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node2, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node2, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node2, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, false);
      node2.params = params;
    }
    parseFunctionBodyAndFinish(node2, type, isMethod = false) {
      this.parseFunctionBody(node2, false, isMethod);
      return this.finishNode(node2, type);
    }
    parseFunctionBody(node2, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(5);
      this.expressionScope.enter(newExpressionScope());
      if (isExpression) {
        node2.body = this.parseMaybeAssign();
        this.checkParams(node2, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | 4);
        node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node2.params);
          if (hasStrictModeDirective && nonSimple) {
            this.raise(Errors.IllegalLanguageModeDirective, {
              at: (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.loc.end : node2
            });
          }
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
          if (this.state.strict && node2.id) {
            this.checkIdentifier(node2.id, 65, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(node2) {
      return node2.type === "Identifier";
    }
    isSimpleParamList(params) {
      for (let i = 0, len = params.length;i < len; i++) {
        if (!this.isSimpleParameter(params[i]))
          return false;
      }
      return true;
    }
    checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      const checkClashes = !allowDuplicates && new Set;
      const formalParameters = {
        type: "FormalParameters"
      };
      for (const param of node2.params) {
        this.checkLVal(param, {
          in: formalParameters,
          binding: 5,
          checkClashes,
          strictModeChanged
        });
      }
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;
      if (this.match(12)) {
        if (!allowEmpty) {
          this.raise(Errors.UnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: ","
          });
        }
        elt = null;
      } else if (this.match(21)) {
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication");
        if (!allowPlaceholder) {
          this.raise(Errors.UnexpectedArgumentPlaceholder, {
            at: this.state.startLoc
          });
        }
        const node2 = this.startNode();
        this.next();
        elt = this.finishNode(node2, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }
      return elt;
    }
    parseIdentifier(liberal) {
      const node2 = this.startNode();
      const name = this.parseIdentifierName(liberal);
      return this.createIdentifier(node2, name);
    }
    createIdentifier(node2, name) {
      node2.name = name;
      node2.loc.identifierName = name;
      return this.finishNode(node2, "Identifier");
    }
    parseIdentifierName(liberal) {
      let name;
      const {
        startLoc,
        type
      } = this.state;
      if (tokenIsKeywordOrIdentifier(type)) {
        name = this.state.value;
      } else {
        this.unexpected();
      }
      const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
      if (liberal) {
        if (tokenIsKeyword2) {
          this.replaceToken(132);
        }
      } else {
        this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
      }
      this.next();
      return name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }
      if (!canBeReservedWord(word)) {
        return;
      }
      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, {
          at: startLoc,
          keyword: word
        });
        return;
      }
      const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
      if (reservedTest(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, {
          at: startLoc,
          reservedWord: word
        });
        return;
      } else if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, {
            at: startLoc
          });
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, {
            at: startLoc
          });
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
            at: startLoc
          });
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError({
          at: startLoc
        });
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(Errors.ArgumentsInClass, {
            at: startLoc
          });
          return;
        }
      }
    }
    isAwaitAllowed() {
      if (this.prodParam.hasAwait)
        return true;
      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }
      return false;
    }
    parseAwait(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
        at: node2
      });
      if (this.eat(55)) {
        this.raise(Errors.ObsoleteAwaitStar, {
          at: node2
        });
      }
      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }
      if (!this.state.soloAwait) {
        node2.argument = this.parseMaybeUnary(null, true);
      }
      return this.finishNode(node2, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      const {
        type
      } = this.state;
      return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
    }
    parseYield() {
      const node2 = this.startNode();
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
        at: node2
      });
      this.next();
      let delegating = false;
      let argument = null;
      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(55);
        switch (this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating)
              break;
          default:
            argument = this.parseMaybeAssign();
        }
      }
      node2.delegate = delegating;
      node2.argument = argument;
      return this.finishNode(node2, "YieldExpression");
    }
    parseImportCall(node2) {
      this.next();
      node2.source = this.parseMaybeAssignAllowIn();
      if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        node2.options = null;
      }
      if (this.eat(12)) {
        this.expectImportAttributesPlugin();
        if (!this.match(11)) {
          node2.options = this.parseMaybeAssignAllowIn();
          this.eat(12);
        }
      }
      this.expect(11);
      return this.finishNode(node2, "ImportExpression");
    }
    checkPipelineAtInfixOperator(left2, leftStartLoc) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        if (left2.type === "SequenceExpression") {
          this.raise(Errors.PipelineHeadSequenceExpression, {
            at: leftStartLoc
          });
        }
      }
    }
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        const bodyNode = this.startNodeAt(startLoc);
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        const bodyNode = this.startNodeAt(startLoc);
        this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
        bodyNode.expression = childExpr;
        return this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19)) {
        throw this.raise(Errors.PipelineBodyNoArrow, {
          at: this.state.startLoc
        });
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipelineTopicUnused, {
          at: startLoc
        });
      }
    }
    withTopicBindingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = 8 & ~flags;
      if (prodParamToSet) {
        this.prodParam.enter(flags | 8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = 8 & flags;
      if (prodParamToClear) {
        this.prodParam.enter(flags & ~8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node2 = this.startNode();
      this.next();
      if (!this.match(5)) {
        this.unexpected(null, 5);
      }
      const program = this.startNodeAt(this.state.endLoc);
      this.next();
      const revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        node2.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }
      return this.finishNode(node2, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(prop) {
    }
  }
  var loopLabel = {
    kind: "loop"
  };
  var switchLabel = {
    kind: "switch"
  };
  var loneSurrogate = /[\uD800-\uDFFF]/u;
  var keywordRelationalOperator = /in(?:stanceof)?/y;

  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;
      if (this.options.tokens) {
        file.tokens = babel7CompatTokens(this.tokens, this.input);
      }
      return this.finishNode(file, "File");
    }
    parseProgram(program, end = 139, sourceType = this.options.sourceType) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);
      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
          this.raise(Errors.ModuleExportUndefined, {
            at,
            localName
          });
        }
      }
      let finishedProgram;
      if (end === 139) {
        finishedProgram = this.finishNode(program, "Program");
      } else {
        finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
      }
      return finishedProgram;
    }
    stmtToDirective(stmt) {
      const directive = stmt;
      directive.type = "Directive";
      directive.value = directive.expression;
      delete directive.expression;
      const directiveLiteral = directive.value;
      const expressionValue = directiveLiteral.value;
      const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
      const val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      this.addExtra(directiveLiteral, "expressionValue", expressionValue);
      directiveLiteral.type = "DirectiveLiteral";
      return directive;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) {
        return null;
      }
      const node2 = this.startNode();
      node2.value = this.state.value;
      this.next();
      return this.finishNode(node2, "InterpreterDirective");
    }
    isLet() {
      if (!this.isContextual(100)) {
        return false;
      }
      return this.hasFollowingBindingAtom();
    }
    chStartsBindingIdentifier(ch, pos) {
      if (isIdentifierStart(ch)) {
        keywordRelationalOperator.lastIndex = pos;
        if (keywordRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }
        return true;
      } else if (ch === 92) {
        return true;
      } else {
        return false;
      }
    }
    chStartsBindingPattern(ch) {
      return ch === 91 || ch === 123;
    }
    hasFollowingBindingAtom() {
      const next = this.nextTokenStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    hasInLineFollowingBindingIdentifier() {
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifier(nextCh, next);
    }
    startsUsingForOf() {
      const {
        type,
        containsEsc
      } = this.lookahead();
      if (type === 102 && !containsEsc) {
        return false;
      } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
        this.expectPlugin("explicitResourceManagement");
        return true;
      }
    }
    startsAwaitUsing() {
      let next = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(next, "using")) {
        next = this.nextTokenInLineStartSince(next + 5);
        const nextCh = this.codePointAtPos(next);
        if (this.chStartsBindingIdentifier(nextCh, next)) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      return false;
    }
    parseModuleItem() {
      return this.parseStatementLike(1 | 2 | 4 | 8);
    }
    parseStatementListItem() {
      return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
      let flags = 0;
      if (this.options.annexB && !this.state.strict) {
        flags |= 4;
        if (allowLabeledFunction) {
          flags |= 8;
        }
      }
      return this.parseStatementLike(flags);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(flags) {
      let decorators = null;
      if (this.match(26)) {
        decorators = this.parseDecorators(true);
      }
      return this.parseStatementContent(flags, decorators);
    }
    parseStatementContent(flags, decorators) {
      const starttype = this.state.type;
      const node2 = this.startNode();
      const allowDeclaration = !!(flags & 2);
      const allowFunctionDeclaration = !!(flags & 4);
      const topLevel = flags & 1;
      switch (starttype) {
        case 60:
          return this.parseBreakContinueStatement(node2, true);
        case 63:
          return this.parseBreakContinueStatement(node2, false);
        case 64:
          return this.parseDebuggerStatement(node2);
        case 90:
          return this.parseDoWhileStatement(node2);
        case 91:
          return this.parseForStatement(node2);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          if (!allowFunctionDeclaration) {
            this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
              at: this.state.startLoc
            });
          }
          return this.parseFunctionStatement(node2, false, !allowDeclaration && allowFunctionDeclaration);
        case 80:
          if (!allowDeclaration)
            this.unexpected();
          return this.parseClass(this.maybeTakeDecorators(decorators, node2), true);
        case 69:
          return this.parseIfStatement(node2);
        case 70:
          return this.parseReturnStatement(node2);
        case 71:
          return this.parseSwitchStatement(node2);
        case 72:
          return this.parseThrowStatement(node2);
        case 73:
          return this.parseTryStatement(node2);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) {
            if (!this.isAwaitAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, {
                at: node2
              });
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, {
                at: node2
              });
            }
            this.next();
            return this.parseVarStatement(node2, "await using");
          }
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
            break;
          }
          this.expectPlugin("explicitResourceManagement");
          if (!this.scope.inModule && this.scope.inTopLevel) {
            this.raise(Errors.UnexpectedUsingDeclaration, {
              at: this.state.startLoc
            });
          } else if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, {
              at: this.state.startLoc
            });
          }
          return this.parseVarStatement(node2, "using");
        case 100: {
          if (this.state.containsEsc) {
            break;
          }
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          if (nextCh !== 91) {
            if (!allowDeclaration && this.hasFollowingLineBreak())
              break;
            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
              break;
            }
          }
        }
        case 75: {
          if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, {
              at: this.state.startLoc
            });
          }
        }
        case 74: {
          const kind = this.state.value;
          return this.parseVarStatement(node2, kind);
        }
        case 92:
          return this.parseWhileStatement(node2);
        case 76:
          return this.parseWithStatement(node2);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(node2);
        case 83: {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }
        case 82: {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(Errors.UnexpectedImportExport, {
              at: this.state.startLoc
            });
          }
          this.next();
          let result;
          if (starttype === 83) {
            result = this.parseImport(node2);
            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node2, decorators);
            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }
          this.assertModuleNodeAllowed(result);
          return result;
        }
        default: {
          if (this.isAsyncFunction()) {
            if (!allowDeclaration) {
              this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                at: this.state.startLoc
              });
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !allowDeclaration && allowFunctionDeclaration);
          }
        }
      }
      const maybeName = this.state.value;
      const expr = this.parseExpression();
      if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
        return this.parseLabeledStatement(node2, maybeName, expr, flags);
      } else {
        return this.parseExpressionStatement(node2, expr, decorators);
      }
    }
    assertModuleNodeAllowed(node2) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(Errors.ImportOutsideModule, {
          at: node2
        });
      }
    }
    decoratorsEnabledBeforeExport() {
      if (this.hasPlugin("decorators-legacy"))
        return true;
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    }
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
      if (maybeDecorators) {
        if (classNode.decorators && classNode.decorators.length > 0) {
          if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
            this.raise(Errors.DecoratorsBeforeAfterExport, {
              at: classNode.decorators[0]
            });
          }
          classNode.decorators.unshift(...maybeDecorators);
        } else {
          classNode.decorators = maybeDecorators;
        }
        this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
        if (exportNode)
          this.resetStartLocationFromNode(exportNode, classNode);
      }
      return classNode;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(allowExport) {
      const decorators = [];
      do {
        decorators.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) {
        if (!allowExport) {
          this.unexpected();
        }
        if (!this.decoratorsEnabledBeforeExport()) {
          this.raise(Errors.DecoratorExportClass, {
            at: this.state.startLoc
          });
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(Errors.UnexpectedLeadingDecorator, {
          at: this.state.startLoc
        });
      }
      return decorators;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const node2 = this.startNode();
      this.next();
      if (this.hasPlugin("decorators")) {
        const startLoc = this.state.startLoc;
        let expr;
        if (this.match(10)) {
          const startLoc2 = this.state.startLoc;
          this.next();
          expr = this.parseExpression();
          this.expect(11);
          expr = this.wrapParenthesis(startLoc2, expr);
          const paramsStartLoc = this.state.startLoc;
          node2.expression = this.parseMaybeDecoratorArguments(expr);
          if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node2.expression !== expr) {
            this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
              at: paramsStartLoc
            });
          }
        } else {
          expr = this.parseIdentifier(false);
          while (this.eat(16)) {
            const node3 = this.startNodeAt(startLoc);
            node3.object = expr;
            if (this.match(138)) {
              this.classScope.usePrivateName(this.state.value, this.state.startLoc);
              node3.property = this.parsePrivateName();
            } else {
              node3.property = this.parseIdentifier(true);
            }
            node3.computed = false;
            expr = this.finishNode(node3, "MemberExpression");
          }
          node2.expression = this.parseMaybeDecoratorArguments(expr);
        }
      } else {
        node2.expression = this.parseExprSubscripts();
      }
      return this.finishNode(node2, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(10)) {
        const node2 = this.startNodeAtNode(expr);
        node2.callee = expr;
        node2.arguments = this.parseCallExpressionArguments(11, false);
        this.toReferencedList(node2.arguments);
        return this.finishNode(node2, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node2, isBreak) {
      this.next();
      if (this.isLineTerminator()) {
        node2.label = null;
      } else {
        node2.label = this.parseIdentifier();
        this.semicolon();
      }
      this.verifyBreakContinue(node2, isBreak);
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node2, isBreak) {
      let i;
      for (i = 0;i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop"))
            break;
          if (node2.label && isBreak)
            break;
        }
      }
      if (i === this.state.labels.length) {
        const type = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, {
          at: node2,
          type
        });
      }
    }
    parseDebuggerStatement(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const val = this.parseExpression();
      this.expect(11);
      return val;
    }
    parseDoWhileStatement(node2) {
      this.next();
      this.state.labels.push(loopLabel);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.state.labels.pop();
      this.expect(92);
      node2.test = this.parseHeaderExpression();
      this.eat(13);
      return this.finishNode(node2, "DoWhileStatement");
    }
    parseForStatement(node2) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = null;
      if (this.isAwaitAllowed() && this.eatContextual(96)) {
        awaitAt = this.state.lastTokStartLoc;
      }
      this.scope.enter(0);
      this.expect(10);
      if (this.match(13)) {
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      const startsWithLet = this.isContextual(100);
      {
        const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
        const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
        const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          const initNode = this.startNode();
          let kind;
          if (startsWithAwaitUsing) {
            kind = "await using";
            if (!this.isAwaitAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, {
                at: this.state.startLoc
              });
            }
            this.next();
          } else {
            kind = this.state.value;
          }
          this.next();
          this.parseVar(initNode, true, kind);
          const init2 = this.finishNode(initNode, "VariableDeclaration");
          const isForIn = this.match(58);
          if (isForIn && starsWithUsingDeclaration) {
            this.raise(Errors.ForInUsing, {
              at: init2
            });
          }
          if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
            return this.parseForIn(node2, init2, awaitAt);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, init2);
        }
      }
      const startsWithAsync = this.isContextual(95);
      const refExpressionErrors = new ExpressionErrors;
      const init = this.parseExpression(true, refExpressionErrors);
      const isForOf = this.isContextual(102);
      if (isForOf) {
        if (startsWithLet) {
          this.raise(Errors.ForOfLet, {
            at: init
          });
        }
        if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
          this.raise(Errors.ForOfAsync, {
            at: init
          });
        }
      }
      if (isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.toAssignable(init, true);
        const type = isForOf ? "ForOfStatement" : "ForInStatement";
        this.checkLVal(init, {
          in: {
            type
          }
        });
        return this.parseForIn(node2, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init);
    }
    parseFunctionStatement(node2, isAsync2, isHangingDeclaration) {
      this.next();
      return this.parseFunction(node2, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync2 ? 8 : 0));
    }
    parseIfStatement(node2) {
      this.next();
      node2.test = this.parseHeaderExpression();
      node2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
      node2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
      return this.finishNode(node2, "IfStatement");
    }
    parseReturnStatement(node2) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(Errors.IllegalReturn, {
          at: this.state.startLoc
        });
      }
      this.next();
      if (this.isLineTerminator()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    }
    parseSwitchStatement(node2) {
      this.next();
      node2.discriminant = this.parseHeaderExpression();
      const cases = node2.cases = [];
      this.expect(5);
      this.state.labels.push(switchLabel);
      this.scope.enter(0);
      let cur;
      for (let sawDefault;!this.match(8); ) {
        if (this.match(61) || this.match(65)) {
          const isCase = this.match(61);
          if (cur)
            this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(Errors.MultipleDefaultsInSwitch, {
                at: this.state.lastTokStartLoc
              });
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(14);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatementListItem());
          } else {
            this.unexpected();
          }
        }
      }
      this.scope.exit();
      if (cur)
        this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    }
    parseThrowStatement(node2) {
      this.next();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.NewlineAfterThrow, {
          at: this.state.lastTokEndLoc
        });
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
      this.checkLVal(param, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      });
      return param;
    }
    parseTryStatement(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.match(62)) {
        const clause = this.startNode();
        this.next();
        if (this.match(10)) {
          this.expect(10);
          clause.param = this.parseCatchClauseParam();
          this.expect(11);
        } else {
          clause.param = null;
          this.scope.enter(0);
        }
        clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
        this.scope.exit();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(67) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(Errors.NoCatchOrFinally, {
          at: node2
        });
      }
      return this.finishNode(node2, "TryStatement");
    }
    parseVarStatement(node2, kind, allowMissingInitializer = false) {
      this.next();
      this.parseVar(node2, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    }
    parseWhileStatement(node2) {
      this.next();
      node2.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.state.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    }
    parseWithStatement(node2) {
      if (this.state.strict) {
        this.raise(Errors.StrictWith, {
          at: this.state.startLoc
        });
      }
      this.next();
      node2.object = this.parseHeaderExpression();
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      return this.finishNode(node2, "WithStatement");
    }
    parseEmptyStatement(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    }
    parseLabeledStatement(node2, maybeName, expr, flags) {
      for (const label of this.state.labels) {
        if (label.name === maybeName) {
          this.raise(Errors.LabelRedeclaration, {
            at: expr,
            labelName: maybeName
          });
        }
      }
      const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
      for (let i = this.state.labels.length - 1;i >= 0; i--) {
        const label = this.state.labels[i];
        if (label.statementStart === node2.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }
      this.state.labels.push({
        name: maybeName,
        kind,
        statementStart: this.state.start
      });
      node2.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
      this.state.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    }
    parseExpressionStatement(node2, expr, decorators) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    }
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
      const node2 = this.startNode();
      if (allowDirectives) {
        this.state.strictErrors.clear();
      }
      this.expect(5);
      if (createNewLexicalScope) {
        this.scope.enter(0);
      }
      this.parseBlockBody(node2, allowDirectives, false, 8, afterBlockParse);
      if (createNewLexicalScope) {
        this.scope.exit();
      }
      return this.finishNode(node2, "BlockStatement");
    }
    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node2.body = [];
      const directives = node2.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;
      while (!this.match(end)) {
        const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive);
            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }
            continue;
          }
          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
      if (!oldStrict) {
        this.setStrict(false);
      }
      this.next();
    }
    parseFor(node2, init) {
      node2.init = init;
      this.semicolon(false);
      node2.test = this.match(13) ? null : this.parseExpression();
      this.semicolon(false);
      node2.update = this.match(11) ? null : this.parseExpression();
      this.expect(11);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node2, "ForStatement");
    }
    parseForIn(node2, init, awaitAt) {
      const isForIn = this.match(58);
      this.next();
      if (isForIn) {
        if (awaitAt !== null)
          this.unexpected(awaitAt);
      } else {
        node2.await = awaitAt !== null;
      }
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(Errors.ForInOfLoopInitializer, {
          at: init,
          type: isForIn ? "ForInStatement" : "ForOfStatement"
        });
      }
      if (init.type === "AssignmentPattern") {
        this.raise(Errors.InvalidLhs, {
          at: init,
          ancestor: {
            type: "ForStatement"
          }
        });
      }
      node2.left = init;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(11);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node2, isFor, kind, allowMissingInitializer = false) {
      const declarations = node2.declarations = [];
      node2.kind = kind;
      for (;; ) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);
        decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        if (decl.init === null && !allowMissingInitializer) {
          if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
            this.raise(Errors.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc,
              kind: "destructuring"
            });
          } else if (kind === "const" && !(this.match(58) || this.isContextual(102))) {
            this.raise(Errors.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc,
              kind: "const"
            });
          }
        }
        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(12))
          break;
      }
      return node2;
    }
    parseVarId(decl, kind) {
      const id = this.parseBindingAtom();
      this.checkLVal(id, {
        in: {
          type: "VariableDeclarator"
        },
        binding: kind === "var" ? 5 : 8201
      });
      decl.id = id;
    }
    parseAsyncFunctionExpression(node2) {
      return this.parseFunction(node2, 8);
    }
    parseFunction(node2, flags = 0) {
      const hangingDeclaration = flags & 2;
      const isDeclaration = !!(flags & 1);
      const requireId = isDeclaration && !(flags & 4);
      const isAsync2 = !!(flags & 8);
      this.initFunction(node2, isAsync2);
      if (this.match(55)) {
        if (hangingDeclaration) {
          this.raise(Errors.GeneratorInSingleStatementContext, {
            at: this.state.startLoc
          });
        }
        this.next();
        node2.generator = true;
      }
      if (isDeclaration) {
        node2.id = this.parseFunctionId(requireId);
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(2);
      this.prodParam.enter(functionFlags(isAsync2, node2.generator));
      if (!isDeclaration) {
        node2.id = this.parseFunctionId();
      }
      this.parseFunctionParams(node2, false);
      this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node2, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();
      if (isDeclaration && !hangingDeclaration) {
        this.registerFunctionStatementId(node2);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node2;
    }
    parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node2, isConstructor) {
      this.expect(10);
      this.expressionScope.enter(newParameterDeclarationScope());
      node2.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
      this.expressionScope.exit();
    }
    registerFunctionStatementId(node2) {
      if (!node2.id)
        return;
      this.scope.declareName(node2.id.name, !this.options.annexB || this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node2.id.loc.start);
    }
    parseClass(node2, isStatement, optionalId) {
      this.next();
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node2, isStatement, optionalId);
      this.parseClassSuper(node2);
      node2.body = this.parseClassBody(!!node2.superClass, oldStrict);
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }
    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: false,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(5);
      this.withSmartMixTopicForbiddingContext(() => {
        while (!this.match(8)) {
          if (this.eat(13)) {
            if (decorators.length > 0) {
              throw this.raise(Errors.DecoratorSemicolon, {
                at: this.state.lastTokEndLoc
              });
            }
            continue;
          }
          if (this.match(26)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }
          this.parseClassMember(classBody, member, state);
          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            this.raise(Errors.DecoratorConstructor, {
              at: member
            });
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();
      if (decorators.length) {
        throw this.raise(Errors.TrailingDecorator, {
          at: this.state.startLoc
        });
      }
      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }
      this.resetPreviousNodeTrailingComments(key);
      return false;
    }
    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual(106);
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const accessorProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;
      this.parsePropertyNamePrefixOperator(member);
      if (this.eat(55)) {
        method.kind = "method";
        const isPrivateName = this.match(138);
        this.parseClassElementName(method);
        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsGenerator, {
            at: publicMethod.key
          });
        }
        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }
      const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
      const isPrivate = this.match(138);
      const key = this.parseClassElementName(member);
      const maybeQuestionTokenStartLoc = this.state.startLoc;
      this.parsePostMemberNameModifiers(publicMember);
      if (this.isClassMethod()) {
        method.kind = "method";
        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;
        if (isConstructor) {
          publicMethod.kind = "constructor";
          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(Errors.DuplicateConstructor, {
              at: key
            });
          }
          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(Errors.OverrideOnConstructor, {
              at: key
            });
          }
          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }
        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        const isGenerator = this.eat(55);
        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStartLoc);
        }
        method.kind = "method";
        const isPrivate2 = this.match(138);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAsync, {
              at: publicMethod.key
            });
          }
          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = key.name;
        const isPrivate2 = this.match(138);
        this.parseClassElementName(publicMethod);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAccessor, {
              at: publicMethod.key
            });
          }
          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }
        this.checkGetterSetterParams(publicMethod);
      } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors");
        this.resetPreviousNodeTrailingComments(key);
        const isPrivate2 = this.match(138);
        this.parseClassElementName(publicProp);
        this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
    parseClassElementName(member) {
      const {
        type,
        value: value2
      } = this.state;
      if ((type === 132 || type === 133) && member.static && value2 === "prototype") {
        this.raise(Errors.StaticPrototype, {
          at: this.state.startLoc
        });
      }
      if (type === 138) {
        if (value2 === "constructor") {
          this.raise(Errors.ConstructorClassPrivateField, {
            at: this.state.startLoc
          });
        }
        const key = this.parsePrivateName();
        member.key = key;
        return key;
      }
      return this.parsePropertyName(member);
    }
    parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.scope.enter(64 | 128 | 16);
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(0);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));
      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(Errors.DecoratorStaticBlock, {
          at: member
        });
      }
    }
    pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(Errors.ConstructorClassField, {
          at: prop.key
        });
      }
      classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      const node2 = this.parseClassPrivateProperty(prop);
      classBody.body.push(node2);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
    }
    pushClassAccessorProperty(classBody, prop, isPrivate) {
      if (!isPrivate && !prop.computed) {
        const key = prop.key;
        if (key.name === "constructor" || key.value === "constructor") {
          this.raise(Errors.ConstructorClassField, {
            at: key
          });
        }
      }
      const node2 = this.parseClassAccessorProperty(prop);
      classBody.body.push(node2);
      if (isPrivate) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
      }
    }
    pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync2, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync2) {
      const node2 = this.parseMethod(method, isGenerator, isAsync2, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node2);
      const kind = node2.kind === "get" ? node2.static ? 6 : 2 : node2.kind === "set" ? node2.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(node2, kind);
    }
    declareClassPrivateMethodInScope(node2, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node2) {
      this.parseInitializer(node2);
      this.semicolon();
      return this.finishNode(node2, "ClassPrivateProperty");
    }
    parseClassProperty(node2) {
      this.parseInitializer(node2);
      this.semicolon();
      return this.finishNode(node2, "ClassProperty");
    }
    parseClassAccessorProperty(node2) {
      this.parseInitializer(node2);
      this.semicolon();
      return this.finishNode(node2, "ClassAccessorProperty");
    }
    parseInitializer(node2) {
      this.scope.enter(64 | 16);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(0);
      node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }
    parseClassId(node2, isStatement, optionalId, bindingType = 8331) {
      if (tokenIsIdentifier(this.state.type)) {
        node2.id = this.parseIdentifier();
        if (isStatement) {
          this.declareNameFromIdentifier(node2.id, bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node2.id = null;
        } else {
          throw this.raise(Errors.MissingClassName, {
            at: this.state.startLoc
          });
        }
      }
    }
    parseClassSuper(node2) {
      node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(node2, decorators) {
      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, true);
      const hasDefault = this.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
      const parseAfterDefault = !hasDefault || this.eat(12);
      const hasStar = parseAfterDefault && this.eatExportStar(node2);
      const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2);
      const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
      const isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault)
          this.unexpected();
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, {
            at: node2
          });
        }
        this.parseExportFrom(node2, true);
        return this.finishNode(node2, "ExportAllDeclaration");
      }
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
        this.unexpected(null, 5);
      }
      if (hasNamespace && parseAfterNamespace) {
        this.unexpected(null, 98);
      }
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, {
            at: node2
          });
        }
        this.parseExportFrom(node2, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node2);
      }
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        var _node2$declaration;
        const node22 = node2;
        this.checkExport(node22, true, false, !!node22.source);
        if (((_node2$declaration = node22.declaration) == null ? undefined : _node2$declaration.type) === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, node22.declaration, node22);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, {
            at: node2
          });
        }
        return this.finishNode(node22, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const node22 = node2;
        const decl = this.parseExportDefaultExpression();
        node22.declaration = decl;
        if (decl.type === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, decl, node22);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, {
            at: node2
          });
        }
        this.checkExport(node22, true, true);
        return this.finishNode(node22, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(node2) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? undefined : maybeDefaultIdentifier.loc.start);
        const id = maybeDefaultIdentifier || this.parseIdentifier(true);
        const specifier = this.startNodeAtNode(id);
        specifier.exported = id;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node2) {
      if (this.isContextual(93)) {
        if (!node2.specifiers)
          node2.specifiers = [];
        const specifier = this.startNodeAt(this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(node2) {
      if (this.match(5)) {
        if (!node2.specifiers)
          node2.specifiers = [];
        const isTypeExport = node2.exportKind === "type";
        node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
        node2.source = null;
        node2.declaration = null;
        if (this.hasPlugin("importAssertions")) {
          node2.assertions = [];
        }
        return true;
      }
      return false;
    }
    maybeParseExportDeclaration(node2) {
      if (this.shouldParseExportDeclaration()) {
        node2.specifiers = [];
        node2.source = null;
        if (this.hasPlugin("importAssertions")) {
          node2.assertions = [];
        }
        node2.declaration = this.parseExportDeclaration(node2);
        return true;
      }
      return false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      const next = this.nextTokenInLineStart();
      return this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode();
      if (this.match(68)) {
        this.next();
        return this.parseFunction(expr, 1 | 4);
      } else if (this.isAsyncFunction()) {
        this.next();
        this.next();
        return this.parseFunction(expr, 1 | 4 | 8);
      }
      if (this.match(80)) {
        return this.parseClass(expr, true, true);
      }
      if (this.match(26)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
          this.raise(Errors.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        }
        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      }
      if (this.match(75) || this.match(74) || this.isLet()) {
        throw this.raise(Errors.UnsupportedDefaultExport, {
          at: this.state.startLoc
        });
      }
      const res = this.parseMaybeAssignAllowIn();
      this.semicolon();
      return res;
    }
    parseExportDeclaration(node2) {
      if (this.match(80)) {
        const node3 = this.parseClass(this.startNode(), true, false);
        return node3;
      }
      return this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type
      } = this.state;
      if (tokenIsIdentifier(type)) {
        if (type === 95 && !this.state.containsEsc || type === 100) {
          return false;
        }
        if ((type === 130 || type === 129) && !this.state.containsEsc) {
          const {
            type: nextType
          } = this.lookahead();
          if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(65)) {
        return false;
      }
      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
        return true;
      }
      if (this.match(65) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return false;
    }
    parseExportFrom(node2, expect) {
      if (this.eatContextual(98)) {
        node2.source = this.parseImportSource();
        this.checkExport(node2);
        this.maybeParseImportAttributes(node2);
        this.checkJSONModuleImport(node2);
      } else if (expect) {
        this.unexpected();
      }
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type
      } = this.state;
      if (type === 26) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, {
              at: this.state.startLoc
            });
          }
          return true;
        }
      }
      return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node2, checkNames, isDefault, isFrom) {
      if (checkNames) {
        var _node$specifiers;
        if (isDefault) {
          this.checkDuplicateExports(node2, "default");
          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            const declaration = node2.declaration;
            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(Errors.ExportDefaultFromAsIdentifier, {
                at: declaration
              });
            }
          }
        } else if ((_node$specifiers = node2.specifiers) != null && _node$specifiers.length) {
          for (const specifier of node2.specifiers) {
            const {
              exported
            } = specifier;
            const exportName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportName);
            if (!isFrom && specifier.local) {
              const {
                local
              } = specifier;
              if (local.type !== "Identifier") {
                this.raise(Errors.ExportBindingIsString, {
                  at: specifier,
                  localName: local.value,
                  exportName
                });
              } else {
                this.checkReservedWord(local.name, local.loc.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node2.declaration) {
          if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
            const id = node2.declaration.id;
            if (!id)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(node2, id.name);
          } else if (node2.declaration.type === "VariableDeclaration") {
            for (const declaration of node2.declaration.declarations) {
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }
    }
    checkDeclaration(node2) {
      if (node2.type === "Identifier") {
        this.checkDuplicateExports(node2, node2.name);
      } else if (node2.type === "ObjectPattern") {
        for (const prop of node2.properties) {
          this.checkDeclaration(prop);
        }
      } else if (node2.type === "ArrayPattern") {
        for (const elem of node2.elements) {
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node2.type === "ObjectProperty") {
        this.checkDeclaration(node2.value);
      } else if (node2.type === "RestElement") {
        this.checkDeclaration(node2.argument);
      } else if (node2.type === "AssignmentPattern") {
        this.checkDeclaration(node2.left);
      }
    }
    checkDuplicateExports(node2, exportName) {
      if (this.exportedIdentifiers.has(exportName)) {
        if (exportName === "default") {
          this.raise(Errors.DuplicateDefaultExport, {
            at: node2
          });
        } else {
          this.raise(Errors.DuplicateExport, {
            at: node2,
            exportName
          });
        }
      }
      this.exportedIdentifiers.add(exportName);
    }
    parseExportSpecifiers(isInTypeExport) {
      const nodes = [];
      let first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.eat(8))
            break;
        }
        const isMaybeTypeOnly = this.isContextual(130);
        const isString = this.match(133);
        const node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        nodes.push(this.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly));
      }
      return nodes;
    }
    parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
      if (this.eatContextual(93)) {
        node2.exported = this.parseModuleExportName();
      } else if (isString) {
        node2.exported = cloneStringLiteral(node2.local);
      } else if (!node2.exported) {
        node2.exported = cloneIdentifier(node2.local);
      }
      return this.finishNode(node2, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        const result = this.parseStringLiteral(this.state.value);
        const surrogate = result.value.match(loneSurrogate);
        if (surrogate) {
          this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
            at: result,
            surrogateCharCode: surrogate[0].charCodeAt(0)
          });
        }
        return result;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(node2) {
      if (node2.assertions != null) {
        return node2.assertions.some(({
          key,
          value: value2
        }) => {
          return value2.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
        });
      }
      return false;
    }
    checkImportReflection(node2) {
      const {
        specifiers
      } = node2;
      const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
      if (node2.phase === "source") {
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.SourcePhaseImportRequiresDefault, {
            at: specifiers[0].loc.start
          });
        }
      } else if (node2.phase === "defer") {
        if (singleBindingType !== "ImportNamespaceSpecifier") {
          this.raise(Errors.DeferImportRequiresNamespace, {
            at: specifiers[0].loc.start
          });
        }
      } else if (node2.module) {
        var _node$assertions;
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.ImportReflectionNotBinding, {
            at: specifiers[0].loc.start
          });
        }
        if (((_node$assertions = node2.assertions) == null ? undefined : _node$assertions.length) > 0) {
          this.raise(Errors.ImportReflectionHasAssertion, {
            at: node2.specifiers[0].loc.start
          });
        }
      }
    }
    checkJSONModuleImport(node2) {
      if (this.isJSONModuleImport(node2) && node2.type !== "ExportAllDeclaration") {
        const {
          specifiers
        } = node2;
        if (specifiers != null) {
          const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
            let imported;
            if (specifier.type === "ExportSpecifier") {
              imported = specifier.local;
            } else if (specifier.type === "ImportSpecifier") {
              imported = specifier.imported;
            }
            if (imported !== undefined) {
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
            }
          });
          if (nonDefaultNamedSpecifier !== undefined) {
            this.raise(Errors.ImportJSONBindingNotDefault, {
              at: nonDefaultNamedSpecifier.loc.start
            });
          }
        }
      }
    }
    isPotentialImportPhase(isExport) {
      if (isExport)
        return false;
      return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      if (isExport) {
        return;
      }
      if (phase === "module") {
        this.expectPlugin("importReflection", loc);
        node2.module = true;
      } else if (this.hasPlugin("importReflection")) {
        node2.module = false;
      }
      if (phase === "source") {
        this.expectPlugin("sourcePhaseImports", loc);
        node2.phase = "source";
      } else if (phase === "defer") {
        this.expectPlugin("deferredImportEvaluation", loc);
        node2.phase = "defer";
      } else if (this.hasPlugin("sourcePhaseImports")) {
        node2.phase = null;
      }
    }
    parseMaybeImportPhase(node2, isExport) {
      if (!this.isPotentialImportPhase(isExport)) {
        this.applyImportPhase(node2, isExport, null);
        return null;
      }
      const phaseIdentifier = this.parseIdentifier(true);
      const {
        type
      } = this.state;
      const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      if (isImportPhase) {
        this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
        this.applyImportPhase(node2, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
        return null;
      } else {
        this.applyImportPhase(node2, isExport, null);
        return phaseIdentifier;
      }
    }
    isPrecedingIdImportPhase(phase) {
      const {
        type
      } = this.state;
      return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    }
    parseImport(node2) {
      if (this.match(133)) {
        return this.parseImportSourceAndAttributes(node2);
      }
      return this.parseImportSpecifiersAndAfter(node2, this.parseMaybeImportPhase(node2, false));
    }
    parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier) {
      node2.specifiers = [];
      const hasDefault = this.maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier);
      const parseNext = !hasDefault || this.eat(12);
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
      if (parseNext && !hasStar)
        this.parseNamedImportSpecifiers(node2);
      this.expectContextual(98);
      return this.parseImportSourceAndAttributes(node2);
    }
    parseImportSourceAndAttributes(node2) {
      var _node$specifiers2;
      (_node$specifiers2 = node2.specifiers) != null || (node2.specifiers = []);
      node2.source = this.parseImportSource();
      this.maybeParseImportAttributes(node2);
      this.checkImportReflection(node2);
      this.checkJSONModuleImport(node2);
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    }
    parseImportSource() {
      if (!this.match(133))
        this.unexpected();
      return this.parseExprAtom();
    }
    parseImportSpecifierLocal(node2, specifier, type) {
      specifier.local = this.parseIdentifier();
      node2.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    finishImportSpecifier(specifier, type, bindingType = 8201) {
      this.checkLVal(specifier.local, {
        in: {
          type
        },
        binding: bindingType
      });
      return this.finishNode(specifier, type);
    }
    parseImportAttributes() {
      this.expect(5);
      const attrs = [];
      const attrNames = new Set;
      do {
        if (this.match(8)) {
          break;
        }
        const node2 = this.startNode();
        const keyName = this.state.value;
        if (attrNames.has(keyName)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
            at: this.state.startLoc,
            key: keyName
          });
        }
        attrNames.add(keyName);
        if (this.match(133)) {
          node2.key = this.parseStringLiteral(keyName);
        } else {
          node2.key = this.parseIdentifier(true);
        }
        this.expect(14);
        if (!this.match(133)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        }
        node2.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node2, "ImportAttribute"));
      } while (this.eat(12));
      this.expect(8);
      return attrs;
    }
    parseModuleAttributes() {
      const attrs = [];
      const attributes = new Set;
      do {
        const node2 = this.startNode();
        node2.key = this.parseIdentifier(true);
        if (node2.key.name !== "type") {
          this.raise(Errors.ModuleAttributeDifferentFromType, {
            at: node2.key
          });
        }
        if (attributes.has(node2.key.name)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
            at: node2.key,
            key: node2.key.name
          });
        }
        attributes.add(node2.key.name);
        this.expect(14);
        if (!this.match(133)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        }
        node2.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node2, "ImportAttribute"));
      } while (this.eat(12));
      return attrs;
    }
    maybeParseImportAttributes(node2) {
      let attributes;
      let useWith = false;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
          return;
        }
        this.next();
        {
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
          } else {
            this.expectImportAttributesPlugin();
            attributes = this.parseImportAttributes();
          }
        }
        useWith = true;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
        if (this.hasPlugin("importAttributes")) {
          if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
            this.raise(Errors.ImportAttributesUseAssert, {
              at: this.state.startLoc
            });
          }
          this.addExtra(node2, "deprecatedAssertSyntax", true);
        } else {
          this.expectOnePlugin(["importAttributes", "importAssertions"]);
        }
        this.next();
        attributes = this.parseImportAttributes();
      } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        attributes = [];
      } else {
        if (this.hasPlugin("moduleAttributes")) {
          attributes = [];
        } else
          return;
      }
      if (!useWith && this.hasPlugin("importAssertions")) {
        node2.assertions = attributes;
      } else {
        node2.attributes = attributes;
      }
    }
    maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier) {
        const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
        specifier.local = maybeDefaultIdentifier;
        node2.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
        return true;
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier");
        return true;
      }
      return false;
    }
    maybeParseStarImportSpecifier(node2) {
      if (this.match(55)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual(93);
        this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier");
        return true;
      }
      return false;
    }
    parseNamedImportSpecifiers(node2) {
      let first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(14)) {
            throw this.raise(Errors.DestructureNamedImport, {
              at: this.state.startLoc
            });
          }
          this.expect(12);
          if (this.eat(8))
            break;
        }
        const specifier = this.startNode();
        const importedIsString = this.match(133);
        const isMaybeTypeOnly = this.isContextual(130);
        specifier.imported = this.parseModuleExportName();
        const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node2.importKind === "type" || node2.importKind === "typeof", isMaybeTypeOnly, undefined);
        node2.specifiers.push(importSpecifier);
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        const {
          imported
        } = specifier;
        if (importedIsString) {
          throw this.raise(Errors.ImportBindingIsString, {
            at: specifier,
            importName: imported.value
          });
        }
        this.checkReservedWord(imported.name, specifier.loc.start, true, true);
        if (!specifier.local) {
          specifier.local = cloneIdentifier(imported);
        }
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }

  class Parser2 extends StatementParser {
    constructor(options, input) {
      options = getOptions(options);
      super(options, input);
      this.options = options;
      this.initializeScopes();
      this.plugins = pluginsMap(this.options.plugins);
      this.filename = options.sourceFilename;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      this.enterInitialScopes();
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  }
  var tokTypes = generateExportedTokenTypes(tt);
  var parserClassCache = {};
  exports.parse = parse2;
  exports.parseExpression = parseExpression;
  exports.tokTypes = tokTypes;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = undefined;
  var ReferencedIdentifier = exports.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
  var ReferencedMemberExpression = exports.ReferencedMemberExpression = ["MemberExpression"];
  var BindingIdentifier = exports.BindingIdentifier = ["Identifier"];
  var Statement = exports.Statement = ["Statement"];
  var Expression = exports.Expression = ["Expression"];
  var Scope = exports.Scope = ["Scopable", "Pattern"];
  var Referenced = exports.Referenced = null;
  var BlockScoped = exports.BlockScoped = null;
  var Var = exports.Var = ["VariableDeclaration"];
  var User = exports.User = null;
  var Generated = exports.Generated = null;
  var Pure = exports.Pure = null;
  var Flow = exports.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
  var RestProperty = exports.RestProperty = ["RestElement"];
  var SpreadProperty = exports.SpreadProperty = ["RestElement"];
  var ExistentialTypeParam = exports.ExistentialTypeParam = ["ExistsTypeAnnotation"];
  var NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
  var ForAwaitStatement = exports.ForAwaitStatement = ["ForOfStatement"];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS((exports) => {
  var isReferencedIdentifier = function(opts) {
    const {
      node: node2,
      parent
    } = this;
    if (!isIdentifier(node2, opts) && !isJSXMemberExpression(parent, opts)) {
      if (isJSXIdentifier(node2, opts)) {
        if (isCompatTag(node2.name))
          return false;
      } else {
        return false;
      }
    }
    return nodeIsReferenced(node2, parent, this.parentPath.parent);
  };
  var isReferencedMemberExpression = function() {
    const {
      node: node2,
      parent
    } = this;
    return isMemberExpression(node2) && nodeIsReferenced(node2, parent);
  };
  var isBindingIdentifier = function() {
    const {
      node: node2,
      parent
    } = this;
    const grandparent = this.parentPath.parent;
    return isIdentifier(node2) && isBinding(node2, parent, grandparent);
  };
  var isStatement = function() {
    const {
      node: node2,
      parent
    } = this;
    if (nodeIsStatement(node2)) {
      if (isVariableDeclaration(node2)) {
        if (isForXStatement(parent, {
          left: node2
        }))
          return false;
        if (isForStatement(parent, {
          init: node2
        }))
          return false;
      }
      return true;
    } else {
      return false;
    }
  };
  var isExpression = function() {
    if (this.isIdentifier()) {
      return this.isReferencedIdentifier();
    } else {
      return nodeIsExpression(this.node);
    }
  };
  var isScope = function() {
    return nodeIsScope(this.node, this.parent);
  };
  var isReferenced = function() {
    return nodeIsReferenced(this.node, this.parent);
  };
  var isBlockScoped = function() {
    return nodeIsBlockScoped(this.node);
  };
  var isVar = function() {
    return nodeIsVar(this.node);
  };
  var isUser = function() {
    return this.node && !!this.node.loc;
  };
  var isGenerated = function() {
    return !this.isUser();
  };
  var isPure = function(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
  };
  var isFlow = function() {
    const {
      node: node2
    } = this;
    if (nodeIsFlow(node2)) {
      return true;
    } else if (isImportDeclaration(node2)) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    } else if (isExportDeclaration(node2)) {
      return node2.exportKind === "type";
    } else if (isImportSpecifier(node2)) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    } else {
      return false;
    }
  };
  var isRestProperty = function() {
    return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  };
  var isSpreadProperty = function() {
    return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  };
  var isForAwaitStatement = function() {
    return isForOfStatement(this.node, {
      await: true
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isBindingIdentifier = isBindingIdentifier;
  exports.isBlockScoped = isBlockScoped;
  exports.isExpression = isExpression;
  exports.isFlow = isFlow;
  exports.isForAwaitStatement = isForAwaitStatement;
  exports.isGenerated = isGenerated;
  exports.isPure = isPure;
  exports.isReferenced = isReferenced;
  exports.isReferencedIdentifier = isReferencedIdentifier;
  exports.isReferencedMemberExpression = isReferencedMemberExpression;
  exports.isRestProperty = isRestProperty;
  exports.isScope = isScope;
  exports.isSpreadProperty = isSpreadProperty;
  exports.isStatement = isStatement;
  exports.isUser = isUser;
  exports.isVar = isVar;
  var _t = require_lib3();
  var {
    isBinding,
    isBlockScoped: nodeIsBlockScoped,
    isExportDeclaration,
    isExpression: nodeIsExpression,
    isFlow: nodeIsFlow,
    isForStatement,
    isForXStatement,
    isIdentifier,
    isImportDeclaration,
    isImportSpecifier,
    isJSXIdentifier,
    isJSXMemberExpression,
    isMemberExpression,
    isRestElement: nodeIsRestElement,
    isReferenced: nodeIsReferenced,
    isScope: nodeIsScope,
    isStatement: nodeIsStatement,
    isVar: nodeIsVar,
    isVariableDeclaration,
    react,
    isForOfStatement
  } = _t;
  var {
    isCompatTag
  } = react;
  {
    exports.isExistentialTypeParam = function isExistentialTypeParam() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    };
    exports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS((exports) => {
  var isVirtualType = function(type) {
    return type in virtualTypes;
  };
  var isExplodedVisitor = function(visitor) {
    return visitor == null ? undefined : visitor._exploded;
  };
  var explode = function(visitor) {
    if (isExplodedVisitor(visitor))
      return visitor;
    visitor._exploded = true;
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      const parts = nodeType.split("|");
      if (parts.length === 1)
        continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const part of parts) {
        visitor[part] = fns;
      }
    }
    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      if (!isVirtualType(nodeType))
        continue;
      const fns = visitor[nodeType];
      for (const type of Object.keys(fns)) {
        fns[type] = wrapCheck(nodeType, fns[type]);
      }
      delete visitor[nodeType];
      const types = virtualTypes[nodeType];
      if (types !== null) {
        for (const type of types) {
          if (visitor[type]) {
            mergePair(visitor[type], fns);
          } else {
            visitor[type] = fns;
          }
        }
      } else {
        mergePair(visitor, fns);
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      let aliases = FLIPPED_ALIAS_KEYS[nodeType];
      if (nodeType in DEPRECATED_KEYS) {
        const deprecatedKey = DEPRECATED_KEYS[nodeType];
        deprecationWarning(nodeType, deprecatedKey, "Visitor ");
        aliases = [deprecatedKey];
      } else if (nodeType in DEPRECATED_ALIASES) {
        const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
        deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
        aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
      }
      if (!aliases)
        continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const alias of aliases) {
        const existing = visitor[alias];
        if (existing) {
          mergePair(existing, fns);
        } else {
          visitor[alias] = Object.assign({}, fns);
        }
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      ensureCallbackArrays(visitor[nodeType]);
    }
    return visitor;
  };
  var verify = function(visitor) {
    if (visitor._verified)
      return;
    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
    }
    for (const nodeType of Object.keys(visitor)) {
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType))
        continue;
      if (TYPES.indexOf(nodeType) < 0) {
        throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
      }
      const visitors = visitor[nodeType];
      if (typeof visitors === "object") {
        for (const visitorKey of Object.keys(visitors)) {
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + `${nodeType} that has the invalid property ${visitorKey}`);
          }
        }
      }
    }
    visitor._verified = true;
  };
  var validateVisitorMethods = function(path3, val) {
    const fns = [].concat(val);
    for (const fn of fns) {
      if (typeof fn !== "function") {
        throw new TypeError(`Non-function found defined in ${path3} with type ${typeof fn}`);
      }
    }
  };
  var merge = function(visitors, states = [], wrapper) {
    const mergedVisitor = {};
    for (let i = 0;i < visitors.length; i++) {
      const visitor = explode(visitors[i]);
      const state = states[i];
      let topVisitor = visitor;
      if (state || wrapper) {
        topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
      }
      mergePair(mergedVisitor, topVisitor);
      for (const key of Object.keys(visitor)) {
        if (shouldIgnoreKey(key))
          continue;
        let typeVisitor = visitor[key];
        if (state || wrapper) {
          typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
        }
        const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
        mergePair(nodeVisitor, typeVisitor);
      }
    }
    return mergedVisitor;
  };
  var wrapWithStateOrWrapper = function(oldVisitor, state, wrapper) {
    const newVisitor = {};
    for (const phase of ["enter", "exit"]) {
      let fns = oldVisitor[phase];
      if (!Array.isArray(fns))
        continue;
      fns = fns.map(function(fn) {
        let newFn = fn;
        if (state) {
          newFn = function(path3) {
            fn.call(state, path3, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state == null ? undefined : state.key, phase, newFn);
        }
        if (newFn !== fn) {
          newFn.toString = () => fn.toString();
        }
        return newFn;
      });
      newVisitor[phase] = fns;
    }
    return newVisitor;
  };
  var ensureEntranceObjects = function(obj) {
    for (const key of Object.keys(obj)) {
      if (shouldIgnoreKey(key))
        continue;
      const fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  };
  var ensureCallbackArrays = function(obj) {
    if (obj.enter && !Array.isArray(obj.enter))
      obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit))
      obj.exit = [obj.exit];
  };
  var wrapCheck = function(nodeType, fn) {
    const fnKey = `is${nodeType}`;
    const validator2 = virtualTypesValidators[fnKey];
    const newFn = function(path3) {
      if (validator2.call(path3)) {
        return fn.apply(this, arguments);
      }
    };
    newFn.toString = () => fn.toString();
    return newFn;
  };
  var shouldIgnoreKey = function(key) {
    if (key[0] === "_")
      return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip")
      return true;
    if (key === "denylist" || key === "noScope" || key === "skipKeys") {
      return true;
    }
    {
      if (key === "blacklist") {
        return true;
      }
    }
    return false;
  };
  var mergePair = function(dest, src) {
    for (const phase of ["enter", "exit"]) {
      if (!src[phase])
        continue;
      dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.explode = explode;
  exports.isExplodedVisitor = isExplodedVisitor;
  exports.merge = merge;
  exports.verify = verify;
  var virtualTypes = require_virtual_types();
  var virtualTypesValidators = require_virtual_types_validator();
  var _t = require_lib3();
  var {
    DEPRECATED_KEYS,
    DEPRECATED_ALIASES,
    FLIPPED_ALIAS_KEYS,
    TYPES,
    __internal__deprecationWarning: deprecationWarning
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS((exports) => {
  var clear = function() {
    clearPath();
    clearScope();
  };
  var clearPath = function() {
    exports.path = pathsCache = new WeakMap;
  };
  var clearScope = function() {
    exports.scope = scope = new WeakMap;
  };
  var getCachedPaths = function(hub, parent) {
    var _pathsCache$get, _hub;
    {
      hub = null;
    }
    return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? undefined : _pathsCache$get.get(parent);
  };
  var getOrCreateCachedPaths = function(hub, parent) {
    var _hub2, _hub3;
    {
      hub = null;
    }
    let parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);
    if (!parents)
      pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = new WeakMap);
    let paths = parents.get(parent);
    if (!paths)
      parents.set(parent, paths = new Map);
    return paths;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.clear = clear;
  exports.clearPath = clearPath;
  exports.clearScope = clearScope;
  exports.getCachedPaths = getCachedPaths;
  exports.getOrCreateCachedPaths = getOrCreateCachedPaths;
  exports.scope = exports.path = undefined;
  var pathsCache = exports.path = new WeakMap;
  var scope = exports.scope = new WeakMap;
  var nullHub = Object.freeze({});
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse2 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  var setup = function(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format3];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  };
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env: env2 } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = __require("tty");
  var util2 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-split-export-declaration/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var splitExportDeclaration = function(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {
      throw new Error("Only default and named export declarations can be split.");
    }
    if (exportDeclaration.isExportDefaultDeclaration()) {
      const declaration2 = exportDeclaration.get("declaration");
      const standaloneDeclaration = declaration2.isFunctionDeclaration() || declaration2.isClassDeclaration();
      const exportExpr = declaration2.isFunctionExpression() || declaration2.isClassExpression();
      const scope = declaration2.isScope() ? declaration2.scope.parent : declaration2.scope;
      let id = declaration2.node.id;
      let needBindingRegistration = false;
      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");
        if (standaloneDeclaration || exportExpr) {
          declaration2.node.id = cloneNode(id);
        }
      } else if (exportExpr && scope.hasBinding(id.name)) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier(id.name);
      }
      const updatedDeclaration = standaloneDeclaration ? declaration2.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration2.node)]);
      const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
      exportDeclaration.insertAfter(updatedExportDeclaration);
      exportDeclaration.replaceWith(updatedDeclaration);
      if (needBindingRegistration) {
        scope.registerDeclaration(exportDeclaration);
      }
      return exportDeclaration;
    } else if (exportDeclaration.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const declaration = exportDeclaration.get("declaration");
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    const specifiers = Object.keys(bindingIdentifiers).map((name) => {
      return exportSpecifier(identifier(name), identifier(name));
    });
    const aliasDeclar = exportNamedDeclaration(null, specifiers);
    exportDeclaration.insertAfter(aliasDeclar);
    exportDeclaration.replaceWith(declaration.node);
    return exportDeclaration;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = splitExportDeclaration;
  var _t = require_lib3();
  var {
    cloneNode,
    exportNamedDeclaration,
    exportSpecifier,
    identifier,
    variableDeclaration,
    variableDeclarator
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-environment-visitor/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var requeueComputedKeyAndDecorators = function(path3) {
    const {
      context,
      node: node2
    } = path3;
    if (node2.computed) {
      context.maybeQueue(path3.get("key"));
    }
    if (node2.decorators) {
      for (const decorator of path3.get("decorators")) {
        context.maybeQueue(decorator);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
  {
    exports.skipAllButComputedKey = function skipAllButComputedKey(path3) {
      path3.skip();
      if (path3.node.computed) {
        path3.context.maybeQueue(path3.get("key"));
      }
    };
  }
  var visitor = {
    FunctionParent(path3) {
      if (path3.isArrowFunctionExpression()) {
        return;
      } else {
        path3.skip();
        if (path3.isMethod()) {
          requeueComputedKeyAndDecorators(path3);
        }
      }
    },
    Property(path3) {
      if (path3.isObjectProperty()) {
        return;
      }
      path3.skip();
      requeueComputedKeyAndDecorators(path3);
    }
  };
  var _default = visitor;
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _helperSplitExportDeclaration = require_lib5();
  var t = require_lib3();
  var _helperEnvironmentVisitor = require_lib6();
  var _traverseNode = require_traverse_node();
  var _visitors = require_visitors();
  var renameVisitor = {
    ReferencedIdentifier({
      node: node2
    }, state) {
      if (node2.name === state.oldName) {
        node2.name = state.newName;
      }
    },
    Scope(path3, state) {
      if (!path3.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path3.skip();
        if (path3.isMethod()) {
          (0, _helperEnvironmentVisitor.requeueComputedKeyAndDecorators)(path3);
        }
      }
    },
    ObjectProperty({
      node: node2,
      scope
    }, state) {
      const {
        name
      } = node2.key;
      if (node2.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
        var _node$extra;
        node2.shorthand = false;
        if ((_node$extra = node2.extra) != null && _node$extra.shorthand)
          node2.extra.shorthand = false;
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(path3, state) {
      if (path3.isVariableDeclaration())
        return;
      const ids = path3.getOuterBindingIdentifiers();
      for (const name in ids) {
        if (name === state.oldName)
          ids[name].name = state.newName;
      }
    }
  };

  class Renamer {
    constructor(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }
    maybeConvertFromExportDeclaration(parentDeclar) {
      const maybeExportDeclar = parentDeclar.parentPath;
      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }
      if (maybeExportDeclar.isExportDefaultDeclaration()) {
        const {
          declaration
        } = maybeExportDeclar.node;
        if (t.isDeclaration(declaration) && !declaration.id) {
          return;
        }
      }
      if (maybeExportDeclar.isExportAllDeclaration()) {
        return;
      }
      (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
    }
    maybeConvertFromClassFunctionDeclaration(path3) {
      return path3;
    }
    maybeConvertFromClassFunctionExpression(path3) {
      return path3;
    }
    rename() {
      const {
        binding,
        oldName,
        newName
      } = this;
      const {
        scope,
        path: path3
      } = binding;
      const parentDeclar = path3.find((path4) => path4.isDeclaration() || path4.isFunctionExpression() || path4.isClassExpression());
      if (parentDeclar) {
        const bindingIds = parentDeclar.getOuterBindingIdentifiers();
        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }
      const blockToTraverse = arguments[0] || scope.block;
      (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, {
        discriminant: true
      });
      if (!arguments[0]) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }
      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(path3);
        this.maybeConvertFromClassFunctionExpression(path3);
      }
    }
  }
  exports.default = Renamer;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS((exports) => {
  var isDeclaredInLoop = function(path3) {
    for (let {
      parentPath,
      key
    } = path3;parentPath; {
      parentPath,
      key
    } = parentPath) {
      if (parentPath.isFunctionParent())
        return false;
      if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
        return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class Binding {
    constructor({
      identifier,
      scope,
      path: path3,
      kind
    }) {
      this.identifier = undefined;
      this.scope = undefined;
      this.path = undefined;
      this.kind = undefined;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path3;
      this.kind = kind;
      if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path3)) {
        this.reassign(path3);
      }
      this.clearValue();
    }
    deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    }
    setValue(value2) {
      if (this.hasDeoptedValue)
        return;
      this.hasValue = true;
      this.value = value2;
    }
    clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    }
    reassign(path3) {
      this.constant = false;
      if (this.constantViolations.indexOf(path3) !== -1) {
        return;
      }
      this.constantViolations.push(path3);
    }
    reference(path3) {
      if (this.referencePaths.indexOf(path3) !== -1) {
        return;
      }
      this.referenced = true;
      this.references++;
      this.referencePaths.push(path3);
    }
    dereference() {
      this.references--;
      this.referenced = !!this.references;
    }
  }
  exports.default = Binding;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/node_modules/globals/globals.json
var require_globals = __commonJS((exports, module) => {
  module.exports = {
    builtin: {
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      globalThis: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es5: {
      Array: false,
      Boolean: false,
      constructor: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      propertyIsEnumerable: false,
      RangeError: false,
      ReferenceError: false,
      RegExp: false,
      String: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false
    },
    es2015: {
      Array: false,
      ArrayBuffer: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es2017: {
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    browser: {
      AbortController: false,
      AbortSignal: false,
      addEventListener: false,
      alert: false,
      AnalyserNode: false,
      Animation: false,
      AnimationEffectReadOnly: false,
      AnimationEffectTiming: false,
      AnimationEffectTimingReadOnly: false,
      AnimationEvent: false,
      AnimationPlaybackEvent: false,
      AnimationTimeline: false,
      applicationCache: false,
      ApplicationCache: false,
      ApplicationCacheErrorEvent: false,
      atob: false,
      Attr: false,
      Audio: false,
      AudioBuffer: false,
      AudioBufferSourceNode: false,
      AudioContext: false,
      AudioDestinationNode: false,
      AudioListener: false,
      AudioNode: false,
      AudioParam: false,
      AudioProcessingEvent: false,
      AudioScheduledSourceNode: false,
      "AudioWorkletGlobalScope ": false,
      AudioWorkletNode: false,
      AudioWorkletProcessor: false,
      BarProp: false,
      BaseAudioContext: false,
      BatteryManager: false,
      BeforeUnloadEvent: false,
      BiquadFilterNode: false,
      Blob: false,
      BlobEvent: false,
      blur: false,
      BroadcastChannel: false,
      btoa: false,
      BudgetService: false,
      ByteLengthQueuingStrategy: false,
      Cache: false,
      caches: false,
      CacheStorage: false,
      cancelAnimationFrame: false,
      cancelIdleCallback: false,
      CanvasCaptureMediaStreamTrack: false,
      CanvasGradient: false,
      CanvasPattern: false,
      CanvasRenderingContext2D: false,
      ChannelMergerNode: false,
      ChannelSplitterNode: false,
      CharacterData: false,
      clearInterval: false,
      clearTimeout: false,
      clientInformation: false,
      ClipboardEvent: false,
      close: false,
      closed: false,
      CloseEvent: false,
      Comment: false,
      CompositionEvent: false,
      confirm: false,
      console: false,
      ConstantSourceNode: false,
      ConvolverNode: false,
      CountQueuingStrategy: false,
      createImageBitmap: false,
      Credential: false,
      CredentialsContainer: false,
      crypto: false,
      Crypto: false,
      CryptoKey: false,
      CSS: false,
      CSSConditionRule: false,
      CSSFontFaceRule: false,
      CSSGroupingRule: false,
      CSSImportRule: false,
      CSSKeyframeRule: false,
      CSSKeyframesRule: false,
      CSSMediaRule: false,
      CSSNamespaceRule: false,
      CSSPageRule: false,
      CSSRule: false,
      CSSRuleList: false,
      CSSStyleDeclaration: false,
      CSSStyleRule: false,
      CSSStyleSheet: false,
      CSSSupportsRule: false,
      CustomElementRegistry: false,
      customElements: false,
      CustomEvent: false,
      DataTransfer: false,
      DataTransferItem: false,
      DataTransferItemList: false,
      defaultstatus: false,
      defaultStatus: false,
      DelayNode: false,
      DeviceMotionEvent: false,
      DeviceOrientationEvent: false,
      devicePixelRatio: false,
      dispatchEvent: false,
      document: false,
      Document: false,
      DocumentFragment: false,
      DocumentType: false,
      DOMError: false,
      DOMException: false,
      DOMImplementation: false,
      DOMMatrix: false,
      DOMMatrixReadOnly: false,
      DOMParser: false,
      DOMPoint: false,
      DOMPointReadOnly: false,
      DOMQuad: false,
      DOMRect: false,
      DOMRectReadOnly: false,
      DOMStringList: false,
      DOMStringMap: false,
      DOMTokenList: false,
      DragEvent: false,
      DynamicsCompressorNode: false,
      Element: false,
      ErrorEvent: false,
      event: false,
      Event: false,
      EventSource: false,
      EventTarget: false,
      external: false,
      fetch: false,
      File: false,
      FileList: false,
      FileReader: false,
      find: false,
      focus: false,
      FocusEvent: false,
      FontFace: false,
      FontFaceSetLoadEvent: false,
      FormData: false,
      frameElement: false,
      frames: false,
      GainNode: false,
      Gamepad: false,
      GamepadButton: false,
      GamepadEvent: false,
      getComputedStyle: false,
      getSelection: false,
      HashChangeEvent: false,
      Headers: false,
      history: false,
      History: false,
      HTMLAllCollection: false,
      HTMLAnchorElement: false,
      HTMLAreaElement: false,
      HTMLAudioElement: false,
      HTMLBaseElement: false,
      HTMLBodyElement: false,
      HTMLBRElement: false,
      HTMLButtonElement: false,
      HTMLCanvasElement: false,
      HTMLCollection: false,
      HTMLContentElement: false,
      HTMLDataElement: false,
      HTMLDataListElement: false,
      HTMLDetailsElement: false,
      HTMLDialogElement: false,
      HTMLDirectoryElement: false,
      HTMLDivElement: false,
      HTMLDListElement: false,
      HTMLDocument: false,
      HTMLElement: false,
      HTMLEmbedElement: false,
      HTMLFieldSetElement: false,
      HTMLFontElement: false,
      HTMLFormControlsCollection: false,
      HTMLFormElement: false,
      HTMLFrameElement: false,
      HTMLFrameSetElement: false,
      HTMLHeadElement: false,
      HTMLHeadingElement: false,
      HTMLHRElement: false,
      HTMLHtmlElement: false,
      HTMLIFrameElement: false,
      HTMLImageElement: false,
      HTMLInputElement: false,
      HTMLLabelElement: false,
      HTMLLegendElement: false,
      HTMLLIElement: false,
      HTMLLinkElement: false,
      HTMLMapElement: false,
      HTMLMarqueeElement: false,
      HTMLMediaElement: false,
      HTMLMenuElement: false,
      HTMLMetaElement: false,
      HTMLMeterElement: false,
      HTMLModElement: false,
      HTMLObjectElement: false,
      HTMLOListElement: false,
      HTMLOptGroupElement: false,
      HTMLOptionElement: false,
      HTMLOptionsCollection: false,
      HTMLOutputElement: false,
      HTMLParagraphElement: false,
      HTMLParamElement: false,
      HTMLPictureElement: false,
      HTMLPreElement: false,
      HTMLProgressElement: false,
      HTMLQuoteElement: false,
      HTMLScriptElement: false,
      HTMLSelectElement: false,
      HTMLShadowElement: false,
      HTMLSlotElement: false,
      HTMLSourceElement: false,
      HTMLSpanElement: false,
      HTMLStyleElement: false,
      HTMLTableCaptionElement: false,
      HTMLTableCellElement: false,
      HTMLTableColElement: false,
      HTMLTableElement: false,
      HTMLTableRowElement: false,
      HTMLTableSectionElement: false,
      HTMLTemplateElement: false,
      HTMLTextAreaElement: false,
      HTMLTimeElement: false,
      HTMLTitleElement: false,
      HTMLTrackElement: false,
      HTMLUListElement: false,
      HTMLUnknownElement: false,
      HTMLVideoElement: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      IdleDeadline: false,
      IIRFilterNode: false,
      Image: false,
      ImageBitmap: false,
      ImageBitmapRenderingContext: false,
      ImageCapture: false,
      ImageData: false,
      indexedDB: false,
      innerHeight: false,
      innerWidth: false,
      InputEvent: false,
      IntersectionObserver: false,
      IntersectionObserverEntry: false,
      Intl: false,
      isSecureContext: false,
      KeyboardEvent: false,
      KeyframeEffect: false,
      KeyframeEffectReadOnly: false,
      length: false,
      localStorage: false,
      location: true,
      Location: false,
      locationbar: false,
      matchMedia: false,
      MediaDeviceInfo: false,
      MediaDevices: false,
      MediaElementAudioSourceNode: false,
      MediaEncryptedEvent: false,
      MediaError: false,
      MediaKeyMessageEvent: false,
      MediaKeySession: false,
      MediaKeyStatusMap: false,
      MediaKeySystemAccess: false,
      MediaList: false,
      MediaQueryList: false,
      MediaQueryListEvent: false,
      MediaRecorder: false,
      MediaSettingsRange: false,
      MediaSource: false,
      MediaStream: false,
      MediaStreamAudioDestinationNode: false,
      MediaStreamAudioSourceNode: false,
      MediaStreamEvent: false,
      MediaStreamTrack: false,
      MediaStreamTrackEvent: false,
      menubar: false,
      MessageChannel: false,
      MessageEvent: false,
      MessagePort: false,
      MIDIAccess: false,
      MIDIConnectionEvent: false,
      MIDIInput: false,
      MIDIInputMap: false,
      MIDIMessageEvent: false,
      MIDIOutput: false,
      MIDIOutputMap: false,
      MIDIPort: false,
      MimeType: false,
      MimeTypeArray: false,
      MouseEvent: false,
      moveBy: false,
      moveTo: false,
      MutationEvent: false,
      MutationObserver: false,
      MutationRecord: false,
      name: false,
      NamedNodeMap: false,
      NavigationPreloadManager: false,
      navigator: false,
      Navigator: false,
      NetworkInformation: false,
      Node: false,
      NodeFilter: false,
      NodeIterator: false,
      NodeList: false,
      Notification: false,
      OfflineAudioCompletionEvent: false,
      OfflineAudioContext: false,
      offscreenBuffering: false,
      OffscreenCanvas: true,
      onabort: true,
      onafterprint: true,
      onanimationend: true,
      onanimationiteration: true,
      onanimationstart: true,
      onappinstalled: true,
      onauxclick: true,
      onbeforeinstallprompt: true,
      onbeforeprint: true,
      onbeforeunload: true,
      onblur: true,
      oncancel: true,
      oncanplay: true,
      oncanplaythrough: true,
      onchange: true,
      onclick: true,
      onclose: true,
      oncontextmenu: true,
      oncuechange: true,
      ondblclick: true,
      ondevicemotion: true,
      ondeviceorientation: true,
      ondeviceorientationabsolute: true,
      ondrag: true,
      ondragend: true,
      ondragenter: true,
      ondragleave: true,
      ondragover: true,
      ondragstart: true,
      ondrop: true,
      ondurationchange: true,
      onemptied: true,
      onended: true,
      onerror: true,
      onfocus: true,
      ongotpointercapture: true,
      onhashchange: true,
      oninput: true,
      oninvalid: true,
      onkeydown: true,
      onkeypress: true,
      onkeyup: true,
      onlanguagechange: true,
      onload: true,
      onloadeddata: true,
      onloadedmetadata: true,
      onloadstart: true,
      onlostpointercapture: true,
      onmessage: true,
      onmessageerror: true,
      onmousedown: true,
      onmouseenter: true,
      onmouseleave: true,
      onmousemove: true,
      onmouseout: true,
      onmouseover: true,
      onmouseup: true,
      onmousewheel: true,
      onoffline: true,
      ononline: true,
      onpagehide: true,
      onpageshow: true,
      onpause: true,
      onplay: true,
      onplaying: true,
      onpointercancel: true,
      onpointerdown: true,
      onpointerenter: true,
      onpointerleave: true,
      onpointermove: true,
      onpointerout: true,
      onpointerover: true,
      onpointerup: true,
      onpopstate: true,
      onprogress: true,
      onratechange: true,
      onrejectionhandled: true,
      onreset: true,
      onresize: true,
      onscroll: true,
      onsearch: true,
      onseeked: true,
      onseeking: true,
      onselect: true,
      onstalled: true,
      onstorage: true,
      onsubmit: true,
      onsuspend: true,
      ontimeupdate: true,
      ontoggle: true,
      ontransitionend: true,
      onunhandledrejection: true,
      onunload: true,
      onvolumechange: true,
      onwaiting: true,
      onwheel: true,
      open: false,
      openDatabase: false,
      opener: false,
      Option: false,
      origin: false,
      OscillatorNode: false,
      outerHeight: false,
      outerWidth: false,
      PageTransitionEvent: false,
      pageXOffset: false,
      pageYOffset: false,
      PannerNode: false,
      parent: false,
      Path2D: false,
      PaymentAddress: false,
      PaymentRequest: false,
      PaymentRequestUpdateEvent: false,
      PaymentResponse: false,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceLongTaskTiming: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceNavigationTiming: false,
      PerformanceObserver: false,
      PerformanceObserverEntryList: false,
      PerformancePaintTiming: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      PeriodicWave: false,
      Permissions: false,
      PermissionStatus: false,
      personalbar: false,
      PhotoCapabilities: false,
      Plugin: false,
      PluginArray: false,
      PointerEvent: false,
      PopStateEvent: false,
      postMessage: false,
      Presentation: false,
      PresentationAvailability: false,
      PresentationConnection: false,
      PresentationConnectionAvailableEvent: false,
      PresentationConnectionCloseEvent: false,
      PresentationConnectionList: false,
      PresentationReceiver: false,
      PresentationRequest: false,
      print: false,
      ProcessingInstruction: false,
      ProgressEvent: false,
      PromiseRejectionEvent: false,
      prompt: false,
      PushManager: false,
      PushSubscription: false,
      PushSubscriptionOptions: false,
      queueMicrotask: false,
      RadioNodeList: false,
      Range: false,
      ReadableStream: false,
      registerProcessor: false,
      RemotePlayback: false,
      removeEventListener: false,
      Request: false,
      requestAnimationFrame: false,
      requestIdleCallback: false,
      resizeBy: false,
      ResizeObserver: false,
      ResizeObserverEntry: false,
      resizeTo: false,
      Response: false,
      RTCCertificate: false,
      RTCDataChannel: false,
      RTCDataChannelEvent: false,
      RTCDtlsTransport: false,
      RTCIceCandidate: false,
      RTCIceGatherer: false,
      RTCIceTransport: false,
      RTCPeerConnection: false,
      RTCPeerConnectionIceEvent: false,
      RTCRtpContributingSource: false,
      RTCRtpReceiver: false,
      RTCRtpSender: false,
      RTCSctpTransport: false,
      RTCSessionDescription: false,
      RTCStatsReport: false,
      RTCTrackEvent: false,
      screen: false,
      Screen: false,
      screenLeft: false,
      ScreenOrientation: false,
      screenTop: false,
      screenX: false,
      screenY: false,
      ScriptProcessorNode: false,
      scroll: false,
      scrollbars: false,
      scrollBy: false,
      scrollTo: false,
      scrollX: false,
      scrollY: false,
      SecurityPolicyViolationEvent: false,
      Selection: false,
      self: false,
      ServiceWorker: false,
      ServiceWorkerContainer: false,
      ServiceWorkerRegistration: false,
      sessionStorage: false,
      setInterval: false,
      setTimeout: false,
      ShadowRoot: false,
      SharedWorker: false,
      SourceBuffer: false,
      SourceBufferList: false,
      speechSynthesis: false,
      SpeechSynthesisEvent: false,
      SpeechSynthesisUtterance: false,
      StaticRange: false,
      status: false,
      statusbar: false,
      StereoPannerNode: false,
      stop: false,
      Storage: false,
      StorageEvent: false,
      StorageManager: false,
      styleMedia: false,
      StyleSheet: false,
      StyleSheetList: false,
      SubtleCrypto: false,
      SVGAElement: false,
      SVGAngle: false,
      SVGAnimatedAngle: false,
      SVGAnimatedBoolean: false,
      SVGAnimatedEnumeration: false,
      SVGAnimatedInteger: false,
      SVGAnimatedLength: false,
      SVGAnimatedLengthList: false,
      SVGAnimatedNumber: false,
      SVGAnimatedNumberList: false,
      SVGAnimatedPreserveAspectRatio: false,
      SVGAnimatedRect: false,
      SVGAnimatedString: false,
      SVGAnimatedTransformList: false,
      SVGAnimateElement: false,
      SVGAnimateMotionElement: false,
      SVGAnimateTransformElement: false,
      SVGAnimationElement: false,
      SVGCircleElement: false,
      SVGClipPathElement: false,
      SVGComponentTransferFunctionElement: false,
      SVGDefsElement: false,
      SVGDescElement: false,
      SVGDiscardElement: false,
      SVGElement: false,
      SVGEllipseElement: false,
      SVGFEBlendElement: false,
      SVGFEColorMatrixElement: false,
      SVGFEComponentTransferElement: false,
      SVGFECompositeElement: false,
      SVGFEConvolveMatrixElement: false,
      SVGFEDiffuseLightingElement: false,
      SVGFEDisplacementMapElement: false,
      SVGFEDistantLightElement: false,
      SVGFEDropShadowElement: false,
      SVGFEFloodElement: false,
      SVGFEFuncAElement: false,
      SVGFEFuncBElement: false,
      SVGFEFuncGElement: false,
      SVGFEFuncRElement: false,
      SVGFEGaussianBlurElement: false,
      SVGFEImageElement: false,
      SVGFEMergeElement: false,
      SVGFEMergeNodeElement: false,
      SVGFEMorphologyElement: false,
      SVGFEOffsetElement: false,
      SVGFEPointLightElement: false,
      SVGFESpecularLightingElement: false,
      SVGFESpotLightElement: false,
      SVGFETileElement: false,
      SVGFETurbulenceElement: false,
      SVGFilterElement: false,
      SVGForeignObjectElement: false,
      SVGGElement: false,
      SVGGeometryElement: false,
      SVGGradientElement: false,
      SVGGraphicsElement: false,
      SVGImageElement: false,
      SVGLength: false,
      SVGLengthList: false,
      SVGLinearGradientElement: false,
      SVGLineElement: false,
      SVGMarkerElement: false,
      SVGMaskElement: false,
      SVGMatrix: false,
      SVGMetadataElement: false,
      SVGMPathElement: false,
      SVGNumber: false,
      SVGNumberList: false,
      SVGPathElement: false,
      SVGPatternElement: false,
      SVGPoint: false,
      SVGPointList: false,
      SVGPolygonElement: false,
      SVGPolylineElement: false,
      SVGPreserveAspectRatio: false,
      SVGRadialGradientElement: false,
      SVGRect: false,
      SVGRectElement: false,
      SVGScriptElement: false,
      SVGSetElement: false,
      SVGStopElement: false,
      SVGStringList: false,
      SVGStyleElement: false,
      SVGSVGElement: false,
      SVGSwitchElement: false,
      SVGSymbolElement: false,
      SVGTextContentElement: false,
      SVGTextElement: false,
      SVGTextPathElement: false,
      SVGTextPositioningElement: false,
      SVGTitleElement: false,
      SVGTransform: false,
      SVGTransformList: false,
      SVGTSpanElement: false,
      SVGUnitTypes: false,
      SVGUseElement: false,
      SVGViewElement: false,
      TaskAttributionTiming: false,
      Text: false,
      TextDecoder: false,
      TextEncoder: false,
      TextEvent: false,
      TextMetrics: false,
      TextTrack: false,
      TextTrackCue: false,
      TextTrackCueList: false,
      TextTrackList: false,
      TimeRanges: false,
      toolbar: false,
      top: false,
      Touch: false,
      TouchEvent: false,
      TouchList: false,
      TrackEvent: false,
      TransitionEvent: false,
      TreeWalker: false,
      UIEvent: false,
      URL: false,
      URLSearchParams: false,
      ValidityState: false,
      visualViewport: false,
      VisualViewport: false,
      VTTCue: false,
      WaveShaperNode: false,
      WebAssembly: false,
      WebGL2RenderingContext: false,
      WebGLActiveInfo: false,
      WebGLBuffer: false,
      WebGLContextEvent: false,
      WebGLFramebuffer: false,
      WebGLProgram: false,
      WebGLQuery: false,
      WebGLRenderbuffer: false,
      WebGLRenderingContext: false,
      WebGLSampler: false,
      WebGLShader: false,
      WebGLShaderPrecisionFormat: false,
      WebGLSync: false,
      WebGLTexture: false,
      WebGLTransformFeedback: false,
      WebGLUniformLocation: false,
      WebGLVertexArrayObject: false,
      WebSocket: false,
      WheelEvent: false,
      window: false,
      Window: false,
      Worker: false,
      WritableStream: false,
      XMLDocument: false,
      XMLHttpRequest: false,
      XMLHttpRequestEventTarget: false,
      XMLHttpRequestUpload: false,
      XMLSerializer: false,
      XPathEvaluator: false,
      XPathExpression: false,
      XPathResult: false,
      XSLTProcessor: false
    },
    worker: {
      addEventListener: false,
      applicationCache: false,
      atob: false,
      Blob: false,
      BroadcastChannel: false,
      btoa: false,
      Cache: false,
      caches: false,
      clearInterval: false,
      clearTimeout: false,
      close: true,
      console: false,
      fetch: false,
      FileReaderSync: false,
      FormData: false,
      Headers: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      ImageData: false,
      importScripts: true,
      indexedDB: false,
      location: false,
      MessageChannel: false,
      MessagePort: false,
      name: false,
      navigator: false,
      Notification: false,
      onclose: true,
      onconnect: true,
      onerror: true,
      onlanguagechange: true,
      onmessage: true,
      onoffline: true,
      ononline: true,
      onrejectionhandled: true,
      onunhandledrejection: true,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      postMessage: true,
      Promise: false,
      queueMicrotask: false,
      removeEventListener: false,
      Request: false,
      Response: false,
      self: true,
      ServiceWorkerRegistration: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false,
      WebSocket: false,
      Worker: false,
      WorkerGlobalScope: false,
      XMLHttpRequest: false
    },
    node: {
      __dirname: false,
      __filename: false,
      Buffer: false,
      clearImmediate: false,
      clearInterval: false,
      clearTimeout: false,
      console: false,
      exports: true,
      global: false,
      Intl: false,
      module: false,
      process: false,
      queueMicrotask: false,
      require: false,
      setImmediate: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false
    },
    commonjs: {
      exports: true,
      global: false,
      module: false,
      require: false
    },
    amd: {
      define: false,
      require: false
    },
    mocha: {
      after: false,
      afterEach: false,
      before: false,
      beforeEach: false,
      context: false,
      describe: false,
      it: false,
      mocha: false,
      run: false,
      setup: false,
      specify: false,
      suite: false,
      suiteSetup: false,
      suiteTeardown: false,
      teardown: false,
      test: false,
      xcontext: false,
      xdescribe: false,
      xit: false,
      xspecify: false
    },
    jasmine: {
      afterAll: false,
      afterEach: false,
      beforeAll: false,
      beforeEach: false,
      describe: false,
      expect: false,
      fail: false,
      fdescribe: false,
      fit: false,
      it: false,
      jasmine: false,
      pending: false,
      runs: false,
      spyOn: false,
      spyOnProperty: false,
      waits: false,
      waitsFor: false,
      xdescribe: false,
      xit: false
    },
    jest: {
      afterAll: false,
      afterEach: false,
      beforeAll: false,
      beforeEach: false,
      describe: false,
      expect: false,
      fdescribe: false,
      fit: false,
      it: false,
      jest: false,
      pit: false,
      require: false,
      test: false,
      xdescribe: false,
      xit: false,
      xtest: false
    },
    qunit: {
      asyncTest: false,
      deepEqual: false,
      equal: false,
      expect: false,
      module: false,
      notDeepEqual: false,
      notEqual: false,
      notOk: false,
      notPropEqual: false,
      notStrictEqual: false,
      ok: false,
      propEqual: false,
      QUnit: false,
      raises: false,
      start: false,
      stop: false,
      strictEqual: false,
      test: false,
      throws: false
    },
    phantomjs: {
      console: true,
      exports: true,
      phantom: true,
      require: true,
      WebPage: true
    },
    couch: {
      emit: false,
      exports: false,
      getRow: false,
      log: false,
      module: false,
      provides: false,
      require: false,
      respond: false,
      send: false,
      start: false,
      sum: false
    },
    rhino: {
      defineClass: false,
      deserialize: false,
      gc: false,
      help: false,
      importClass: false,
      importPackage: false,
      java: false,
      load: false,
      loadClass: false,
      Packages: false,
      print: false,
      quit: false,
      readFile: false,
      readUrl: false,
      runCommand: false,
      seal: false,
      serialize: false,
      spawn: false,
      sync: false,
      toint32: false,
      version: false
    },
    nashorn: {
      __DIR__: false,
      __FILE__: false,
      __LINE__: false,
      com: false,
      edu: false,
      exit: false,
      java: false,
      Java: false,
      javafx: false,
      JavaImporter: false,
      javax: false,
      JSAdapter: false,
      load: false,
      loadWithNewGlobal: false,
      org: false,
      Packages: false,
      print: false,
      quit: false
    },
    wsh: {
      ActiveXObject: true,
      Enumerator: true,
      GetObject: true,
      ScriptEngine: true,
      ScriptEngineBuildVersion: true,
      ScriptEngineMajorVersion: true,
      ScriptEngineMinorVersion: true,
      VBArray: true,
      WScript: true,
      WSH: true,
      XDomainRequest: true
    },
    jquery: {
      $: false,
      jQuery: false
    },
    yui: {
      YAHOO: false,
      YAHOO_config: false,
      YUI: false,
      YUI_config: false
    },
    shelljs: {
      cat: false,
      cd: false,
      chmod: false,
      config: false,
      cp: false,
      dirs: false,
      echo: false,
      env: false,
      error: false,
      exec: false,
      exit: false,
      find: false,
      grep: false,
      ln: false,
      ls: false,
      mkdir: false,
      mv: false,
      popd: false,
      pushd: false,
      pwd: false,
      rm: false,
      sed: false,
      set: false,
      target: false,
      tempdir: false,
      test: false,
      touch: false,
      which: false
    },
    prototypejs: {
      $: false,
      $$: false,
      $A: false,
      $break: false,
      $continue: false,
      $F: false,
      $H: false,
      $R: false,
      $w: false,
      Abstract: false,
      Ajax: false,
      Autocompleter: false,
      Builder: false,
      Class: false,
      Control: false,
      Draggable: false,
      Draggables: false,
      Droppables: false,
      Effect: false,
      Element: false,
      Enumerable: false,
      Event: false,
      Field: false,
      Form: false,
      Hash: false,
      Insertion: false,
      ObjectRange: false,
      PeriodicalExecuter: false,
      Position: false,
      Prototype: false,
      Scriptaculous: false,
      Selector: false,
      Sortable: false,
      SortableObserver: false,
      Sound: false,
      Template: false,
      Toggle: false,
      Try: false
    },
    meteor: {
      _: false,
      $: false,
      Accounts: false,
      AccountsClient: false,
      AccountsCommon: false,
      AccountsServer: false,
      App: false,
      Assets: false,
      Blaze: false,
      check: false,
      Cordova: false,
      DDP: false,
      DDPRateLimiter: false,
      DDPServer: false,
      Deps: false,
      EJSON: false,
      Email: false,
      HTTP: false,
      Log: false,
      Match: false,
      Meteor: false,
      Mongo: false,
      MongoInternals: false,
      Npm: false,
      Package: false,
      Plugin: false,
      process: false,
      Random: false,
      ReactiveDict: false,
      ReactiveVar: false,
      Router: false,
      ServiceConfiguration: false,
      Session: false,
      share: false,
      Spacebars: false,
      Template: false,
      Tinytest: false,
      Tracker: false,
      UI: false,
      Utils: false,
      WebApp: false,
      WebAppInternals: false
    },
    mongo: {
      _isWindows: false,
      _rand: false,
      BulkWriteResult: false,
      cat: false,
      cd: false,
      connect: false,
      db: false,
      getHostName: false,
      getMemInfo: false,
      hostname: false,
      ISODate: false,
      listFiles: false,
      load: false,
      ls: false,
      md5sumFile: false,
      mkdir: false,
      Mongo: false,
      NumberInt: false,
      NumberLong: false,
      ObjectId: false,
      PlanCache: false,
      print: false,
      printjson: false,
      pwd: false,
      quit: false,
      removeFile: false,
      rs: false,
      sh: false,
      UUID: false,
      version: false,
      WriteResult: false
    },
    applescript: {
      $: false,
      Application: false,
      Automation: false,
      console: false,
      delay: false,
      Library: false,
      ObjC: false,
      ObjectSpecifier: false,
      Path: false,
      Progress: false,
      Ref: false
    },
    serviceworker: {
      addEventListener: false,
      applicationCache: false,
      atob: false,
      Blob: false,
      BroadcastChannel: false,
      btoa: false,
      Cache: false,
      caches: false,
      CacheStorage: false,
      clearInterval: false,
      clearTimeout: false,
      Client: false,
      clients: false,
      Clients: false,
      close: true,
      console: false,
      ExtendableEvent: false,
      ExtendableMessageEvent: false,
      fetch: false,
      FetchEvent: false,
      FileReaderSync: false,
      FormData: false,
      Headers: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      ImageData: false,
      importScripts: false,
      indexedDB: false,
      location: false,
      MessageChannel: false,
      MessagePort: false,
      name: false,
      navigator: false,
      Notification: false,
      onclose: true,
      onconnect: true,
      onerror: true,
      onfetch: true,
      oninstall: true,
      onlanguagechange: true,
      onmessage: true,
      onmessageerror: true,
      onnotificationclick: true,
      onnotificationclose: true,
      onoffline: true,
      ononline: true,
      onpush: true,
      onpushsubscriptionchange: true,
      onrejectionhandled: true,
      onsync: true,
      onunhandledrejection: true,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      postMessage: true,
      Promise: false,
      queueMicrotask: false,
      registration: false,
      removeEventListener: false,
      Request: false,
      Response: false,
      self: false,
      ServiceWorker: false,
      ServiceWorkerContainer: false,
      ServiceWorkerGlobalScope: false,
      ServiceWorkerMessageEvent: false,
      ServiceWorkerRegistration: false,
      setInterval: false,
      setTimeout: false,
      skipWaiting: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false,
      WebSocket: false,
      WindowClient: false,
      Worker: false,
      WorkerGlobalScope: false,
      XMLHttpRequest: false
    },
    atomtest: {
      advanceClock: false,
      fakeClearInterval: false,
      fakeClearTimeout: false,
      fakeSetInterval: false,
      fakeSetTimeout: false,
      resetTimeouts: false,
      waitsForPromise: false
    },
    embertest: {
      andThen: false,
      click: false,
      currentPath: false,
      currentRouteName: false,
      currentURL: false,
      fillIn: false,
      find: false,
      findAll: false,
      findWithAssert: false,
      keyEvent: false,
      pauseTest: false,
      resumeTest: false,
      triggerEvent: false,
      visit: false,
      wait: false
    },
    protractor: {
      $: false,
      $$: false,
      browser: false,
      by: false,
      By: false,
      DartObject: false,
      element: false,
      protractor: false
    },
    "shared-node-browser": {
      clearInterval: false,
      clearTimeout: false,
      console: false,
      setInterval: false,
      setTimeout: false,
      URL: false,
      URLSearchParams: false
    },
    webextensions: {
      browser: false,
      chrome: false,
      opr: false
    },
    greasemonkey: {
      cloneInto: false,
      createObjectIn: false,
      exportFunction: false,
      GM: false,
      GM_addStyle: false,
      GM_deleteValue: false,
      GM_getResourceText: false,
      GM_getResourceURL: false,
      GM_getValue: false,
      GM_info: false,
      GM_listValues: false,
      GM_log: false,
      GM_openInTab: false,
      GM_registerMenuCommand: false,
      GM_setClipboard: false,
      GM_setValue: false,
      GM_xmlhttpRequest: false,
      unsafeWindow: false
    },
    devtools: {
      $: false,
      $_: false,
      $$: false,
      $0: false,
      $1: false,
      $2: false,
      $3: false,
      $4: false,
      $x: false,
      chrome: false,
      clear: false,
      copy: false,
      debug: false,
      dir: false,
      dirxml: false,
      getEventListeners: false,
      inspect: false,
      keys: false,
      monitor: false,
      monitorEvents: false,
      profile: false,
      profileEnd: false,
      queryObjects: false,
      table: false,
      undebug: false,
      unmonitor: false,
      unmonitorEvents: false,
      values: false
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS((exports) => {
  var gatherNodeParts = function(node2, parts) {
    switch (node2 == null ? undefined : node2.type) {
      default:
        if (isImportDeclaration(node2) || isExportDeclaration(node2)) {
          var _node$specifiers;
          if ((isExportAllDeclaration(node2) || isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && node2.source) {
            gatherNodeParts(node2.source, parts);
          } else if ((isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && (_node$specifiers = node2.specifiers) != null && _node$specifiers.length) {
            for (const e of node2.specifiers)
              gatherNodeParts(e, parts);
          } else if ((isExportDefaultDeclaration(node2) || isExportNamedDeclaration(node2)) && node2.declaration) {
            gatherNodeParts(node2.declaration, parts);
          }
        } else if (isModuleSpecifier(node2)) {
          gatherNodeParts(node2.local, parts);
        } else if (isLiteral(node2) && !isNullLiteral(node2) && !isRegExpLiteral(node2) && !isTemplateLiteral(node2)) {
          parts.push(node2.value);
        }
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node2.object, parts);
        gatherNodeParts(node2.property, parts);
        break;
      case "Identifier":
      case "JSXIdentifier":
        parts.push(node2.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node2.callee, parts);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const e of node2.properties) {
          gatherNodeParts(e, parts);
        }
        break;
      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node2.argument, parts);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node2.key, parts);
        break;
      case "ThisExpression":
        parts.push("this");
        break;
      case "Super":
        parts.push("super");
        break;
      case "Import":
        parts.push("import");
        break;
      case "DoExpression":
        parts.push("do");
        break;
      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node2.argument, parts);
        break;
      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node2.argument, parts);
        break;
      case "AssignmentExpression":
        gatherNodeParts(node2.left, parts);
        break;
      case "VariableDeclarator":
        gatherNodeParts(node2.id, parts);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node2.id, parts);
        break;
      case "PrivateName":
        gatherNodeParts(node2.id, parts);
        break;
      case "ParenthesizedExpression":
        gatherNodeParts(node2.expression, parts);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node2.argument, parts);
        break;
      case "MetaProperty":
        gatherNodeParts(node2.meta, parts);
        gatherNodeParts(node2.property, parts);
        break;
      case "JSXElement":
        gatherNodeParts(node2.openingElement, parts);
        break;
      case "JSXOpeningElement":
        gatherNodeParts(node2.name, parts);
        break;
      case "JSXFragment":
        gatherNodeParts(node2.openingFragment, parts);
        break;
      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;
      case "JSXNamespacedName":
        gatherNodeParts(node2.namespace, parts);
        gatherNodeParts(node2.name, parts);
        break;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _renamer = require_renamer();
  var _index = require_lib13();
  var _binding = require_binding();
  var _globals = require_globals();
  var _t = require_lib3();
  var t = _t;
  var _cache = require_cache();
  var _visitors = require_visitors();
  var {
    NOT_LOCAL_BINDING,
    callExpression,
    cloneNode,
    getBindingIdentifiers,
    identifier,
    isArrayExpression,
    isBinary,
    isClass,
    isClassBody,
    isClassDeclaration,
    isExportAllDeclaration,
    isExportDefaultDeclaration,
    isExportNamedDeclaration,
    isFunctionDeclaration,
    isIdentifier,
    isImportDeclaration,
    isLiteral,
    isMethod,
    isModuleSpecifier,
    isNullLiteral,
    isObjectExpression,
    isProperty,
    isPureish,
    isRegExpLiteral,
    isSuper,
    isTaggedTemplateExpression,
    isTemplateLiteral,
    isThisExpression,
    isUnaryExpression,
    isVariableDeclaration,
    matchesPattern,
    memberExpression,
    numericLiteral,
    toIdentifier,
    variableDeclaration,
    variableDeclarator,
    isRecordExpression,
    isTupleExpression,
    isObjectProperty,
    isTopicReference,
    isMetaProperty,
    isPrivateName,
    isExportDeclaration,
    buildUndefinedNode
  } = _t;
  var collectorVisitor = {
    ForStatement(path3) {
      const declar = path3.get("init");
      if (declar.isVar()) {
        const {
          scope
        } = path3;
        const parentScope = scope.getFunctionParent() || scope.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    },
    Declaration(path3) {
      if (path3.isBlockScoped())
        return;
      if (path3.isImportDeclaration())
        return;
      if (path3.isExportDeclaration())
        return;
      const parent = path3.scope.getFunctionParent() || path3.scope.getProgramParent();
      parent.registerDeclaration(path3);
    },
    ImportDeclaration(path3) {
      const parent = path3.scope.getBlockParent();
      parent.registerDeclaration(path3);
    },
    ReferencedIdentifier(path3, state) {
      state.references.push(path3);
    },
    ForXStatement(path3, state) {
      const left2 = path3.get("left");
      if (left2.isPattern() || left2.isIdentifier()) {
        state.constantViolations.push(path3);
      } else if (left2.isVar()) {
        const {
          scope
        } = path3;
        const parentScope = scope.getFunctionParent() || scope.getProgramParent();
        parentScope.registerBinding("var", left2);
      }
    },
    ExportDeclaration: {
      exit(path3) {
        const {
          node: node2,
          scope
        } = path3;
        if (isExportAllDeclaration(node2))
          return;
        const declar = node2.declaration;
        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          const id = declar.id;
          if (!id)
            return;
          const binding = scope.getBinding(id.name);
          binding == null || binding.reference(path3);
        } else if (isVariableDeclaration(declar)) {
          for (const decl of declar.declarations) {
            for (const name of Object.keys(getBindingIdentifiers(decl))) {
              const binding = scope.getBinding(name);
              binding == null || binding.reference(path3);
            }
          }
        }
      }
    },
    LabeledStatement(path3) {
      path3.scope.getBlockParent().registerDeclaration(path3);
    },
    AssignmentExpression(path3, state) {
      state.assignments.push(path3);
    },
    UpdateExpression(path3, state) {
      state.constantViolations.push(path3);
    },
    UnaryExpression(path3, state) {
      if (path3.node.operator === "delete") {
        state.constantViolations.push(path3);
      }
    },
    BlockScoped(path3) {
      let scope = path3.scope;
      if (scope.path === path3)
        scope = scope.parent;
      const parent = scope.getBlockParent();
      parent.registerDeclaration(path3);
      if (path3.isClassDeclaration() && path3.node.id) {
        const id = path3.node.id;
        const name = id.name;
        path3.scope.bindings[name] = path3.scope.parent.getBinding(name);
      }
    },
    CatchClause(path3) {
      path3.scope.registerBinding("let", path3);
    },
    Function(path3) {
      const params = path3.get("params");
      for (const param of params) {
        path3.scope.registerBinding("param", param);
      }
      if (path3.isFunctionExpression() && path3.has("id") && !path3.get("id").node[NOT_LOCAL_BINDING]) {
        path3.scope.registerBinding("local", path3.get("id"), path3);
      }
    },
    ClassExpression(path3) {
      if (path3.has("id") && !path3.get("id").node[NOT_LOCAL_BINDING]) {
        path3.scope.registerBinding("local", path3);
      }
    }
  };
  var uid = 0;

  class Scope {
    constructor(path3) {
      this.uid = undefined;
      this.path = undefined;
      this.block = undefined;
      this.labels = undefined;
      this.inited = undefined;
      this.bindings = undefined;
      this.references = undefined;
      this.globals = undefined;
      this.uids = undefined;
      this.data = undefined;
      this.crawling = undefined;
      const {
        node: node2
      } = path3;
      const cached = _cache.scope.get(node2);
      if ((cached == null ? undefined : cached.path) === path3) {
        return cached;
      }
      _cache.scope.set(node2, this);
      this.uid = uid++;
      this.block = node2;
      this.path = path3;
      this.labels = new Map;
      this.inited = false;
    }
    get parent() {
      var _parent;
      let parent, path3 = this.path;
      do {
        const shouldSkip = path3.key === "key" || path3.listKey === "decorators";
        path3 = path3.parentPath;
        if (shouldSkip && path3.isMethod())
          path3 = path3.parentPath;
        if (path3 && path3.isScope())
          parent = path3;
      } while (path3 && !parent);
      return (_parent = parent) == null ? undefined : _parent.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(node2, opts, state) {
      (0, _index.default)(node2, opts, this, state, this.path);
    }
    generateDeclaredUidIdentifier(name) {
      const id = this.generateUidIdentifier(name);
      this.push({
        id
      });
      return cloneNode(id);
    }
    generateUidIdentifier(name) {
      return identifier(this.generateUid(name));
    }
    generateUid(name = "temp") {
      name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let uid2;
      let i = 1;
      do {
        uid2 = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
      const program = this.getProgramParent();
      program.references[uid2] = true;
      program.uids[uid2] = true;
      return uid2;
    }
    _generateUid(name, i) {
      let id = name;
      if (i > 1)
        id += i;
      return `_${id}`;
    }
    generateUidBasedOnNode(node2, defaultName) {
      const parts = [];
      gatherNodeParts(node2, parts);
      let id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(node2, defaultName) {
      return identifier(this.generateUidBasedOnNode(node2, defaultName));
    }
    isStatic(node2) {
      if (isThisExpression(node2) || isSuper(node2) || isTopicReference(node2)) {
        return true;
      }
      if (isIdentifier(node2)) {
        const binding = this.getBinding(node2.name);
        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node2.name);
        }
      }
      return false;
    }
    maybeGenerateMemoised(node2, dontPush) {
      if (this.isStatic(node2)) {
        return null;
      } else {
        const id = this.generateUidIdentifierBasedOnNode(node2);
        if (!dontPush) {
          this.push({
            id
          });
          return cloneNode(id);
        }
        return id;
      }
    }
    checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param")
        return;
      if (local.kind === "local")
        return;
      const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
      if (duplicate) {
        throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
      }
    }
    rename(oldName, newName) {
      const binding = this.getBinding(oldName);
      if (binding) {
        newName || (newName = this.generateUidIdentifier(oldName).name);
        const renamer = new _renamer.default(binding, oldName, newName);
        {
          renamer.rename(arguments[2]);
        }
      }
    }
    _renameFromMap(map, oldName, newName, value2) {
      if (map[oldName]) {
        map[newName] = value2;
        map[oldName] = null;
      }
    }
    dump() {
      const sep = "-".repeat(60);
      console.log(sep);
      let scope = this;
      do {
        console.log("#", scope.block.type);
        for (const name of Object.keys(scope.bindings)) {
          const binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);
      console.log(sep);
    }
    toArray(node2, i, arrayLikeIsIterable) {
      if (isIdentifier(node2)) {
        const binding = this.getBinding(node2.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node2;
        }
      }
      if (isArrayExpression(node2)) {
        return node2;
      }
      if (isIdentifier(node2, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node2]);
      }
      let helperName;
      const args = [node2];
      if (i === true) {
        helperName = "toConsumableArray";
      } else if (typeof i === "number") {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(this.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return callExpression(this.hub.addHelper(helperName), args);
    }
    hasLabel(name) {
      return !!this.getLabel(name);
    }
    getLabel(name) {
      return this.labels.get(name);
    }
    registerLabel(path3) {
      this.labels.set(path3.node.label.name, path3);
    }
    registerDeclaration(path3) {
      if (path3.isLabeledStatement()) {
        this.registerLabel(path3);
      } else if (path3.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path3.get("id"), path3);
      } else if (path3.isVariableDeclaration()) {
        const declarations = path3.get("declarations");
        const {
          kind
        } = path3.node;
        for (const declar of declarations) {
          this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
        }
      } else if (path3.isClassDeclaration()) {
        if (path3.node.declare)
          return;
        this.registerBinding("let", path3);
      } else if (path3.isImportDeclaration()) {
        const isTypeDeclaration = path3.node.importKind === "type" || path3.node.importKind === "typeof";
        const specifiers = path3.get("specifiers");
        for (const specifier of specifiers) {
          const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
          this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
        }
      } else if (path3.isExportDeclaration()) {
        const declar = path3.get("declaration");
        if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
          this.registerDeclaration(declar);
        }
      } else {
        this.registerBinding("unknown", path3);
      }
    }
    buildUndefinedNode() {
      return buildUndefinedNode();
    }
    registerConstantViolation(path3) {
      const ids = path3.getBindingIdentifiers();
      for (const name of Object.keys(ids)) {
        var _this$getBinding;
        (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path3);
      }
    }
    registerBinding(kind, path3, bindingPath = path3) {
      if (!kind)
        throw new ReferenceError("no `kind`");
      if (path3.isVariableDeclaration()) {
        const declarators = path3.get("declarations");
        for (const declar of declarators) {
          this.registerBinding(kind, declar);
        }
        return;
      }
      const parent = this.getProgramParent();
      const ids = path3.getOuterBindingIdentifiers(true);
      for (const name of Object.keys(ids)) {
        parent.references[name] = true;
        for (const id of ids[name]) {
          const local = this.getOwnBinding(name);
          if (local) {
            if (local.identifier === id)
              continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }
          if (local) {
            this.registerConstantViolation(bindingPath);
          } else {
            this.bindings[name] = new _binding.default({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind
            });
          }
        }
      }
    }
    addGlobal(node2) {
      this.globals[node2.name] = node2;
    }
    hasUid(name) {
      let scope = this;
      do {
        if (scope.uids[name])
          return true;
      } while (scope = scope.parent);
      return false;
    }
    hasGlobal(name) {
      let scope = this;
      do {
        if (scope.globals[name])
          return true;
      } while (scope = scope.parent);
      return false;
    }
    hasReference(name) {
      return !!this.getProgramParent().references[name];
    }
    isPure(node2, constantsOnly) {
      if (isIdentifier(node2)) {
        const binding = this.getBinding(node2.name);
        if (!binding)
          return false;
        if (constantsOnly)
          return binding.constant;
        return true;
      } else if (isThisExpression(node2) || isMetaProperty(node2) || isTopicReference(node2) || isPrivateName(node2)) {
        return true;
      } else if (isClass(node2)) {
        var _node$decorators;
        if (node2.superClass && !this.isPure(node2.superClass, constantsOnly)) {
          return false;
        }
        if (((_node$decorators = node2.decorators) == null ? undefined : _node$decorators.length) > 0) {
          return false;
        }
        return this.isPure(node2.body, constantsOnly);
      } else if (isClassBody(node2)) {
        for (const method of node2.body) {
          if (!this.isPure(method, constantsOnly))
            return false;
        }
        return true;
      } else if (isBinary(node2)) {
        return this.isPure(node2.left, constantsOnly) && this.isPure(node2.right, constantsOnly);
      } else if (isArrayExpression(node2) || isTupleExpression(node2)) {
        for (const elem of node2.elements) {
          if (elem !== null && !this.isPure(elem, constantsOnly))
            return false;
        }
        return true;
      } else if (isObjectExpression(node2) || isRecordExpression(node2)) {
        for (const prop of node2.properties) {
          if (!this.isPure(prop, constantsOnly))
            return false;
        }
        return true;
      } else if (isMethod(node2)) {
        var _node$decorators2;
        if (node2.computed && !this.isPure(node2.key, constantsOnly))
          return false;
        if (((_node$decorators2 = node2.decorators) == null ? undefined : _node$decorators2.length) > 0) {
          return false;
        }
        return true;
      } else if (isProperty(node2)) {
        var _node$decorators3;
        if (node2.computed && !this.isPure(node2.key, constantsOnly))
          return false;
        if (((_node$decorators3 = node2.decorators) == null ? undefined : _node$decorators3.length) > 0) {
          return false;
        }
        if (isObjectProperty(node2) || node2.static) {
          if (node2.value !== null && !this.isPure(node2.value, constantsOnly)) {
            return false;
          }
        }
        return true;
      } else if (isUnaryExpression(node2)) {
        return this.isPure(node2.argument, constantsOnly);
      } else if (isTaggedTemplateExpression(node2)) {
        return matchesPattern(node2.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node2.quasi, constantsOnly);
      } else if (isTemplateLiteral(node2)) {
        for (const expression of node2.expressions) {
          if (!this.isPure(expression, constantsOnly))
            return false;
        }
        return true;
      } else {
        return isPureish(node2);
      }
    }
    setData(key, val) {
      return this.data[key] = val;
    }
    getData(key) {
      let scope = this;
      do {
        const data = scope.data[key];
        if (data != null)
          return data;
      } while (scope = scope.parent);
    }
    removeData(key) {
      let scope = this;
      do {
        const data = scope.data[key];
        if (data != null)
          scope.data[key] = null;
      } while (scope = scope.parent);
    }
    init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    }
    crawl() {
      const path3 = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);
      const programParent = this.getProgramParent();
      if (programParent.crawling)
        return;
      const state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      if (path3.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
        for (const visit2 of collectorVisitor.enter) {
          visit2.call(state, path3, state);
        }
        const typeVisitors = collectorVisitor[path3.type];
        if (typeVisitors) {
          for (const visit2 of typeVisitors.enter) {
            visit2.call(state, path3, state);
          }
        }
      }
      path3.traverse(collectorVisitor, state);
      this.crawling = false;
      for (const path4 of state.assignments) {
        const ids = path4.getBindingIdentifiers();
        for (const name of Object.keys(ids)) {
          if (path4.scope.getBinding(name))
            continue;
          programParent.addGlobal(ids[name]);
        }
        path4.scope.registerConstantViolation(path4);
      }
      for (const ref of state.references) {
        const binding = ref.scope.getBinding(ref.node.name);
        if (binding) {
          binding.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }
      for (const path4 of state.constantViolations) {
        path4.scope.registerConstantViolation(path4);
      }
    }
    push(opts) {
      let path3 = this.path;
      if (path3.isPattern()) {
        path3 = this.getPatternParent().path;
      } else if (!path3.isBlockStatement() && !path3.isProgram()) {
        path3 = this.getBlockParent().path;
      }
      if (path3.isSwitchStatement()) {
        path3 = (this.getFunctionParent() || this.getProgramParent()).path;
      }
      const {
        init,
        unique,
        kind = "var",
        id
      } = opts;
      if (!init && !unique && (kind === "var" || kind === "let") && path3.isFunction() && !path3.node.name && t.isCallExpression(path3.parent, {
        callee: path3.node
      }) && path3.parent.arguments.length <= path3.node.params.length && t.isIdentifier(id)) {
        path3.pushContainer("params", id);
        path3.scope.registerBinding("param", path3.get("params")[path3.node.params.length - 1]);
        return;
      }
      if (path3.isLoop() || path3.isCatchClause() || path3.isFunction()) {
        path3.ensureBlock();
        path3 = path3.get("body");
      }
      const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      const dataKey = `declaration:${kind}:${blockHoist}`;
      let declarPath = !unique && path3.getData(dataKey);
      if (!declarPath) {
        const declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;
        [declarPath] = path3.unshiftContainer("body", [declar]);
        if (!unique)
          path3.setData(dataKey, declarPath);
      }
      const declarator = variableDeclarator(id, init);
      const len = declarPath.node.declarations.push(declarator);
      path3.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
    }
    getProgramParent() {
      let scope = this;
      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let scope = this;
      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);
      return null;
    }
    getBlockParent() {
      let scope = this;
      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let scope = this;
      do {
        if (!scope.path.isPattern()) {
          return scope.getBlockParent();
        }
      } while (scope = scope.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const ids = Object.create(null);
      let scope = this;
      do {
        for (const key of Object.keys(scope.bindings)) {
          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }
        scope = scope.parent;
      } while (scope);
      return ids;
    }
    getAllBindingsOfKind(...kinds) {
      const ids = Object.create(null);
      for (const kind of kinds) {
        let scope = this;
        do {
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            if (binding.kind === kind)
              ids[name] = binding;
          }
          scope = scope.parent;
        } while (scope);
      }
      return ids;
    }
    bindingIdentifierEquals(name, node2) {
      return this.getBindingIdentifier(name) === node2;
    }
    getBinding(name) {
      let scope = this;
      let previousPath;
      do {
        const binding = scope.getOwnBinding(name);
        if (binding) {
          var _previousPath;
          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
          } else {
            return binding;
          }
        } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
          break;
        }
        previousPath = scope.path;
      } while (scope = scope.parent);
    }
    getOwnBinding(name) {
      return this.bindings[name];
    }
    getBindingIdentifier(name) {
      var _this$getBinding2;
      return (_this$getBinding2 = this.getBinding(name)) == null ? undefined : _this$getBinding2.identifier;
    }
    getOwnBindingIdentifier(name) {
      const binding = this.bindings[name];
      return binding == null ? undefined : binding.identifier;
    }
    hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
    hasBinding(name, opts) {
      var _opts, _opts2, _opts3;
      if (!name)
        return false;
      if (this.hasOwnBinding(name))
        return true;
      {
        if (typeof opts === "boolean")
          opts = {
            noGlobals: opts
          };
      }
      if (this.parentHasBinding(name, opts))
        return true;
      if (!((_opts = opts) != null && _opts.noUids) && this.hasUid(name))
        return true;
      if (!((_opts2 = opts) != null && _opts2.noGlobals) && Scope.globals.includes(name))
        return true;
      if (!((_opts3 = opts) != null && _opts3.noGlobals) && Scope.contextVariables.includes(name))
        return true;
      return false;
    }
    parentHasBinding(name, opts) {
      var _this$parent;
      return (_this$parent = this.parent) == null ? undefined : _this$parent.hasBinding(name, opts);
    }
    moveBindingTo(name, scope) {
      const info = this.getBinding(name);
      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    }
    removeOwnBinding(name) {
      delete this.bindings[name];
    }
    removeBinding(name) {
      var _this$getBinding3;
      (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
      let scope = this;
      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    }
  }
  exports.default = Scope;
  Scope.globals = Object.keys(_globals.builtin);
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
  })(exports, function(exports2) {
    exports2.get = undefined;
    exports2.put = undefined;
    exports2.pop = undefined;

    class SetArray {
      constructor() {
        this._indexes = { __proto__: null };
        this.array = [];
      }
    }
    (() => {
      exports2.get = (strarr, key) => strarr._indexes[key];
      exports2.put = (strarr, key) => {
        const index = exports2.get(strarr, key);
        if (index !== undefined)
          return index;
        const { array, _indexes: indexes } = strarr;
        return indexes[key] = array.push(key) - 1;
      };
      exports2.pop = (strarr) => {
        const { array, _indexes: indexes } = strarr;
        if (array.length === 0)
          return;
        const last = array.pop();
        indexes[last] = undefined;
      };
    })();
    exports2.SetArray = SetArray;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
  })(exports, function(exports2) {
    const comma = ",".charCodeAt(0);
    const semicolon = ";".charCodeAt(0);
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const intToChar = new Uint8Array(64);
    const charToInt = new Uint8Array(128);
    for (let i = 0;i < chars.length; i++) {
      const c = chars.charCodeAt(i);
      intToChar[i] = c;
      charToInt[c] = i;
    }
    const td = typeof TextDecoder !== "undefined" ? new TextDecoder : typeof Buffer !== "undefined" ? {
      decode(buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
      }
    } : {
      decode(buf) {
        let out = "";
        for (let i = 0;i < buf.length; i++) {
          out += String.fromCharCode(buf[i]);
        }
        return out;
      }
    };
    function decode(mappings) {
      const state = new Int32Array(5);
      const decoded = [];
      let index = 0;
      do {
        const semi = indexOf(mappings, index);
        const line = [];
        let sorted = true;
        let lastCol = 0;
        state[0] = 0;
        for (let i = index;i < semi; i++) {
          let seg;
          i = decodeInteger(mappings, i, state, 0);
          const col = state[0];
          if (col < lastCol)
            sorted = false;
          lastCol = col;
          if (hasMoreVlq(mappings, i, semi)) {
            i = decodeInteger(mappings, i, state, 1);
            i = decodeInteger(mappings, i, state, 2);
            i = decodeInteger(mappings, i, state, 3);
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 4);
              seg = [col, state[1], state[2], state[3], state[4]];
            } else {
              seg = [col, state[1], state[2], state[3]];
            }
          } else {
            seg = [col];
          }
          line.push(seg);
        }
        if (!sorted)
          sort(line);
        decoded.push(line);
        index = semi + 1;
      } while (index <= mappings.length);
      return decoded;
    }
    function indexOf(mappings, index) {
      const idx = mappings.indexOf(";", index);
      return idx === -1 ? mappings.length : idx;
    }
    function decodeInteger(mappings, pos, state, j) {
      let value2 = 0;
      let shift = 0;
      let integer = 0;
      do {
        const c = mappings.charCodeAt(pos++);
        integer = charToInt[c];
        value2 |= (integer & 31) << shift;
        shift += 5;
      } while (integer & 32);
      const shouldNegate = value2 & 1;
      value2 >>>= 1;
      if (shouldNegate) {
        value2 = -2147483648 | -value2;
      }
      state[j] += value2;
      return pos;
    }
    function hasMoreVlq(mappings, i, length) {
      if (i >= length)
        return false;
      return mappings.charCodeAt(i) !== comma;
    }
    function sort(line) {
      line.sort(sortComparator);
    }
    function sortComparator(a, b) {
      return a[0] - b[0];
    }
    function encode(decoded) {
      const state = new Int32Array(5);
      const bufLength = 1024 * 16;
      const subLength = bufLength - 36;
      const buf = new Uint8Array(bufLength);
      const sub = buf.subarray(0, subLength);
      let pos = 0;
      let out = "";
      for (let i = 0;i < decoded.length; i++) {
        const line = decoded[i];
        if (i > 0) {
          if (pos === bufLength) {
            out += td.decode(buf);
            pos = 0;
          }
          buf[pos++] = semicolon;
        }
        if (line.length === 0)
          continue;
        state[0] = 0;
        for (let j = 0;j < line.length; j++) {
          const segment = line[j];
          if (pos > subLength) {
            out += td.decode(sub);
            buf.copyWithin(0, subLength, pos);
            pos -= subLength;
          }
          if (j > 0)
            buf[pos++] = comma;
          pos = encodeInteger(buf, pos, state, segment, 0);
          if (segment.length === 1)
            continue;
          pos = encodeInteger(buf, pos, state, segment, 1);
          pos = encodeInteger(buf, pos, state, segment, 2);
          pos = encodeInteger(buf, pos, state, segment, 3);
          if (segment.length === 4)
            continue;
          pos = encodeInteger(buf, pos, state, segment, 4);
        }
      }
      return out + td.decode(buf.subarray(0, pos));
    }
    function encodeInteger(buf, pos, state, segment, j) {
      const next = segment[j];
      let num = next - state[j];
      state[j] = next;
      num = num < 0 ? -num << 1 | 1 : num << 1;
      do {
        let clamped = num & 31;
        num >>>= 5;
        if (num > 0)
          clamped |= 32;
        buf[pos++] = intToChar[clamped];
      } while (num > 0);
      return pos;
    }
    exports2.decode = decode;
    exports2.encode = encode;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
  })(exports, function() {
    const schemeRegex = /^[\w+.-]+:\/\//;
    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var UrlType;
    (function(UrlType2) {
      UrlType2[UrlType2["Empty"] = 1] = "Empty";
      UrlType2[UrlType2["Hash"] = 2] = "Hash";
      UrlType2[UrlType2["Query"] = 3] = "Query";
      UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
      UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
      UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
      UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
    })(UrlType || (UrlType = {}));
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
      return input.startsWith("//");
    }
    function isAbsolutePath(input) {
      return input.startsWith("/");
    }
    function isFileUrl(input) {
      return input.startsWith("file:");
    }
    function isRelative(input) {
      return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
      const match = urlRegex.exec(input);
      return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
    }
    function parseFileUrl(input) {
      const match = fileRegex.exec(input);
      const path3 = match[2];
      return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path3) ? path3 : "/" + path3, match[3] || "", match[4] || "");
    }
    function makeUrl(scheme, user, host, port, path3, query, hash) {
      return {
        scheme,
        user,
        host,
        port,
        path: path3,
        query,
        hash,
        type: UrlType.Absolute
      };
    }
    function parseUrl(input) {
      if (isSchemeRelativeUrl(input)) {
        const url2 = parseAbsoluteUrl("http:" + input);
        url2.scheme = "";
        url2.type = UrlType.SchemeRelative;
        return url2;
      }
      if (isAbsolutePath(input)) {
        const url2 = parseAbsoluteUrl("http://foo.com" + input);
        url2.scheme = "";
        url2.host = "";
        url2.type = UrlType.AbsolutePath;
        return url2;
      }
      if (isFileUrl(input))
        return parseFileUrl(input);
      if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
      const url = parseAbsoluteUrl("http://foo.com/" + input);
      url.scheme = "";
      url.host = "";
      url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
      return url;
    }
    function stripPathFilename(path3) {
      if (path3.endsWith("/.."))
        return path3;
      const index = path3.lastIndexOf("/");
      return path3.slice(0, index + 1);
    }
    function mergePaths(url, base) {
      normalizePath(base, base.type);
      if (url.path === "/") {
        url.path = base.path;
      } else {
        url.path = stripPathFilename(base.path) + url.path;
      }
    }
    function normalizePath(url, type) {
      const rel = type <= UrlType.RelativePath;
      const pieces = url.path.split("/");
      let pointer = 1;
      let positive = 0;
      let addTrailingSlash = false;
      for (let i = 1;i < pieces.length; i++) {
        const piece = pieces[i];
        if (!piece) {
          addTrailingSlash = true;
          continue;
        }
        addTrailingSlash = false;
        if (piece === ".")
          continue;
        if (piece === "..") {
          if (positive) {
            addTrailingSlash = true;
            positive--;
            pointer--;
          } else if (rel) {
            pieces[pointer++] = piece;
          }
          continue;
        }
        pieces[pointer++] = piece;
        positive++;
      }
      let path3 = "";
      for (let i = 1;i < pointer; i++) {
        path3 += "/" + pieces[i];
      }
      if (!path3 || addTrailingSlash && !path3.endsWith("/..")) {
        path3 += "/";
      }
      url.path = path3;
    }
    function resolve6(input, base) {
      if (!input && !base)
        return "";
      const url = parseUrl(input);
      let inputType = url.type;
      if (base && inputType !== UrlType.Absolute) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch (inputType) {
          case UrlType.Empty:
            url.hash = baseUrl.hash;
          case UrlType.Hash:
            url.query = baseUrl.query;
          case UrlType.Query:
          case UrlType.RelativePath:
            mergePaths(url, baseUrl);
          case UrlType.AbsolutePath:
            url.user = baseUrl.user;
            url.host = baseUrl.host;
            url.port = baseUrl.port;
          case UrlType.SchemeRelative:
            url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
          inputType = baseType;
      }
      normalizePath(url, inputType);
      const queryHash = url.query + url.hash;
      switch (inputType) {
        case UrlType.Hash:
        case UrlType.Query:
          return queryHash;
        case UrlType.RelativePath: {
          const path3 = url.path.slice(1);
          if (!path3)
            return queryHash || ".";
          if (isRelative(base || input) && !isRelative(path3)) {
            return "./" + path3 + queryHash;
          }
          return path3 + queryHash;
        }
        case UrlType.AbsolutePath:
          return url.path + queryHash;
        default:
          return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
      }
    }
    return resolve6;
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
  })(exports, function(exports2, sourcemapCodec, resolveUri) {
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { default: e };
    }
    var resolveUri__default = _interopDefaultLegacy(resolveUri);
    function resolve6(input, base) {
      if (base && !base.endsWith("/"))
        base += "/";
      return resolveUri__default["default"](input, base);
    }
    function stripFilename(path3) {
      if (!path3)
        return "";
      const index = path3.lastIndexOf("/");
      return path3.slice(0, index + 1);
    }
    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;
    const REV_GENERATED_LINE = 1;
    const REV_GENERATED_COLUMN = 2;
    function maybeSort(mappings, owned) {
      const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
      if (unsortedIndex === mappings.length)
        return mappings;
      if (!owned)
        mappings = mappings.slice();
      for (let i = unsortedIndex;i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
      }
      return mappings;
    }
    function nextUnsortedSegmentLine(mappings, start) {
      for (let i = start;i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
          return i;
      }
      return mappings.length;
    }
    function isSorted(line) {
      for (let j = 1;j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
          return false;
        }
      }
      return true;
    }
    function sortSegments(line, owned) {
      if (!owned)
        line = line.slice();
      return line.sort(sortComparator);
    }
    function sortComparator(a, b) {
      return a[COLUMN] - b[COLUMN];
    }
    let found = false;
    function binarySearch(haystack, needle, low, high) {
      while (low <= high) {
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
          found = true;
          return mid;
        }
        if (cmp < 0) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      found = false;
      return low - 1;
    }
    function upperBound(haystack, needle, index) {
      for (let i = index + 1;i < haystack.length; index = i++) {
        if (haystack[i][COLUMN] !== needle)
          break;
      }
      return index;
    }
    function lowerBound(haystack, needle, index) {
      for (let i = index - 1;i >= 0; index = i--) {
        if (haystack[i][COLUMN] !== needle)
          break;
      }
      return index;
    }
    function memoizedState() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function memoizedBinarySearch(haystack, needle, state, key) {
      const { lastKey, lastNeedle, lastIndex } = state;
      let low = 0;
      let high = haystack.length - 1;
      if (key === lastKey) {
        if (needle === lastNeedle) {
          found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
          return lastIndex;
        }
        if (needle >= lastNeedle) {
          low = lastIndex === -1 ? 0 : lastIndex;
        } else {
          high = lastIndex;
        }
      }
      state.lastKey = key;
      state.lastNeedle = needle;
      return state.lastIndex = binarySearch(haystack, needle, low, high);
    }
    function buildBySources(decoded, memos) {
      const sources = memos.map(buildNullArray);
      for (let i = 0;i < decoded.length; i++) {
        const line = decoded[i];
        for (let j = 0;j < line.length; j++) {
          const seg = line[j];
          if (seg.length === 1)
            continue;
          const sourceIndex = seg[SOURCES_INDEX];
          const sourceLine = seg[SOURCE_LINE];
          const sourceColumn = seg[SOURCE_COLUMN];
          const originalSource = sources[sourceIndex];
          const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
          const memo = memos[sourceIndex];
          const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
          insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
        }
      }
      return sources;
    }
    function insert(array, index, value2) {
      for (let i = array.length;i > index; i--) {
        array[i] = array[i - 1];
      }
      array[index] = value2;
    }
    function buildNullArray() {
      return { __proto__: null };
    }
    const AnyMap = function(map, mapUrl) {
      const parsed = typeof map === "string" ? JSON.parse(map) : map;
      if (!("sections" in parsed))
        return new TraceMap(parsed, mapUrl);
      const mappings = [];
      const sources = [];
      const sourcesContent = [];
      const names = [];
      recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
      const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings
      };
      return exports2.presortedDecodedMap(joined);
    };
    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
      const { sections } = input;
      for (let i = 0;i < sections.length; i++) {
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
          const nextOffset = sections[i + 1].offset;
          sl = Math.min(stopLine, lineOffset + nextOffset.line);
          if (sl === stopLine) {
            sc = Math.min(stopColumn, columnOffset + nextOffset.column);
          } else if (sl < stopLine) {
            sc = columnOffset + nextOffset.column;
          }
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
      }
    }
    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
      if ("sections" in input)
        return recurse(...arguments);
      const map = new TraceMap(input, mapUrl);
      const sourcesOffset = sources.length;
      const namesOffset = names.length;
      const decoded = exports2.decodedMappings(map);
      const { resolvedSources, sourcesContent: contents } = map;
      append(sources, resolvedSources);
      append(names, map.names);
      if (contents)
        append(sourcesContent, contents);
      else
        for (let i = 0;i < resolvedSources.length; i++)
          sourcesContent.push(null);
      for (let i = 0;i < decoded.length; i++) {
        const lineI = lineOffset + i;
        if (lineI > stopLine)
          return;
        const out = getLine(mappings, lineI);
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for (let j = 0;j < line.length; j++) {
          const seg = line[j];
          const column = cOffset + seg[COLUMN];
          if (lineI === stopLine && column >= stopColumn)
            return;
          if (seg.length === 1) {
            out.push([column]);
            continue;
          }
          const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
          const sourceLine = seg[SOURCE_LINE];
          const sourceColumn = seg[SOURCE_COLUMN];
          out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
        }
      }
    }
    function append(arr, other) {
      for (let i = 0;i < other.length; i++)
        arr.push(other[i]);
    }
    function getLine(arr, index) {
      for (let i = arr.length;i <= index; i++)
        arr[i] = [];
      return arr[index];
    }
    const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
    const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
    const LEAST_UPPER_BOUND = -1;
    const GREATEST_LOWER_BOUND = 1;
    exports2.encodedMappings = undefined;
    exports2.decodedMappings = undefined;
    exports2.traceSegment = undefined;
    exports2.originalPositionFor = undefined;
    exports2.generatedPositionFor = undefined;
    exports2.allGeneratedPositionsFor = undefined;
    exports2.eachMapping = undefined;
    exports2.sourceContentFor = undefined;
    exports2.presortedDecodedMap = undefined;
    exports2.decodedMap = undefined;
    exports2.encodedMap = undefined;

    class TraceMap {
      constructor(map, mapUrl) {
        const isString = typeof map === "string";
        if (!isString && map._decodedMemo)
          return map;
        const parsed = isString ? JSON.parse(map) : map;
        const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version2;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        const from = resolve6(sourceRoot || "", stripFilename(mapUrl));
        this.resolvedSources = sources.map((s) => resolve6(s || "", from));
        const { mappings } = parsed;
        if (typeof mappings === "string") {
          this._encoded = mappings;
          this._decoded = undefined;
        } else {
          this._encoded = undefined;
          this._decoded = maybeSort(mappings, isString);
        }
        this._decodedMemo = memoizedState();
        this._bySources = undefined;
        this._bySourceMemos = undefined;
      }
    }
    (() => {
      exports2.encodedMappings = (map) => {
        var _a2;
        return (_a2 = map._encoded) !== null && _a2 !== undefined ? _a2 : map._encoded = sourcemapCodec.encode(map._decoded);
      };
      exports2.decodedMappings = (map) => {
        return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
      };
      exports2.traceSegment = (map, line, column) => {
        const decoded = exports2.decodedMappings(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      };
      exports2.originalPositionFor = (map, { line, column, bias }) => {
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = exports2.decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      };
      exports2.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      };
      exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      };
      exports2.eachMapping = (map, cb) => {
        const decoded = exports2.decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0;i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0;j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      };
      exports2.sourceContentFor = (map, source) => {
        const { sources, resolvedSources, sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        let index = sources.indexOf(source);
        if (index === -1)
          index = resolvedSources.indexOf(source);
        return index === -1 ? null : sourcesContent[index];
      };
      exports2.presortedDecodedMap = (map, mapUrl) => {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        tracer._decoded = map.mappings;
        return tracer;
      };
      exports2.decodedMap = (map) => {
        return clone(map, exports2.decodedMappings(map));
      };
      exports2.encodedMap = (map) => {
        return clone(map, exports2.encodedMappings(map));
      };
      function generatedPosition(map, source, line, column, bias, all) {
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex = sources.indexOf(source);
        if (sourceIndex === -1)
          sourceIndex = resolvedSources.indexOf(source);
        if (sourceIndex === -1)
          return all ? [] : GMapping(null, null);
        const generated = map._bySources || (map._bySources = buildBySources(exports2.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = map._bySourceMemos[sourceIndex];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    })();
    function clone(map, mappings) {
      return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings
      };
    }
    function OMapping(source, line, column, name) {
      return { source, line, column, name };
    }
    function GMapping(line, column) {
      return { line, column };
    }
    function traceSegmentInternal(segments, memo, line, column, bias) {
      let index = memoizedBinarySearch(segments, column, memo, line);
      if (found) {
        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
      } else if (bias === LEAST_UPPER_BOUND)
        index++;
      if (index === -1 || index === segments.length)
        return -1;
      return index;
    }
    function sliceGeneratedPositions(segments, memo, line, column, bias) {
      let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
      if (!found && bias === LEAST_UPPER_BOUND)
        min++;
      if (min === -1 || min === segments.length)
        return [];
      const matchedColumn = found ? column : segments[min][COLUMN];
      if (!found)
        min = lowerBound(segments, matchedColumn, min);
      const max = upperBound(segments, matchedColumn, min);
      const result = [];
      for (;min <= max; min++) {
        const segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
      }
      return result;
    }
    exports2.AnyMap = AnyMap;
    exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
    exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
    exports2.TraceMap = TraceMap;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
  })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;
    const NO_NAME = -1;
    exports2.addSegment = undefined;
    exports2.addMapping = undefined;
    exports2.maybeAddSegment = undefined;
    exports2.maybeAddMapping = undefined;
    exports2.setSourceContent = undefined;
    exports2.toDecodedMap = undefined;
    exports2.toEncodedMap = undefined;
    exports2.fromMap = undefined;
    exports2.allMappings = undefined;
    let addSegmentInternal;

    class GenMapping {
      constructor({ file, sourceRoot } = {}) {
        this._names = new setArray.SetArray;
        this._sources = new setArray.SetArray;
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
      }
    }
    (() => {
      exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      exports2.addMapping = (map, mapping) => {
        return addMappingInternal(false, map, mapping);
      };
      exports2.maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      exports2.setSourceContent = (map, source, content) => {
        const { _sources: sources, _sourcesContent: sourcesContent } = map;
        sourcesContent[setArray.put(sources, source)] = content;
      };
      exports2.toDecodedMap = (map) => {
        const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: file || undefined,
          names: names.array,
          sourceRoot: sourceRoot || undefined,
          sources: sources.array,
          sourcesContent,
          mappings
        };
      };
      exports2.toEncodedMap = (map) => {
        const decoded = exports2.toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      };
      exports2.allMappings = (map) => {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = map;
        for (let i = 0;i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0;j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source = undefined;
            let original = undefined;
            let name = undefined;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name });
          }
        }
        return out;
      };
      exports2.fromMap = (input) => {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(gen._names, map.names);
        putAll(gen._sources, map.sources);
        gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        gen._mappings = traceMapping.decodedMappings(map);
        return gen;
      };
      addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index))
            return;
          return insert(line, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== undefined ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      };
    })();
    function getLine(mappings, index) {
      for (let i = mappings.length;i <= index; i++) {
        mappings[i] = [];
      }
      return mappings[index];
    }
    function getColumnIndex(line, genColumn) {
      let index = line.length;
      for (let i = index - 1;i >= 0; index = i--) {
        const current = line[i];
        if (genColumn >= current[COLUMN])
          break;
      }
      return index;
    }
    function insert(array, index, value2) {
      for (let i = array.length;i > index; i--) {
        array[i] = array[i - 1];
      }
      array[index] = value2;
    }
    function removeEmptyFinalLines(mappings) {
      const { length } = mappings;
      let len = length;
      for (let i = len - 1;i >= 0; len = i, i--) {
        if (mappings[i].length > 0)
          break;
      }
      if (len < length)
        mappings.length = len;
    }
    function putAll(strarr, array) {
      for (let i = 0;i < array.length; i++)
        setArray.put(strarr, array[i]);
    }
    function skipSourceless(line, index) {
      if (index === 0)
        return true;
      const prev = line[index - 1];
      return prev.length === 1;
    }
    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
      if (index === 0)
        return false;
      const prev = line[index - 1];
      if (prev.length === 1)
        return false;
      return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
    }
    function addMappingInternal(skipable, map, mapping) {
      const { generated, source, original, name, content } = mapping;
      if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
      }
      const s = source;
      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
    }
    exports2.GenMapping = GenMapping;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _genMapping = require_gen_mapping_umd();
  var _traceMapping = require_trace_mapping_umd();

  class SourceMap {
    constructor(opts, code) {
      var _opts$sourceFileName;
      this._map = undefined;
      this._rawMappings = undefined;
      this._sourceFileName = undefined;
      this._lastGenLine = 0;
      this._lastSourceLine = 0;
      this._lastSourceColumn = 0;
      this._inputMap = undefined;
      const map = this._map = new _genMapping.GenMapping({
        sourceRoot: opts.sourceRoot
      });
      this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? undefined : _opts$sourceFileName.replace(/\\/g, "/");
      this._rawMappings = undefined;
      if (opts.inputSourceMap) {
        this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
        const resolvedSources = this._inputMap.resolvedSources;
        if (resolvedSources.length) {
          for (let i = 0;i < resolvedSources.length; i++) {
            var _this$_inputMap$sourc;
            (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? undefined : _this$_inputMap$sourc[i]);
          }
        }
      }
      if (typeof code === "string" && !opts.inputSourceMap) {
        (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
      } else if (typeof code === "object") {
        for (const sourceFileName of Object.keys(code)) {
          (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }
      }
    }
    get() {
      return (0, _genMapping.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, _genMapping.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
    }
    mark(generated, line, column, identifierName, identifierNamePos, filename) {
      var _originalMapping;
      this._rawMappings = undefined;
      let originalMapping;
      if (line != null) {
        if (this._inputMap) {
          originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
            line,
            column
          });
          if (!originalMapping.name && identifierNamePos) {
            const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
            if (originalIdentifierMapping.name) {
              identifierName = originalIdentifierMapping.name;
            }
          }
        } else {
          originalMapping = {
            source: (filename == null ? undefined : filename.replace(/\\/g, "/")) || this._sourceFileName,
            line,
            column
          };
        }
      }
      (0, _genMapping.maybeAddMapping)(this._map, {
        name: identifierName,
        generated,
        source: (_originalMapping = originalMapping) == null ? undefined : _originalMapping.source,
        original: originalMapping
      });
    }
  }
  exports.default = SourceMap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class Buffer2 {
    constructor(map, indentChar) {
      this._map = null;
      this._buf = "";
      this._str = "";
      this._appendCount = 0;
      this._last = 0;
      this._queue = [];
      this._queueCursor = 0;
      this._canMarkIdName = true;
      this._indentChar = "";
      this._fastIndentations = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: undefined,
        identifierNamePos: undefined,
        line: undefined,
        column: undefined,
        filename: undefined
      };
      this._map = map;
      this._indentChar = indentChar;
      for (let i = 0;i < 64; i++) {
        this._fastIndentations.push(indentChar.repeat(i));
      }
      this._allocQueue();
    }
    _allocQueue() {
      const queue = this._queue;
      for (let i = 0;i < 16; i++) {
        queue.push({
          char: 0,
          repeat: 1,
          line: undefined,
          column: undefined,
          identifierName: undefined,
          identifierNamePos: undefined,
          filename: ""
        });
      }
    }
    _pushQueue(char, repeat, line, column, filename) {
      const cursor = this._queueCursor;
      if (cursor === this._queue.length) {
        this._allocQueue();
      }
      const item = this._queue[cursor];
      item.char = char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.filename = filename;
      this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const map = this._map;
      const result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? undefined : map.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          const resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },
        set map(value2) {
          Object.defineProperty(result, "map", {
            value: value2,
            writable: true
          });
        },
        get rawMappings() {
          const mappings = map == null ? undefined : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },
        set rawMappings(value2) {
          Object.defineProperty(result, "rawMappings", {
            value: value2,
            writable: true
          });
        }
      };
      return result;
    }
    append(str, maybeNewline) {
      this._flush();
      this._append(str, this._sourcePosition, maybeNewline);
    }
    appendChar(char) {
      this._flush();
      this._appendChar(char, 1, this._sourcePosition);
    }
    queue(char) {
      if (char === 10) {
        while (this._queueCursor !== 0) {
          const char2 = this._queue[this._queueCursor - 1].char;
          if (char2 !== 32 && char2 !== 9) {
            break;
          }
          this._queueCursor--;
        }
      }
      const sourcePosition = this._sourcePosition;
      this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
    queueIndentation(repeat) {
      if (repeat === 0)
        return;
      this._pushQueue(-1, repeat, undefined, undefined, undefined);
    }
    _flush() {
      const queueCursor = this._queueCursor;
      const queue = this._queue;
      for (let i = 0;i < queueCursor; i++) {
        const item = queue[i];
        this._appendChar(item.char, item.repeat, item);
      }
      this._queueCursor = 0;
    }
    _appendChar(char, repeat, sourcePos) {
      this._last = char;
      if (char === -1) {
        const fastIndentation = this._fastIndentations[repeat];
        if (fastIndentation !== undefined) {
          this._str += fastIndentation;
        } else {
          this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        }
      } else {
        this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
      }
      if (char !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
      if (this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
    }
    _append(str, sourcePos, maybeNewline) {
      const len = str.length;
      const position = this._position;
      this._last = str.charCodeAt(len - 1);
      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }
      if (!maybeNewline && !this._map) {
        position.column += len;
        return;
      }
      const {
        column,
        identifierName,
        identifierNamePos,
        filename
      } = sourcePos;
      let line = sourcePos.line;
      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      let i = str.indexOf("\n");
      let last = 0;
      if (i !== 0) {
        this._mark(line, column, identifierName, identifierNamePos, filename);
      }
      while (i !== -1) {
        position.line++;
        position.column = 0;
        last = i + 1;
        if (last < len && line !== undefined) {
          this._mark(++line, 0, null, null, filename);
        }
        i = str.indexOf("\n", last);
      }
      position.column += len - last;
    }
    _mark(line, column, identifierName, identifierNamePos, filename) {
      var _this$_map;
      (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
    removeTrailingNewline() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
        this._queueCursor--;
      }
    }
    removeLastSemicolon() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
        this._queueCursor--;
      }
    }
    getLastChar() {
      const queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    }
    getNewlineCount() {
      const queueCursor = this._queueCursor;
      let count = 0;
      if (queueCursor === 0)
        return this._last === 10 ? 1 : 0;
      for (let i = queueCursor - 1;i >= 0; i--) {
        if (this._queue[i].char !== 10) {
          break;
        }
        count++;
      }
      return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
    endsWithCharAndNewline() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0) {
        const lastCp = queue[queueCursor - 1].char;
        if (lastCp !== 10)
          return;
        if (queueCursor > 1) {
          return queue[queueCursor - 2].char;
        } else {
          return this._last;
        }
      }
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(loc, cb) {
      if (!this._map) {
        cb();
        return;
      }
      this.source("start", loc);
      const identifierName = loc.identifierName;
      const sourcePos = this._sourcePosition;
      if (identifierName) {
        this._canMarkIdName = false;
        sourcePos.identifierName = identifierName;
      }
      cb();
      if (identifierName) {
        this._canMarkIdName = true;
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      this.source("end", loc);
    }
    source(prop, loc) {
      if (!this._map)
        return;
      this._normalizePosition(prop, loc, 0);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!this._map)
        return;
      this._normalizePosition(prop, loc, columnOffset);
    }
    withSource(prop, loc, cb) {
      if (this._map) {
        this.source(prop, loc);
      }
      cb();
    }
    _normalizePosition(prop, loc, columnOffset) {
      const pos = loc[prop];
      const target = this._sourcePosition;
      if (pos) {
        target.line = pos.line;
        target.column = Math.max(pos.column + columnOffset, 0);
        target.filename = loc.filename;
      }
    }
    getCurrentColumn() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      let lastIndex = -1;
      let len = 0;
      for (let i = 0;i < queueCursor; i++) {
        const item = queue[i];
        if (item.char === 10) {
          lastIndex = len;
        }
        len += item.repeat;
      }
      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
    getCurrentLine() {
      let count = 0;
      const queue = this._queue;
      for (let i = 0;i < this._queueCursor; i++) {
        if (queue[i].char === 10) {
          count++;
        }
      }
      return this._position.line + count;
    }
  }
  exports.default = Buffer2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS((exports) => {
  var crawlInternal = function(node2, state) {
    if (!node2)
      return state;
    if (isMemberExpression(node2) || isOptionalMemberExpression(node2)) {
      crawlInternal(node2.object, state);
      if (node2.computed)
        crawlInternal(node2.property, state);
    } else if (isBinary(node2) || isAssignmentExpression(node2)) {
      crawlInternal(node2.left, state);
      crawlInternal(node2.right, state);
    } else if (isCallExpression(node2) || isOptionalCallExpression(node2)) {
      state.hasCall = true;
      crawlInternal(node2.callee, state);
    } else if (isFunction2(node2)) {
      state.hasFunction = true;
    } else if (isIdentifier(node2)) {
      state.hasHelper = state.hasHelper || node2.callee && isHelper(node2.callee);
    }
    return state;
  };
  var crawl = function(node2) {
    return crawlInternal(node2, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  };
  var isHelper = function(node2) {
    if (!node2)
      return false;
    if (isMemberExpression(node2)) {
      return isHelper(node2.object) || isHelper(node2.property);
    } else if (isIdentifier(node2)) {
      return node2.name === "require" || node2.name.charCodeAt(0) === 95;
    } else if (isCallExpression(node2)) {
      return isHelper(node2.callee);
    } else if (isBinary(node2) || isAssignmentExpression(node2)) {
      return isIdentifier(node2.left) && isHelper(node2.left) || isHelper(node2.right);
    } else {
      return false;
    }
  };
  var isType = function(node2) {
    return isLiteral(node2) || isObjectExpression(node2) || isArrayExpression(node2) || isIdentifier(node2) || isMemberExpression(node2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.nodes = undefined;
  var _t = require_lib3();
  var {
    FLIPPED_ALIAS_KEYS,
    isArrayExpression,
    isAssignmentExpression,
    isBinary,
    isBlockStatement,
    isCallExpression,
    isFunction: isFunction2,
    isIdentifier,
    isLiteral,
    isMemberExpression,
    isObjectExpression,
    isOptionalCallExpression,
    isOptionalMemberExpression,
    isStringLiteral
  } = _t;
  var nodes = exports.nodes = {
    AssignmentExpression(node2) {
      const state = crawl(node2.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return state.hasFunction ? 1 | 2 : 2;
      }
    },
    SwitchCase(node2, parent) {
      return (!!node2.consequent.length || parent.cases[0] === node2 ? 1 : 0) | (!node2.consequent.length && parent.cases[parent.cases.length - 1] === node2 ? 2 : 0);
    },
    LogicalExpression(node2) {
      if (isFunction2(node2.left) || isFunction2(node2.right)) {
        return 2;
      }
    },
    Literal(node2) {
      if (isStringLiteral(node2) && node2.value === "use strict") {
        return 2;
      }
    },
    CallExpression(node2) {
      if (isFunction2(node2.callee) || isHelper(node2)) {
        return 1 | 2;
      }
    },
    OptionalCallExpression(node2) {
      if (isFunction2(node2.callee)) {
        return 1 | 2;
      }
    },
    VariableDeclaration(node2) {
      for (let i = 0;i < node2.declarations.length; i++) {
        const declar = node2.declarations[i];
        let enabled = isHelper(declar.id) && !isType(declar.init);
        if (!enabled && declar.init) {
          const state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) {
          return 1 | 2;
        }
      }
    },
    IfStatement(node2) {
      if (isBlockStatement(node2.consequent)) {
        return 1 | 2;
      }
    }
  };
  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node2, parent) {
    if (parent.properties[0] === node2) {
      return 1;
    }
  };
  nodes.ObjectTypeCallProperty = function(node2, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node2 && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeIndexer = function(node2, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node2 && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeInternalSlot = function(node2, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node2 && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return 1;
    }
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
      const ret = amounts ? 1 | 2 : 0;
      nodes[type2] = () => ret;
    });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS((exports) => {
  var isTSTypeExpression = function(nodeType) {
    return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
  };
  var NullableTypeAnnotation = function(node2, parent) {
    return isArrayTypeAnnotation(parent);
  };
  var FunctionTypeAnnotation = function(node2, parent, printStack) {
    if (printStack.length < 3)
      return;
    const parentType = parent.type;
    return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || parentType === "TypeAnnotation" && isArrowFunctionExpression(printStack[printStack.length - 3]);
  };
  var UpdateExpression = function(node2, parent) {
    return hasPostfixPart(node2, parent) || isClassExtendsClause(node2, parent);
  };
  var ObjectExpression = function(node2, parent, printStack) {
    return isFirstInContext(printStack, 1 | 2);
  };
  var DoExpression = function(node2, parent, printStack) {
    return !node2.async && isFirstInContext(printStack, 1);
  };
  var Binary = function(node2, parent) {
    const parentType = parent.type;
    if (node2.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
      return parent.left === node2;
    }
    if (isClassExtendsClause(node2, parent)) {
      return true;
    }
    if (hasPostfixPart(node2, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
      return true;
    }
    if (parentType === "BinaryExpression" || parentType === "LogicalExpression") {
      const parentPos = PRECEDENCE.get(parent.operator);
      const nodePos = PRECEDENCE.get(node2.operator);
      if (parentPos === nodePos && parent.right === node2 && parentType !== "LogicalExpression" || parentPos > nodePos) {
        return true;
      }
    }
    return;
  };
  var UnionTypeAnnotation = function(node2, parent) {
    const parentType = parent.type;
    return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
  };
  var OptionalIndexedAccessType = function(node2, parent) {
    return isIndexedAccessType(parent) && parent.objectType === node2;
  };
  var TSAsExpression = function() {
    return true;
  };
  var TSUnionType = function(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSOptionalType" || parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSRestType";
  };
  var TSInferType = function(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSOptionalType";
  };
  var TSInstantiationExpression = function(node2, parent) {
    const parentType = parent.type;
    return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
  };
  var BinaryExpression = function(node2, parent) {
    if (node2.operator === "in") {
      const parentType = parent.type;
      return parentType === "VariableDeclarator" || parentType === "ForStatement" || parentType === "ForInStatement" || parentType === "ForOfStatement";
    }
    return false;
  };
  var SequenceExpression = function(node2, parent) {
    const parentType = parent.type;
    if (parentType === "ForStatement" || parentType === "ThrowStatement" || parentType === "ReturnStatement" || parentType === "IfStatement" && parent.test === node2 || parentType === "WhileStatement" && parent.test === node2 || parentType === "ForInStatement" && parent.right === node2 || parentType === "SwitchStatement" && parent.discriminant === node2 || parentType === "ExpressionStatement" && parent.expression === node2) {
      return false;
    }
    return true;
  };
  var YieldExpression = function(node2, parent) {
    const parentType = parent.type;
    return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node2, parent) || parentType === "AwaitExpression" && isYieldExpression(node2) || parentType === "ConditionalExpression" && node2 === parent.test || isClassExtendsClause(node2, parent);
  };
  var ClassExpression = function(node2, parent, printStack) {
    return isFirstInContext(printStack, 1 | 4);
  };
  var UnaryLike = function(node2, parent) {
    return hasPostfixPart(node2, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node2 || isClassExtendsClause(node2, parent);
  };
  var FunctionExpression = function(node2, parent, printStack) {
    return isFirstInContext(printStack, 1 | 4);
  };
  var ArrowFunctionExpression = function(node2, parent) {
    return isExportDeclaration(parent) || ConditionalExpression(node2, parent);
  };
  var ConditionalExpression = function(node2, parent) {
    const parentType = parent.type;
    if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node2 || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
      return true;
    }
    return UnaryLike(node2, parent);
  };
  var OptionalMemberExpression = function(node2, parent) {
    return isCallExpression(parent) && parent.callee === node2 || isMemberExpression(parent) && parent.object === node2;
  };
  var AssignmentExpression = function(node2, parent) {
    if (isObjectPattern(node2.left)) {
      return true;
    } else {
      return ConditionalExpression(node2, parent);
    }
  };
  var LogicalExpression = function(node2, parent) {
    const parentType = parent.type;
    if (isTSTypeExpression(parentType))
      return true;
    if (parentType !== "LogicalExpression")
      return false;
    switch (node2.operator) {
      case "||":
        return parent.operator === "??" || parent.operator === "&&";
      case "&&":
        return parent.operator === "??";
      case "??":
        return parent.operator !== "??";
    }
  };
  var Identifier = function(node2, parent, printStack) {
    var _node$extra;
    const parentType = parent.type;
    if ((_node$extra = node2.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node2) {
      const rightType = parent.right.type;
      if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
        return true;
      }
    }
    if (node2.name === "let") {
      const isFollowedByBracket = isMemberExpression(parent, {
        object: node2,
        computed: true
      }) || isOptionalMemberExpression(parent, {
        object: node2,
        computed: true,
        optional: false
      });
      return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);
    }
    return node2.name === "async" && isForOfStatement(parent) && node2 === parent.left;
  };
  var isFirstInContext = function(printStack, checkParam) {
    const expressionStatement = checkParam & 1;
    const arrowBody = checkParam & 2;
    const exportDefault = checkParam & 4;
    const forHead = checkParam & 8;
    const forInHead = checkParam & 16;
    const forOfHead = checkParam & 32;
    let i = printStack.length - 1;
    if (i <= 0)
      return;
    let node2 = printStack[i];
    i--;
    let parent = printStack[i];
    while (i >= 0) {
      const parentType = parent.type;
      if (expressionStatement && parentType === "ExpressionStatement" && parent.expression === node2 || exportDefault && parentType === "ExportDefaultDeclaration" && node2 === parent.declaration || arrowBody && parentType === "ArrowFunctionExpression" && parent.body === node2 || forHead && parentType === "ForStatement" && parent.init === node2 || forInHead && parentType === "ForInStatement" && parent.left === node2 || forOfHead && parentType === "ForOfStatement" && parent.left === node2) {
        return true;
      }
      if (i > 0 && (hasPostfixPart(node2, parent) && parentType !== "NewExpression" || parentType === "SequenceExpression" && parent.expressions[0] === node2 || parentType === "UpdateExpression" && !parent.prefix || parentType === "ConditionalExpression" && parent.test === node2 || (parentType === "BinaryExpression" || parentType === "LogicalExpression") && parent.left === node2 || parentType === "AssignmentExpression" && parent.left === node2)) {
        node2 = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArrowFunctionExpression = ArrowFunctionExpression;
  exports.AssignmentExpression = AssignmentExpression;
  exports.Binary = Binary;
  exports.BinaryExpression = BinaryExpression;
  exports.ClassExpression = ClassExpression;
  exports.ConditionalExpression = ConditionalExpression;
  exports.DoExpression = DoExpression;
  exports.FunctionExpression = FunctionExpression;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.Identifier = Identifier;
  exports.LogicalExpression = LogicalExpression;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  exports.ObjectExpression = ObjectExpression;
  exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
  exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
  exports.SequenceExpression = SequenceExpression;
  exports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
  exports.TSInferType = TSInferType;
  exports.TSInstantiationExpression = TSInstantiationExpression;
  exports.TSIntersectionType = exports.TSUnionType = TSUnionType;
  exports.UnaryLike = UnaryLike;
  exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.UpdateExpression = UpdateExpression;
  exports.AwaitExpression = exports.YieldExpression = YieldExpression;
  var _t = require_lib3();
  var {
    isArrayTypeAnnotation,
    isArrowFunctionExpression,
    isBinaryExpression,
    isCallExpression,
    isExportDeclaration,
    isForOfStatement,
    isIndexedAccessType,
    isMemberExpression,
    isObjectPattern,
    isOptionalMemberExpression,
    isYieldExpression
  } = _t;
  var PRECEDENCE = new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  var isClassExtendsClause = (node2, parent) => {
    const parentType = parent.type;
    return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node2;
  };
  var hasPostfixPart = (node2, parent) => {
    const parentType = parent.type;
    return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node2 || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node2 || parentType === "TaggedTemplateExpression" && parent.tag === node2 || parentType === "TSNonNullExpression";
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/node/index.js
var require_node2 = __commonJS((exports) => {
  var expandAliases = function(obj) {
    const map = new Map;
    function add(type, func) {
      const fn = map.get(type);
      map.set(type, fn ? function(node2, parent, stack) {
        var _fn;
        return (_fn = fn(node2, parent, stack)) != null ? _fn : func(node2, parent, stack);
      } : func);
    }
    for (const type of Object.keys(obj)) {
      const aliases = FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        for (const alias of aliases) {
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }
    return map;
  };
  var isOrHasCallExpression = function(node2) {
    if (isCallExpression(node2)) {
      return true;
    }
    return isMemberExpression(node2) && isOrHasCallExpression(node2.object);
  };
  var needsWhitespace = function(node2, parent, type) {
    var _expandedWhitespaceNo;
    if (!node2)
      return false;
    if (isExpressionStatement(node2)) {
      node2 = node2.expression;
    }
    const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node2.type)) == null ? undefined : _expandedWhitespaceNo(node2, parent);
    if (typeof flag === "number") {
      return (flag & type) !== 0;
    }
    return false;
  };
  var needsWhitespaceBefore = function(node2, parent) {
    return needsWhitespace(node2, parent, 1);
  };
  var needsWhitespaceAfter = function(node2, parent) {
    return needsWhitespace(node2, parent, 2);
  };
  var needsParens = function(node2, parent, printStack) {
    var _expandedParens$get;
    if (!parent)
      return false;
    if (isNewExpression(parent) && parent.callee === node2) {
      if (isOrHasCallExpression(node2))
        return true;
    }
    return (_expandedParens$get = expandedParens.get(node2.type)) == null ? undefined : _expandedParens$get(node2, parent, printStack);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.needsParens = needsParens;
  exports.needsWhitespace = needsWhitespace;
  exports.needsWhitespaceAfter = needsWhitespaceAfter;
  exports.needsWhitespaceBefore = needsWhitespaceBefore;
  var whitespace = require_whitespace();
  var parens = require_parentheses();
  var _t = require_lib3();
  var {
    FLIPPED_ALIAS_KEYS,
    isCallExpression,
    isExpressionStatement,
    isMemberExpression,
    isNewExpression
  } = _t;
  var expandedParens = expandAliases(parens);
  var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS((exports) => {
  var TaggedTemplateExpression = function(node2) {
    this.print(node2.tag, node2);
    this.print(node2.typeParameters, node2);
    this.print(node2.quasi, node2);
  };
  var TemplateElement = function(node2, parent) {
    const isFirst = parent.quasis[0] === node2;
    const isLast = parent.quasis[parent.quasis.length - 1] === node2;
    const value2 = (isFirst ? "`" : "}") + node2.value.raw + (isLast ? "`" : "${");
    this.token(value2, true);
  };
  var TemplateLiteral = function(node2) {
    const quasis = node2.quasis;
    for (let i = 0;i < quasis.length; i++) {
      this.print(quasis[i], node2);
      if (i + 1 < quasis.length) {
        this.print(node2.expressions[i], node2);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TaggedTemplateExpression = TaggedTemplateExpression;
  exports.TemplateElement = TemplateElement;
  exports.TemplateLiteral = TemplateLiteral;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS((exports) => {
  var UnaryExpression = function(node2) {
    const {
      operator
    } = node2;
    if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
      this.word(operator);
      this.space();
    } else {
      this.token(operator);
    }
    this.print(node2.argument, node2);
  };
  var DoExpression = function(node2) {
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    this.word("do");
    this.space();
    this.print(node2.body, node2);
  };
  var ParenthesizedExpression = function(node2) {
    this.tokenChar(40);
    this.print(node2.expression, node2);
    this.rightParens(node2);
  };
  var UpdateExpression = function(node2) {
    if (node2.prefix) {
      this.token(node2.operator);
      this.print(node2.argument, node2);
    } else {
      this.printTerminatorless(node2.argument, node2, true);
      this.token(node2.operator);
    }
  };
  var ConditionalExpression = function(node2) {
    this.print(node2.test, node2);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node2.consequent, node2);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node2.alternate, node2);
  };
  var NewExpression = function(node2, parent) {
    this.word("new");
    this.space();
    this.print(node2.callee, node2);
    if (this.format.minified && node2.arguments.length === 0 && !node2.optional && !isCallExpression(parent, {
      callee: node2
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }
    this.print(node2.typeArguments, node2);
    this.print(node2.typeParameters, node2);
    if (node2.optional) {
      this.token("?.");
    }
    this.tokenChar(40);
    this.printList(node2.arguments, node2);
    this.rightParens(node2);
  };
  var SequenceExpression = function(node2) {
    this.printList(node2.expressions, node2);
  };
  var ThisExpression = function() {
    this.word("this");
  };
  var Super = function() {
    this.word("super");
  };
  var isDecoratorMemberExpression = function(node2) {
    switch (node2.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !node2.computed && node2.property.type === "Identifier" && isDecoratorMemberExpression(node2.object);
      default:
        return false;
    }
  };
  var shouldParenthesizeDecoratorExpression = function(node2) {
    if (node2.type === "ParenthesizedExpression") {
      return false;
    }
    return !isDecoratorMemberExpression(node2.type === "CallExpression" ? node2.callee : node2);
  };
  var _shouldPrintDecoratorsBeforeExport = function(node2) {
    if (typeof this.format.decoratorsBeforeExport === "boolean") {
      return this.format.decoratorsBeforeExport;
    }
    return typeof node2.start === "number" && node2.start === node2.declaration.start;
  };
  var Decorator = function(node2) {
    this.tokenChar(64);
    const {
      expression
    } = node2;
    if (shouldParenthesizeDecoratorExpression(expression)) {
      this.tokenChar(40);
      this.print(expression, node2);
      this.tokenChar(41);
    } else {
      this.print(expression, node2);
    }
    this.newline();
  };
  var OptionalMemberExpression = function(node2) {
    let {
      computed
    } = node2;
    const {
      optional,
      property: property2
    } = node2;
    this.print(node2.object, node2);
    if (!computed && isMemberExpression(property2)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    if (isLiteral(property2) && typeof property2.value === "number") {
      computed = true;
    }
    if (optional) {
      this.token("?.");
    }
    if (computed) {
      this.tokenChar(91);
      this.print(property2, node2);
      this.tokenChar(93);
    } else {
      if (!optional) {
        this.tokenChar(46);
      }
      this.print(property2, node2);
    }
  };
  var OptionalCallExpression = function(node2) {
    this.print(node2.callee, node2);
    this.print(node2.typeParameters, node2);
    if (node2.optional) {
      this.token("?.");
    }
    this.print(node2.typeArguments, node2);
    this.tokenChar(40);
    this.printList(node2.arguments, node2);
    this.rightParens(node2);
  };
  var CallExpression = function(node2) {
    this.print(node2.callee, node2);
    this.print(node2.typeArguments, node2);
    this.print(node2.typeParameters, node2);
    this.tokenChar(40);
    this.printList(node2.arguments, node2);
    this.rightParens(node2);
  };
  var Import = function() {
    this.word("import");
  };
  var AwaitExpression = function(node2) {
    this.word("await");
    if (node2.argument) {
      this.space();
      this.printTerminatorless(node2.argument, node2, false);
    }
  };
  var YieldExpression = function(node2) {
    this.word("yield", true);
    if (node2.delegate) {
      this.tokenChar(42);
      if (node2.argument) {
        this.space();
        this.print(node2.argument, node2);
      }
    } else {
      if (node2.argument) {
        this.space();
        this.printTerminatorless(node2.argument, node2, false);
      }
    }
  };
  var EmptyStatement = function() {
    this.semicolon(true);
  };
  var ExpressionStatement = function(node2) {
    this.print(node2.expression, node2);
    this.semicolon();
  };
  var AssignmentPattern = function(node2) {
    this.print(node2.left, node2);
    if (node2.left.optional)
      this.tokenChar(63);
    this.print(node2.left.typeAnnotation, node2);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.right, node2);
  };
  var AssignmentExpression = function(node2, parent) {
    const parens = this.inForStatementInitCounter && node2.operator === "in" && !n.needsParens(node2, parent);
    if (parens) {
      this.tokenChar(40);
    }
    this.print(node2.left, node2);
    this.space();
    if (node2.operator === "in" || node2.operator === "instanceof") {
      this.word(node2.operator);
    } else {
      this.token(node2.operator);
    }
    this.space();
    this.print(node2.right, node2);
    if (parens) {
      this.tokenChar(41);
    }
  };
  var BindExpression = function(node2) {
    this.print(node2.object, node2);
    this.token("::");
    this.print(node2.callee, node2);
  };
  var MemberExpression = function(node2) {
    this.print(node2.object, node2);
    if (!node2.computed && isMemberExpression(node2.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    let computed = node2.computed;
    if (isLiteral(node2.property) && typeof node2.property.value === "number") {
      computed = true;
    }
    if (computed) {
      this.tokenChar(91);
      this.print(node2.property, node2);
      this.tokenChar(93);
    } else {
      this.tokenChar(46);
      this.print(node2.property, node2);
    }
  };
  var MetaProperty = function(node2) {
    this.print(node2.meta, node2);
    this.tokenChar(46);
    this.print(node2.property, node2);
  };
  var PrivateName = function(node2) {
    this.tokenChar(35);
    this.print(node2.id, node2);
  };
  var V8IntrinsicIdentifier = function(node2) {
    this.tokenChar(37);
    this.word(node2.name);
  };
  var ModuleExpression = function(node2) {
    this.word("module", true);
    this.space();
    this.tokenChar(123);
    this.indent();
    const {
      body
    } = node2;
    if (body.body.length || body.directives.length) {
      this.newline();
    }
    this.print(body, node2);
    this.dedent();
    this.rightBrace(node2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
  exports.AssignmentPattern = AssignmentPattern;
  exports.AwaitExpression = AwaitExpression;
  exports.BindExpression = BindExpression;
  exports.CallExpression = CallExpression;
  exports.ConditionalExpression = ConditionalExpression;
  exports.Decorator = Decorator;
  exports.DoExpression = DoExpression;
  exports.EmptyStatement = EmptyStatement;
  exports.ExpressionStatement = ExpressionStatement;
  exports.Import = Import;
  exports.MemberExpression = MemberExpression;
  exports.MetaProperty = MetaProperty;
  exports.ModuleExpression = ModuleExpression;
  exports.NewExpression = NewExpression;
  exports.OptionalCallExpression = OptionalCallExpression;
  exports.OptionalMemberExpression = OptionalMemberExpression;
  exports.ParenthesizedExpression = ParenthesizedExpression;
  exports.PrivateName = PrivateName;
  exports.SequenceExpression = SequenceExpression;
  exports.Super = Super;
  exports.ThisExpression = ThisExpression;
  exports.UnaryExpression = UnaryExpression;
  exports.UpdateExpression = UpdateExpression;
  exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
  exports.YieldExpression = YieldExpression;
  exports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
  var _t = require_lib3();
  var n = require_node2();
  var {
    isCallExpression,
    isLiteral,
    isMemberExpression,
    isNewExpression
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS((exports) => {
  var WithStatement = function(node2) {
    this.word("with");
    this.space();
    this.tokenChar(40);
    this.print(node2.object, node2);
    this.tokenChar(41);
    this.printBlock(node2);
  };
  var IfStatement = function(node2) {
    this.word("if");
    this.space();
    this.tokenChar(40);
    this.print(node2.test, node2);
    this.tokenChar(41);
    this.space();
    const needsBlock = node2.alternate && isIfStatement(getLastStatement(node2.consequent));
    if (needsBlock) {
      this.tokenChar(123);
      this.newline();
      this.indent();
    }
    this.printAndIndentOnComments(node2.consequent, node2);
    if (needsBlock) {
      this.dedent();
      this.newline();
      this.tokenChar(125);
    }
    if (node2.alternate) {
      if (this.endsWith(125))
        this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node2.alternate, node2);
    }
  };
  var getLastStatement = function(statement) {
    const {
      body
    } = statement;
    if (isStatement(body) === false) {
      return statement;
    }
    return getLastStatement(body);
  };
  var ForStatement = function(node2) {
    this.word("for");
    this.space();
    this.tokenChar(40);
    this.inForStatementInitCounter++;
    this.print(node2.init, node2);
    this.inForStatementInitCounter--;
    this.tokenChar(59);
    if (node2.test) {
      this.space();
      this.print(node2.test, node2);
    }
    this.tokenChar(59);
    if (node2.update) {
      this.space();
      this.print(node2.update, node2);
    }
    this.tokenChar(41);
    this.printBlock(node2);
  };
  var WhileStatement = function(node2) {
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node2.test, node2);
    this.tokenChar(41);
    this.printBlock(node2);
  };
  var ForXStatement = function(node2) {
    this.word("for");
    this.space();
    const isForOf = node2.type === "ForOfStatement";
    if (isForOf && node2.await) {
      this.word("await");
      this.space();
    }
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    this.print(node2.left, node2);
    this.space();
    this.word(isForOf ? "of" : "in");
    this.space();
    this.print(node2.right, node2);
    this.tokenChar(41);
    this.printBlock(node2);
  };
  var DoWhileStatement = function(node2) {
    this.word("do");
    this.space();
    this.print(node2.body, node2);
    this.space();
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node2.test, node2);
    this.tokenChar(41);
    this.semicolon();
  };
  var printStatementAfterKeyword = function(printer, node2, parent, isLabel) {
    if (node2) {
      printer.space();
      printer.printTerminatorless(node2, parent, isLabel);
    }
    printer.semicolon();
  };
  var BreakStatement = function(node2) {
    this.word("break");
    printStatementAfterKeyword(this, node2.label, node2, true);
  };
  var ContinueStatement = function(node2) {
    this.word("continue");
    printStatementAfterKeyword(this, node2.label, node2, true);
  };
  var ReturnStatement = function(node2) {
    this.word("return");
    printStatementAfterKeyword(this, node2.argument, node2, false);
  };
  var ThrowStatement = function(node2) {
    this.word("throw");
    printStatementAfterKeyword(this, node2.argument, node2, false);
  };
  var LabeledStatement = function(node2) {
    this.print(node2.label, node2);
    this.tokenChar(58);
    this.space();
    this.print(node2.body, node2);
  };
  var TryStatement = function(node2) {
    this.word("try");
    this.space();
    this.print(node2.block, node2);
    this.space();
    if (node2.handlers) {
      this.print(node2.handlers[0], node2);
    } else {
      this.print(node2.handler, node2);
    }
    if (node2.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node2.finalizer, node2);
    }
  };
  var CatchClause = function(node2) {
    this.word("catch");
    this.space();
    if (node2.param) {
      this.tokenChar(40);
      this.print(node2.param, node2);
      this.print(node2.param.typeAnnotation, node2);
      this.tokenChar(41);
      this.space();
    }
    this.print(node2.body, node2);
  };
  var SwitchStatement = function(node2) {
    this.word("switch");
    this.space();
    this.tokenChar(40);
    this.print(node2.discriminant, node2);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node2.cases, node2, {
      indent: true,
      addNewlines(leading, cas) {
        if (!leading && node2.cases[node2.cases.length - 1] === cas)
          return -1;
      }
    });
    this.rightBrace(node2);
  };
  var SwitchCase = function(node2) {
    if (node2.test) {
      this.word("case");
      this.space();
      this.print(node2.test, node2);
      this.tokenChar(58);
    } else {
      this.word("default");
      this.tokenChar(58);
    }
    if (node2.consequent.length) {
      this.newline();
      this.printSequence(node2.consequent, node2, {
        indent: true
      });
    }
  };
  var DebuggerStatement = function() {
    this.word("debugger");
    this.semicolon();
  };
  var VariableDeclaration = function(node2, parent) {
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    const {
      kind
    } = node2;
    this.word(kind, kind === "using" || kind === "await using");
    this.space();
    let hasInits = false;
    if (!isFor(parent)) {
      for (const declar of node2.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }
    this.printList(node2.declarations, node2, {
      separator: hasInits ? function() {
        this.tokenChar(44);
        this.newline();
      } : undefined,
      indent: node2.declarations.length > 1 ? true : false
    });
    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node2)
          return;
      } else {
        if (parent.left === node2)
          return;
      }
    }
    this.semicolon();
  };
  var VariableDeclarator = function(node2) {
    this.print(node2.id, node2);
    if (node2.definite)
      this.tokenChar(33);
    this.print(node2.id.typeAnnotation, node2);
    if (node2.init) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.init, node2);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BreakStatement = BreakStatement;
  exports.CatchClause = CatchClause;
  exports.ContinueStatement = ContinueStatement;
  exports.DebuggerStatement = DebuggerStatement;
  exports.DoWhileStatement = DoWhileStatement;
  exports.ForOfStatement = exports.ForInStatement = undefined;
  exports.ForStatement = ForStatement;
  exports.IfStatement = IfStatement;
  exports.LabeledStatement = LabeledStatement;
  exports.ReturnStatement = ReturnStatement;
  exports.SwitchCase = SwitchCase;
  exports.SwitchStatement = SwitchStatement;
  exports.ThrowStatement = ThrowStatement;
  exports.TryStatement = TryStatement;
  exports.VariableDeclaration = VariableDeclaration;
  exports.VariableDeclarator = VariableDeclarator;
  exports.WhileStatement = WhileStatement;
  exports.WithStatement = WithStatement;
  var _t = require_lib3();
  var {
    isFor,
    isForStatement,
    isIfStatement,
    isStatement
  } = _t;
  var ForInStatement = exports.ForInStatement = ForXStatement;
  var ForOfStatement = exports.ForOfStatement = ForXStatement;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS((exports) => {
  var ClassDeclaration = function(node2, parent) {
    const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
      this.printJoin(node2.decorators, node2);
    }
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("class");
    if (node2.id) {
      this.space();
      this.print(node2.id, node2);
    }
    this.print(node2.typeParameters, node2);
    if (node2.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.superClass, node2);
      this.print(node2.superTypeParameters, node2);
    }
    if (node2.implements) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node2.implements, node2);
    }
    this.space();
    this.print(node2.body, node2);
  };
  var ClassBody = function(node2) {
    this.tokenChar(123);
    if (node2.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node2.body, node2, {
        indent: true
      });
      if (!this.endsWith(10))
        this.newline();
      this.rightBrace(node2);
    }
  };
  var ClassProperty = function(node2) {
    var _node$key$loc;
    this.printJoin(node2.decorators, node2);
    const endLine = (_node$key$loc = node2.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? undefined : _node$key$loc.line;
    if (endLine)
      this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node2);
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key, node2);
      this.tokenChar(93);
    } else {
      this._variance(node2);
      this.print(node2.key, node2);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation, node2);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value, node2);
    }
    this.semicolon();
  };
  var ClassAccessorProperty = function(node2) {
    var _node$key$loc2;
    this.printJoin(node2.decorators, node2);
    const endLine = (_node$key$loc2 = node2.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? undefined : _node$key$loc2.line;
    if (endLine)
      this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node2);
    this.word("accessor", true);
    this.space();
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key, node2);
      this.tokenChar(93);
    } else {
      this._variance(node2);
      this.print(node2.key, node2);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation, node2);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value, node2);
    }
    this.semicolon();
  };
  var ClassPrivateProperty = function(node2) {
    this.printJoin(node2.decorators, node2);
    if (node2.static) {
      this.word("static");
      this.space();
    }
    this.print(node2.key, node2);
    this.print(node2.typeAnnotation, node2);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value, node2);
    }
    this.semicolon();
  };
  var ClassMethod = function(node2) {
    this._classMethodHead(node2);
    this.space();
    this.print(node2.body, node2);
  };
  var ClassPrivateMethod = function(node2) {
    this._classMethodHead(node2);
    this.space();
    this.print(node2.body, node2);
  };
  var _classMethodHead = function(node2) {
    var _node$key$loc3;
    this.printJoin(node2.decorators, node2);
    const endLine = (_node$key$loc3 = node2.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? undefined : _node$key$loc3.line;
    if (endLine)
      this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node2);
    this._methodHead(node2);
  };
  var StaticBlock = function(node2) {
    this.word("static");
    this.space();
    this.tokenChar(123);
    if (node2.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node2.body, node2, {
        indent: true
      });
      this.rightBrace(node2);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ClassAccessorProperty = ClassAccessorProperty;
  exports.ClassBody = ClassBody;
  exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
  exports.ClassMethod = ClassMethod;
  exports.ClassPrivateMethod = ClassPrivateMethod;
  exports.ClassPrivateProperty = ClassPrivateProperty;
  exports.ClassProperty = ClassProperty;
  exports.StaticBlock = StaticBlock;
  exports._classMethodHead = _classMethodHead;
  var _t = require_lib3();
  var {
    isExportDefaultDeclaration,
    isExportNamedDeclaration
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS((exports) => {
  var _params = function(node2, idNode, parentNode) {
    this.print(node2.typeParameters, node2);
    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    if (nameInfo) {
      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    this.tokenChar(40);
    this._parameters(node2.params, node2);
    this.tokenChar(41);
    const noLineTerminator = node2.type === "ArrowFunctionExpression";
    this.print(node2.returnType, node2, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
  };
  var _parameters = function(parameters, parent) {
    const paramLength = parameters.length;
    for (let i = 0;i < paramLength; i++) {
      this._param(parameters[i], parent);
      if (i < parameters.length - 1) {
        this.tokenChar(44);
        this.space();
      }
    }
  };
  var _param = function(parameter, parent) {
    this.printJoin(parameter.decorators, parameter);
    this.print(parameter, parent);
    if (parameter.optional) {
      this.tokenChar(63);
    }
    this.print(parameter.typeAnnotation, parameter);
  };
  var _methodHead = function(node2) {
    const kind = node2.kind;
    const key = node2.key;
    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    if (kind === "method" || kind === "init") {
      if (node2.generator) {
        this.tokenChar(42);
      }
    }
    if (node2.computed) {
      this.tokenChar(91);
      this.print(key, node2);
      this.tokenChar(93);
    } else {
      this.print(key, node2);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    this._params(node2, node2.computed && node2.key.type !== "StringLiteral" ? undefined : node2.key, undefined);
  };
  var _predicate = function(node2, noLineTerminatorAfter) {
    if (node2.predicate) {
      if (!node2.returnType) {
        this.tokenChar(58);
      }
      this.space();
      this.print(node2.predicate, node2, noLineTerminatorAfter);
    }
  };
  var _functionHead = function(node2, parent) {
    if (node2.async) {
      this.word("async");
      this._endsWithInnerRaw = false;
      this.space();
    }
    this.word("function");
    if (node2.generator) {
      this._endsWithInnerRaw = false;
      this.tokenChar(42);
    }
    this.space();
    if (node2.id) {
      this.print(node2.id, node2);
    }
    this._params(node2, node2.id, parent);
    if (node2.type !== "TSDeclareFunction") {
      this._predicate(node2);
    }
  };
  var FunctionExpression = function(node2, parent) {
    this._functionHead(node2, parent);
    this.space();
    this.print(node2.body, node2);
  };
  var ArrowFunctionExpression = function(node2, parent) {
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    let firstParam;
    if (!this.format.retainLines && node2.params.length === 1 && isIdentifier(firstParam = node2.params[0]) && !hasTypesOrComments(node2, firstParam)) {
      this.print(firstParam, node2, true);
    } else {
      this._params(node2, undefined, parent);
    }
    this._predicate(node2, true);
    this.space();
    this.printInnerComments();
    this.token("=>");
    this.space();
    this.print(node2.body, node2);
  };
  var hasTypesOrComments = function(node2, param) {
    var _param$leadingComment, _param$trailingCommen;
    return !!(node2.typeParameters || node2.returnType || node2.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
  };
  var _getFuncIdName = function(idNode, parent) {
    let id = idNode;
    if (!id && parent) {
      const parentType = parent.type;
      if (parentType === "VariableDeclarator") {
        id = parent.id;
      } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
        id = parent.left;
      } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
        if (!parent.computed || parent.key.type === "StringLiteral") {
          id = parent.key;
        }
      } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
        id = parent.key;
      }
    }
    if (!id)
      return;
    let nameInfo;
    if (id.type === "Identifier") {
      var _id$loc, _id$loc2;
      nameInfo = {
        pos: (_id$loc = id.loc) == null ? undefined : _id$loc.start,
        name: ((_id$loc2 = id.loc) == null ? undefined : _id$loc2.identifierName) || id.name
      };
    } else if (id.type === "PrivateName") {
      var _id$loc3;
      nameInfo = {
        pos: (_id$loc3 = id.loc) == null ? undefined : _id$loc3.start,
        name: "#" + id.id.name
      };
    } else if (id.type === "StringLiteral") {
      var _id$loc4;
      nameInfo = {
        pos: (_id$loc4 = id.loc) == null ? undefined : _id$loc4.start,
        name: id.value
      };
    }
    return nameInfo;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArrowFunctionExpression = ArrowFunctionExpression;
  exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
  exports._functionHead = _functionHead;
  exports._methodHead = _methodHead;
  exports._param = _param;
  exports._parameters = _parameters;
  exports._params = _params;
  exports._predicate = _predicate;
  var _t = require_lib3();
  var {
    isIdentifier
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS((exports) => {
  var ImportSpecifier = function(node2) {
    if (node2.importKind === "type" || node2.importKind === "typeof") {
      this.word(node2.importKind);
      this.space();
    }
    this.print(node2.imported, node2);
    if (node2.local && node2.local.name !== node2.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node2.local, node2);
    }
  };
  var ImportDefaultSpecifier = function(node2) {
    this.print(node2.local, node2);
  };
  var ExportDefaultSpecifier = function(node2) {
    this.print(node2.exported, node2);
  };
  var ExportSpecifier = function(node2) {
    if (node2.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.print(node2.local, node2);
    if (node2.exported && node2.local.name !== node2.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node2.exported, node2);
    }
  };
  var ExportNamespaceSpecifier = function(node2) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node2.exported, node2);
  };
  var _printAttributes = function(node2) {
    const {
      importAttributesKeyword
    } = this.format;
    const {
      attributes,
      assertions
    } = node2;
    if (attributes && !importAttributesKeyword && !warningShown) {
      warningShown = true;
      console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
    }
    const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    this.word(useAssertKeyword ? "assert" : "with");
    this.space();
    if (!useAssertKeyword && importAttributesKeyword !== "with") {
      this.printList(attributes || assertions, node2);
      return;
    }
    this.tokenChar(123);
    this.space();
    this.printList(attributes || assertions, node2);
    this.space();
    this.tokenChar(125);
  };
  var ExportAllDeclaration = function(node2) {
    var _node$attributes, _node$assertions;
    this.word("export");
    this.space();
    if (node2.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.tokenChar(42);
    this.space();
    this.word("from");
    this.space();
    if ((_node$attributes = node2.attributes) != null && _node$attributes.length || (_node$assertions = node2.assertions) != null && _node$assertions.length) {
      this.print(node2.source, node2, true);
      this.space();
      this._printAttributes(node2);
    } else {
      this.print(node2.source, node2);
    }
    this.semicolon();
  };
  var maybePrintDecoratorsBeforeExport = function(printer, node2) {
    if (isClassDeclaration(node2.declaration) && printer._shouldPrintDecoratorsBeforeExport(node2)) {
      printer.printJoin(node2.declaration.decorators, node2);
    }
  };
  var ExportNamedDeclaration = function(node2) {
    maybePrintDecoratorsBeforeExport(this, node2);
    this.word("export");
    this.space();
    if (node2.declaration) {
      const declar = node2.declaration;
      this.print(declar, node2);
      if (!isStatement(declar))
        this.semicolon();
    } else {
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      const specifiers = node2.specifiers.slice(0);
      let hasSpecial = false;
      for (;; ) {
        const first = specifiers[0];
        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift(), node2);
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      if (specifiers.length || !specifiers.length && !hasSpecial) {
        this.tokenChar(123);
        if (specifiers.length) {
          this.space();
          this.printList(specifiers, node2);
          this.space();
        }
        this.tokenChar(125);
      }
      if (node2.source) {
        var _node$attributes2, _node$assertions2;
        this.space();
        this.word("from");
        this.space();
        if ((_node$attributes2 = node2.attributes) != null && _node$attributes2.length || (_node$assertions2 = node2.assertions) != null && _node$assertions2.length) {
          this.print(node2.source, node2, true);
          this.space();
          this._printAttributes(node2);
        } else {
          this.print(node2.source, node2);
        }
      }
      this.semicolon();
    }
  };
  var ExportDefaultDeclaration = function(node2) {
    maybePrintDecoratorsBeforeExport(this, node2);
    this.word("export");
    this.noIndentInnerCommentsHere();
    this.space();
    this.word("default");
    this.space();
    const declar = node2.declaration;
    this.print(declar, node2);
    if (!isStatement(declar))
      this.semicolon();
  };
  var ImportDeclaration = function(node2) {
    var _node$attributes3, _node$assertions3;
    this.word("import");
    this.space();
    const isTypeKind = node2.importKind === "type" || node2.importKind === "typeof";
    if (isTypeKind) {
      this.noIndentInnerCommentsHere();
      this.word(node2.importKind);
      this.space();
    } else if (node2.module) {
      this.noIndentInnerCommentsHere();
      this.word("module");
      this.space();
    } else if (node2.phase) {
      this.noIndentInnerCommentsHere();
      this.word(node2.phase);
      this.space();
    }
    const specifiers = node2.specifiers.slice(0);
    const hasSpecifiers = !!specifiers.length;
    while (hasSpecifiers) {
      const first = specifiers[0];
      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift(), node2);
        if (specifiers.length) {
          this.tokenChar(44);
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length) {
      this.tokenChar(123);
      this.space();
      this.printList(specifiers, node2);
      this.space();
      this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
      this.tokenChar(123);
      this.tokenChar(125);
    }
    if (hasSpecifiers || isTypeKind) {
      this.space();
      this.word("from");
      this.space();
    }
    if ((_node$attributes3 = node2.attributes) != null && _node$attributes3.length || (_node$assertions3 = node2.assertions) != null && _node$assertions3.length) {
      this.print(node2.source, node2, true);
      this.space();
      this._printAttributes(node2);
    } else {
      this.print(node2.source, node2);
    }
    this.semicolon();
  };
  var ImportAttribute = function(node2) {
    this.print(node2.key);
    this.tokenChar(58);
    this.space();
    this.print(node2.value);
  };
  var ImportNamespaceSpecifier = function(node2) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node2.local, node2);
  };
  var ImportExpression = function(node2) {
    this.word("import");
    if (node2.phase) {
      this.tokenChar(46);
      this.word(node2.phase);
    }
    this.tokenChar(40);
    this.print(node2.source, node2);
    if (node2.options != null) {
      this.tokenChar(44);
      this.space();
      this.print(node2.options, node2);
    }
    this.tokenChar(41);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExportAllDeclaration = ExportAllDeclaration;
  exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
  exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
  exports.ExportNamedDeclaration = ExportNamedDeclaration;
  exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
  exports.ExportSpecifier = ExportSpecifier;
  exports.ImportAttribute = ImportAttribute;
  exports.ImportDeclaration = ImportDeclaration;
  exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
  exports.ImportExpression = ImportExpression;
  exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  exports.ImportSpecifier = ImportSpecifier;
  exports._printAttributes = _printAttributes;
  var _t = require_lib3();
  var {
    isClassDeclaration,
    isExportDefaultSpecifier,
    isExportNamespaceSpecifier,
    isImportDefaultSpecifier,
    isImportNamespaceSpecifier,
    isStatement
  } = _t;
  var warningShown = false;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS((exports, module) => {
  var object = {};
  var hasOwnProperty = object.hasOwnProperty;
  var forOwn = (object2, callback) => {
    for (const key in object2) {
      if (hasOwnProperty.call(object2, key)) {
        callback(key, object2[key]);
      }
    }
  };
  var extend = (destination, source) => {
    if (!source) {
      return destination;
    }
    forOwn(source, (key, value2) => {
      destination[key] = value2;
    });
    return destination;
  };
  var forEach = (array, callback) => {
    const length = array.length;
    let index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  var toString2 = object.toString;
  var isArray = Array.isArray;
  var isBuffer = Buffer.isBuffer;
  var isObject = (value2) => {
    return toString2.call(value2) == "[object Object]";
  };
  var isString = (value2) => {
    return typeof value2 == "string" || toString2.call(value2) == "[object String]";
  };
  var isNumber = (value2) => {
    return typeof value2 == "number" || toString2.call(value2) == "[object Number]";
  };
  var isFunction2 = (value2) => {
    return typeof value2 == "function";
  };
  var isMap = (value2) => {
    return toString2.call(value2) == "[object Map]";
  };
  var isSet = (value2) => {
    return toString2.call(value2) == "[object Set]";
  };
  var singleEscapes = {
    '"': '\\"',
    "\'": "\\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t"
  };
  var regexSingleEscape = /["'\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
  var jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };
    const defaults = {
      escapeEverything: false,
      minimal: false,
      isScriptContext: false,
      quotes: "single",
      wrap: false,
      es6: false,
      json: false,
      compact: true,
      lowercaseHex: false,
      numbers: "decimal",
      indent: "\t",
      indentLevel: 0,
      __inline1__: false,
      __inline2__: false
    };
    const json = options && options.json;
    if (json) {
      defaults.quotes = "double";
      defaults.wrap = true;
    }
    options = extend(defaults, options);
    if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
      options.quotes = "single";
    }
    const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "\'";
    const compact = options.compact;
    const lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel);
    let oldIndent = "";
    const inline1 = options.__inline1__;
    const inline2 = options.__inline2__;
    const newLine = compact ? "" : "\n";
    let result;
    let isEmpty = true;
    const useBinNumbers = options.numbers == "binary";
    const useOctNumbers = options.numbers == "octal";
    const useDecNumbers = options.numbers == "decimal";
    const useHexNumbers = options.numbers == "hexadecimal";
    if (json && argument && isFunction2(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return "new Map()";
        }
        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }
        return "new Map(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return "new Set()";
        }
        return "new Set(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return "Buffer.from([])";
        }
        return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isArray(argument)) {
        result = [];
        options.wrap = true;
        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, (value2) => {
          isEmpty = false;
          if (inline2) {
            options.__inline2__ = false;
          }
          result.push((compact || inline2 ? "" : indent) + jsesc(value2, options));
        });
        if (isEmpty) {
          return "[]";
        }
        if (inline2) {
          return "[" + result.join(", ") + "]";
        }
        return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
      } else if (isNumber(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }
        if (useDecNumbers) {
          return String(argument);
        }
        if (useHexNumbers) {
          let hexadecimal = argument.toString(16);
          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }
          return "0x" + hexadecimal;
        }
        if (useBinNumbers) {
          return "0b" + argument.toString(2);
        }
        if (useOctNumbers) {
          return "0o" + argument.toString(8);
        }
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || "null";
        }
        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value2) => {
          isEmpty = false;
          result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value2, options));
        });
        if (isEmpty) {
          return "{}";
        }
        return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
      }
    }
    const string = argument;
    let index = -1;
    const length = string.length;
    result = "";
    while (++index < length) {
      const character = string.charAt(index);
      if (options.es6) {
        const first = string.charCodeAt(index);
        if (first >= 55296 && first <= 56319 && length > index + 1) {
          const second = string.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            let hexadecimal2 = codePoint.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            result += "\\u{" + hexadecimal2 + "}";
            ++index;
            continue;
          }
        }
      }
      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }
        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }
        if (character == "`") {
          result += quote == character ? "\\`" : character;
          continue;
        }
        if (character == "\'") {
          result += quote == character ? "\\\'" : character;
          continue;
        }
      }
      if (character == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
        result += "\\0";
        continue;
      }
      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }
      const charCode = character.charCodeAt(0);
      if (options.minimal && charCode != 8232 && charCode != 8233) {
        result += character;
        continue;
      }
      let hexadecimal = charCode.toString(16);
      if (!lowercaseHex) {
        hexadecimal = hexadecimal.toUpperCase();
      }
      const longhand = hexadecimal.length > 2 || json;
      const escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
      result += escaped;
      continue;
    }
    if (options.wrap) {
      result = quote + result + quote;
    }
    if (quote == "`") {
      result = result.replace(/\$\{/g, "\\${");
    }
    if (options.isScriptContext) {
      return result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
    }
    return result;
  };
  jsesc.version = "2.5.2";
  module.exports = jsesc;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS((exports) => {
  var Identifier = function(node2) {
    var _node$loc;
    this.sourceIdentifierName(((_node$loc = node2.loc) == null ? undefined : _node$loc.identifierName) || node2.name);
    this.word(node2.name);
  };
  var ArgumentPlaceholder = function() {
    this.tokenChar(63);
  };
  var RestElement = function(node2) {
    this.token("...");
    this.print(node2.argument, node2);
  };
  var ObjectExpression = function(node2) {
    const props = node2.properties;
    this.tokenChar(123);
    if (props.length) {
      this.space();
      this.printList(props, node2, {
        indent: true,
        statement: true
      });
      this.space();
    }
    this.sourceWithOffset("end", node2.loc, -1);
    this.tokenChar(125);
  };
  var ObjectMethod = function(node2) {
    this.printJoin(node2.decorators, node2);
    this._methodHead(node2);
    this.space();
    this.print(node2.body, node2);
  };
  var ObjectProperty = function(node2) {
    this.printJoin(node2.decorators, node2);
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key, node2);
      this.tokenChar(93);
    } else {
      if (isAssignmentPattern(node2.value) && isIdentifier(node2.key) && node2.key.name === node2.value.left.name) {
        this.print(node2.value, node2);
        return;
      }
      this.print(node2.key, node2);
      if (node2.shorthand && isIdentifier(node2.key) && isIdentifier(node2.value) && node2.key.name === node2.value.name) {
        return;
      }
    }
    this.tokenChar(58);
    this.space();
    this.print(node2.value, node2);
  };
  var ArrayExpression = function(node2) {
    const elems = node2.elements;
    const len = elems.length;
    this.tokenChar(91);
    for (let i = 0;i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0)
          this.space();
        this.print(elem, node2);
        if (i < len - 1)
          this.tokenChar(44);
      } else {
        this.tokenChar(44);
      }
    }
    this.tokenChar(93);
  };
  var RecordExpression = function(node2) {
    const props = node2.properties;
    let startToken;
    let endToken;
    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "{|";
      endToken = "|}";
    } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    } else {
      startToken = "#{";
      endToken = "}";
    }
    this.token(startToken);
    if (props.length) {
      this.space();
      this.printList(props, node2, {
        indent: true,
        statement: true
      });
      this.space();
    }
    this.token(endToken);
  };
  var TupleExpression = function(node2) {
    const elems = node2.elements;
    const len = elems.length;
    let startToken;
    let endToken;
    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "[|";
      endToken = "|]";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#[";
      endToken = "]";
    } else {
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    }
    this.token(startToken);
    for (let i = 0;i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0)
          this.space();
        this.print(elem, node2);
        if (i < len - 1)
          this.tokenChar(44);
      }
    }
    this.token(endToken);
  };
  var RegExpLiteral = function(node2) {
    this.word(`/${node2.pattern}/${node2.flags}`);
  };
  var BooleanLiteral = function(node2) {
    this.word(node2.value ? "true" : "false");
  };
  var NullLiteral = function() {
    this.word("null");
  };
  var NumericLiteral = function(node2) {
    const raw = this.getPossibleRaw(node2);
    const opts = this.format.jsescOption;
    const value2 = node2.value;
    const str = value2 + "";
    if (opts.numbers) {
      this.number(_jsesc(value2, opts), value2);
    } else if (raw == null) {
      this.number(str, value2);
    } else if (this.format.minified) {
      this.number(raw.length < str.length ? raw : str, value2);
    } else {
      this.number(raw, value2);
    }
  };
  var StringLiteral = function(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    const val = _jsesc(node2.value, this.format.jsescOption);
    this.token(val);
  };
  var BigIntLiteral = function(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== undefined) {
      this.word(raw);
      return;
    }
    this.word(node2.value + "n");
  };
  var DecimalLiteral = function(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== undefined) {
      this.word(raw);
      return;
    }
    this.word(node2.value + "m");
  };
  var TopicReference = function() {
    const {
      topicToken
    } = this.format;
    if (validTopicTokenSet.has(topicToken)) {
      this.token(topicToken);
    } else {
      const givenTopicTokenJSON = JSON.stringify(topicToken);
      const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
      throw new Error(`The "topicToken" generator option must be one of ` + `${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
    }
  };
  var PipelineTopicExpression = function(node2) {
    this.print(node2.expression, node2);
  };
  var PipelineBareFunction = function(node2) {
    this.print(node2.callee, node2);
  };
  var PipelinePrimaryTopicReference = function() {
    this.tokenChar(35);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArgumentPlaceholder = ArgumentPlaceholder;
  exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
  exports.BigIntLiteral = BigIntLiteral;
  exports.BooleanLiteral = BooleanLiteral;
  exports.DecimalLiteral = DecimalLiteral;
  exports.Identifier = Identifier;
  exports.NullLiteral = NullLiteral;
  exports.NumericLiteral = NumericLiteral;
  exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
  exports.ObjectMethod = ObjectMethod;
  exports.ObjectProperty = ObjectProperty;
  exports.PipelineBareFunction = PipelineBareFunction;
  exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
  exports.PipelineTopicExpression = PipelineTopicExpression;
  exports.RecordExpression = RecordExpression;
  exports.RegExpLiteral = RegExpLiteral;
  exports.SpreadElement = exports.RestElement = RestElement;
  exports.StringLiteral = StringLiteral;
  exports.TopicReference = TopicReference;
  exports.TupleExpression = TupleExpression;
  var _t = require_lib3();
  var _jsesc = require_jsesc();
  var {
    isAssignmentPattern,
    isIdentifier
  } = _t;
  var validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS((exports) => {
  var AnyTypeAnnotation = function() {
    this.word("any");
  };
  var ArrayTypeAnnotation = function(node2) {
    this.print(node2.elementType, node2, true);
    this.tokenChar(91);
    this.tokenChar(93);
  };
  var BooleanTypeAnnotation = function() {
    this.word("boolean");
  };
  var BooleanLiteralTypeAnnotation = function(node2) {
    this.word(node2.value ? "true" : "false");
  };
  var NullLiteralTypeAnnotation = function() {
    this.word("null");
  };
  var DeclareClass = function(node2, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("class");
    this.space();
    this._interfaceish(node2);
  };
  var DeclareFunction = function(node2, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("function");
    this.space();
    this.print(node2.id, node2);
    this.print(node2.id.typeAnnotation.typeAnnotation, node2);
    if (node2.predicate) {
      this.space();
      this.print(node2.predicate, node2);
    }
    this.semicolon();
  };
  var InferredPredicate = function() {
    this.tokenChar(37);
    this.word("checks");
  };
  var DeclaredPredicate = function(node2) {
    this.tokenChar(37);
    this.word("checks");
    this.tokenChar(40);
    this.print(node2.value, node2);
    this.tokenChar(41);
  };
  var DeclareInterface = function(node2) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node2);
  };
  var DeclareModule = function(node2) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node2.id, node2);
    this.space();
    this.print(node2.body, node2);
  };
  var DeclareModuleExports = function(node2) {
    this.word("declare");
    this.space();
    this.word("module");
    this.tokenChar(46);
    this.word("exports");
    this.print(node2.typeAnnotation, node2);
  };
  var DeclareTypeAlias = function(node2) {
    this.word("declare");
    this.space();
    this.TypeAlias(node2);
  };
  var DeclareOpaqueType = function(node2, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.OpaqueType(node2);
  };
  var DeclareVariable = function(node2, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("var");
    this.space();
    this.print(node2.id, node2);
    this.print(node2.id.typeAnnotation, node2);
    this.semicolon();
  };
  var DeclareExportDeclaration = function(node2) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();
    if (node2.default) {
      this.word("default");
      this.space();
    }
    FlowExportDeclaration.call(this, node2);
  };
  var DeclareExportAllDeclaration = function(node2) {
    this.word("declare");
    this.space();
    _modules.ExportAllDeclaration.call(this, node2);
  };
  var EnumDeclaration = function(node2) {
    const {
      id,
      body
    } = node2;
    this.word("enum");
    this.space();
    this.print(id, node2);
    this.print(body, node2);
  };
  var enumExplicitType = function(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }
    context.space();
  };
  var enumBody = function(context, node2) {
    const {
      members
    } = node2;
    context.token("{");
    context.indent();
    context.newline();
    for (const member of members) {
      context.print(member, node2);
      context.newline();
    }
    if (node2.hasUnknownMembers) {
      context.token("...");
      context.newline();
    }
    context.dedent();
    context.token("}");
  };
  var EnumBooleanBody = function(node2) {
    const {
      explicitType
    } = node2;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node2);
  };
  var EnumNumberBody = function(node2) {
    const {
      explicitType
    } = node2;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node2);
  };
  var EnumStringBody = function(node2) {
    const {
      explicitType
    } = node2;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node2);
  };
  var EnumSymbolBody = function(node2) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node2);
  };
  var EnumDefaultedMember = function(node2) {
    const {
      id
    } = node2;
    this.print(id, node2);
    this.tokenChar(44);
  };
  var enumInitializedMember = function(context, node2) {
    const {
      id,
      init
    } = node2;
    context.print(id, node2);
    context.space();
    context.token("=");
    context.space();
    context.print(init, node2);
    context.token(",");
  };
  var EnumBooleanMember = function(node2) {
    enumInitializedMember(this, node2);
  };
  var EnumNumberMember = function(node2) {
    enumInitializedMember(this, node2);
  };
  var EnumStringMember = function(node2) {
    enumInitializedMember(this, node2);
  };
  var FlowExportDeclaration = function(node2) {
    if (node2.declaration) {
      const declar = node2.declaration;
      this.print(declar, node2);
      if (!isStatement(declar))
        this.semicolon();
    } else {
      this.tokenChar(123);
      if (node2.specifiers.length) {
        this.space();
        this.printList(node2.specifiers, node2);
        this.space();
      }
      this.tokenChar(125);
      if (node2.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node2.source, node2);
      }
      this.semicolon();
    }
  };
  var ExistsTypeAnnotation = function() {
    this.tokenChar(42);
  };
  var FunctionTypeAnnotation = function(node2, parent) {
    this.print(node2.typeParameters, node2);
    this.tokenChar(40);
    if (node2.this) {
      this.word("this");
      this.tokenChar(58);
      this.space();
      this.print(node2.this.typeAnnotation, node2);
      if (node2.params.length || node2.rest) {
        this.tokenChar(44);
        this.space();
      }
    }
    this.printList(node2.params, node2);
    if (node2.rest) {
      if (node2.params.length) {
        this.tokenChar(44);
        this.space();
      }
      this.token("...");
      this.print(node2.rest, node2);
    }
    this.tokenChar(41);
    const type = parent == null ? undefined : parent.type;
    if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
      this.tokenChar(58);
    } else {
      this.space();
      this.token("=>");
    }
    this.space();
    this.print(node2.returnType, node2);
  };
  var FunctionTypeParam = function(node2) {
    this.print(node2.name, node2);
    if (node2.optional)
      this.tokenChar(63);
    if (node2.name) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node2.typeAnnotation, node2);
  };
  var InterfaceExtends = function(node2) {
    this.print(node2.id, node2);
    this.print(node2.typeParameters, node2, true);
  };
  var _interfaceish = function(node2) {
    var _node$extends;
    this.print(node2.id, node2);
    this.print(node2.typeParameters, node2);
    if ((_node$extends = node2.extends) != null && _node$extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node2.extends, node2);
    }
    if (node2.type === "DeclareClass") {
      var _node$mixins, _node$implements;
      if ((_node$mixins = node2.mixins) != null && _node$mixins.length) {
        this.space();
        this.word("mixins");
        this.space();
        this.printList(node2.mixins, node2);
      }
      if ((_node$implements = node2.implements) != null && _node$implements.length) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node2.implements, node2);
      }
    }
    this.space();
    this.print(node2.body, node2);
  };
  var _variance = function(node2) {
    var _node$variance;
    const kind = (_node$variance = node2.variance) == null ? undefined : _node$variance.kind;
    if (kind != null) {
      if (kind === "plus") {
        this.tokenChar(43);
      } else if (kind === "minus") {
        this.tokenChar(45);
      }
    }
  };
  var InterfaceDeclaration = function(node2) {
    this.word("interface");
    this.space();
    this._interfaceish(node2);
  };
  var andSeparator = function() {
    this.space();
    this.tokenChar(38);
    this.space();
  };
  var InterfaceTypeAnnotation = function(node2) {
    var _node$extends2;
    this.word("interface");
    if ((_node$extends2 = node2.extends) != null && _node$extends2.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node2.extends, node2);
    }
    this.space();
    this.print(node2.body, node2);
  };
  var IntersectionTypeAnnotation = function(node2) {
    this.printJoin(node2.types, node2, {
      separator: andSeparator
    });
  };
  var MixedTypeAnnotation = function() {
    this.word("mixed");
  };
  var EmptyTypeAnnotation = function() {
    this.word("empty");
  };
  var NullableTypeAnnotation = function(node2) {
    this.tokenChar(63);
    this.print(node2.typeAnnotation, node2);
  };
  var NumberTypeAnnotation = function() {
    this.word("number");
  };
  var StringTypeAnnotation = function() {
    this.word("string");
  };
  var ThisTypeAnnotation = function() {
    this.word("this");
  };
  var TupleTypeAnnotation = function(node2) {
    this.tokenChar(91);
    this.printList(node2.types, node2);
    this.tokenChar(93);
  };
  var TypeofTypeAnnotation = function(node2) {
    this.word("typeof");
    this.space();
    this.print(node2.argument, node2);
  };
  var TypeAlias = function(node2) {
    this.word("type");
    this.space();
    this.print(node2.id, node2);
    this.print(node2.typeParameters, node2);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.right, node2);
    this.semicolon();
  };
  var TypeAnnotation = function(node2) {
    this.tokenChar(58);
    this.space();
    if (node2.optional)
      this.tokenChar(63);
    this.print(node2.typeAnnotation, node2);
  };
  var TypeParameterInstantiation = function(node2) {
    this.tokenChar(60);
    this.printList(node2.params, node2, {});
    this.tokenChar(62);
  };
  var TypeParameter = function(node2) {
    this._variance(node2);
    this.word(node2.name);
    if (node2.bound) {
      this.print(node2.bound, node2);
    }
    if (node2.default) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.default, node2);
    }
  };
  var OpaqueType = function(node2) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node2.id, node2);
    this.print(node2.typeParameters, node2);
    if (node2.supertype) {
      this.tokenChar(58);
      this.space();
      this.print(node2.supertype, node2);
    }
    if (node2.impltype) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.impltype, node2);
    }
    this.semicolon();
  };
  var ObjectTypeAnnotation = function(node2) {
    if (node2.exact) {
      this.token("{|");
    } else {
      this.tokenChar(123);
    }
    const props = [...node2.properties, ...node2.callProperties || [], ...node2.indexers || [], ...node2.internalSlots || []];
    if (props.length) {
      this.newline();
      this.space();
      this.printJoin(props, node2, {
        addNewlines(leading) {
          if (leading && !props[0])
            return 1;
        },
        indent: true,
        statement: true,
        iterator: () => {
          if (props.length !== 1 || node2.inexact) {
            this.tokenChar(44);
            this.space();
          }
        }
      });
      this.space();
    }
    if (node2.inexact) {
      this.indent();
      this.token("...");
      if (props.length) {
        this.newline();
      }
      this.dedent();
    }
    if (node2.exact) {
      this.token("|}");
    } else {
      this.tokenChar(125);
    }
  };
  var ObjectTypeInternalSlot = function(node2) {
    if (node2.static) {
      this.word("static");
      this.space();
    }
    this.tokenChar(91);
    this.tokenChar(91);
    this.print(node2.id, node2);
    this.tokenChar(93);
    this.tokenChar(93);
    if (node2.optional)
      this.tokenChar(63);
    if (!node2.method) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node2.value, node2);
  };
  var ObjectTypeCallProperty = function(node2) {
    if (node2.static) {
      this.word("static");
      this.space();
    }
    this.print(node2.value, node2);
  };
  var ObjectTypeIndexer = function(node2) {
    if (node2.static) {
      this.word("static");
      this.space();
    }
    this._variance(node2);
    this.tokenChar(91);
    if (node2.id) {
      this.print(node2.id, node2);
      this.tokenChar(58);
      this.space();
    }
    this.print(node2.key, node2);
    this.tokenChar(93);
    this.tokenChar(58);
    this.space();
    this.print(node2.value, node2);
  };
  var ObjectTypeProperty = function(node2) {
    if (node2.proto) {
      this.word("proto");
      this.space();
    }
    if (node2.static) {
      this.word("static");
      this.space();
    }
    if (node2.kind === "get" || node2.kind === "set") {
      this.word(node2.kind);
      this.space();
    }
    this._variance(node2);
    this.print(node2.key, node2);
    if (node2.optional)
      this.tokenChar(63);
    if (!node2.method) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node2.value, node2);
  };
  var ObjectTypeSpreadProperty = function(node2) {
    this.token("...");
    this.print(node2.argument, node2);
  };
  var QualifiedTypeIdentifier = function(node2) {
    this.print(node2.qualification, node2);
    this.tokenChar(46);
    this.print(node2.id, node2);
  };
  var SymbolTypeAnnotation = function() {
    this.word("symbol");
  };
  var orSeparator = function() {
    this.space();
    this.tokenChar(124);
    this.space();
  };
  var UnionTypeAnnotation = function(node2) {
    this.printJoin(node2.types, node2, {
      separator: orSeparator
    });
  };
  var TypeCastExpression = function(node2) {
    this.tokenChar(40);
    this.print(node2.expression, node2);
    this.print(node2.typeAnnotation, node2);
    this.tokenChar(41);
  };
  var Variance = function(node2) {
    if (node2.kind === "plus") {
      this.tokenChar(43);
    } else {
      this.tokenChar(45);
    }
  };
  var VoidTypeAnnotation = function() {
    this.word("void");
  };
  var IndexedAccessType = function(node2) {
    this.print(node2.objectType, node2, true);
    this.tokenChar(91);
    this.print(node2.indexType, node2);
    this.tokenChar(93);
  };
  var OptionalIndexedAccessType = function(node2) {
    this.print(node2.objectType, node2);
    if (node2.optional) {
      this.token("?.");
    }
    this.tokenChar(91);
    this.print(node2.indexType, node2);
    this.tokenChar(93);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnyTypeAnnotation = AnyTypeAnnotation;
  exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
  exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
  exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
  exports.DeclareClass = DeclareClass;
  exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
  exports.DeclareExportDeclaration = DeclareExportDeclaration;
  exports.DeclareFunction = DeclareFunction;
  exports.DeclareInterface = DeclareInterface;
  exports.DeclareModule = DeclareModule;
  exports.DeclareModuleExports = DeclareModuleExports;
  exports.DeclareOpaqueType = DeclareOpaqueType;
  exports.DeclareTypeAlias = DeclareTypeAlias;
  exports.DeclareVariable = DeclareVariable;
  exports.DeclaredPredicate = DeclaredPredicate;
  exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
  exports.EnumBooleanBody = EnumBooleanBody;
  exports.EnumBooleanMember = EnumBooleanMember;
  exports.EnumDeclaration = EnumDeclaration;
  exports.EnumDefaultedMember = EnumDefaultedMember;
  exports.EnumNumberBody = EnumNumberBody;
  exports.EnumNumberMember = EnumNumberMember;
  exports.EnumStringBody = EnumStringBody;
  exports.EnumStringMember = EnumStringMember;
  exports.EnumSymbolBody = EnumSymbolBody;
  exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.FunctionTypeParam = FunctionTypeParam;
  exports.IndexedAccessType = IndexedAccessType;
  exports.InferredPredicate = InferredPredicate;
  exports.InterfaceDeclaration = InterfaceDeclaration;
  exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
  exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
  exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
  exports.MixedTypeAnnotation = MixedTypeAnnotation;
  exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _types2.NumericLiteral;
    }
  });
  exports.NumberTypeAnnotation = NumberTypeAnnotation;
  exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
  exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
  exports.ObjectTypeIndexer = ObjectTypeIndexer;
  exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
  exports.ObjectTypeProperty = ObjectTypeProperty;
  exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
  exports.OpaqueType = OpaqueType;
  exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
  exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _types2.StringLiteral;
    }
  });
  exports.StringTypeAnnotation = StringTypeAnnotation;
  exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
  exports.ThisTypeAnnotation = ThisTypeAnnotation;
  exports.TupleTypeAnnotation = TupleTypeAnnotation;
  exports.TypeAlias = TypeAlias;
  exports.TypeAnnotation = TypeAnnotation;
  exports.TypeCastExpression = TypeCastExpression;
  exports.TypeParameter = TypeParameter;
  exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
  exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
  exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.Variance = Variance;
  exports.VoidTypeAnnotation = VoidTypeAnnotation;
  exports._interfaceish = _interfaceish;
  exports._variance = _variance;
  var _t = require_lib3();
  var _modules = require_modules();
  var _types2 = require_types();
  var {
    isDeclareExportDeclaration,
    isStatement
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS((exports) => {
  var File = function(node2) {
    if (node2.program) {
      this.print(node2.program.interpreter, node2);
    }
    this.print(node2.program, node2);
  };
  var Program = function(node2) {
    var _node$directives;
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    const directivesLen = (_node$directives = node2.directives) == null ? undefined : _node$directives.length;
    if (directivesLen) {
      var _node$directives$trai;
      const newline = node2.body.length ? 2 : 1;
      this.printSequence(node2.directives, node2, {
        trailingCommentsLineOffset: newline
      });
      if (!((_node$directives$trai = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node2.body, node2);
  };
  var BlockStatement = function(node2) {
    var _node$directives2;
    this.tokenChar(123);
    const directivesLen = (_node$directives2 = node2.directives) == null ? undefined : _node$directives2.length;
    if (directivesLen) {
      var _node$directives$trai2;
      const newline = node2.body.length ? 2 : 1;
      this.printSequence(node2.directives, node2, {
        indent: true,
        trailingCommentsLineOffset: newline
      });
      if (!((_node$directives$trai2 = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node2.body, node2, {
      indent: true
    });
    this.rightBrace(node2);
  };
  var Directive = function(node2) {
    this.print(node2.value, node2);
    this.semicolon();
  };
  var DirectiveLiteral = function(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    const {
      value: value2
    } = node2;
    if (!unescapedDoubleQuoteRE.test(value2)) {
      this.token(`"${value2}"`);
    } else if (!unescapedSingleQuoteRE.test(value2)) {
      this.token(`'${value2}'`);
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
    }
  };
  var InterpreterDirective = function(node2) {
    this.token(`#!${node2.value}`);
    this.newline(1, true);
  };
  var Placeholder = function(node2) {
    this.token("%%");
    this.print(node2.name);
    this.token("%%");
    if (node2.expectedNode === "Statement") {
      this.semicolon();
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BlockStatement = BlockStatement;
  exports.Directive = Directive;
  exports.DirectiveLiteral = DirectiveLiteral;
  exports.File = File;
  exports.InterpreterDirective = InterpreterDirective;
  exports.Placeholder = Placeholder;
  exports.Program = Program;
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS((exports) => {
  var JSXAttribute = function(node2) {
    this.print(node2.name, node2);
    if (node2.value) {
      this.tokenChar(61);
      this.print(node2.value, node2);
    }
  };
  var JSXIdentifier = function(node2) {
    this.word(node2.name);
  };
  var JSXNamespacedName = function(node2) {
    this.print(node2.namespace, node2);
    this.tokenChar(58);
    this.print(node2.name, node2);
  };
  var JSXMemberExpression = function(node2) {
    this.print(node2.object, node2);
    this.tokenChar(46);
    this.print(node2.property, node2);
  };
  var JSXSpreadAttribute = function(node2) {
    this.tokenChar(123);
    this.token("...");
    this.print(node2.argument, node2);
    this.tokenChar(125);
  };
  var JSXExpressionContainer = function(node2) {
    this.tokenChar(123);
    this.print(node2.expression, node2);
    this.tokenChar(125);
  };
  var JSXSpreadChild = function(node2) {
    this.tokenChar(123);
    this.token("...");
    this.print(node2.expression, node2);
    this.tokenChar(125);
  };
  var JSXText = function(node2) {
    const raw = this.getPossibleRaw(node2);
    if (raw !== undefined) {
      this.token(raw, true);
    } else {
      this.token(node2.value, true);
    }
  };
  var JSXElement = function(node2) {
    const open = node2.openingElement;
    this.print(open, node2);
    if (open.selfClosing)
      return;
    this.indent();
    for (const child of node2.children) {
      this.print(child, node2);
    }
    this.dedent();
    this.print(node2.closingElement, node2);
  };
  var spaceSeparator = function() {
    this.space();
  };
  var JSXOpeningElement = function(node2) {
    this.tokenChar(60);
    this.print(node2.name, node2);
    this.print(node2.typeParameters, node2);
    if (node2.attributes.length > 0) {
      this.space();
      this.printJoin(node2.attributes, node2, {
        separator: spaceSeparator
      });
    }
    if (node2.selfClosing) {
      this.space();
      this.token("/>");
    } else {
      this.tokenChar(62);
    }
  };
  var JSXClosingElement = function(node2) {
    this.token("</");
    this.print(node2.name, node2);
    this.tokenChar(62);
  };
  var JSXEmptyExpression = function() {
    this.printInnerComments();
  };
  var JSXFragment = function(node2) {
    this.print(node2.openingFragment, node2);
    this.indent();
    for (const child of node2.children) {
      this.print(child, node2);
    }
    this.dedent();
    this.print(node2.closingFragment, node2);
  };
  var JSXOpeningFragment = function() {
    this.tokenChar(60);
    this.tokenChar(62);
  };
  var JSXClosingFragment = function() {
    this.token("</");
    this.tokenChar(62);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.JSXAttribute = JSXAttribute;
  exports.JSXClosingElement = JSXClosingElement;
  exports.JSXClosingFragment = JSXClosingFragment;
  exports.JSXElement = JSXElement;
  exports.JSXEmptyExpression = JSXEmptyExpression;
  exports.JSXExpressionContainer = JSXExpressionContainer;
  exports.JSXFragment = JSXFragment;
  exports.JSXIdentifier = JSXIdentifier;
  exports.JSXMemberExpression = JSXMemberExpression;
  exports.JSXNamespacedName = JSXNamespacedName;
  exports.JSXOpeningElement = JSXOpeningElement;
  exports.JSXOpeningFragment = JSXOpeningFragment;
  exports.JSXSpreadAttribute = JSXSpreadAttribute;
  exports.JSXSpreadChild = JSXSpreadChild;
  exports.JSXText = JSXText;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS((exports) => {
  var TSTypeAnnotation = function(node2) {
    this.tokenChar(58);
    this.space();
    if (node2.optional)
      this.tokenChar(63);
    this.print(node2.typeAnnotation, node2);
  };
  var TSTypeParameterInstantiation = function(node2, parent) {
    this.tokenChar(60);
    this.printList(node2.params, node2, {});
    if (parent.type === "ArrowFunctionExpression" && node2.params.length === 1) {
      this.tokenChar(44);
    }
    this.tokenChar(62);
  };
  var TSTypeParameter = function(node2) {
    if (node2.in) {
      this.word("in");
      this.space();
    }
    if (node2.out) {
      this.word("out");
      this.space();
    }
    this.word(node2.name);
    if (node2.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.constraint, node2);
    }
    if (node2.default) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.default, node2);
    }
  };
  var TSParameterProperty = function(node2) {
    if (node2.accessibility) {
      this.word(node2.accessibility);
      this.space();
    }
    if (node2.readonly) {
      this.word("readonly");
      this.space();
    }
    this._param(node2.parameter);
  };
  var TSDeclareFunction = function(node2, parent) {
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    this._functionHead(node2, parent);
    this.tokenChar(59);
  };
  var TSDeclareMethod = function(node2) {
    this._classMethodHead(node2);
    this.tokenChar(59);
  };
  var TSQualifiedName = function(node2) {
    this.print(node2.left, node2);
    this.tokenChar(46);
    this.print(node2.right, node2);
  };
  var TSCallSignatureDeclaration = function(node2) {
    this.tsPrintSignatureDeclarationBase(node2);
    this.tokenChar(59);
  };
  var TSConstructSignatureDeclaration = function(node2) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node2);
    this.tokenChar(59);
  };
  var TSPropertySignature = function(node2) {
    const {
      readonly
    } = node2;
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node2);
    this.print(node2.typeAnnotation, node2);
    this.tokenChar(59);
  };
  var tsPrintPropertyOrMethodName = function(node2) {
    if (node2.computed) {
      this.tokenChar(91);
    }
    this.print(node2.key, node2);
    if (node2.computed) {
      this.tokenChar(93);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
  };
  var TSMethodSignature = function(node2) {
    const {
      kind
    } = node2;
    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node2);
    this.tsPrintSignatureDeclarationBase(node2);
    this.tokenChar(59);
  };
  var TSIndexSignature = function(node2) {
    const {
      readonly,
      static: isStatic
    } = node2;
    if (isStatic) {
      this.word("static");
      this.space();
    }
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this._parameters(node2.parameters, node2);
    this.tokenChar(93);
    this.print(node2.typeAnnotation, node2);
    this.tokenChar(59);
  };
  var TSAnyKeyword = function() {
    this.word("any");
  };
  var TSBigIntKeyword = function() {
    this.word("bigint");
  };
  var TSUnknownKeyword = function() {
    this.word("unknown");
  };
  var TSNumberKeyword = function() {
    this.word("number");
  };
  var TSObjectKeyword = function() {
    this.word("object");
  };
  var TSBooleanKeyword = function() {
    this.word("boolean");
  };
  var TSStringKeyword = function() {
    this.word("string");
  };
  var TSSymbolKeyword = function() {
    this.word("symbol");
  };
  var TSVoidKeyword = function() {
    this.word("void");
  };
  var TSUndefinedKeyword = function() {
    this.word("undefined");
  };
  var TSNullKeyword = function() {
    this.word("null");
  };
  var TSNeverKeyword = function() {
    this.word("never");
  };
  var TSIntrinsicKeyword = function() {
    this.word("intrinsic");
  };
  var TSThisType = function() {
    this.word("this");
  };
  var TSFunctionType = function(node2) {
    this.tsPrintFunctionOrConstructorType(node2);
  };
  var TSConstructorType = function(node2) {
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node2);
  };
  var tsPrintFunctionOrConstructorType = function(node2) {
    const {
      typeParameters
    } = node2;
    const parameters = node2.parameters;
    this.print(typeParameters, node2);
    this.tokenChar(40);
    this._parameters(parameters, node2);
    this.tokenChar(41);
    this.space();
    this.token("=>");
    this.space();
    const returnType = node2.typeAnnotation;
    this.print(returnType.typeAnnotation, node2);
  };
  var TSTypeReference = function(node2) {
    this.print(node2.typeName, node2, true);
    this.print(node2.typeParameters, node2, true);
  };
  var TSTypePredicate = function(node2) {
    if (node2.asserts) {
      this.word("asserts");
      this.space();
    }
    this.print(node2.parameterName);
    if (node2.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node2.typeAnnotation.typeAnnotation);
    }
  };
  var TSTypeQuery = function(node2) {
    this.word("typeof");
    this.space();
    this.print(node2.exprName);
    if (node2.typeParameters) {
      this.print(node2.typeParameters, node2);
    }
  };
  var TSTypeLiteral = function(node2) {
    this.tsPrintTypeLiteralOrInterfaceBody(node2.members, node2);
  };
  var tsPrintTypeLiteralOrInterfaceBody = function(members, node2) {
    tsPrintBraced(this, members, node2);
  };
  var tsPrintBraced = function(printer, members, node2) {
    printer.token("{");
    if (members.length) {
      printer.indent();
      printer.newline();
      for (const member of members) {
        printer.print(member, node2);
        printer.newline();
      }
      printer.dedent();
    }
    printer.rightBrace(node2);
  };
  var TSArrayType = function(node2) {
    this.print(node2.elementType, node2, true);
    this.token("[]");
  };
  var TSTupleType = function(node2) {
    this.tokenChar(91);
    this.printList(node2.elementTypes, node2);
    this.tokenChar(93);
  };
  var TSOptionalType = function(node2) {
    this.print(node2.typeAnnotation, node2);
    this.tokenChar(63);
  };
  var TSRestType = function(node2) {
    this.token("...");
    this.print(node2.typeAnnotation, node2);
  };
  var TSNamedTupleMember = function(node2) {
    this.print(node2.label, node2);
    if (node2.optional)
      this.tokenChar(63);
    this.tokenChar(58);
    this.space();
    this.print(node2.elementType, node2);
  };
  var TSUnionType = function(node2) {
    tsPrintUnionOrIntersectionType(this, node2, "|");
  };
  var TSIntersectionType = function(node2) {
    tsPrintUnionOrIntersectionType(this, node2, "&");
  };
  var tsPrintUnionOrIntersectionType = function(printer, node2, sep) {
    printer.printJoin(node2.types, node2, {
      separator() {
        this.space();
        this.token(sep);
        this.space();
      }
    });
  };
  var TSConditionalType = function(node2) {
    this.print(node2.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node2.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node2.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node2.falseType);
  };
  var TSInferType = function(node2) {
    this.token("infer");
    this.space();
    this.print(node2.typeParameter);
  };
  var TSParenthesizedType = function(node2) {
    this.tokenChar(40);
    this.print(node2.typeAnnotation, node2);
    this.tokenChar(41);
  };
  var TSTypeOperator = function(node2) {
    this.word(node2.operator);
    this.space();
    this.print(node2.typeAnnotation, node2);
  };
  var TSIndexedAccessType = function(node2) {
    this.print(node2.objectType, node2, true);
    this.tokenChar(91);
    this.print(node2.indexType, node2);
    this.tokenChar(93);
  };
  var TSMappedType = function(node2) {
    const {
      nameType,
      optional,
      readonly,
      typeParameter
    } = node2;
    this.tokenChar(123);
    this.space();
    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this.word(typeParameter.name);
    this.space();
    this.word("in");
    this.space();
    this.print(typeParameter.constraint, typeParameter);
    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType, node2);
    }
    this.tokenChar(93);
    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.tokenChar(63);
    }
    this.tokenChar(58);
    this.space();
    this.print(node2.typeAnnotation, node2);
    this.space();
    this.tokenChar(125);
  };
  var tokenIfPlusMinus = function(self2, tok) {
    if (tok !== true) {
      self2.token(tok);
    }
  };
  var TSLiteralType = function(node2) {
    this.print(node2.literal, node2);
  };
  var TSExpressionWithTypeArguments = function(node2) {
    this.print(node2.expression, node2);
    this.print(node2.typeParameters, node2);
  };
  var TSInterfaceDeclaration = function(node2) {
    const {
      declare,
      id,
      typeParameters,
      extends: extendz,
      body
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("interface");
    this.space();
    this.print(id, node2);
    this.print(typeParameters, node2);
    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz, node2);
    }
    this.space();
    this.print(body, node2);
  };
  var TSInterfaceBody = function(node2) {
    this.tsPrintTypeLiteralOrInterfaceBody(node2.body, node2);
  };
  var TSTypeAliasDeclaration = function(node2) {
    const {
      declare,
      id,
      typeParameters,
      typeAnnotation
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("type");
    this.space();
    this.print(id, node2);
    this.print(typeParameters, node2);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation, node2);
    this.tokenChar(59);
  };
  var TSTypeExpression = function(node2) {
    var _expression$trailingC;
    const {
      type,
      expression,
      typeAnnotation
    } = node2;
    const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);
    this.print(expression, node2, true, undefined, forceParens);
    this.space();
    this.word(type === "TSAsExpression" ? "as" : "satisfies");
    this.space();
    this.print(typeAnnotation, node2);
  };
  var TSTypeAssertion = function(node2) {
    const {
      typeAnnotation,
      expression
    } = node2;
    this.tokenChar(60);
    this.print(typeAnnotation, node2);
    this.tokenChar(62);
    this.space();
    this.print(expression, node2);
  };
  var TSInstantiationExpression = function(node2) {
    this.print(node2.expression, node2);
    this.print(node2.typeParameters, node2);
  };
  var TSEnumDeclaration = function(node2) {
    const {
      declare,
      const: isConst,
      id,
      members
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (isConst) {
      this.word("const");
      this.space();
    }
    this.word("enum");
    this.space();
    this.print(id, node2);
    this.space();
    tsPrintBraced(this, members, node2);
  };
  var TSEnumMember = function(node2) {
    const {
      id,
      initializer
    } = node2;
    this.print(id, node2);
    if (initializer) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(initializer, node2);
    }
    this.tokenChar(44);
  };
  var TSModuleDeclaration = function(node2) {
    const {
      declare,
      id
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (!node2.global) {
      this.word(id.type === "Identifier" ? "namespace" : "module");
      this.space();
    }
    this.print(id, node2);
    if (!node2.body) {
      this.tokenChar(59);
      return;
    }
    let body = node2.body;
    while (body.type === "TSModuleDeclaration") {
      this.tokenChar(46);
      this.print(body.id, body);
      body = body.body;
    }
    this.space();
    this.print(body, node2);
  };
  var TSModuleBlock = function(node2) {
    tsPrintBraced(this, node2.body, node2);
  };
  var TSImportType = function(node2) {
    const {
      argument,
      qualifier,
      typeParameters
    } = node2;
    this.word("import");
    this.tokenChar(40);
    this.print(argument, node2);
    this.tokenChar(41);
    if (qualifier) {
      this.tokenChar(46);
      this.print(qualifier, node2);
    }
    if (typeParameters) {
      this.print(typeParameters, node2);
    }
  };
  var TSImportEqualsDeclaration = function(node2) {
    const {
      isExport,
      id,
      moduleReference
    } = node2;
    if (isExport) {
      this.word("export");
      this.space();
    }
    this.word("import");
    this.space();
    this.print(id, node2);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference, node2);
    this.tokenChar(59);
  };
  var TSExternalModuleReference = function(node2) {
    this.token("require(");
    this.print(node2.expression, node2);
    this.tokenChar(41);
  };
  var TSNonNullExpression = function(node2) {
    this.print(node2.expression, node2);
    this.tokenChar(33);
  };
  var TSExportAssignment = function(node2) {
    this.word("export");
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.expression, node2);
    this.tokenChar(59);
  };
  var TSNamespaceExportDeclaration = function(node2) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node2.id, node2);
  };
  var tsPrintSignatureDeclarationBase = function(node2) {
    const {
      typeParameters
    } = node2;
    const parameters = node2.parameters;
    this.print(typeParameters, node2);
    this.tokenChar(40);
    this._parameters(parameters, node2);
    this.tokenChar(41);
    const returnType = node2.typeAnnotation;
    this.print(returnType, node2);
  };
  var tsPrintClassMemberModifiers = function(node2) {
    const isField = node2.type === "ClassAccessorProperty" || node2.type === "ClassProperty";
    if (isField && node2.declare) {
      this.word("declare");
      this.space();
    }
    if (node2.accessibility) {
      this.word(node2.accessibility);
      this.space();
    }
    if (node2.static) {
      this.word("static");
      this.space();
    }
    if (node2.override) {
      this.word("override");
      this.space();
    }
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    if (isField && node2.readonly) {
      this.word("readonly");
      this.space();
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TSAnyKeyword = TSAnyKeyword;
  exports.TSArrayType = TSArrayType;
  exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;
  exports.TSBigIntKeyword = TSBigIntKeyword;
  exports.TSBooleanKeyword = TSBooleanKeyword;
  exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
  exports.TSConditionalType = TSConditionalType;
  exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
  exports.TSConstructorType = TSConstructorType;
  exports.TSDeclareFunction = TSDeclareFunction;
  exports.TSDeclareMethod = TSDeclareMethod;
  exports.TSEnumDeclaration = TSEnumDeclaration;
  exports.TSEnumMember = TSEnumMember;
  exports.TSExportAssignment = TSExportAssignment;
  exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
  exports.TSExternalModuleReference = TSExternalModuleReference;
  exports.TSFunctionType = TSFunctionType;
  exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
  exports.TSImportType = TSImportType;
  exports.TSIndexSignature = TSIndexSignature;
  exports.TSIndexedAccessType = TSIndexedAccessType;
  exports.TSInferType = TSInferType;
  exports.TSInstantiationExpression = TSInstantiationExpression;
  exports.TSInterfaceBody = TSInterfaceBody;
  exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
  exports.TSIntersectionType = TSIntersectionType;
  exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
  exports.TSLiteralType = TSLiteralType;
  exports.TSMappedType = TSMappedType;
  exports.TSMethodSignature = TSMethodSignature;
  exports.TSModuleBlock = TSModuleBlock;
  exports.TSModuleDeclaration = TSModuleDeclaration;
  exports.TSNamedTupleMember = TSNamedTupleMember;
  exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
  exports.TSNeverKeyword = TSNeverKeyword;
  exports.TSNonNullExpression = TSNonNullExpression;
  exports.TSNullKeyword = TSNullKeyword;
  exports.TSNumberKeyword = TSNumberKeyword;
  exports.TSObjectKeyword = TSObjectKeyword;
  exports.TSOptionalType = TSOptionalType;
  exports.TSParameterProperty = TSParameterProperty;
  exports.TSParenthesizedType = TSParenthesizedType;
  exports.TSPropertySignature = TSPropertySignature;
  exports.TSQualifiedName = TSQualifiedName;
  exports.TSRestType = TSRestType;
  exports.TSStringKeyword = TSStringKeyword;
  exports.TSSymbolKeyword = TSSymbolKeyword;
  exports.TSThisType = TSThisType;
  exports.TSTupleType = TSTupleType;
  exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
  exports.TSTypeAnnotation = TSTypeAnnotation;
  exports.TSTypeAssertion = TSTypeAssertion;
  exports.TSTypeLiteral = TSTypeLiteral;
  exports.TSTypeOperator = TSTypeOperator;
  exports.TSTypeParameter = TSTypeParameter;
  exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
  exports.TSTypePredicate = TSTypePredicate;
  exports.TSTypeQuery = TSTypeQuery;
  exports.TSTypeReference = TSTypeReference;
  exports.TSUndefinedKeyword = TSUndefinedKeyword;
  exports.TSUnionType = TSUnionType;
  exports.TSUnknownKeyword = TSUnknownKeyword;
  exports.TSVoidKeyword = TSVoidKeyword;
  exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
  exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
  exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
  exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
  exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _templateLiterals = require_template_literals();
  Object.keys(_templateLiterals).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _templateLiterals[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _templateLiterals[key];
      }
    });
  });
  var _expressions = require_expressions();
  Object.keys(_expressions).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _expressions[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _expressions[key];
      }
    });
  });
  var _statements = require_statements();
  Object.keys(_statements).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _statements[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _statements[key];
      }
    });
  });
  var _classes = require_classes();
  Object.keys(_classes).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _classes[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _classes[key];
      }
    });
  });
  var _methods = require_methods();
  Object.keys(_methods).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _methods[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _methods[key];
      }
    });
  });
  var _modules = require_modules();
  Object.keys(_modules).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _modules[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _modules[key];
      }
    });
  });
  var _types = require_types();
  Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _types[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _types[key];
      }
    });
  });
  var _flow = require_flow2();
  Object.keys(_flow).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _flow[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _flow[key];
      }
    });
  });
  var _base = require_base();
  Object.keys(_base).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _base[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _base[key];
      }
    });
  });
  var _jsx = require_jsx2();
  Object.keys(_jsx).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _jsx[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _jsx[key];
      }
    });
  });
  var _typescript = require_typescript2();
  Object.keys(_typescript).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _typescript[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _typescript[key];
      }
    });
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS((exports) => {
  var commaSeparator = function() {
    this.tokenChar(44);
    this.space();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _buffer = require_buffer();
  var n = require_node2();
  var _t = require_lib3();
  var generatorFunctions = require_generators();
  var {
    isFunction: isFunction2,
    isStatement,
    isClassBody,
    isTSInterfaceBody,
    isTSEnumDeclaration
  } = _t;
  var SCIENTIFIC_NOTATION = /e/i;
  var ZERO_DECIMAL_INTEGER = /\.0+$/;
  var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
  var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
  var {
    needsParens
  } = n;

  class Printer {
    constructor(format3, map) {
      this.inForStatementInitCounter = 0;
      this._printStack = [];
      this._indent = 0;
      this._indentRepeat = 0;
      this._insideAux = false;
      this._parenPushNewlineState = null;
      this._noLineTerminator = false;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new Set;
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this._lastCommentLine = 0;
      this._endsWithInnerRaw = false;
      this._indentInnerComments = true;
      this.format = format3;
      this._indentRepeat = format3.indent.style.length;
      this._inputMap = map == null ? undefined : map._inputMap;
      this._buf = new _buffer.default(map, format3.indent.style[0]);
    }
    generate(ast) {
      this.print(ast);
      this._maybeAddAuxComment();
      return this._buf.get();
    }
    indent() {
      if (this.format.compact || this.format.concise)
        return;
      this._indent++;
    }
    dedent() {
      if (this.format.compact || this.format.concise)
        return;
      this._indent--;
    }
    semicolon(force = false) {
      this._maybeAddAuxComment();
      if (force) {
        this._appendChar(59);
      } else {
        this._queue(59);
      }
      this._noLineTerminator = false;
    }
    rightBrace(node2) {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(125);
    }
    rightParens(node2) {
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(41);
    }
    space(force = false) {
      if (this.format.compact)
        return;
      if (force) {
        this._space();
      } else if (this._buf.hasContent()) {
        const lastCp = this.getLastChar();
        if (lastCp !== 32 && lastCp !== 10) {
          this._space();
        }
      }
    }
    word(str, noLineTerminatorAfter = false) {
      this._maybePrintInnerComments();
      if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {
        this._space();
      }
      this._maybeAddAuxComment();
      this._append(str, false);
      this._endsWithWord = true;
      this._noLineTerminator = noLineTerminatorAfter;
    }
    number(str, number) {
      function isNonDecimalLiteral(str2) {
        if (str2.length > 2 && str2.charCodeAt(0) === 48) {
          const secondChar = str2.charCodeAt(1);
          return secondChar === 98 || secondChar === 111 || secondChar === 120;
        }
        return false;
      }
      this.word(str);
      this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
    token(str, maybeNewline = false) {
      this._maybePrintInnerComments();
      const lastChar = this.getLastChar();
      const strFirst = str.charCodeAt(0);
      if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
        this._space();
      }
      this._maybeAddAuxComment();
      this._append(str, maybeNewline);
      this._noLineTerminator = false;
    }
    tokenChar(char) {
      this._maybePrintInnerComments();
      const lastChar = this.getLastChar();
      if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
        this._space();
      }
      this._maybeAddAuxComment();
      this._appendChar(char);
      this._noLineTerminator = false;
    }
    newline(i = 1, force) {
      if (i <= 0)
        return;
      if (!force) {
        if (this.format.retainLines || this.format.compact)
          return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      if (i > 2)
        i = 2;
      i -= this._buf.getNewlineCount();
      for (let j = 0;j < i; j++) {
        this._newline();
      }
      return;
    }
    endsWith(char) {
      return this.getLastChar() === char;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(loc, cb) {
      if (!loc) {
        cb();
        return;
      }
      this._catchUp("start", loc);
      this._buf.exactSource(loc, cb);
    }
    source(prop, loc) {
      if (!loc)
        return;
      this._catchUp(prop, loc);
      this._buf.source(prop, loc);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!loc)
        return;
      this._catchUp(prop, loc);
      this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
    withSource(prop, loc, cb) {
      if (!loc) {
        cb();
        return;
      }
      this._catchUp(prop, loc);
      this._buf.withSource(prop, loc, cb);
    }
    sourceIdentifierName(identifierName, pos) {
      if (!this._buf._canMarkIdName)
        return;
      const sourcePosition = this._buf._sourcePosition;
      sourcePosition.identifierNamePos = pos;
      sourcePosition.identifierName = identifierName;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(str, maybeNewline) {
      this._maybeAddParen(str);
      this._maybeIndent(str.charCodeAt(0));
      this._buf.append(str, maybeNewline);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
    _appendChar(char) {
      this._maybeAddParenChar(char);
      this._maybeIndent(char);
      this._buf.appendChar(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
    _queue(char) {
      this._maybeAddParenChar(char);
      this._maybeIndent(char);
      this._buf.queue(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
    _maybeIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        this._buf.queueIndentation(this._getIndent());
      }
    }
    _shouldIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        return true;
      }
    }
    _maybeAddParenChar(char) {
      const parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState)
        return;
      if (char === 32) {
        return;
      }
      if (char !== 10) {
        this._parenPushNewlineState = null;
        return;
      }
      this.tokenChar(40);
      this.indent();
      parenPushNewlineState.printed = true;
    }
    _maybeAddParen(str) {
      const parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState)
        return;
      const len = str.length;
      let i;
      for (i = 0;i < len && str.charCodeAt(i) === 32; i++)
        continue;
      if (i === len) {
        return;
      }
      const cha = str.charCodeAt(i);
      if (cha !== 10) {
        if (cha !== 47 || i + 1 === len) {
          this._parenPushNewlineState = null;
          return;
        }
        const chaPost = str.charCodeAt(i + 1);
        if (chaPost === 42) {
          return;
        } else if (chaPost !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40);
      this.indent();
      parenPushNewlineState.printed = true;
    }
    catchUp(line) {
      if (!this.format.retainLines)
        return;
      const count = line - this._buf.getCurrentLine();
      for (let i = 0;i < count; i++) {
        this._newline();
      }
    }
    _catchUp(prop, loc) {
      var _loc$prop;
      if (!this.format.retainLines)
        return;
      const line = loc == null || (_loc$prop = loc[prop]) == null ? undefined : _loc$prop.line;
      if (line != null) {
        const count = line - this._buf.getCurrentLine();
        for (let i = 0;i < count; i++) {
          this._newline();
        }
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(node2, parent, isLabel) {
      if (isLabel) {
        this._noLineTerminator = true;
        this.print(node2, parent);
      } else {
        const terminatorState = {
          printed: false
        };
        this._parenPushNewlineState = terminatorState;
        this.print(node2, parent);
        if (terminatorState.printed) {
          this.dedent();
          this.newline();
          this.tokenChar(41);
        }
      }
    }
    print(node2, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {
      var _node$extra, _node$leadingComments;
      if (!node2)
        return;
      this._endsWithInnerRaw = false;
      const nodeType = node2.type;
      const format3 = this.format;
      const oldConcise = format3.concise;
      if (node2._compact) {
        format3.concise = true;
      }
      const printMethod = this[nodeType];
      if (printMethod === undefined) {
        throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node2.constructor.name)}`);
      }
      this._printStack.push(node2);
      const oldInAux = this._insideAux;
      this._insideAux = node2.loc == undefined;
      this._maybeAddAuxComment(this._insideAux && !oldInAux);
      const parenthesized = (_node$extra = node2.extra) == null ? undefined : _node$extra.parenthesized;
      let shouldPrintParens = forceParens || parenthesized && format3.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node2, parent, this._printStack);
      if (!shouldPrintParens && parenthesized && (_node$leadingComments = node2.leadingComments) != null && _node$leadingComments.length && node2.leadingComments[0].type === "CommentBlock") {
        const parentType = parent == null ? undefined : parent.type;
        switch (parentType) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (parent.callee !== node2)
              break;
          default:
            shouldPrintParens = true;
        }
      }
      if (shouldPrintParens) {
        this.tokenChar(40);
        this._endsWithInnerRaw = false;
      }
      this._lastCommentLine = 0;
      this._printLeadingComments(node2, parent);
      const loc = nodeType === "Program" || nodeType === "File" ? null : node2.loc;
      this.exactSource(loc, printMethod.bind(this, node2, parent));
      if (shouldPrintParens) {
        this._printTrailingComments(node2, parent);
        this.tokenChar(41);
        this._noLineTerminator = noLineTerminatorAfter;
      } else if (noLineTerminatorAfter && !this._noLineTerminator) {
        this._noLineTerminator = true;
        this._printTrailingComments(node2, parent);
      } else {
        this._printTrailingComments(node2, parent, trailingCommentsLineOffset);
      }
      this._printStack.pop();
      format3.concise = oldConcise;
      this._insideAux = oldInAux;
      this._endsWithInnerRaw = false;
    }
    _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode)
        this._printAuxBeforeComment();
      if (!this._insideAux)
        this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode)
        return;
      this._printAuxAfterOnNextUserNode = true;
      const comment = this.format.auxiliaryCommentBefore;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode)
        return;
      this._printAuxAfterOnNextUserNode = false;
      const comment = this.format.auxiliaryCommentAfter;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    getPossibleRaw(node2) {
      const extra = node2.extra;
      if ((extra == null ? undefined : extra.raw) != null && extra.rawValue != null && node2.value === extra.rawValue) {
        return extra.raw;
      }
    }
    printJoin(nodes, parent, opts = {}) {
      if (!(nodes != null && nodes.length))
        return;
      let {
        indent
      } = opts;
      if (indent == null && this.format.retainLines) {
        var _nodes$0$loc;
        const startLine = (_nodes$0$loc = nodes[0].loc) == null ? undefined : _nodes$0$loc.start.line;
        if (startLine != null && startLine !== this._buf.getCurrentLine()) {
          indent = true;
        }
      }
      if (indent)
        this.indent();
      const newlineOpts = {
        addNewlines: opts.addNewlines,
        nextNodeStartLine: 0
      };
      const separator = opts.separator ? opts.separator.bind(this) : null;
      const len = nodes.length;
      for (let i = 0;i < len; i++) {
        const node2 = nodes[i];
        if (!node2)
          continue;
        if (opts.statement)
          this._printNewline(i === 0, newlineOpts);
        this.print(node2, parent, undefined, opts.trailingCommentsLineOffset || 0);
        opts.iterator == null || opts.iterator(node2, i);
        if (i < len - 1)
          separator == null || separator();
        if (opts.statement) {
          var _node$trailingComment;
          if (!((_node$trailingComment = node2.trailingComments) != null && _node$trailingComment.length)) {
            this._lastCommentLine = 0;
          }
          if (i + 1 === len) {
            this.newline(1);
          } else {
            var _nextNode$loc;
            const nextNode = nodes[i + 1];
            newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? undefined : _nextNode$loc.start.line) || 0;
            this._printNewline(true, newlineOpts);
          }
        }
      }
      if (indent)
        this.dedent();
    }
    printAndIndentOnComments(node2, parent) {
      const indent = node2.leadingComments && node2.leadingComments.length > 0;
      if (indent)
        this.indent();
      this.print(node2, parent);
      if (indent)
        this.dedent();
    }
    printBlock(parent) {
      const node2 = parent.body;
      if (node2.type !== "EmptyStatement") {
        this.space();
      }
      this.print(node2, parent);
    }
    _printTrailingComments(node2, parent, lineOffset) {
      const {
        innerComments,
        trailingComments
      } = node2;
      if (innerComments != null && innerComments.length) {
        this._printComments(2, innerComments, node2, parent, lineOffset);
      }
      if (trailingComments != null && trailingComments.length) {
        this._printComments(2, trailingComments, node2, parent, lineOffset);
      }
    }
    _printLeadingComments(node2, parent) {
      const comments = node2.leadingComments;
      if (!(comments != null && comments.length))
        return;
      this._printComments(0, comments, node2, parent);
    }
    _maybePrintInnerComments() {
      if (this._endsWithInnerRaw)
        this.printInnerComments();
      this._endsWithInnerRaw = true;
      this._indentInnerComments = true;
    }
    printInnerComments() {
      const node2 = this._printStack[this._printStack.length - 1];
      const comments = node2.innerComments;
      if (!(comments != null && comments.length))
        return;
      const hasSpace = this.endsWith(32);
      const indent = this._indentInnerComments;
      const printedCommentsCount = this._printedComments.size;
      if (indent)
        this.indent();
      this._printComments(1, comments, node2);
      if (hasSpace && printedCommentsCount !== this._printedComments.size) {
        this.space();
      }
      if (indent)
        this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
    printSequence(nodes, parent, opts = {}) {
      var _opts$indent;
      opts.statement = true;
      (_opts$indent = opts.indent) != null || (opts.indent = false);
      this.printJoin(nodes, parent, opts);
    }
    printList(items, parent, opts = {}) {
      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }
      this.printJoin(items, parent, opts);
    }
    _printNewline(newLine, opts) {
      const format3 = this.format;
      if (format3.retainLines || format3.compact)
        return;
      if (format3.concise) {
        this.space();
        return;
      }
      if (!newLine) {
        return;
      }
      const startLine = opts.nextNodeStartLine;
      const lastCommentLine = this._lastCommentLine;
      if (startLine > 0 && lastCommentLine > 0) {
        const offset = startLine - lastCommentLine;
        if (offset >= 0) {
          this.newline(offset || 1);
          return;
        }
      }
      if (this._buf.hasContent()) {
        this.newline(1);
      }
    }
    _shouldPrintComment(comment) {
      if (comment.ignore)
        return 0;
      if (this._printedComments.has(comment))
        return 0;
      if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
        return 2;
      }
      this._printedComments.add(comment);
      if (!this.format.shouldPrintComment(comment.value)) {
        return 0;
      }
      return 1;
    }
    _printComment(comment, skipNewLines) {
      const noLineTerminator = this._noLineTerminator;
      const isBlockComment = comment.type === "CommentBlock";
      const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
        this.newline(1);
      }
      const lastCharCode = this.getLastChar();
      if (lastCharCode !== 91 && lastCharCode !== 123) {
        this.space();
      }
      let val;
      if (isBlockComment) {
        const {
          _parenPushNewlineState
        } = this;
        if ((_parenPushNewlineState == null ? undefined : _parenPushNewlineState.printed) === false && HAS_NEWLINE.test(comment.value)) {
          this.tokenChar(40);
          this.indent();
          _parenPushNewlineState.printed = true;
        }
        val = `/*${comment.value}*/`;
        if (this.format.indent.adjustMultilineComment) {
          var _comment$loc;
          const offset = (_comment$loc = comment.loc) == null ? undefined : _comment$loc.start.column;
          if (offset) {
            const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, "\n");
          }
          if (this.format.concise) {
            val = val.replace(/\n(?!$)/g, `\n`);
          } else {
            let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            if (this._shouldIndent(47) || this.format.retainLines) {
              indentSize += this._getIndent();
            }
            val = val.replace(/\n(?!$)/g, `\n${" ".repeat(indentSize)}`);
          }
        }
      } else if (!noLineTerminator) {
        val = `//${comment.value}`;
      } else {
        val = `/*${comment.value}*/`;
      }
      if (this.endsWith(47))
        this._space();
      this.source("start", comment.loc);
      this._append(val, isBlockComment);
      if (!isBlockComment && !noLineTerminator) {
        this.newline(1, true);
      }
      if (printNewLines && skipNewLines !== 3) {
        this.newline(1);
      }
    }
    _printComments(type, comments, node2, parent, lineOffset = 0) {
      const nodeLoc = node2.loc;
      const len = comments.length;
      let hasLoc = !!nodeLoc;
      const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
      const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
      let lastLine = 0;
      let leadingCommentNewline = 0;
      const maybeNewline = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let i = 0;i < len; i++) {
        const comment = comments[i];
        const shouldPrint = this._shouldPrintComment(comment);
        if (shouldPrint === 2) {
          hasLoc = false;
          break;
        }
        if (hasLoc && comment.loc && shouldPrint === 1) {
          const commentStartLine = comment.loc.start.line;
          const commentEndLine = comment.loc.end.line;
          if (type === 0) {
            let offset = 0;
            if (i === 0) {
              if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine != commentEndLine)) {
                offset = leadingCommentNewline = 1;
              }
            } else {
              offset = commentStartLine - lastLine;
            }
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
              lastLine = nodeStartLine;
            }
          } else if (type === 1) {
            const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.min(1, nodeEndLine - lastLine));
              lastLine = nodeEndLine;
            }
          } else {
            const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
          }
        } else {
          hasLoc = false;
          if (shouldPrint !== 1) {
            continue;
          }
          if (len === 1) {
            const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
            const shouldSkipNewline = singleLine && !isStatement(node2) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
            if (type === 0) {
              this._printComment(comment, shouldSkipNewline && node2.type !== "ObjectExpression" || singleLine && isFunction2(parent, {
                body: node2
              }) ? 1 : 0);
            } else if (shouldSkipNewline && type === 2) {
              this._printComment(comment, 1);
            } else {
              this._printComment(comment, 0);
            }
          } else if (type === 1 && !(node2.type === "ObjectExpression" && node2.properties.length > 1) && node2.type !== "ClassBody" && node2.type !== "TSInterfaceBody") {
            this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
          } else {
            this._printComment(comment, 0);
          }
        }
      }
      if (type === 2 && hasLoc && lastLine) {
        this._lastCommentLine = lastLine;
      }
    }
  }
  Object.assign(Printer.prototype, generatorFunctions);
  {
    Printer.prototype.Noop = function Noop() {
    };
  }
  var _default = exports.default = Printer;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/generator/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var normalizeOptions = function(code, opts) {
    var _opts$recordAndTupleS;
    const format3 = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      recordAndTupleSyntaxType: (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash",
      topicToken: opts.topicToken,
      importAttributesKeyword: opts.importAttributesKeyword
    };
    {
      format3.decoratorsBeforeExport = opts.decoratorsBeforeExport;
      format3.jsescOption.json = opts.jsonCompatibleStrings;
    }
    if (format3.minified) {
      format3.compact = true;
      format3.shouldPrintComment = format3.shouldPrintComment || (() => format3.comments);
    } else {
      format3.shouldPrintComment = format3.shouldPrintComment || ((value2) => format3.comments || value2.includes("@license") || value2.includes("@preserve"));
    }
    if (format3.compact === "auto") {
      format3.compact = typeof code === "string" && code.length > 500000;
      if (format3.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
      }
    }
    if (format3.compact) {
      format3.indent.adjustMultilineComment = false;
    }
    const {
      auxiliaryCommentBefore,
      auxiliaryCommentAfter,
      shouldPrintComment
    } = format3;
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
      format3.auxiliaryCommentBefore = undefined;
    }
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
      format3.auxiliaryCommentAfter = undefined;
    }
    return format3;
  };
  var generate = function(ast, opts = {}, code) {
    const format3 = normalizeOptions(code, opts);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    const printer = new _printer.default(format3, map);
    return printer.generate(ast);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = generate;
  var _sourceMap = require_source_map();
  var _printer = require_printer();
  {
    exports.CodeGenerator = class CodeGenerator {
      constructor(ast, opts = {}, code) {
        this._ast = undefined;
        this._format = undefined;
        this._map = undefined;
        this._ast = ast;
        this._format = normalizeOptions(code, opts);
        this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      }
      generate() {
        const printer = new _printer.default(this._format, this._map);
        return printer.generate(this._ast);
      }
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS((exports) => {
  var findParent = function(callback) {
    let path3 = this;
    while (path3 = path3.parentPath) {
      if (callback(path3))
        return path3;
    }
    return null;
  };
  var find = function(callback) {
    let path3 = this;
    do {
      if (callback(path3))
        return path3;
    } while (path3 = path3.parentPath);
    return null;
  };
  var getFunctionParent = function() {
    return this.findParent((p) => p.isFunction());
  };
  var getStatementParent = function() {
    let path3 = this;
    do {
      if (!path3.parentPath || Array.isArray(path3.container) && path3.isStatement()) {
        break;
      } else {
        path3 = path3.parentPath;
      }
    } while (path3);
    if (path3 && (path3.isProgram() || path3.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }
    return path3;
  };
  var getEarliestCommonAncestorFrom = function(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
      let earliest;
      const keys = VISITOR_KEYS[deepest.type];
      for (const ancestry of ancestries) {
        const path3 = ancestry[i + 1];
        if (!earliest) {
          earliest = path3;
          continue;
        }
        if (path3.listKey && earliest.listKey === path3.listKey) {
          if (path3.key < earliest.key) {
            earliest = path3;
            continue;
          }
        }
        const earliestKeyIndex = keys.indexOf(earliest.parentKey);
        const currentKeyIndex = keys.indexOf(path3.parentKey);
        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path3;
        }
      }
      return earliest;
    });
  };
  var getDeepestCommonAncestorFrom = function(paths, filter) {
    if (!paths.length) {
      return this;
    }
    if (paths.length === 1) {
      return paths[0];
    }
    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    const ancestries = paths.map((path3) => {
      const ancestry = [];
      do {
        ancestry.unshift(path3);
      } while ((path3 = path3.parentPath) && path3 !== this);
      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }
      return ancestry;
    });
    const first = ancestries[0];
    depthLoop:
      for (let i = 0;i < minDepth; i++) {
        const shouldMatch = first[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  };
  var getAncestry = function() {
    let path3 = this;
    const paths = [];
    do {
      paths.push(path3);
    } while (path3 = path3.parentPath);
    return paths;
  };
  var isAncestor = function(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  };
  var isDescendant = function(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
  };
  var inType = function(...candidateTypes) {
    let path3 = this;
    while (path3) {
      for (const type of candidateTypes) {
        if (path3.node.type === type)
          return true;
      }
      path3 = path3.parentPath;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.find = find;
  exports.findParent = findParent;
  exports.getAncestry = getAncestry;
  exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  exports.getFunctionParent = getFunctionParent;
  exports.getStatementParent = getStatementParent;
  exports.inType = inType;
  exports.isAncestor = isAncestor;
  exports.isDescendant = isDescendant;
  var _t = require_lib3();
  var {
    VISITOR_KEYS
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS((exports) => {
  var createUnionType = function(types) {
    {
      if (isFlowType(types[0])) {
        if (createFlowUnionType) {
          return createFlowUnionType(types);
        }
        return createUnionTypeAnnotation(types);
      } else {
        if (createTSUnionType) {
          return createTSUnionType(types);
        }
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createUnionType = createUnionType;
  var _t = require_lib3();
  var {
    createFlowUnionType,
    createTSUnionType,
    createUnionTypeAnnotation,
    isFlowType,
    isTSType
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS((exports) => {
  var _default = function(node2) {
    if (!this.isReferenced())
      return;
    const binding = this.scope.getBinding(node2.name);
    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node2.name);
      }
    }
    if (node2.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node2.name === "NaN" || node2.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node2.name === "arguments") {
    }
  };
  var getTypeAnnotationBindingConstantViolations = function(binding, path3, name) {
    const types = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding, path3, functionConstantViolations);
    const testType = getConditionalAnnotation(binding, path3, name);
    if (testType) {
      const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter((path4) => testConstantViolations.indexOf(path4) < 0);
      types.push(testType.typeAnnotation);
    }
    if (constantViolations.length) {
      constantViolations.push(...functionConstantViolations);
      for (const violation of constantViolations) {
        types.push(violation.getTypeAnnotation());
      }
    }
    if (!types.length) {
      return;
    }
    return (0, _util.createUnionType)(types);
  };
  var getConstantViolationsBefore = function(binding, path3, functions) {
    const violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter((violation) => {
      violation = violation.resolve();
      const status = violation._guessExecutionStatusRelativeTo(path3);
      if (functions && status === "unknown")
        functions.push(violation);
      return status === "before";
    });
  };
  var inferAnnotationFromBinaryExpression = function(name, path3) {
    const operator = path3.node.operator;
    const right2 = path3.get("right").resolve();
    const left2 = path3.get("left").resolve();
    let target;
    if (left2.isIdentifier({
      name
    })) {
      target = right2;
    } else if (right2.isIdentifier({
      name
    })) {
      target = left2;
    }
    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }
      if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return numberTypeAnnotation();
      }
      return;
    }
    if (operator !== "===" && operator !== "==")
      return;
    let typeofPath;
    let typePath;
    if (left2.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left2;
      typePath = right2;
    } else if (right2.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right2;
      typePath = left2;
    }
    if (!typeofPath)
      return;
    if (!typeofPath.get("argument").isIdentifier({
      name
    }))
      return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral())
      return;
    const typeValue = typePath.node.value;
    if (typeof typeValue !== "string")
      return;
    return createTypeAnnotationBasedOnTypeof(typeValue);
  };
  var getParentConditionalPath = function(binding, path3, name) {
    let parentPath;
    while (parentPath = path3.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path3.key === "test") {
          return;
        }
        return parentPath;
      }
      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding)
          return;
      }
      path3 = parentPath;
    }
  };
  var getConditionalAnnotation = function(binding, path3, name) {
    const ifStatement = getParentConditionalPath(binding, path3, name);
    if (!ifStatement)
      return;
    const test = ifStatement.get("test");
    const paths = [test];
    const types = [];
    for (let i = 0;i < paths.length; i++) {
      const path4 = paths[i];
      if (path4.isLogicalExpression()) {
        if (path4.node.operator === "&&") {
          paths.push(path4.get("left"));
          paths.push(path4.get("right"));
        }
      } else if (path4.isBinaryExpression()) {
        const type = inferAnnotationFromBinaryExpression(name, path4);
        if (type)
          types.push(type);
      }
    }
    if (types.length) {
      return {
        typeAnnotation: (0, _util.createUnionType)(types),
        ifStatement
      };
    }
    return getConditionalAnnotation(binding, ifStatement, name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _t = require_lib3();
  var _util = require_util();
  var {
    BOOLEAN_NUMBER_BINARY_OPERATORS,
    createTypeAnnotationBasedOnTypeof,
    numberTypeAnnotation,
    voidTypeAnnotation
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS((exports) => {
  var VariableDeclarator = function() {
    if (!this.get("id").isIdentifier())
      return;
    return this.get("init").getTypeAnnotation();
  };
  var TypeCastExpression = function(node2) {
    return node2.typeAnnotation;
  };
  var TSAsExpression = function(node2) {
    return node2.typeAnnotation;
  };
  var TSNonNullExpression = function() {
    return this.get("expression").getTypeAnnotation();
  };
  var NewExpression = function(node2) {
    if (node2.callee.type === "Identifier") {
      return genericTypeAnnotation(node2.callee);
    }
  };
  var TemplateLiteral = function() {
    return stringTypeAnnotation();
  };
  var UnaryExpression = function(node2) {
    const operator = node2.operator;
    if (operator === "void") {
      return voidTypeAnnotation();
    } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation();
    } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return stringTypeAnnotation();
    } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return booleanTypeAnnotation();
    }
  };
  var BinaryExpression = function(node2) {
    const operator = node2.operator;
    if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation();
    } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return booleanTypeAnnotation();
    } else if (operator === "+") {
      const right2 = this.get("right");
      const left2 = this.get("left");
      if (left2.isBaseType("number") && right2.isBaseType("number")) {
        return numberTypeAnnotation();
      } else if (left2.isBaseType("string") || right2.isBaseType("string")) {
        return stringTypeAnnotation();
      }
      return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
    }
  };
  var LogicalExpression = function() {
    const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, _util.createUnionType)(argumentTypes);
  };
  var ConditionalExpression = function() {
    const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, _util.createUnionType)(argumentTypes);
  };
  var SequenceExpression = function() {
    return this.get("expressions").pop().getTypeAnnotation();
  };
  var ParenthesizedExpression = function() {
    return this.get("expression").getTypeAnnotation();
  };
  var AssignmentExpression = function() {
    return this.get("right").getTypeAnnotation();
  };
  var UpdateExpression = function(node2) {
    const operator = node2.operator;
    if (operator === "++" || operator === "--") {
      return numberTypeAnnotation();
    }
  };
  var StringLiteral = function() {
    return stringTypeAnnotation();
  };
  var NumericLiteral = function() {
    return numberTypeAnnotation();
  };
  var BooleanLiteral = function() {
    return booleanTypeAnnotation();
  };
  var NullLiteral = function() {
    return nullLiteralTypeAnnotation();
  };
  var RegExpLiteral = function() {
    return genericTypeAnnotation(identifier("RegExp"));
  };
  var ObjectExpression = function() {
    return genericTypeAnnotation(identifier("Object"));
  };
  var ArrayExpression = function() {
    return genericTypeAnnotation(identifier("Array"));
  };
  var RestElement = function() {
    return ArrayExpression();
  };
  var Func = function() {
    return genericTypeAnnotation(identifier("Function"));
  };
  var CallExpression = function() {
    const {
      callee
    } = this.node;
    if (isObjectKeys(callee)) {
      return arrayTypeAnnotation(stringTypeAnnotation());
    } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
      name: "Array"
    })) {
      return arrayTypeAnnotation(anyTypeAnnotation());
    } else if (isObjectEntries(callee)) {
      return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
    }
    return resolveCall(this.get("callee"));
  };
  var TaggedTemplateExpression = function() {
    return resolveCall(this.get("tag"));
  };
  var resolveCall = function(callee) {
    callee = callee.resolve();
    if (callee.isFunction()) {
      const {
        node: node2
      } = callee;
      if (node2.async) {
        if (node2.generator) {
          return genericTypeAnnotation(identifier("AsyncIterator"));
        } else {
          return genericTypeAnnotation(identifier("Promise"));
        }
      } else {
        if (node2.generator) {
          return genericTypeAnnotation(identifier("Iterator"));
        } else if (callee.node.returnType) {
          return callee.node.returnType;
        } else {
        }
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArrayExpression = ArrayExpression;
  exports.AssignmentExpression = AssignmentExpression;
  exports.BinaryExpression = BinaryExpression;
  exports.BooleanLiteral = BooleanLiteral;
  exports.CallExpression = CallExpression;
  exports.ConditionalExpression = ConditionalExpression;
  exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
  Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
      return _infererReference.default;
    }
  });
  exports.LogicalExpression = LogicalExpression;
  exports.NewExpression = NewExpression;
  exports.NullLiteral = NullLiteral;
  exports.NumericLiteral = NumericLiteral;
  exports.ObjectExpression = ObjectExpression;
  exports.ParenthesizedExpression = ParenthesizedExpression;
  exports.RegExpLiteral = RegExpLiteral;
  exports.RestElement = RestElement;
  exports.SequenceExpression = SequenceExpression;
  exports.StringLiteral = StringLiteral;
  exports.TSAsExpression = TSAsExpression;
  exports.TSNonNullExpression = TSNonNullExpression;
  exports.TaggedTemplateExpression = TaggedTemplateExpression;
  exports.TemplateLiteral = TemplateLiteral;
  exports.TypeCastExpression = TypeCastExpression;
  exports.UnaryExpression = UnaryExpression;
  exports.UpdateExpression = UpdateExpression;
  exports.VariableDeclarator = VariableDeclarator;
  var _t = require_lib3();
  var _infererReference = require_inferer_reference();
  var _util = require_util();
  var {
    BOOLEAN_BINARY_OPERATORS,
    BOOLEAN_UNARY_OPERATORS,
    NUMBER_BINARY_OPERATORS,
    NUMBER_UNARY_OPERATORS,
    STRING_UNARY_OPERATORS,
    anyTypeAnnotation,
    arrayTypeAnnotation,
    booleanTypeAnnotation,
    buildMatchMemberExpression,
    genericTypeAnnotation,
    identifier,
    nullLiteralTypeAnnotation,
    numberTypeAnnotation,
    stringTypeAnnotation,
    tupleTypeAnnotation,
    unionTypeAnnotation,
    voidTypeAnnotation,
    isIdentifier
  } = _t;
  TypeCastExpression.validParent = true;
  TSAsExpression.validParent = true;
  RestElement.validParent = true;
  var isArrayFrom = buildMatchMemberExpression("Array.from");
  var isObjectKeys = buildMatchMemberExpression("Object.keys");
  var isObjectValues = buildMatchMemberExpression("Object.values");
  var isObjectEntries = buildMatchMemberExpression("Object.entries");
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS((exports) => {
  var getTypeAnnotation = function() {
    let type = this.getData("typeAnnotation");
    if (type != null) {
      return type;
    }
    type = this._getTypeAnnotation() || anyTypeAnnotation();
    if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
      type = type.typeAnnotation;
    }
    this.setData("typeAnnotation", type);
    return type;
  };
  var _getTypeAnnotation = function() {
    const node2 = this.node;
    if (!node2) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath;
        const declarParent = declar.parentPath;
        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }
        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }
        return voidTypeAnnotation();
      } else {
        return;
      }
    }
    if (node2.typeAnnotation) {
      return node2.typeAnnotation;
    }
    if (typeAnnotationInferringNodes.has(node2)) {
      return;
    }
    typeAnnotationInferringNodes.add(node2);
    try {
      var _inferer;
      let inferer = inferers[node2.type];
      if (inferer) {
        return inferer.call(this, node2);
      }
      inferer = inferers[this.parentPath.type];
      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes.delete(node2);
    }
  };
  var isBaseType = function(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  };
  var _isBaseType = function(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error(`Unknown base type ${baseName}`);
      }
    }
  };
  var couldBeBaseType = function(name) {
    const type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type))
      return true;
    if (isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) {
        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  };
  var baseTypeStrictlyMatches = function(rightArg) {
    const left2 = this.getTypeAnnotation();
    const right2 = rightArg.getTypeAnnotation();
    if (!isAnyTypeAnnotation(left2) && isFlowBaseAnnotation(left2)) {
      return right2.type === left2.type;
    }
    return false;
  };
  var isGenericType = function(genericName) {
    const type = this.getTypeAnnotation();
    if (genericName === "Array") {
      if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
        return true;
      }
    }
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
      name: genericName
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._getTypeAnnotation = _getTypeAnnotation;
  exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  exports.couldBeBaseType = couldBeBaseType;
  exports.getTypeAnnotation = getTypeAnnotation;
  exports.isBaseType = isBaseType;
  exports.isGenericType = isGenericType;
  var inferers = require_inferers();
  var _t = require_lib3();
  var {
    anyTypeAnnotation,
    isAnyTypeAnnotation,
    isArrayTypeAnnotation,
    isBooleanTypeAnnotation,
    isEmptyTypeAnnotation,
    isFlowBaseAnnotation,
    isGenericTypeAnnotation,
    isIdentifier,
    isMixedTypeAnnotation,
    isNumberTypeAnnotation,
    isStringTypeAnnotation,
    isTSArrayType,
    isTSTypeAnnotation,
    isTSTypeReference,
    isTupleTypeAnnotation,
    isTypeAnnotation,
    isUnionTypeAnnotation,
    isVoidTypeAnnotation,
    stringTypeAnnotation,
    voidTypeAnnotation
  } = _t;
  var typeAnnotationInferringNodes = new WeakSet;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/js-tokens/index.js
var require_js_tokens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  exports.matchToToken = function(match) {
    var token = { type: "invalid", value: match[0], closed: undefined };
    if (match[1])
      token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5])
      token.type = "comment";
    else if (match[6])
      token.type = "comment", token.closed = !!match[7];
    else if (match[8])
      token.type = "regex";
    else if (match[9])
      token.type = "number";
    else if (match[10])
      token.type = "name";
    else if (match[11])
      token.type = "punctuator";
    else if (match[12])
      token.type = "whitespace";
    return token;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports, module) => {
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var comparativeDistance = function(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  };
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var key;
  var convert = module.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
  }
  var channels;
  var labels;
  var model;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value2 = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z2 = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z2 * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z2 = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > 0.008856 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z2 = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z2 * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z2 * 0.0415;
    b = x * 0.0557 + y * -0.204 + z2 * 1.057;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z2 = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > 0.008856 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z2;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z2 = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z22 = Math.pow(z2, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z2 = z22 > 0.008856 ? z22 : (z2 - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z2 *= 108.883;
    return [x, y, z2];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value2 = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value2 = Math.round(value2 / 50);
    if (value2 === 0) {
      return 30;
    }
    var ansi2 = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value2 === 2) {
      ansi2 += 60;
    }
    return ansi2;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi2 = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi2;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var buildGraph = function() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0;i < len; i++) {
        var adjacent = adjacents[i];
        var node2 = graph[adjacent];
        if (node2.distance === -1) {
          node2.distance = graph[current].distance + 1;
          node2.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link = function(from, to) {
    return function(args) {
      return to(from(args));
    };
  };
  var wrapConversion = function(toModel, graph) {
    var path3 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path3.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path3;
    return fn;
  };
  var conversions = require_conversions();
  module.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0;i < len; i++) {
      var toModel = models[i];
      var node2 = graph[toModel];
      if (node2.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var wrapRaw = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports, module) => {
  var assembleStyles = function() {
    const codes = new Map;
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  };
  var colorConvert = require_color_convert();
  var wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `\x1B[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS((exports, module) => {
  module.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  };
  var os = __require("os");
  var hasFlag = require_has_flag2();
  var env2 = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates = __commonJS((exports, module) => {
  var unescape2 = function(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  };
  var parseArguments = function(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape2(escape2) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  };
  var parseStyle = function(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  };
  var buildStyle = function(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  };
  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  module.exports = (chalk, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape2(escapeChar));
      } else if (style) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS((exports, module) => {
  var applyOptions = function(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === undefined ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  };
  var Chalk = function(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);
      chalk.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };
      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }
    applyOptions(this, options);
  };
  var build2 = function(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1;a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}\$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  };
  var chalkTag = function(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1;i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk, parts.join(""));
  };
  var escapeStringRegexp = require_escape_string_regexp();
  var ansiStyles = require_ansi_styles();
  var stdoutColor = require_supports_color2().stdout;
  var template = require_templates();
  var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  var skipModels = new Set(["gray"]);
  var styles = Object.create(null);
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "\x1B[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build2.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build2.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build2.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build2.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, styles);
  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk();
  module.exports.supportsColor = stdoutColor;
  module.exports.default = module.exports;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/highlight/lib/index.js
var require_lib8 = __commonJS((exports) => {
  var _getRequireWildcardCache = function(e) {
    if (typeof WeakMap != "function")
      return null;
    var r = new WeakMap, t = new WeakMap;
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t : r;
    })(e);
  };
  var _interopRequireWildcard = function(e, r) {
    if (!r && e && e.__esModule)
      return e;
    if (e === null || typeof e != "object" && typeof e != "function")
      return { default: e };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e))
      return t.get(e);
    var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e)
      if (u !== "default" && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    return n.default = e, t && t.set(e, n), n;
  };
  var getDefs = function(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsxIdentifier: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  };
  var highlightTokens = function(defs, text) {
    let highlighted = "";
    for (const {
      type,
      value: value2
    } of tokenize(text)) {
      const colorize = defs[type];
      if (colorize) {
        highlighted += value2.split(NEWLINE).map((str) => colorize(str)).join("\n");
      } else {
        highlighted += value2;
      }
    }
    return highlighted;
  };
  var shouldHighlight = function(options) {
    return _chalk.default.level > 0 || options.forceColor;
  };
  var getChalk = function(forceColor) {
    if (forceColor) {
      var _chalkWithForcedColor;
      (_chalkWithForcedColor = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
        enabled: true,
        level: 1
      }));
      return chalkWithForcedColor;
    }
    return _chalk.default;
  };
  var highlight = function(code, options = {}) {
    if (code !== "" && shouldHighlight(options)) {
      const defs = getDefs(getChalk(options.forceColor));
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = highlight;
  exports.shouldHighlight = shouldHighlight;
  var _jsTokens = require_js_tokens();
  var _helperValidatorIdentifier = require_lib();
  var _chalk = _interopRequireWildcard(require_chalk(), true);
  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = function* (text) {
      let match;
      while (match = _jsTokens.default.exec(text)) {
        const token = _jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }
  var chalkWithForcedColor = undefined;
  {
    exports.getChalk = (options) => getChalk(options.forceColor);
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS((exports, module) => {
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS((exports, module) => {
  var comparativeDistance = function(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  };
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var key;
  var convert = module.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
  }
  var channels;
  var labels;
  var model;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value2 = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z2 = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z2 * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z2 = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > 0.008856 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z2 = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z2 * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z2 * 0.0415;
    b = x * 0.0557 + y * -0.204 + z2 * 1.057;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z2 = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > 0.008856 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z2;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z2 = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z22 = Math.pow(z2, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z2 = z22 > 0.008856 ? z22 : (z2 - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z2 *= 108.883;
    return [x, y, z2];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value2 = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value2 = Math.round(value2 / 50);
    if (value2 === 0) {
      return 30;
    }
    var ansi2 = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value2 === 2) {
      ansi2 += 60;
    }
    return ansi2;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi2 = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi2;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/route.js
var require_route2 = __commonJS((exports, module) => {
  var buildGraph = function() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0;i < len; i++) {
        var adjacent = adjacents[i];
        var node2 = graph[adjacent];
        if (node2.distance === -1) {
          node2.distance = graph[current].distance + 1;
          node2.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link = function(from, to) {
    return function(args) {
      return to(from(args));
    };
  };
  var wrapConversion = function(toModel, graph) {
    var path3 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path3.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path3;
    return fn;
  };
  var conversions = require_conversions2();
  module.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0;i < len; i++) {
      var toModel = models[i];
      var node2 = graph[toModel];
      if (node2.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS((exports, module) => {
  var wrapRaw = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions2();
  var route = require_route2();
  var convert = {};
  var models = Object.keys(conversions);
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS((exports, module) => {
  var assembleStyles = function() {
    const codes = new Map;
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  };
  var colorConvert = require_color_convert2();
  var wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `\x1B[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag3 = __commonJS((exports, module) => {
  module.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/node_modules/supports-color/index.js
var require_supports_color3 = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  };
  var os = __require("os");
  var hasFlag = require_has_flag3();
  var env2 = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/templates.js
var require_templates2 = __commonJS((exports, module) => {
  var unescape2 = function(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  };
  var parseArguments = function(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape2(escape2) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  };
  var parseStyle = function(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  };
  var buildStyle = function(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  };
  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  module.exports = (chalk, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape2(escapeChar));
      } else if (style) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/node_modules/chalk/index.js
var require_chalk2 = __commonJS((exports, module) => {
  var applyOptions = function(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === undefined ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  };
  var Chalk = function(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);
      chalk.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };
      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }
    applyOptions(this, options);
  };
  var build2 = function(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1;a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}\$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  };
  var chalkTag = function(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1;i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk, parts.join(""));
  };
  var escapeStringRegexp = require_escape_string_regexp2();
  var ansiStyles = require_ansi_styles2();
  var stdoutColor = require_supports_color3().stdout;
  var template = require_templates2();
  var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  var skipModels = new Set(["gray"]);
  var styles = Object.create(null);
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "\x1B[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build2.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build2.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build2.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build2.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, styles);
  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk();
  module.exports.supportsColor = stdoutColor;
  module.exports.default = module.exports;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/code-frame/lib/index.js
var require_lib9 = __commonJS((exports) => {
  var _getRequireWildcardCache = function(e) {
    if (typeof WeakMap != "function")
      return null;
    var r = new WeakMap, t = new WeakMap;
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t : r;
    })(e);
  };
  var _interopRequireWildcard = function(e, r) {
    if (!r && e && e.__esModule)
      return e;
    if (e === null || typeof e != "object" && typeof e != "function")
      return { default: e };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e))
      return t.get(e);
    var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e)
      if (u !== "default" && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    return n.default = e, t && t.set(e, n), n;
  };
  var getChalk = function(forceColor) {
    if (forceColor) {
      var _chalkWithForcedColor;
      (_chalkWithForcedColor = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
        enabled: true,
        level: 1
      }));
      return chalkWithForcedColor;
    }
    return _chalk.default;
  };
  var getDefs = function(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  };
  var getMarkerLines = function(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0;i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  };
  var codeFrameColumns = function(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
    const chalk = getChalk(opts.forceColor);
    const defs = getDefs(chalk);
    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
    let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }
        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
    }
    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  };
  var _default = function(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.codeFrameColumns = codeFrameColumns;
  exports.default = _default;
  var _highlight = require_lib8();
  var _chalk = _interopRequireWildcard(require_chalk2(), true);
  var chalkWithForcedColor = undefined;
  var deprecationWarningShown = false;
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-hoist-variables/lib/index.js
var require_lib10 = __commonJS((exports) => {
  var hoistVariables = function(path3, emit, kind = "var") {
    path3.traverse(visitor, {
      kind,
      emit
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hoistVariables;
  var _t = require_lib3();
  var {
    assignmentExpression,
    expressionStatement,
    identifier
  } = _t;
  var visitor = {
    Scope(path3, state) {
      if (state.kind === "let")
        path3.skip();
    },
    FunctionParent(path3) {
      path3.skip();
    },
    VariableDeclaration(path3, state) {
      if (state.kind && path3.node.kind !== state.kind)
        return;
      const nodes = [];
      const declarations = path3.get("declarations");
      let firstId;
      for (const declar of declarations) {
        firstId = declar.node.id;
        if (declar.node.init) {
          nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
        }
        for (const name of Object.keys(declar.getBindingIdentifiers())) {
          state.emit(identifier(name), name, declar.node.init !== null);
        }
      }
      if (path3.parentPath.isFor({
        left: path3.node
      })) {
        path3.replaceWith(firstId);
      } else {
        path3.replaceWithMultiple(nodes);
      }
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS((exports) => {
  var replaceWithMultiple = function(nodes) {
    var _getCachedPaths;
    this.resync();
    nodes = this._verifyNodeList(nodes);
    inheritLeadingComments(nodes[0], this.node);
    inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths.delete(this.node);
    this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);
    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }
    return paths;
  };
  var replaceWithSourceString = function(replacement) {
    this.resync();
    let ast;
    try {
      replacement = `(${replacement})`;
      ast = (0, _parser.parse)(replacement);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }
      throw err;
    }
    const expressionAST = ast.program.body[0].expression;
    _index.default.removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
  };
  var replaceWith = function(replacementPath) {
    this.resync();
    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }
    let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }
    if (this.node === replacement) {
      return [this];
    }
    if (this.isProgram() && !isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }
    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }
    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }
    let nodePath = "";
    if (this.isNodeType("Statement") && isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = expressionStatement(replacement);
        nodePath = "expression";
      }
    }
    if (this.isNodeType("Expression") && isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }
    const oldNode = this.node;
    if (oldNode) {
      inheritsComments(replacement, oldNode);
      removeComments(oldNode);
    }
    this._replaceWith(replacement);
    this.type = replacement.type;
    this.setScope();
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  };
  var _replaceWith = function(node2) {
    var _getCachedPaths2;
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }
    if (this.inList) {
      validate2(this.parent, this.key, [node2]);
    } else {
      validate2(this.parent, this.key, node2);
    }
    this.debug(`Replace with ${node2 == null ? undefined : node2.type}`);
    (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node2, this).delete(this.node);
    this.node = this.container[this.key] = node2;
  };
  var replaceExpressionWithStatements = function(nodes) {
    this.resync();
    const declars = [];
    const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
    if (nodesAsSingleExpression) {
      for (const id of declars)
        this.scope.push({
          id
        });
      return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
    }
    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent == null ? undefined : functionParent.is("async");
    const isParentGenerator = functionParent == null ? undefined : functionParent.is("generator");
    const container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    const callee = this.get("callee");
    (0, _helperHoistVariables.default)(callee.get("body"), (id) => {
      this.scope.push({
        id
      });
    }, "var");
    const completionRecords = this.get("callee").getCompletionRecords();
    for (const path3 of completionRecords) {
      if (!path3.isExpressionStatement())
        continue;
      const loop = path3.findParent((path4) => path4.isLoop());
      if (loop) {
        let uid = loop.getData("expressionReplacementReturnUid");
        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier(uid.name);
        }
        path3.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path3.node.expression));
      } else {
        path3.replaceWith(returnStatement(path3.node.expression));
      }
    }
    callee.arrowFunctionToExpression();
    const newCallee = callee;
    const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
    const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
    if (needToAwaitFunction) {
      newCallee.set("async", true);
      if (!needToYieldFunction) {
        this.replaceWith(awaitExpression(this.node));
      }
    }
    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(yieldExpression(this.node, true));
    }
    return newCallee.get("body.body");
  };
  var gatherSequenceExpressions = function(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node2 of nodes) {
      if (!isEmptyStatement(node2)) {
        ensureLastUndefined = false;
      }
      if (isExpression(node2)) {
        exprs.push(node2);
      } else if (isExpressionStatement(node2)) {
        exprs.push(node2.expression);
      } else if (isVariableDeclaration(node2)) {
        if (node2.kind !== "var")
          return;
        for (const declar of node2.declarations) {
          const bindings = getBindingIdentifiers(declar);
          for (const key of Object.keys(bindings)) {
            declars.push(cloneNode(bindings[key]));
          }
          if (declar.init) {
            exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if (isIfStatement(node2)) {
        const consequent = node2.consequent ? gatherSequenceExpressions([node2.consequent], declars) : buildUndefinedNode();
        const alternate = node2.alternate ? gatherSequenceExpressions([node2.alternate], declars) : buildUndefinedNode();
        if (!consequent || !alternate)
          return;
        exprs.push(conditionalExpression(node2.test, consequent, alternate));
      } else if (isBlockStatement(node2)) {
        const body = gatherSequenceExpressions(node2.body, declars);
        if (!body)
          return;
        exprs.push(body);
      } else if (isEmptyStatement(node2)) {
        if (nodes.indexOf(node2) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined)
      exprs.push(buildUndefinedNode());
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  };
  var replaceInline = function(nodes) {
    this.resync();
    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);
        const paths = this._containerInsertAfter(nodes);
        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._replaceWith = _replaceWith;
  exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
  exports.replaceInline = replaceInline;
  exports.replaceWith = replaceWith;
  exports.replaceWithMultiple = replaceWithMultiple;
  exports.replaceWithSourceString = replaceWithSourceString;
  var _codeFrame = require_lib9();
  var _index = require_lib13();
  var _index2 = require_path();
  var _cache = require_cache();
  var _parser = require_lib4();
  var _t = require_lib3();
  var _helperHoistVariables = require_lib10();
  var {
    FUNCTION_TYPES,
    arrowFunctionExpression,
    assignmentExpression,
    awaitExpression,
    blockStatement,
    buildUndefinedNode,
    callExpression,
    cloneNode,
    conditionalExpression,
    expressionStatement,
    getBindingIdentifiers,
    identifier,
    inheritLeadingComments,
    inheritTrailingComments,
    inheritsComments,
    isBlockStatement,
    isEmptyStatement,
    isExpression,
    isExpressionStatement,
    isIfStatement,
    isProgram,
    isStatement,
    isVariableDeclaration,
    removeComments,
    returnStatement,
    sequenceExpression,
    validate: validate2,
    yieldExpression
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS((exports) => {
  var isValidObjectCallee = function(val) {
    return VALID_OBJECT_CALLEES.includes(val);
  };
  var isValidIdentifierCallee = function(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
  };
  var isInvalidMethod = function(val) {
    return INVALID_METHODS.includes(val);
  };
  var evaluateTruthy = function() {
    const res = this.evaluate();
    if (res.confident)
      return !!res.value;
  };
  var deopt = function(path3, state) {
    if (!state.confident)
      return;
    state.deoptPath = path3;
    state.confident = false;
  };
  var evaluateCached = function(path3, state) {
    const {
      node: node2
    } = path3;
    const {
      seen
    } = state;
    if (seen.has(node2)) {
      const existing = seen.get(node2);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path3, state);
        return;
      }
    } else {
      const item = {
        resolved: false
      };
      seen.set(node2, item);
      const val = _evaluate(path3, state);
      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  };
  var _evaluate = function(path3, state) {
    if (!state.confident)
      return;
    if (path3.isSequenceExpression()) {
      const exprs = path3.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }
    if (path3.isStringLiteral() || path3.isNumericLiteral() || path3.isBooleanLiteral()) {
      return path3.node.value;
    }
    if (path3.isNullLiteral()) {
      return null;
    }
    if (path3.isTemplateLiteral()) {
      return evaluateQuasis(path3, path3.node.quasis, state);
    }
    if (path3.isTaggedTemplateExpression() && path3.get("tag").isMemberExpression()) {
      const object = path3.get("tag.object");
      const {
        node: {
          name
        }
      } = object;
      const property2 = path3.get("tag.property");
      if (object.isIdentifier() && name === "String" && !path3.scope.getBinding(name) && property2.isIdentifier() && property2.node.name === "raw") {
        return evaluateQuasis(path3, path3.node.quasi.quasis, state, true);
      }
    }
    if (path3.isConditionalExpression()) {
      const testResult = evaluateCached(path3.get("test"), state);
      if (!state.confident)
        return;
      if (testResult) {
        return evaluateCached(path3.get("consequent"), state);
      } else {
        return evaluateCached(path3.get("alternate"), state);
      }
    }
    if (path3.isExpressionWrapper()) {
      return evaluateCached(path3.get("expression"), state);
    }
    if (path3.isMemberExpression() && !path3.parentPath.isCallExpression({
      callee: path3.node
    })) {
      const property2 = path3.get("property");
      const object = path3.get("object");
      if (object.isLiteral()) {
        const value2 = object.node.value;
        const type = typeof value2;
        let key = null;
        if (path3.node.computed) {
          key = evaluateCached(property2, state);
          if (!state.confident)
            return;
        } else if (property2.isIdentifier()) {
          key = property2.node.name;
        }
        if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
          return value2[key];
        }
      }
    }
    if (path3.isReferencedIdentifier()) {
      const binding = path3.scope.getBinding(path3.node.name);
      if (binding) {
        if (binding.constantViolations.length > 0 || path3.node.start < binding.path.node.end) {
          deopt(binding.path, state);
          return;
        }
        if (binding.hasValue) {
          return binding.value;
        }
      }
      const name = path3.node.name;
      if (Globals.has(name)) {
        if (!binding) {
          return Globals.get(name);
        }
        deopt(binding.path, state);
        return;
      }
      const resolved = path3.resolve();
      if (resolved === path3) {
        deopt(path3, state);
        return;
      } else {
        return evaluateCached(resolved, state);
      }
    }
    if (path3.isUnaryExpression({
      prefix: true
    })) {
      if (path3.node.operator === "void") {
        return;
      }
      const argument = path3.get("argument");
      if (path3.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }
      const arg = evaluateCached(argument, state);
      if (!state.confident)
        return;
      switch (path3.node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg;
      }
    }
    if (path3.isArrayExpression()) {
      const arr = [];
      const elems = path3.get("elements");
      for (const elem of elems) {
        const elemValue = elem.evaluate();
        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          deopt(elemValue.deopt, state);
          return;
        }
      }
      return arr;
    }
    if (path3.isObjectExpression()) {
      const obj = {};
      const props = path3.get("properties");
      for (const prop of props) {
        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          deopt(prop, state);
          return;
        }
        const keyPath = prop.get("key");
        let key;
        if (prop.node.computed) {
          key = keyPath.evaluate();
          if (!key.confident) {
            deopt(key.deopt, state);
            return;
          }
          key = key.value;
        } else if (keyPath.isIdentifier()) {
          key = keyPath.node.name;
        } else {
          key = keyPath.node.value;
        }
        const valuePath = prop.get("value");
        let value2 = valuePath.evaluate();
        if (!value2.confident) {
          deopt(value2.deopt, state);
          return;
        }
        value2 = value2.value;
        obj[key] = value2;
      }
      return obj;
    }
    if (path3.isLogicalExpression()) {
      const wasConfident = state.confident;
      const left2 = evaluateCached(path3.get("left"), state);
      const leftConfident = state.confident;
      state.confident = wasConfident;
      const right2 = evaluateCached(path3.get("right"), state);
      const rightConfident = state.confident;
      switch (path3.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left2 || rightConfident);
          if (!state.confident)
            return;
          return left2 || right2;
        case "&&":
          state.confident = leftConfident && (!left2 || rightConfident);
          if (!state.confident)
            return;
          return left2 && right2;
        case "??":
          state.confident = leftConfident && (left2 != null || rightConfident);
          if (!state.confident)
            return;
          return left2 != null ? left2 : right2;
      }
    }
    if (path3.isBinaryExpression()) {
      const left2 = evaluateCached(path3.get("left"), state);
      if (!state.confident)
        return;
      const right2 = evaluateCached(path3.get("right"), state);
      if (!state.confident)
        return;
      switch (path3.node.operator) {
        case "-":
          return left2 - right2;
        case "+":
          return left2 + right2;
        case "/":
          return left2 / right2;
        case "*":
          return left2 * right2;
        case "%":
          return left2 % right2;
        case "**":
          return Math.pow(left2, right2);
        case "<":
          return left2 < right2;
        case ">":
          return left2 > right2;
        case "<=":
          return left2 <= right2;
        case ">=":
          return left2 >= right2;
        case "==":
          return left2 == right2;
        case "!=":
          return left2 != right2;
        case "===":
          return left2 === right2;
        case "!==":
          return left2 !== right2;
        case "|":
          return left2 | right2;
        case "&":
          return left2 & right2;
        case "^":
          return left2 ^ right2;
        case "<<":
          return left2 << right2;
        case ">>":
          return left2 >> right2;
        case ">>>":
          return left2 >>> right2;
      }
    }
    if (path3.isCallExpression()) {
      const callee = path3.get("callee");
      let context;
      let func;
      if (callee.isIdentifier() && !path3.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
        func = global[callee.node.name];
      }
      if (callee.isMemberExpression()) {
        const object = callee.get("object");
        const property2 = callee.get("property");
        if (object.isIdentifier() && property2.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property2.node.name)) {
          context = global[object.node.name];
          const key = property2.node.name;
          if (Object.hasOwnProperty.call(context, key)) {
            func = context[key];
          }
        }
        if (object.isLiteral() && property2.isIdentifier()) {
          const type = typeof object.node.value;
          if (type === "string" || type === "number") {
            context = object.node.value;
            func = context[property2.node.name];
          }
        }
      }
      if (func) {
        const args = path3.get("arguments").map((arg) => evaluateCached(arg, state));
        if (!state.confident)
          return;
        return func.apply(context, args);
      }
    }
    deopt(path3, state);
  };
  var evaluateQuasis = function(path3, quasis, state, raw = false) {
    let str = "";
    let i = 0;
    const exprs = path3.isTemplateLiteral() ? path3.get("expressions") : path3.get("quasi.expressions");
    for (const elem of quasis) {
      if (!state.confident)
        break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      if (expr)
        str += String(evaluateCached(expr, state));
    }
    if (!state.confident)
      return;
    return str;
  };
  var evaluate = function() {
    const state = {
      confident: true,
      deoptPath: null,
      seen: new Map
    };
    let value2 = evaluateCached(this, state);
    if (!state.confident)
      value2 = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value2
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.evaluate = evaluate;
  exports.evaluateTruthy = evaluateTruthy;
  var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
  var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
  var INVALID_METHODS = ["random"];
  var Globals = new Map([["undefined", undefined], ["Infinity", Infinity], ["NaN", NaN]]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS((exports) => {
  var makeStatementFormatter = function(fn) {
    return {
      code: (str) => `/* @babel/template */;\n${str}`,
      validate: () => {
      },
      unwrap: (ast) => {
        return fn(ast.program.body.slice(1));
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.statements = exports.statement = exports.smart = exports.program = exports.expression = undefined;
  var _t = require_lib3();
  var {
    assertExpressionStatement
  } = _t;
  var smart = makeStatementFormatter((body) => {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  exports.smart = smart;
  var statements = makeStatementFormatter((body) => body);
  exports.statements = statements;
  var statement = makeStatementFormatter((body) => {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  });
  exports.statement = statement;
  var expression = {
    code: (str) => `(\n${str}\n)`,
    validate: (ast) => {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      if (expression.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: ({
      program: program2
    }) => {
      const [stmt] = program2.body;
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  exports.expression = expression;
  var program = {
    code: (str) => str,
    validate: () => {
    },
    unwrap: (ast) => ast.program
  };
  exports.program = program;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/options.js
var require_options = __commonJS((exports) => {
  var _objectWithoutPropertiesLoose = function(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0;i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  };
  var merge = function(a, b) {
    const {
      placeholderWhitelist = a.placeholderWhitelist,
      placeholderPattern = a.placeholderPattern,
      preserveComments = a.preserveComments,
      syntacticPlaceholders = a.syntacticPlaceholders
    } = b;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    };
  };
  var validate2 = function(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }
    const _ref = opts || {}, {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = _ref, parser3 = _objectWithoutPropertiesLoose(_ref, _excluded);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    }
    return {
      parser: parser3,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  };
  var normalizeReplacements = function(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce((acc, replacement, i) => {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.merge = merge;
  exports.normalizeReplacements = normalizeReplacements;
  exports.validate = validate2;
  var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/parse.js
var require_parse2 = __commonJS((exports) => {
  var parseAndBuildMetadata = function(formatter, code, opts) {
    const {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
      preserveComments
    });
    formatter.validate(ast);
    const state = {
      syntactic: {
        placeholders: [],
        placeholderNames: new Set
      },
      legacy: {
        placeholders: [],
        placeholderNames: new Set
      },
      placeholderWhitelist,
      placeholderPattern,
      syntacticPlaceholders
    };
    traverse(ast, placeholderVisitorHandler, state);
    return Object.assign({
      ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
  };
  var placeholderVisitorHandler = function(node2, ancestors, state) {
    var _state$placeholderWhi;
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node2)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      }
      name = node2.name.name;
      hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node2) || isJSXIdentifier(node2)) {
      name = node2.name;
    } else if (isStringLiteral(node2)) {
      name = node2.value;
    } else {
      return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }
    ancestors = ancestors.slice();
    const {
      node: parent,
      key
    } = ancestors[ancestors.length - 1];
    let type;
    if (isStringLiteral(node2) || isPlaceholder(node2, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction2(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node2)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node2) && isPlaceholder(node2)) {
      type = "statement";
    } else {
      type = "other";
    }
    const {
      placeholders,
      placeholderNames
    } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    placeholders.push({
      name,
      type,
      resolve: (ast) => resolveAncestors(ast, ancestors),
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  };
  var resolveAncestors = function(ast, ancestors) {
    let parent = ast;
    for (let i = 0;i < ancestors.length - 1; i++) {
      const {
        key: key2,
        index: index2
      } = ancestors[i];
      if (index2 === undefined) {
        parent = parent[key2];
      } else {
        parent = parent[key2][index2];
      }
    }
    const {
      key,
      index
    } = ancestors[ancestors.length - 1];
    return {
      parent,
      key,
      index
    };
  };
  var parseWithCodeFrame = function(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }
    parserOpts = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, parserOpts, {
      plugins
    });
    try {
      return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }
      throw err;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parseAndBuildMetadata;
  var _t = require_lib3();
  var _parser = require_lib4();
  var _codeFrame = require_lib9();
  var {
    isCallExpression,
    isExpressionStatement,
    isFunction: isFunction2,
    isIdentifier,
    isJSXIdentifier,
    isNewExpression,
    isPlaceholder,
    isStatement,
    isStringLiteral,
    removePropertiesDeep,
    traverse
  } = _t;
  var PATTERN = /^[_$A-Z0-9]+$/;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS((exports) => {
  var populatePlaceholders = function(metadata, replacements) {
    const ast = cloneNode(metadata.ast);
    if (replacements) {
      metadata.placeholders.forEach((placeholder) => {
        if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
          const placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}\$/ }`);
        }
      });
      Object.keys(replacements).forEach((key) => {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error(`Unknown substitution "${key}" given`);
        }
      });
    }
    metadata.placeholders.slice().reverse().forEach((placeholder) => {
      try {
        applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
        throw e;
      }
    });
    return ast;
  };
  var applyReplacement = function(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map((node2) => cloneNode(node2));
      } else if (typeof replacement === "object") {
        replacement = cloneNode(replacement);
      }
    }
    const {
      parent,
      key,
      index
    } = placeholder.resolve(ast);
    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = stringLiteral(replacement);
      }
      if (!replacement || !isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = blockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = expressionStatement(identifier(replacement));
        } else if (!isStatement(replacement)) {
          replacement = expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }
          if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }
      if (index === undefined)
        throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }
      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }
    if (index === undefined) {
      validate2(parent, key, replacement);
      parent[key] = replacement;
    } else {
      const items = parent[key].slice();
      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice(index, 1, ...replacement);
        } else {
          items[index] = replacement;
        }
      } else {
        items[index] = replacement;
      }
      validate2(parent, key, items);
      parent[key] = items;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = populatePlaceholders;
  var _t = require_lib3();
  var {
    blockStatement,
    cloneNode,
    emptyStatement,
    expressionStatement,
    identifier,
    isStatement,
    isStringLiteral,
    stringLiteral,
    validate: validate2
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/string.js
var require_string2 = __commonJS((exports) => {
  var stringTemplate = function(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return (arg) => {
      const replacements = (0, _options.normalizeReplacements)(arg);
      if (!metadata)
        metadata = (0, _parse.default)(formatter, code, opts);
      return formatter.unwrap((0, _populate.default)(metadata, replacements));
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = stringTemplate;
  var _options = require_options();
  var _parse = require_parse2();
  var _populate = require_populate();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS((exports) => {
  var literalTemplate = function(formatter, tpl, opts) {
    const {
      metadata,
      names
    } = buildLiteralData(formatter, tpl, opts);
    return (arg) => {
      const defaultReplacements = {};
      arg.forEach((replacement, i) => {
        defaultReplacements[names[i]] = replacement;
      });
      return (arg2) => {
        const replacements = (0, _options.normalizeReplacements)(arg2);
        if (replacements) {
          Object.keys(replacements).forEach((key) => {
            if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }
        return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  };
  var buildLiteralData = function(formatter, tpl, opts) {
    let prefix = "BABEL_TPL$";
    const raw = tpl.join("");
    do {
      prefix = "$$" + prefix;
    } while (raw.includes(prefix));
    const {
      names,
      code
    } = buildTemplateCode(tpl, prefix);
    const metadata = (0, _parse.default)(formatter, formatter.code(code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
      metadata,
      names
    };
  };
  var buildTemplateCode = function(tpl, prefix) {
    const names = [];
    let code = tpl[0];
    for (let i = 1;i < tpl.length; i++) {
      const value2 = `${prefix}${i - 1}`;
      names.push(value2);
      code += value2 + tpl[i];
    }
    return {
      names,
      code
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = literalTemplate;
  var _options = require_options();
  var _parse = require_parse2();
  var _populate = require_populate();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS((exports) => {
  var createTemplateBuilder = function(formatter, defaultOpts) {
    const templateFnCache = new WeakMap;
    const templateAstCache = new WeakMap;
    const cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign((tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1)
          throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
      } else if (Array.isArray(tpl)) {
        let builder = templateFnCache.get(tpl);
        if (!builder) {
          builder = (0, _literal.default)(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }
        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0)
          throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }
      throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
      ast: (tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1)
            throw new Error("Unexpected extra params.");
          return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          let builder = templateAstCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }
          return builder(args)();
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }
    });
  };
  var extendedTrace = function(fn) {
    let rootStack = "";
    try {
      throw new Error;
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }
    return (arg) => {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += `\n    =============\n${rootStack}`;
        throw err;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createTemplateBuilder;
  var _options = require_options();
  var _string = require_string2();
  var _literal = require_literal();
  var NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/template/lib/index.js
var require_lib11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = undefined;
  var formatters = require_formatters();
  var _builder = require_builder();
  var smart = (0, _builder.default)(formatters.smart);
  exports.smart = smart;
  var statement = (0, _builder.default)(formatters.statement);
  exports.statement = statement;
  var statements = (0, _builder.default)(formatters.statements);
  exports.statements = statements;
  var expression = (0, _builder.default)(formatters.expression);
  exports.expression = expression;
  var program = (0, _builder.default)(formatters.program);
  exports.program = program;
  var _default = Object.assign(smart.bind(undefined), {
    smart,
    statement,
    statements,
    expression,
    program,
    ast: smart.ast
  });
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-function-name/lib/index.js
var require_lib12 = __commonJS((exports) => {
  var getFunctionArity = function(node2) {
    const count = node2.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
    return count === -1 ? node2.params.length : count;
  };
  var getNameFromLiteralId = function(id) {
    if (isNullLiteral(id)) {
      return "null";
    }
    if (isRegExpLiteral(id)) {
      return `_${id.pattern}_${id.flags}`;
    }
    if (isTemplateLiteral(id)) {
      return id.quasis.map((quasi) => quasi.value.raw).join("");
    }
    if (id.value !== undefined) {
      return id.value + "";
    }
    return "";
  };
  var wrap2 = function(state, method, id, scope) {
    if (state.selfReference) {
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
      } else {
        if (!isFunction2(method))
          return;
        let build2 = buildPropertyMethodAssignmentWrapper;
        if (method.generator) {
          build2 = buildGeneratorPropertyMethodAssignmentWrapper;
        }
        const template = build2({
          FUNCTION: method,
          FUNCTION_ID: id,
          FUNCTION_KEY: scope.generateUidIdentifier(id.name)
        }).expression;
        const params = template.callee.body.body[0].params;
        for (let i = 0, len = getFunctionArity(method);i < len; i++) {
          params.push(scope.generateUidIdentifier("x"));
        }
        return template;
      }
    }
    method.id = id;
    scope.getProgramParent().references[id.name] = true;
  };
  var visit2 = function(node2, name, scope) {
    const state = {
      selfAssignment: false,
      selfReference: false,
      outerDeclar: scope.getBindingIdentifier(name),
      name
    };
    const binding = scope.getOwnBinding(name);
    if (binding) {
      if (binding.kind === "param") {
        state.selfReference = true;
      } else {
      }
    } else if (state.outerDeclar || scope.hasGlobal(name)) {
      scope.traverse(node2, visitor, state);
    }
    return state;
  };
  var _default = function({
    node: node2,
    parent,
    scope,
    id
  }, localBinding = false, supportUnicodeId = false) {
    if (node2.id)
      return;
    if ((isObjectProperty(parent) || isObjectMethod(parent, {
      kind: "method"
    })) && (!parent.computed || isLiteral(parent.key))) {
      id = parent.key;
    } else if (isVariableDeclarator(parent)) {
      id = parent.id;
      if (isIdentifier(id) && !localBinding) {
        const binding = scope.parent.getBinding(id.name);
        if (binding && binding.constant && scope.getBinding(id.name) === binding) {
          node2.id = cloneNode(id);
          node2.id[NOT_LOCAL_BINDING] = true;
          return;
        }
      }
    } else if (isAssignmentExpression(parent, {
      operator: "="
    })) {
      id = parent.left;
    } else if (!id) {
      return;
    }
    let name;
    if (id && isLiteral(id)) {
      name = getNameFromLiteralId(id);
    } else if (id && isIdentifier(id)) {
      name = id.name;
    }
    if (name === undefined) {
      return;
    }
    if (!supportUnicodeId && isFunction2(node2) && /[\uD800-\uDFFF]/.test(name)) {
      return;
    }
    name = toBindingIdentifierName(name);
    const newId = identifier(name);
    newId[NOT_LOCAL_BINDING] = true;
    const state = visit2(node2, name, scope);
    return wrap2(state, node2, newId, scope) || node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _template = require_lib11();
  var _t = require_lib3();
  var {
    NOT_LOCAL_BINDING,
    cloneNode,
    identifier,
    isAssignmentExpression,
    isAssignmentPattern,
    isFunction: isFunction2,
    isIdentifier,
    isLiteral,
    isNullLiteral,
    isObjectMethod,
    isObjectProperty,
    isRegExpLiteral,
    isRestElement,
    isTemplateLiteral,
    isVariableDeclarator,
    toBindingIdentifierName
  } = _t;
  var buildPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
  var buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
  var visitor = {
    "ReferencedIdentifier|BindingIdentifier"(path3, state) {
      if (path3.node.name !== state.name)
        return;
      const localDeclar = path3.scope.getBindingIdentifier(state.name);
      if (localDeclar !== state.outerDeclar)
        return;
      state.selfReference = true;
      path3.stop();
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS((exports) => {
  var toComputedKey = function() {
    let key;
    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }
    if (!this.node.computed) {
      if (isIdentifier(key))
        key = stringLiteral(key.name);
    }
    return key;
  };
  var ensureBlock = function() {
    const body = this.get("body");
    const bodyNode = body.node;
    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }
    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }
    if (body.isBlockStatement()) {
      return bodyNode;
    }
    const statements = [];
    let stringPath = "body";
    let key;
    let listKey;
    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";
      if (this.isFunction()) {
        key = "argument";
        statements.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements.push(expressionStatement(body.node));
      }
    }
    this.node.body = blockStatement(statements);
    const parentPath = this.get(stringPath);
    body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  };
  var unwrapFunctionEnvironment = function() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }
    hoistFunctionEnvironment(this);
  };
  var setType2 = function(path3, type) {
    path3.node.type = type;
  };
  var arrowFunctionToExpression = function({
    allowInsertArrow = true,
    allowInsertArrowWithRest = allowInsertArrow,
    noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? undefined : _arguments$.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }
    const {
      thisBinding,
      fnPath: fn
    } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
    fn.ensureBlock();
    setType2(fn, "FunctionExpression");
    if (!noNewArrows) {
      const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
      if (checkBinding) {
        fn.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }
      fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
      fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
      return fn.get("callee.object");
    }
    return fn;
  };
  var hoistFunctionEnvironment = function(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
    let arrowParent;
    let thisEnvFn = fnPath.findParent((p) => {
      if (p.isArrowFunctionExpression()) {
        var _arrowParent;
        (_arrowParent = arrowParent) != null || (arrowParent = p);
        return false;
      }
      return p.isFunction() || p.isProgram() || p.isClassProperty({
        static: false
      }) || p.isClassPrivateProperty({
        static: false
      });
    });
    const inConstructor = thisEnvFn.isClassMethod({
      kind: "constructor"
    });
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
      if (arrowParent) {
        thisEnvFn = arrowParent;
      } else if (allowInsertArrow) {
        fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
        thisEnvFn = fnPath.get("callee");
        fnPath = thisEnvFn.get("body");
      } else {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }
    }
    const {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    } = getScopeInformation(fnPath);
    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      if (!allowInsertArrowWithRest) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const allSuperCalls = [];
      thisEnvFn.traverse(getSuperCallsVisitor, {
        allSuperCalls
      });
      const superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach((superCall) => {
        const callee = identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }
    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
        const args = () => identifier("arguments");
        if (thisEnvFn.scope.path.isProgram()) {
          return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
        } else {
          return args();
        }
      });
      argumentsPaths.forEach((argumentsChild) => {
        const argsRef = identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }
    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
      newTargetPaths.forEach((targetChild) => {
        const targetRef = identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }
    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
      flatSuperProps.forEach((superProp) => {
        const key = superProp.node.computed ? "" : superProp.get("property").node.name;
        const superParentPath = superProp.parentPath;
        const isAssignment = superParentPath.isAssignmentExpression({
          left: superProp.node
        });
        const isCall = superParentPath.isCallExpression({
          callee: superProp.node
        });
        const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
          tag: superProp.node
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];
        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }
        if (isAssignment) {
          const value2 = superParentPath.node.right;
          args.push(value2);
        }
        const call = callExpression(identifier(superBinding), args);
        if (isCall) {
          superParentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier("call")));
          thisPaths.push(superParentPath.get("arguments.0"));
        } else if (isAssignment) {
          superParentPath.replaceWith(call);
        } else if (isTaggedTemplate) {
          superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
          thisPaths.push(superProp.get("arguments.0"));
        } else {
          superProp.replaceWith(call);
        }
      });
    }
    let thisBinding;
    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);
      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach((thisChild) => {
          const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows)
          thisBinding = null;
      }
    }
    return {
      thisBinding,
      fnPath
    };
  };
  var isLogicalOp = function(op) {
    return LOGICAL_OPERATORS.includes(op);
  };
  var standardizeSuperProperty = function(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      const assignmentPath = superProp.parentPath;
      const op = assignmentPath.node.operator.slice(0, -1);
      const value2 = assignmentPath.node.right;
      const isLogicalAssignment = isLogicalOp(op);
      if (superProp.node.computed) {
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const object = superProp.node.object;
        const property2 = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property2), true));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value2));
      } else {
        const object = superProp.node.object;
        const property2 = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, property2));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property2.name)), value2));
      }
      if (isLogicalAssignment) {
        assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
      } else {
        assignmentPath.node.operator = "=";
      }
      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      const updateExpr = superProp.parentPath;
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier(tmp.name));
      }
      updateExpr.replaceWith(sequenceExpression(parts));
      const left2 = updateExpr.get("expressions.0.right");
      const right2 = updateExpr.get("expressions.1.left");
      return [left2, right2];
    }
    return [superProp];
    function rightExpression(op, left2, right2) {
      if (op === "=") {
        return assignmentExpression("=", left2, right2);
      } else {
        return binaryExpression(op, left2, right2);
      }
    }
  };
  var hasSuperClass = function(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  };
  var getThisBinding = function(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", (thisBinding) => {
      if (!inConstructor || !hasSuperClass(thisEnvFn))
        return thisExpression();
      thisEnvFn.traverse(assignSuperThisVisitor, {
        supers: new WeakSet,
        thisBinding
      });
    });
  };
  var getSuperBinding = function(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", () => {
      const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
    });
  };
  var getSuperPropBinding = function(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
      const argsList = [];
      let fnBody;
      if (propName) {
        fnBody = memberExpression(_super(), identifier(propName));
      } else {
        const method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier(method.name), true);
      }
      if (isAssignment) {
        const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
      }
      return arrowFunctionExpression(argsList, fnBody);
    });
  };
  var getBinding = function(thisEnvFn, key, init) {
    const cacheKey = "binding:" + key;
    let data = thisEnvFn.getData(cacheKey);
    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id,
        init: init(data)
      });
    }
    return data;
  };
  var getScopeInformation = function(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    fnPath.traverse(getScopeInformationVisitor, {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    });
    return {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.arrowFunctionToExpression = arrowFunctionToExpression;
  exports.ensureBlock = ensureBlock;
  exports.toComputedKey = toComputedKey;
  exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
  var _t = require_lib3();
  var _helperEnvironmentVisitor = require_lib6();
  var _helperFunctionName = require_lib12();
  var _visitors = require_visitors();
  var {
    arrowFunctionExpression,
    assignmentExpression,
    binaryExpression,
    blockStatement,
    callExpression,
    conditionalExpression,
    expressionStatement,
    identifier,
    isIdentifier,
    jsxIdentifier,
    logicalExpression,
    LOGICAL_OPERATORS,
    memberExpression,
    metaProperty,
    numericLiteral,
    objectExpression,
    restElement,
    returnStatement,
    sequenceExpression,
    spreadElement,
    stringLiteral,
    super: _super,
    thisExpression,
    toExpression,
    unaryExpression
  } = _t;
  {
    exports.arrowFunctionToShadowed = function() {
      if (!this.isArrowFunctionExpression())
        return;
      this.arrowFunctionToExpression();
    };
  }
  var getSuperCallsVisitor = (0, _visitors.merge)([{
    CallExpression(child, {
      allSuperCalls
    }) {
      if (!child.get("callee").isSuper())
        return;
      allSuperCalls.push(child);
    }
  }, _helperEnvironmentVisitor.default]);
  var assignSuperThisVisitor = (0, _visitors.merge)([{
    CallExpression(child, {
      supers,
      thisBinding
    }) {
      if (!child.get("callee").isSuper())
        return;
      if (supers.has(child.node))
        return;
      supers.add(child.node);
      child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
    }
  }, _helperEnvironmentVisitor.default]);
  var getScopeInformationVisitor = (0, _visitors.merge)([{
    ThisExpression(child, {
      thisPaths
    }) {
      thisPaths.push(child);
    },
    JSXIdentifier(child, {
      thisPaths
    }) {
      if (child.node.name !== "this")
        return;
      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }
      thisPaths.push(child);
    },
    CallExpression(child, {
      superCalls
    }) {
      if (child.get("callee").isSuper())
        superCalls.push(child);
    },
    MemberExpression(child, {
      superProps
    }) {
      if (child.get("object").isSuper())
        superProps.push(child);
    },
    Identifier(child, {
      argumentsPaths
    }) {
      if (!child.isReferencedIdentifier({
        name: "arguments"
      }))
        return;
      let curr = child.scope;
      do {
        if (curr.hasOwnBinding("arguments")) {
          curr.rename("arguments");
          return;
        }
        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
          break;
        }
      } while (curr = curr.parent);
      argumentsPaths.push(child);
    },
    MetaProperty(child, {
      newTargetPaths
    }) {
      if (!child.get("meta").isIdentifier({
        name: "new"
      }))
        return;
      if (!child.get("property").isIdentifier({
        name: "target"
      }))
        return;
      newTargetPaths.push(child);
    }
  }, _helperEnvironmentVisitor.default]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS((exports) => {
  var matchesPattern = function(pattern, allowPartial) {
    return _matchesPattern(this.node, pattern, allowPartial);
  };
  var has = function(key) {
    const val = this.node && this.node[key];
    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  };
  var isStatic = function() {
    return this.scope.isStatic(this.node);
  };
  var isnt = function(key) {
    return !this.has(key);
  };
  var equals = function(key, value2) {
    return this.node[key] === value2;
  };
  var isNodeType = function(type) {
    return isType(this.type, type);
  };
  var canHaveVariableDeclarationOrExpression = function() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  };
  var canSwapBetweenExpressionAndStatement = function(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }
    if (this.isExpression()) {
      return isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return isExpression(replacement);
    }
    return false;
  };
  var isCompletionRecord = function(allowInsideFunction) {
    let path3 = this;
    let first = true;
    do {
      const {
        type,
        container
      } = path3;
      if (!first && (path3.isFunction() || type === "StaticBlock")) {
        return !!allowInsideFunction;
      }
      first = false;
      if (Array.isArray(container) && path3.key !== container.length - 1) {
        return false;
      }
    } while ((path3 = path3.parentPath) && !path3.isProgram() && !path3.isDoExpression());
    return true;
  };
  var isStatementOrBlock = function() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
      return false;
    } else {
      return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
    }
  };
  var referencesImport = function(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
        value: importName
      }) : this.node.property.name === importName)) {
        const object = this.get("object");
        return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
      }
      return false;
    }
    const binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module")
      return false;
    const path3 = binding.path;
    const parent = path3.parentPath;
    if (!parent.isImportDeclaration())
      return false;
    if (parent.node.source.value === moduleSource) {
      if (!importName)
        return true;
    } else {
      return false;
    }
    if (path3.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }
    if (path3.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }
    if (path3.isImportSpecifier() && isIdentifier(path3.node.imported, {
      name: importName
    })) {
      return true;
    }
    return false;
  };
  var getSource = function() {
    const node2 = this.node;
    if (node2.end) {
      const code = this.hub.getCode();
      if (code)
        return code.slice(node2.start, node2.end);
    }
    return "";
  };
  var willIMaybeExecuteBefore = function(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  };
  var getOuterFunction = function(path3) {
    return path3.isProgram() ? path3 : (path3.parentPath.scope.getFunctionParent() || path3.parentPath.scope.getProgramParent()).path;
  };
  var isExecutionUncertain = function(type, key) {
    switch (type) {
      case "LogicalExpression":
        return key === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return key === "consequent" || key === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return key === "body";
      case "ForStatement":
        return key === "body" || key === "update";
      case "SwitchStatement":
        return key === "cases";
      case "TryStatement":
        return key === "handler";
      case "AssignmentPattern":
        return key === "right";
      case "OptionalMemberExpression":
        return key === "property";
      case "OptionalCallExpression":
        return key === "arguments";
      default:
        return false;
    }
  };
  var isExecutionUncertainInList = function(paths, maxIndex) {
    for (let i = 0;i < maxIndex; i++) {
      const path3 = paths[i];
      if (isExecutionUncertain(path3.parent.type, path3.parentKey)) {
        return true;
      }
    }
    return false;
  };
  var _guessExecutionStatusRelativeTo = function(target) {
    return _guessExecutionStatusRelativeToCached(this, target, new Map);
  };
  var _guessExecutionStatusRelativeToCached = function(base, target, cache) {
    const funcParent = {
      this: getOuterFunction(base),
      target: getOuterFunction(target)
    };
    if (funcParent.target.node !== funcParent.this.node) {
      return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
    }
    const paths = {
      target: target.getAncestry(),
      this: base.getAncestry()
    };
    if (paths.target.indexOf(base) >= 0)
      return "after";
    if (paths.this.indexOf(target) >= 0)
      return "before";
    let commonPath;
    const commonIndex = {
      target: 0,
      this: 0
    };
    while (!commonPath && commonIndex.this < paths.this.length) {
      const path3 = paths.this[commonIndex.this];
      commonIndex.target = paths.target.indexOf(path3);
      if (commonIndex.target >= 0) {
        commonPath = path3;
      } else {
        commonIndex.this++;
      }
    }
    if (!commonPath) {
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    }
    if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
      return "unknown";
    }
    const divergence = {
      this: paths.this[commonIndex.this - 1],
      target: paths.target[commonIndex.target - 1]
    };
    if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
      return divergence.target.key > divergence.this.key ? "before" : "after";
    }
    const keys = VISITOR_KEYS[commonPath.type];
    const keyPosition = {
      this: keys.indexOf(divergence.this.parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition.this ? "before" : "after";
  };
  var _guessExecutionStatusRelativeToDifferentFunctionsInternal = function(base, target, cache) {
    if (!target.isFunctionDeclaration()) {
      if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
        return "before";
      }
      return "unknown";
    } else if (target.parentPath.isExportDeclaration()) {
      return "unknown";
    }
    const binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references)
      return "before";
    const referencePaths = binding.referencePaths;
    let allStatus;
    for (const path3 of referencePaths) {
      const childOfFunction = !!path3.find((path4) => path4.node === target.node);
      if (childOfFunction)
        continue;
      if (path3.key !== "callee" || !path3.parentPath.isCallExpression()) {
        return "unknown";
      }
      const status = _guessExecutionStatusRelativeToCached(base, path3, cache);
      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }
    return allStatus;
  };
  var _guessExecutionStatusRelativeToDifferentFunctionsCached = function(base, target, cache) {
    let nodeMap = cache.get(base.node);
    let cached;
    if (!nodeMap) {
      cache.set(base.node, nodeMap = new Map);
    } else if (cached = nodeMap.get(target.node)) {
      if (cached === SYMBOL_CHECKING) {
        return "unknown";
      }
      return cached;
    }
    nodeMap.set(target.node, SYMBOL_CHECKING);
    const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
    nodeMap.set(target.node, result);
    return result;
  };
  var resolve6 = function(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  };
  var _resolve = function(dangerous, resolved) {
    if (resolved && resolved.indexOf(this) >= 0)
      return;
    resolved = resolved || [];
    resolved.push(this);
    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      } else {
      }
    } else if (this.isReferencedIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding)
        return;
      if (!binding.constant)
        return;
      if (binding.kind === "module")
        return;
      if (binding.path !== this) {
        const ret = binding.path.resolve(dangerous, resolved);
        if (this.find((parent) => parent.node === ret.node))
          return;
        return ret;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      const targetKey = this.toComputedKey();
      if (!isLiteral(targetKey))
        return;
      const targetName = targetKey.value;
      const target = this.get("object").resolve(dangerous, resolved);
      if (target.isObjectExpression()) {
        const props = target.get("properties");
        for (const prop of props) {
          if (!prop.isProperty())
            continue;
          const key = prop.get("key");
          let match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match)
            return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        const elems = target.get("elements");
        const elem = elems[targetName];
        if (elem)
          return elem.resolve(dangerous, resolved);
      }
    }
  };
  var isConstantExpression = function() {
    if (this.isIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding)
        return false;
      return binding.constant;
    }
    if (this.isLiteral()) {
      if (this.isRegExpLiteral()) {
        return false;
      }
      if (this.isTemplateLiteral()) {
        return this.get("expressions").every((expression) => expression.isConstantExpression());
      }
      return true;
    }
    if (this.isUnaryExpression()) {
      if (this.node.operator !== "void") {
        return false;
      }
      return this.get("argument").isConstantExpression();
    }
    if (this.isBinaryExpression()) {
      const {
        operator
      } = this.node;
      return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return false;
  };
  var isInStrictMode = function() {
    const start = this.isProgram() ? this : this.parentPath;
    const strictParent = start.find((path3) => {
      if (path3.isProgram({
        sourceType: "module"
      }))
        return true;
      if (path3.isClass())
        return true;
      if (path3.isArrowFunctionExpression() && !path3.get("body").isBlockStatement()) {
        return false;
      }
      let body;
      if (path3.isFunction()) {
        body = path3.node.body;
      } else if (path3.isProgram()) {
        body = path3.node;
      } else {
        return false;
      }
      for (const directive of body.directives) {
        if (directive.value.value === "use strict") {
          return true;
        }
      }
    });
    return !!strictParent;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
  exports._resolve = _resolve;
  exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
  exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
  exports.equals = equals;
  exports.getSource = getSource;
  exports.has = has;
  exports.is = undefined;
  exports.isCompletionRecord = isCompletionRecord;
  exports.isConstantExpression = isConstantExpression;
  exports.isInStrictMode = isInStrictMode;
  exports.isNodeType = isNodeType;
  exports.isStatementOrBlock = isStatementOrBlock;
  exports.isStatic = isStatic;
  exports.isnt = isnt;
  exports.matchesPattern = matchesPattern;
  exports.referencesImport = referencesImport;
  exports.resolve = resolve6;
  exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
  var _t = require_lib3();
  var {
    STATEMENT_OR_BLOCK_KEYS,
    VISITOR_KEYS,
    isBlockStatement,
    isExpression,
    isIdentifier,
    isLiteral,
    isStringLiteral,
    isType,
    matchesPattern: _matchesPattern
  } = _t;
  var is = exports.is = has;
  var SYMBOL_CHECKING = Symbol();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/context.js
var require_context = __commonJS((exports) => {
  var call = function(key) {
    const opts = this.opts;
    this.debug(key);
    if (this.node) {
      if (this._call(opts[key]))
        return true;
    }
    if (this.node) {
      var _opts$this$node$type;
      return this._call((_opts$this$node$type = opts[this.node.type]) == null ? undefined : _opts$this$node$type[key]);
    }
    return false;
  };
  var _call = function(fns) {
    if (!fns)
      return false;
    for (const fn of fns) {
      if (!fn)
        continue;
      const node2 = this.node;
      if (!node2)
        return true;
      const ret = fn.call(this.state, this, this.state);
      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
      }
      if (ret) {
        throw new Error(`Unexpected return value from visitor method ${fn}`);
      }
      if (this.node !== node2)
        return true;
      if (this._traverseFlags > 0)
        return true;
    }
    return false;
  };
  var isDenylisted = function() {
    var _this$opts$denylist;
    const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist && denylist.indexOf(this.node.type) > -1;
  };
  var restoreContext = function(path3, context) {
    if (path3.context !== context) {
      path3.context = context;
      path3.state = context.state;
      path3.opts = context.opts;
    }
  };
  var visit2 = function() {
    var _this$opts$shouldSkip, _this$opts;
    if (!this.node) {
      return false;
    }
    if (this.isDenylisted()) {
      return false;
    }
    if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
      return false;
    }
    const currentContext = this.context;
    if (this.shouldSkip || this.call("enter")) {
      this.debug("Skip...");
      return this.shouldStop;
    }
    restoreContext(this, currentContext);
    this.debug("Recursing into...");
    this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    this.call("exit");
    return this.shouldStop;
  };
  var skip = function() {
    this.shouldSkip = true;
  };
  var skipKey = function(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }
    this.skipKeys[key] = true;
  };
  var stop = function() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
  };
  var setScope = function() {
    var _this$opts2, _this$scope;
    if ((_this$opts2 = this.opts) != null && _this$opts2.noScope)
      return;
    let path3 = this.parentPath;
    if ((this.key === "key" || this.listKey === "decorators") && path3.isMethod() || this.key === "discriminant" && path3.isSwitchStatement()) {
      path3 = path3.parentPath;
    }
    let target;
    while (path3 && !target) {
      var _path$opts;
      if ((_path$opts = path3.opts) != null && _path$opts.noScope)
        return;
      target = path3.scope;
      path3 = path3.parentPath;
    }
    this.scope = this.getScope(target);
    (_this$scope = this.scope) == null || _this$scope.init();
  };
  var setContext = function(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }
    this._traverseFlags = 0;
    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }
    this.setScope();
    return this;
  };
  var resync = function() {
    if (this.removed)
      return;
    this._resyncParent();
    this._resyncList();
    this._resyncKey();
  };
  var _resyncParent = function() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  };
  var _resyncKey = function() {
    if (!this.container)
      return;
    if (this.node === this.container[this.key]) {
      return;
    }
    if (Array.isArray(this.container)) {
      for (let i = 0;i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          this.setKey(i);
          return;
        }
      }
    } else {
      for (const key of Object.keys(this.container)) {
        if (this.container[key] === this.node) {
          this.setKey(key);
          return;
        }
      }
    }
    this.key = null;
  };
  var _resyncList = function() {
    if (!this.parent || !this.inList)
      return;
    const newContainer = this.parent[this.listKey];
    if (this.container === newContainer)
      return;
    this.container = newContainer || null;
  };
  var _resyncRemoved = function() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      this._markRemoved();
    }
  };
  var popContext = function() {
    this.contexts.pop();
    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  };
  var pushContext = function(context) {
    this.contexts.push(context);
    this.setContext(context);
  };
  var setup = function(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  };
  var setKey = function(key) {
    var _this$node;
    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? undefined : _this$node.type;
  };
  var requeue = function(pathToQueue = this) {
    if (pathToQueue.removed)
      return;
    const contexts = this.contexts;
    for (const context of contexts) {
      context.maybeQueue(pathToQueue);
    }
  };
  var _getQueueContexts = function() {
    let path3 = this;
    let contexts = this.contexts;
    while (!contexts.length) {
      path3 = path3.parentPath;
      if (!path3)
        break;
      contexts = path3.contexts;
    }
    return contexts;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._call = _call;
  exports._getQueueContexts = _getQueueContexts;
  exports._resyncKey = _resyncKey;
  exports._resyncList = _resyncList;
  exports._resyncParent = _resyncParent;
  exports._resyncRemoved = _resyncRemoved;
  exports.call = call;
  exports.isBlacklisted = exports.isDenylisted = isDenylisted;
  exports.popContext = popContext;
  exports.pushContext = pushContext;
  exports.requeue = requeue;
  exports.resync = resync;
  exports.setContext = setContext;
  exports.setKey = setKey;
  exports.setScope = setScope;
  exports.setup = setup;
  exports.skip = skip;
  exports.skipKey = skipKey;
  exports.stop = stop;
  exports.visit = visit2;
  var _traverseNode = require_traverse_node();
  var _index = require_path();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hooks = undefined;
  var hooks = exports.hooks = [function(self2, parent) {
    const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function(self2, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function(self2, parent) {
    if (parent.isBinary()) {
      if (self2.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }
      return true;
    }
  }, function(self2, parent) {
    if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self2.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS((exports) => {
  var remove = function() {
    var _this$opts;
    this._assertUnremoved();
    this.resync();
    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      this._removeFromScope();
    }
    if (this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings();
    this._remove();
    this._markRemoved();
  };
  var _removeFromScope = function() {
    const bindings = getBindingIdentifiers(this.node, false, false, true);
    Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
  };
  var _callRemovalHooks = function() {
    if (this.parentPath) {
      for (const fn of _removalHooks.hooks) {
        if (fn(this, this.parentPath))
          return true;
      }
    }
  };
  var _remove = function() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  };
  var _markRemoved = function() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
    if (this.parent) {
      (0, _cache.getCachedPaths)(this.hub, this.parent).delete(this.node);
    }
    this.node = null;
  };
  var _assertUnremoved = function() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._assertUnremoved = _assertUnremoved;
  exports._callRemovalHooks = _callRemovalHooks;
  exports._markRemoved = _markRemoved;
  exports._remove = _remove;
  exports._removeFromScope = _removeFromScope;
  exports.remove = remove;
  var _removalHooks = require_removal_hooks();
  var _cache = require_cache();
  var _index = require_path();
  var _t = require_lib3();
  var {
    getBindingIdentifiers
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _t = require_lib3();
  var _t2 = _t;
  var {
    react
  } = _t;
  var {
    cloneNode,
    jsxExpressionContainer,
    variableDeclaration,
    variableDeclarator
  } = _t2;
  var referenceVisitor = {
    ReferencedIdentifier(path3, state) {
      if (path3.isJSXIdentifier() && react.isCompatTag(path3.node.name) && !path3.parentPath.isJSXMemberExpression()) {
        return;
      }
      if (path3.node.name === "this") {
        let scope = path3.scope;
        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);
        if (scope)
          state.breakOnScopePaths.push(scope.path);
      }
      const binding = path3.scope.getBinding(path3.node.name);
      if (!binding)
        return;
      for (const violation of binding.constantViolations) {
        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path3.stop();
          return;
        }
      }
      if (binding !== state.scope.getBinding(path3.node.name))
        return;
      state.bindings[path3.node.name] = binding;
    }
  };

  class PathHoister {
    constructor(path3, scope) {
      this.breakOnScopePaths = undefined;
      this.bindings = undefined;
      this.mutableBinding = undefined;
      this.scopes = undefined;
      this.scope = undefined;
      this.path = undefined;
      this.attachAfter = undefined;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path3;
      this.attachAfter = false;
    }
    isCompatibleScope(scope) {
      for (const key of Object.keys(this.bindings)) {
        const binding = this.bindings[key];
        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }
      return true;
    }
    getCompatibleScopes() {
      let scope = this.path.scope;
      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }
        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
          break;
        }
      } while (scope = scope.parent);
    }
    getAttachmentPath() {
      let path3 = this._getAttachmentPath();
      if (!path3)
        return;
      let targetScope = path3.scope;
      if (targetScope.path === path3) {
        targetScope = path3.scope.parent;
      }
      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (const name of Object.keys(this.bindings)) {
          if (!targetScope.hasOwnBinding(name))
            continue;
          const binding = this.bindings[name];
          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }
          const bindingParentPath = this.getAttachmentParentForPath(binding.path);
          if (bindingParentPath.key >= path3.key) {
            this.attachAfter = true;
            path3 = binding.path;
            for (const violationPath of binding.constantViolations) {
              if (this.getAttachmentParentForPath(violationPath).key > path3.key) {
                path3 = violationPath;
              }
            }
          }
        }
      }
      return path3;
    }
    _getAttachmentPath() {
      const scopes = this.scopes;
      const scope = scopes.pop();
      if (!scope)
        return;
      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope)
            return;
          const bodies = scope.path.get("body").get("body");
          for (let i = 0;i < bodies.length; i++) {
            if (bodies[i].node._blockHoist)
              continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const scope = this.scopes.pop();
      if (scope)
        return this.getAttachmentParentForPath(scope.path);
    }
    getAttachmentParentForPath(path3) {
      do {
        if (!path3.parentPath || Array.isArray(path3.container) && path3.isStatement()) {
          return path3;
        }
      } while (path3 = path3.parentPath);
    }
    hasOwnParamBindings(scope) {
      for (const name of Object.keys(this.bindings)) {
        if (!scope.hasOwnBinding(name))
          continue;
        const binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant)
          return true;
      }
      return false;
    }
    run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding)
        return;
      this.getCompatibleScopes();
      const attachTo = this.getAttachmentPath();
      if (!attachTo)
        return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent())
        return;
      let uid = attachTo.scope.generateUidIdentifier("ref");
      const declarator = variableDeclarator(uid, this.path.node);
      const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
      const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
      const parent = this.path.parentPath;
      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = jsxExpressionContainer(uid);
      }
      this.path.replaceWith(cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }
  }
  exports.default = PathHoister;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS((exports) => {
  var insertBefore = function(nodes_) {
    this._assertUnremoved();
    const nodes = this._verifyNodeList(nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node)
        nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      const node2 = this.node;
      const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  };
  var _containerInsert = function(from, nodes) {
    this.updateSiblingKeys(from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);
    for (let i = 0;i < nodes.length; i++) {
      var _this$context;
      const to = from + i;
      const path3 = this.getSibling(to);
      paths.push(path3);
      if ((_this$context = this.context) != null && _this$context.queue) {
        path3.pushContext(this.context);
      }
    }
    const contexts = this._getQueueContexts();
    for (const path3 of paths) {
      path3.setScope();
      path3.debug("Inserted.");
      for (const context of contexts) {
        context.maybeQueue(path3, true);
      }
    }
    return paths;
  };
  var _containerInsertBefore = function(nodes) {
    return this._containerInsert(this.key, nodes);
  };
  var _containerInsertAfter = function(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  };
  var isHiddenInSequenceExpression = function(path3) {
    return isSequenceExpression(path3.parent) && (last(path3.parent.expressions) !== path3.node || isHiddenInSequenceExpression(path3.parentPath));
  };
  var isAlmostConstantAssignment = function(node2, scope) {
    if (!isAssignmentExpression(node2) || !isIdentifier(node2.left)) {
      return false;
    }
    const blockScope = scope.getBlockParent();
    return blockScope.hasOwnBinding(node2.left.name) && blockScope.getOwnBinding(node2.left.name).constantViolations.length <= 1;
  };
  var insertAfter = function(nodes_) {
    this._assertUnremoved();
    if (this.isSequenceExpression()) {
      return last(this.get("expressions")).insertAfter(nodes_);
    }
    const nodes = this._verifyNodeList(nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map((node2) => {
        return isExpression(node2) ? expressionStatement(node2) : node2;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) {
        const node2 = this.node;
        let {
          scope
        } = this;
        if (scope.path.isPattern()) {
          assertExpression(node2);
          this.replaceWith(callExpression(arrowFunctionExpression([], node2), []));
          this.get("callee.body").insertAfter(nodes);
          return [this];
        }
        if (isHiddenInSequenceExpression(this)) {
          nodes.unshift(node2);
        } else if (isCallExpression(node2) && isSuper(node2.callee)) {
          nodes.unshift(node2);
          nodes.push(thisExpression());
        } else if (isAlmostConstantAssignment(node2, scope)) {
          nodes.unshift(node2);
          nodes.push(cloneNode(node2.left));
        } else if (scope.isPure(node2, true)) {
          nodes.push(node2);
        } else {
          if (parentPath.isMethod({
            computed: true,
            key: node2
          })) {
            scope = scope.parent;
          }
          const temp = scope.generateDeclaredUidIdentifier();
          nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node2)));
          nodes.push(expressionStatement(cloneNode(temp)));
        }
      }
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      const node2 = this.node;
      const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  };
  var updateSiblingKeys = function(fromIndex, incrementBy) {
    if (!this.parent)
      return;
    const paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];
    for (const [, path3] of paths) {
      if (typeof path3.key === "number" && path3.key >= fromIndex) {
        path3.key += incrementBy;
      }
    }
  };
  var _verifyNodeList = function(nodes) {
    if (!nodes) {
      return [];
    }
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (let i = 0;i < nodes.length; i++) {
      const node2 = nodes[i];
      let msg;
      if (!node2) {
        msg = "has falsy node";
      } else if (typeof node2 !== "object") {
        msg = "contains a non-object node";
      } else if (!node2.type) {
        msg = "without a type";
      } else if (node2 instanceof _index.default) {
        msg = "has a NodePath when it expected a raw object";
      }
      if (msg) {
        const type = Array.isArray(node2) ? "array" : typeof node2;
        throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
      }
    }
    return nodes;
  };
  var unshiftContainer = function(listKey, nodes) {
    this._assertUnremoved();
    nodes = this._verifyNodeList(nodes);
    const path3 = _index.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey,
      key: 0
    }).setContext(this.context);
    return path3._containerInsertBefore(nodes);
  };
  var pushContainer = function(listKey, nodes) {
    this._assertUnremoved();
    const verifiedNodes = this._verifyNodeList(nodes);
    const container = this.node[listKey];
    const path3 = _index.default.get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: container.length
    }).setContext(this.context);
    return path3.replaceWithMultiple(verifiedNodes);
  };
  var hoist = function(scope = this.scope) {
    const hoister = new _hoister.default(this, scope);
    return hoister.run();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._containerInsert = _containerInsert;
  exports._containerInsertAfter = _containerInsertAfter;
  exports._containerInsertBefore = _containerInsertBefore;
  exports._verifyNodeList = _verifyNodeList;
  exports.hoist = hoist;
  exports.insertAfter = insertAfter;
  exports.insertBefore = insertBefore;
  exports.pushContainer = pushContainer;
  exports.unshiftContainer = unshiftContainer;
  exports.updateSiblingKeys = updateSiblingKeys;
  var _cache = require_cache();
  var _hoister = require_hoister();
  var _index = require_path();
  var _t = require_lib3();
  var {
    arrowFunctionExpression,
    assertExpression,
    assignmentExpression,
    blockStatement,
    callExpression,
    cloneNode,
    expressionStatement,
    isAssignmentExpression,
    isCallExpression,
    isExportNamedDeclaration,
    isExpression,
    isIdentifier,
    isSequenceExpression,
    isSuper,
    thisExpression
  } = _t;
  var last = (arr) => arr[arr.length - 1];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS((exports) => {
  var NormalCompletion = function(path3) {
    return {
      type: NORMAL_COMPLETION,
      path: path3
    };
  };
  var BreakCompletion = function(path3) {
    return {
      type: BREAK_COMPLETION,
      path: path3
    };
  };
  var getOpposite = function() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
    return null;
  };
  var addCompletionRecords = function(path3, records, context) {
    if (path3) {
      records.push(..._getCompletionRecords(path3, context));
    }
    return records;
  };
  var completionRecordForSwitch = function(cases, records, context) {
    let lastNormalCompletions = [];
    for (let i = 0;i < cases.length; i++) {
      const casePath = cases[i];
      const caseCompletions = _getCompletionRecords(casePath, context);
      const normalCompletions = [];
      const breakCompletions = [];
      for (const c of caseCompletions) {
        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }
        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }
      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }
      records.push(...breakCompletions);
    }
    records.push(...lastNormalCompletions);
    return records;
  };
  var normalCompletionToBreak = function(completions) {
    completions.forEach((c) => {
      c.type = BREAK_COMPLETION;
    });
  };
  var replaceBreakStatementInBreakCompletion = function(completions, reachable) {
    completions.forEach((c) => {
      if (c.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
        } else {
          c.path.remove();
        }
      }
    });
  };
  var getStatementListCompletion = function(paths, context) {
    const completions = [];
    if (context.canHaveBreak) {
      let lastNormalCompletions = [];
      for (let i = 0;i < paths.length; i++) {
        const path3 = paths[i];
        const newContext = Object.assign({}, context, {
          inCaseClause: false
        });
        if (path3.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
          newContext.shouldPopulateBreak = true;
        } else {
          newContext.shouldPopulateBreak = false;
        }
        const statementCompletions = _getCompletionRecords(path3, newContext);
        if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
            label: null
          }))) {
            normalCompletionToBreak(lastNormalCompletions);
            completions.push(...lastNormalCompletions);
            if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
              completions.push(...statementCompletions);
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
            replaceBreakStatementInBreakCompletion(statementCompletions, false);
          } else {
            completions.push(...statementCompletions);
            if (!context.shouldPopulateBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }
          break;
        }
        if (i === paths.length - 1) {
          completions.push(...statementCompletions);
        } else {
          lastNormalCompletions = [];
          for (let i2 = 0;i2 < statementCompletions.length; i2++) {
            const c = statementCompletions[i2];
            if (c.type === BREAK_COMPLETION) {
              completions.push(c);
            }
            if (c.type === NORMAL_COMPLETION) {
              lastNormalCompletions.push(c);
            }
          }
        }
      }
    } else if (paths.length) {
      for (let i = paths.length - 1;i >= 0; i--) {
        const pathCompletions = _getCompletionRecords(paths[i], context);
        if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
          completions.push(...pathCompletions);
          break;
        }
      }
    }
    return completions;
  };
  var _getCompletionRecords = function(path3, context) {
    let records = [];
    if (path3.isIfStatement()) {
      records = addCompletionRecords(path3.get("consequent"), records, context);
      records = addCompletionRecords(path3.get("alternate"), records, context);
    } else if (path3.isDoExpression() || path3.isFor() || path3.isWhile() || path3.isLabeledStatement()) {
      return addCompletionRecords(path3.get("body"), records, context);
    } else if (path3.isProgram() || path3.isBlockStatement()) {
      return getStatementListCompletion(path3.get("body"), context);
    } else if (path3.isFunction()) {
      return _getCompletionRecords(path3.get("body"), context);
    } else if (path3.isTryStatement()) {
      records = addCompletionRecords(path3.get("block"), records, context);
      records = addCompletionRecords(path3.get("handler"), records, context);
    } else if (path3.isCatchClause()) {
      return addCompletionRecords(path3.get("body"), records, context);
    } else if (path3.isSwitchStatement()) {
      return completionRecordForSwitch(path3.get("cases"), records, context);
    } else if (path3.isSwitchCase()) {
      return getStatementListCompletion(path3.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true
      });
    } else if (path3.isBreakStatement()) {
      records.push(BreakCompletion(path3));
    } else {
      records.push(NormalCompletion(path3));
    }
    return records;
  };
  var getCompletionRecords = function() {
    const records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false
    });
    return records.map((r) => r.path);
  };
  var getSibling = function(key) {
    return _index.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key
    }).setContext(this.context);
  };
  var getPrevSibling = function() {
    return this.getSibling(this.key - 1);
  };
  var getNextSibling = function() {
    return this.getSibling(this.key + 1);
  };
  var getAllNextSiblings = function() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }
    return siblings;
  };
  var getAllPrevSiblings = function() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }
    return siblings;
  };
  var get = function(key, context = true) {
    if (context === true)
      context = this.context;
    const parts = key.split(".");
    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  };
  var _getKey = function(key, context) {
    const node2 = this.node;
    const container = node2[key];
    if (Array.isArray(container)) {
      return container.map((_, i) => {
        return _index.default.get({
          listKey: key,
          parentPath: this,
          parent: node2,
          container,
          key: i
        }).setContext(context);
      });
    } else {
      return _index.default.get({
        parentPath: this,
        parent: node2,
        container: node2,
        key
      }).setContext(context);
    }
  };
  var _getPattern = function(parts, context) {
    let path3 = this;
    for (const part of parts) {
      if (part === ".") {
        path3 = path3.parentPath;
      } else {
        if (Array.isArray(path3)) {
          path3 = path3[part];
        } else {
          path3 = path3.get(part, context);
        }
      }
    }
    return path3;
  };
  var getBindingIdentifiers = function(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
  };
  var getOuterBindingIdentifiers = function(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
  };
  var getBindingIdentifierPaths = function(duplicates = false, outerOnly = false) {
    const path3 = this;
    const search = [path3];
    const ids = Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id)
        continue;
      if (!id.node)
        continue;
      const keys = _getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) {
        if (duplicates) {
          const _ids = ids[id.node.name] = ids[id.node.name] || [];
          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }
        continue;
      }
      if (id.isExportDeclaration()) {
        const declaration = id.get("declaration");
        if (isDeclaration(declaration)) {
          search.push(declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }
        if (id.isFunctionExpression()) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          const child = id.get(key);
          if (Array.isArray(child)) {
            search.push(...child);
          } else if (child.node) {
            search.push(child);
          }
        }
      }
    }
    return ids;
  };
  var getOuterBindingIdentifierPaths = function(duplicates = false) {
    return this.getBindingIdentifierPaths(duplicates, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._getKey = _getKey;
  exports._getPattern = _getPattern;
  exports.get = get;
  exports.getAllNextSiblings = getAllNextSiblings;
  exports.getAllPrevSiblings = getAllPrevSiblings;
  exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
  exports.getBindingIdentifiers = getBindingIdentifiers;
  exports.getCompletionRecords = getCompletionRecords;
  exports.getNextSibling = getNextSibling;
  exports.getOpposite = getOpposite;
  exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
  exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
  exports.getPrevSibling = getPrevSibling;
  exports.getSibling = getSibling;
  var _index = require_path();
  var _t = require_lib3();
  var {
    getBindingIdentifiers: _getBindingIdentifiers,
    getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
    isDeclaration,
    numericLiteral,
    unaryExpression
  } = _t;
  var NORMAL_COMPLETION = 0;
  var BREAK_COMPLETION = 1;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS((exports) => {
  var shareCommentsWithSiblings = function() {
    if (typeof this.key === "string")
      return;
    const node2 = this.node;
    if (!node2)
      return;
    const trailing = node2.trailingComments;
    const leading = node2.leadingComments;
    if (!trailing && !leading)
      return;
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);
    if (hasPrev) {
      if (leading) {
        prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
      }
      if (trailing && !hasNext)
        prev.addComments("trailing", trailing);
    }
    if (hasNext) {
      if (trailing) {
        next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
      }
      if (leading && !hasPrev)
        next.addComments("leading", leading);
    }
  };
  var removeIfExisting = function(list, toRemove) {
    if (!(toRemove != null && toRemove.length))
      return list;
    const set = new Set(toRemove);
    return list.filter((el) => {
      return !set.has(el);
    });
  };
  var addComment = function(type, content, line) {
    _addComment(this.node, type, content, line);
  };
  var addComments = function(type, comments) {
    _addComments(this.node, type, comments);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addComment = addComment;
  exports.addComments = addComments;
  exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
  var _t = require_lib3();
  var {
    addComment: _addComment,
    addComments: _addComments
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = undefined;
  var virtualTypes = require_virtual_types();
  var _debug = require_src();
  var _index = require_lib13();
  var _index2 = require_scope();
  var _t = require_lib3();
  var t = _t;
  var cache = require_cache();
  var _generator = require_lib7();
  var NodePath_ancestry = require_ancestry();
  var NodePath_inference = require_inference();
  var NodePath_replacement = require_replacement();
  var NodePath_evaluation = require_evaluation();
  var NodePath_conversion = require_conversion();
  var NodePath_introspection = require_introspection();
  var NodePath_context = require_context();
  var NodePath_removal = require_removal();
  var NodePath_modification = require_modification();
  var NodePath_family = require_family();
  var NodePath_comments = require_comments();
  var NodePath_virtual_types_validator = require_virtual_types_validator();
  var {
    validate: validate2
  } = _t;
  var debug = _debug("babel");
  var REMOVED = exports.REMOVED = 1 << 0;
  var SHOULD_STOP = exports.SHOULD_STOP = 1 << 1;
  var SHOULD_SKIP = exports.SHOULD_SKIP = 1 << 2;

  class NodePath {
    constructor(hub, parent) {
      this.contexts = [];
      this.state = null;
      this.opts = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this.parent = parent;
      this.hub = hub;
      this.data = null;
      this.context = null;
      this.scope = null;
    }
    static get({
      hub,
      parentPath,
      parent,
      container,
      listKey,
      key
    }) {
      if (!hub && parentPath) {
        hub = parentPath.hub;
      }
      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }
      const targetNode = container[key];
      const paths = cache.getOrCreateCachedPaths(hub, parent);
      let path3 = paths.get(targetNode);
      if (!path3) {
        path3 = new NodePath(hub, parent);
        if (targetNode)
          paths.set(targetNode, path3);
      }
      path3.setup(parentPath, container, listKey, key);
      return path3;
    }
    getScope(scope) {
      return this.isScope() ? new _index2.default(this) : scope;
    }
    setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }
      return this.data[key] = val;
    }
    getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }
      let val = this.data[key];
      if (val === undefined && def !== undefined)
        val = this.data[key] = def;
      return val;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(msg, Error2 = SyntaxError) {
      return this.hub.buildError(this.node, msg, Error2);
    }
    traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
    set(key, node2) {
      validate2(this.node, key, node2);
      this.node[key] = node2;
    }
    getPathLocation() {
      const parts = [];
      let path3 = this;
      do {
        let key = path3.key;
        if (path3.inList)
          key = `${path3.listKey}[${key}]`;
        parts.unshift(key);
      } while (path3 = path3.parentPath);
      return parts.join(".");
    }
    debug(message) {
      if (!debug.enabled)
        return;
      debug(`${this.getPathLocation()} ${this.type}: ${message}`);
    }
    toString() {
      return (0, _generator.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & SHOULD_SKIP);
    }
    set shouldSkip(v) {
      if (v) {
        this._traverseFlags |= SHOULD_SKIP;
      } else {
        this._traverseFlags &= ~SHOULD_SKIP;
      }
    }
    get shouldStop() {
      return !!(this._traverseFlags & SHOULD_STOP);
    }
    set shouldStop(v) {
      if (v) {
        this._traverseFlags |= SHOULD_STOP;
      } else {
        this._traverseFlags &= ~SHOULD_STOP;
      }
    }
    get removed() {
      return !!(this._traverseFlags & REMOVED);
    }
    set removed(v) {
      if (v) {
        this._traverseFlags |= REMOVED;
      } else {
        this._traverseFlags &= ~REMOVED;
      }
    }
  }
  Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
  {
    NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
  }
  for (const type of t.TYPES) {
    const typeKey = `is${type}`;
    const fn = t[typeKey];
    NodePath.prototype[typeKey] = function(opts) {
      return fn(this.node, opts);
    };
    NodePath.prototype[`assert${type}`] = function(opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError(`Expected node path of type ${type}`);
      }
    };
  }
  Object.assign(NodePath.prototype, NodePath_virtual_types_validator);
  for (const type of Object.keys(virtualTypes)) {
    if (type[0] === "_")
      continue;
    if (!t.TYPES.includes(type))
      t.TYPES.push(type);
  }
  var _default = exports.default = NodePath;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_path();
  var _t = require_lib3();
  var {
    VISITOR_KEYS
  } = _t;

  class TraversalContext {
    constructor(scope, opts, state, parentPath) {
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }
    shouldVisit(node2) {
      const opts = this.opts;
      if (opts.enter || opts.exit)
        return true;
      if (opts[node2.type])
        return true;
      const keys = VISITOR_KEYS[node2.type];
      if (!(keys != null && keys.length))
        return false;
      for (const key of keys) {
        if (node2[key]) {
          return true;
        }
      }
      return false;
    }
    create(node2, container, key, listKey) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: node2,
        container,
        key,
        listKey
      });
    }
    maybeQueue(path3, notPriority) {
      if (this.queue) {
        if (notPriority) {
          this.queue.push(path3);
        } else {
          this.priorityQueue.push(path3);
        }
      }
    }
    visitMultiple(container, parent, listKey) {
      if (container.length === 0)
        return false;
      const queue = [];
      for (let key = 0;key < container.length; key++) {
        const node2 = container[key];
        if (node2 && this.shouldVisit(node2)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }
      return this.visitQueue(queue);
    }
    visitSingle(node2, key) {
      if (this.shouldVisit(node2[key])) {
        return this.visitQueue([this.create(node2, node2, key)]);
      } else {
        return false;
      }
    }
    visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      const visited = new WeakSet;
      let stop = false;
      for (const path3 of queue) {
        path3.resync();
        if (path3.contexts.length === 0 || path3.contexts[path3.contexts.length - 1] !== this) {
          path3.pushContext(this);
        }
        if (path3.key === null)
          continue;
        const {
          node: node2
        } = path3;
        if (visited.has(node2))
          continue;
        if (node2)
          visited.add(node2);
        if (path3.visit()) {
          stop = true;
          break;
        }
        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop)
            break;
        }
      }
      for (const path3 of queue) {
        path3.popContext();
      }
      this.queue = null;
      return stop;
    }
    visit(node2, key) {
      const nodes = node2[key];
      if (!nodes)
        return false;
      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node2, key);
      } else {
        return this.visitSingle(node2, key);
      }
    }
  }
  exports.default = TraversalContext;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS((exports) => {
  var traverseNode = function(node2, opts, scope, state, path3, skipKeys, visitSelf) {
    const keys = VISITOR_KEYS[node2.type];
    if (!keys)
      return false;
    const context = new _context.default(scope, opts, state, path3);
    if (visitSelf) {
      if (skipKeys != null && skipKeys[path3.parentKey])
        return false;
      return context.visitQueue([path3]);
    }
    for (const key of keys) {
      if (skipKeys != null && skipKeys[key])
        continue;
      if (context.visit(node2, key)) {
        return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.traverseNode = traverseNode;
  var _context = require_context2();
  var _t = require_lib3();
  var {
    VISITOR_KEYS
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class Hub {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(node2, msg, Error2 = TypeError) {
      return new Error2(msg);
    }
  }
  exports.default = Hub;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/traverse/lib/index.js
var require_lib13 = __commonJS((exports) => {
  var traverse = function(parent, opts = {}, scope, state, parentPath, visitSelf) {
    if (!parent)
      return;
    if (!opts.noScope && !scope) {
      if (parent.type !== "Program" && parent.type !== "File") {
        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");
      }
    }
    if (!parentPath && visitSelf) {
      throw new Error("visitSelf can only be used when providing a NodePath.");
    }
    if (!VISITOR_KEYS[parent.type]) {
      return;
    }
    visitors.explode(opts);
    (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
  };
  var hasDenylistedType = function(path3, state) {
    if (path3.node.type === state.type) {
      state.has = true;
      path3.stop();
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "Hub", {
    enumerable: true,
    get: function() {
      return _hub.default;
    }
  });
  Object.defineProperty(exports, "NodePath", {
    enumerable: true,
    get: function() {
      return _index.default;
    }
  });
  Object.defineProperty(exports, "Scope", {
    enumerable: true,
    get: function() {
      return _index2.default;
    }
  });
  exports.visitors = exports.default = undefined;
  var visitors = require_visitors();
  exports.visitors = visitors;
  var _t = require_lib3();
  var cache = require_cache();
  var _traverseNode = require_traverse_node();
  var _index = require_path();
  var _index2 = require_scope();
  var _hub = require_hub();
  var {
    VISITOR_KEYS,
    removeProperties,
    traverseFast
  } = _t;
  var _default = exports.default = traverse;
  traverse.visitors = visitors;
  traverse.verify = visitors.verify;
  traverse.explode = visitors.explode;
  traverse.cheap = function(node2, enter) {
    traverseFast(node2, enter);
    return;
  };
  traverse.node = function(node2, opts, scope, state, path3, skipKeys) {
    (0, _traverseNode.traverseNode)(node2, opts, scope, state, path3, skipKeys);
  };
  traverse.clearNode = function(node2, opts) {
    removeProperties(node2, opts);
  };
  traverse.removeProperties = function(tree, opts) {
    traverseFast(tree, traverse.clearNode, opts);
    return tree;
  };
  traverse.hasType = function(tree, type, denylistTypes) {
    if (denylistTypes != null && denylistTypes.includes(tree.type))
      return false;
    if (tree.type === type)
      return true;
    const state = {
      has: false,
      type
    };
    traverse(tree, {
      noScope: true,
      denylist: denylistTypes,
      enter: hasDenylistedType
    }, null, state);
    return state.has;
  };
  traverse.cache = cache;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helpers/lib/helpers-generated.js
var require_helpers_generated = __commonJS((exports) => {
  var helper = function(minVersion, source) {
    return Object.freeze({
      minVersion,
      ast: () => _template.default.program.ast(source, {
        preserveComments: true
      })
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _template = require_lib11();
  var _default = exports.default = Object.freeze({
    AsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};'),
    OverloadYield: helper("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"),
    applyDecs: helper("7.17.8", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}'),
    applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'),
    applyDecs2203R: helper("7.20.0", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'),
    applyDecs2301: helper("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'),
    applyDecs2305: helper("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";export default function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v,g=t[0],b=t[3],w=!u;if(!w){r||Array.isArray(g)||(g=[g]);var S={},A=[],P=3===o?"get":4===o||d?"set":"value";f?(p||d?S={get:setFunctionName((function(){return b(this)}),n,"get"),set:function(e){t[4](this,e)}}:S[P]=b,p||setFunctionName(S[P],n,2===o?"":P)):p||(S=Object.getOwnPropertyDescriptor(e,n))}for(var j=g.length-1;j>=0;j-=r?2:1){var D=g[j],E=r?g[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(w)v=D.call(E,e,O);else{var k,F;O.static=l,O.private=f,f||!p&&2!==o?2===o?k=function(e){return m(e),S.value}:((o<2||3===o)&&(k=i(S,"get",f&&m)),(o<2||4===o)&&(F=i(S,"set",f&&m))):(k=function(e){return e[n]},p&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),v=D.call(E,d?{get:S.get,set:S.set}:S[P],O),d){if("object"==typeof v&&v)(y=s(v.get,"accessor.get"))&&(S.get=y),(y=s(v.set,"accessor.set"))&&(S.set=y),(y=s(v.init,"accessor.init"))&&A.push(y);else if(void 0!==v)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(v,(p?"field":"method")+" decorators","return")&&(p?A.push(v):S[P]=v)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=A.length-1;r>=0;r--)t=A[r].call(e,t);return t})),p||w||(f?d?u.push(i(S,"get"),i(S,"set")):u.push(2===o?S[P]:i.call.bind(S[P])):Object.defineProperty(e,n,S)),v}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(s(applyDec(e,[r],n,e.name,5,f,t),"class decorators","return")||e,f),c.bind(null,t,e)]}}}'),
    asyncGeneratorDelegate: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}'),
    asyncIterator: helper("7.15.9", 'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}'),
    awaitAsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}'),
    checkInRHS: helper("7.20.5", 'export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}'),
    defineAccessor: helper("7.20.7", "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}"),
    dispose: helper("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=r,this.error=e,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}export default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(r,e):r,s=!0,next()}return next()}'),
    importDeferProxy: helper("7.23.0", "export default function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}"),
    interopRequireWildcard: helper("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}export default function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}'),
    iterableToArrayLimit: helper("7.0.0-beta.0", 'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'),
    iterableToArrayLimitLoose: helper("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'),
    jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=new Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}'),
    objectSpread2: helper("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}'),
    regeneratorRuntime: helper("7.18.0", 'export default function _regeneratorRuntime(){"use strict";\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a \'"+n+"\' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}'),
    setFunctionName: helper("7.23.6", 'export default function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}'),
    toPrimitive: helper("7.1.5", 'export default function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}'),
    toPropertyKey: helper("7.1.5", 'import toPrimitive from"toPrimitive";export default function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:String(i)}'),
    typeof: helper("7.0.0-beta.0", 'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}'),
    using: helper("7.22.0", 'export default function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}'),
    wrapRegExp: helper("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=new RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}')
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helpers/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _template = require_lib11();
  var _helpersGenerated = require_helpers_generated();
  var helpers = Object.assign({
    __proto__: null
  }, _helpersGenerated.default);
  var _default = exports.default = helpers;
  var helper = (minVersion) => (tpl) => ({
    minVersion,
    ast: () => _template.default.program.ast(tpl)
  });
  {
    helpers.AwaitValue = helper("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `;
  }
  helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
  helpers.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`;
  helpers.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`;
  helpers.createClass = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`;
  helpers.defineEnumerableProperties = helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`;
  helpers.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
  helpers.defineProperty = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
  helpers.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;
  {
    helpers.objectSpread = helper("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `;
  }
  helpers.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
  helpers.inheritsLoose = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
  helpers.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
  helpers.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`;
  helpers.isNativeReflectConstruct = helper("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`;
  helpers.construct = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`;
  helpers.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      // Firefox 31 throws when "toString" is applied to an HTMLElement
      return typeof fn === "function";
    }
  }
`;
  helpers.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
  helpers.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
  helpers.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
  helpers.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`;
  helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`;
  helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`;
  helpers.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`;
  helpers.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`;
  helpers.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`;
  helpers.createSuper = helper("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `;
  helpers.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
  helpers.get = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`;
  helpers.set = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`;
  helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
  helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
  helpers.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`;
  helpers.writeOnlyError = helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`;
  helpers.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`;
  helpers.temporalUndefined = helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`;
  helpers.tdz = helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`;
  helpers.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
  helpers.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
  helpers.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
  helpers.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
  helpers.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
  helpers.arrayWithoutHoles = helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
  helpers.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
  helpers.maybeArrayLike = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`;
  helpers.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`;
  helpers.unsupportedIterableToArray = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`;
  helpers.arrayLikeToArray = helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
  helpers.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
  helpers.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
  helpers.createForOfIteratorHelper = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
  helpers.createForOfIteratorHelperLoose = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`;
  helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
  helpers.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`;
  helpers.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
  helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`;
  helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`;
  helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`;
  helpers.classPrivateFieldGet = helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
  helpers.classPrivateFieldSet = helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
  helpers.classPrivateFieldDestructureSet = helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
  helpers.classExtractFieldDescriptor = helper("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`;
  helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
  helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
  helpers.classStaticPrivateMethodGet = helper("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`;
  helpers.classStaticPrivateMethodSet = helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`;
  helpers.classApplyDescriptorGet = helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`;
  helpers.classApplyDescriptorSet = helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`;
  helpers.classApplyDescriptorDestructureSet = helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`;
  helpers.classStaticPrivateFieldDestructureSet = helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
  helpers.classCheckPrivateStaticAccess = helper("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`;
  helpers.classCheckPrivateStaticFieldDescriptor = helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`;
  helpers.decorate = helper("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`;
  helpers.classPrivateMethodGet = helper("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`;
  helpers.checkPrivateRedeclaration = helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`;
  helpers.classPrivateFieldInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
  helpers.classPrivateMethodInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;
  {
    helpers.classPrivateMethodSet = helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
  }
  helpers.identity = helper("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
  helpers.nullishReceiverError = helper("7.22.6")`
  export default function _nullishReceiverError(r) {
    throw new TypeError("Cannot set property of null or undefined.");
  }
`;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helpers/lib/index.js
var require_lib14 = __commonJS((exports) => {
  var makePath = function(path3) {
    const parts = [];
    for (;path3.parentPath; path3 = path3.parentPath) {
      parts.push(path3.key);
      if (path3.inList)
        parts.push(path3.listKey);
    }
    return parts.reverse().join(".");
  };
  var getHelperMetadata = function(file2) {
    const globals = new Set;
    const localBindingNames = new Set;
    const dependencies = new Map;
    let exportName;
    let exportPath;
    const exportBindingAssignments = [];
    const importPaths = [];
    const importBindingsReferences = [];
    const dependencyVisitor = {
      ImportDeclaration(child) {
        const name = child.node.source.value;
        if (!_helpers.default[name]) {
          throw child.buildCodeFrameError(`Unknown helper ${name}`);
        }
        if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
          throw child.buildCodeFrameError("Helpers can only import a default value");
        }
        const bindingIdentifier = child.node.specifiers[0].local;
        dependencies.set(bindingIdentifier, name);
        importPaths.push(makePath(child));
      },
      ExportDefaultDeclaration(child) {
        const decl = child.get("declaration");
        if (!decl.isFunctionDeclaration() || !decl.node.id) {
          throw decl.buildCodeFrameError("Helpers can only export named function declarations");
        }
        exportName = decl.node.id.name;
        exportPath = makePath(child);
      },
      ExportAllDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      ExportNamedDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      Statement(child) {
        if (child.isImportDeclaration() || child.isExportDeclaration())
          return;
        child.skip();
      }
    };
    const referenceVisitor = {
      Program(path3) {
        const bindings = path3.scope.getAllBindings();
        Object.keys(bindings).forEach((name) => {
          if (name === exportName)
            return;
          if (dependencies.has(bindings[name].identifier))
            return;
          localBindingNames.add(name);
        });
      },
      ReferencedIdentifier(child) {
        const name = child.node.name;
        const binding = child.scope.getBinding(name);
        if (!binding) {
          globals.add(name);
        } else if (dependencies.has(binding.identifier)) {
          importBindingsReferences.push(makePath(child));
        }
      },
      AssignmentExpression(child) {
        const left2 = child.get("left");
        if (!(exportName in left2.getBindingIdentifiers()))
          return;
        if (!left2.isIdentifier()) {
          throw left2.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
        }
        const binding = child.scope.getBinding(exportName);
        if (binding != null && binding.scope.path.isProgram()) {
          exportBindingAssignments.push(makePath(child));
        }
      }
    };
    (0, _traverse.default)(file2.ast, dependencyVisitor, file2.scope);
    (0, _traverse.default)(file2.ast, referenceVisitor, file2.scope);
    if (!exportPath)
      throw new Error("Helpers must have a default export.");
    exportBindingAssignments.reverse();
    return {
      globals: Array.from(globals),
      localBindingNames: Array.from(localBindingNames),
      dependencies,
      exportBindingAssignments,
      exportPath,
      exportName,
      importBindingsReferences,
      importPaths
    };
  };
  var permuteHelperAST = function(file2, metadata, id, localBindings, getDependency) {
    if (localBindings && !id) {
      throw new Error("Unexpected local bindings for module-based helpers.");
    }
    if (!id)
      return;
    const {
      localBindingNames,
      dependencies,
      exportBindingAssignments,
      exportPath,
      exportName,
      importBindingsReferences,
      importPaths
    } = metadata;
    const dependenciesRefs = {};
    dependencies.forEach((name, id2) => {
      dependenciesRefs[id2.name] = typeof getDependency === "function" && getDependency(name) || id2;
    });
    const toRename = {};
    const bindings = new Set(localBindings || []);
    if (id.type === "Identifier")
      bindings.add(id.name);
    localBindingNames.forEach((name) => {
      let newName = name;
      while (bindings.has(newName))
        newName = "_" + newName;
      if (newName !== name)
        toRename[name] = newName;
    });
    if (id.type === "Identifier" && exportName !== id.name) {
      toRename[exportName] = id.name;
    }
    const {
      path: path3
    } = file2;
    const exp = path3.get(exportPath);
    const imps = importPaths.map((p) => path3.get(p));
    const impsBindingRefs = importBindingsReferences.map((p) => path3.get(p));
    const decl = exp.get("declaration");
    if (id.type === "Identifier") {
      exp.replaceWith(decl);
    } else if (id.type === "MemberExpression") {
      exportBindingAssignments.forEach((assignPath) => {
        const assign = path3.get(assignPath);
        assign.replaceWith(assignmentExpression("=", id, assign.node));
      });
      exp.replaceWith(decl);
      path3.pushContainer("body", expressionStatement(assignmentExpression("=", id, identifier(exportName))));
    } else {
      throw new Error("Unexpected helper format.");
    }
    Object.keys(toRename).forEach((name) => {
      path3.scope.rename(name, toRename[name]);
    });
    for (const path4 of imps)
      path4.remove();
    for (const path4 of impsBindingRefs) {
      const node2 = cloneNode(dependenciesRefs[path4.node.name]);
      path4.replaceWith(node2);
    }
  };
  var loadHelper = function(name) {
    if (!helperData[name]) {
      const helper = _helpers.default[name];
      if (!helper) {
        throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: name
        });
      }
      const fn = () => {
        {
          if (!FileClass) {
            const fakeFile = {
              ast: file(helper.ast()),
              path: null
            };
            (0, _traverse.default)(fakeFile.ast, {
              Program: (path3) => (fakeFile.path = path3).stop()
            });
            return fakeFile;
          }
        }
        return new FileClass({
          filename: `babel-helper://${name}`
        }, {
          ast: file(helper.ast()),
          code: "[internal Babel helper code]",
          inputMap: null
        });
      };
      let metadata = null;
      helperData[name] = {
        minVersion: helper.minVersion,
        build(getDependency, id, localBindings) {
          const file2 = fn();
          metadata || (metadata = getHelperMetadata(file2));
          permuteHelperAST(file2, metadata, id, localBindings, getDependency);
          return {
            nodes: file2.ast.program.body,
            globals: metadata.globals
          };
        },
        getDependencies() {
          metadata || (metadata = getHelperMetadata(fn()));
          return Array.from(metadata.dependencies.values());
        }
      };
    }
    return helperData[name];
  };
  var get = function(name, getDependency, id, localBindings) {
    return loadHelper(name).build(getDependency, id, localBindings);
  };
  var minVersion = function(name) {
    return loadHelper(name).minVersion;
  };
  var getDependencies = function(name) {
    return loadHelper(name).getDependencies();
  };
  var ensure = function(name, newFileClass) {
    FileClass || (FileClass = newFileClass);
    loadHelper(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.ensure = ensure;
  exports.get = get;
  exports.getDependencies = getDependencies;
  exports.list = undefined;
  exports.minVersion = minVersion;
  var _traverse = require_lib13();
  var _t = require_lib3();
  var _helpers = require_helpers();
  var {
    assignmentExpression,
    cloneNode,
    expressionStatement,
    file,
    identifier
  } = _t;
  var FileClass = undefined;
  var helperData = Object.create(null);
  var list = exports.list = Object.keys(_helpers.default).map((name) => name.replace(/^_/, ""));
  var _default = exports.default = get;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-imports/lib/import-builder.js
var require_import_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _assert = __require("assert");
  var _t = require_lib3();
  var {
    callExpression,
    cloneNode,
    expressionStatement,
    identifier,
    importDeclaration,
    importDefaultSpecifier,
    importNamespaceSpecifier,
    importSpecifier,
    memberExpression,
    stringLiteral,
    variableDeclaration,
    variableDeclarator
  } = _t;

  class ImportBuilder {
    constructor(importedSource, scope, hub) {
      this._statements = [];
      this._resultName = null;
      this._importedSource = undefined;
      this._scope = scope;
      this._hub = hub;
      this._importedSource = importedSource;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));
      return this;
    }
    require() {
      this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)])));
      return this;
    }
    namespace(name = "namespace") {
      const local = this._scope.generateUidIdentifier(name);
      const statement = this._statements[this._statements.length - 1];
      _assert(statement.type === "ImportDeclaration");
      _assert(statement.specifiers.length === 0);
      statement.specifiers = [importNamespaceSpecifier(local)];
      this._resultName = cloneNode(local);
      return this;
    }
    default(name) {
      const id = this._scope.generateUidIdentifier(name);
      const statement = this._statements[this._statements.length - 1];
      _assert(statement.type === "ImportDeclaration");
      _assert(statement.specifiers.length === 0);
      statement.specifiers = [importDefaultSpecifier(id)];
      this._resultName = cloneNode(id);
      return this;
    }
    named(name, importName) {
      if (importName === "default")
        return this.default(name);
      const id = this._scope.generateUidIdentifier(name);
      const statement = this._statements[this._statements.length - 1];
      _assert(statement.type === "ImportDeclaration");
      _assert(statement.specifiers.length === 0);
      statement.specifiers = [importSpecifier(id, identifier(importName))];
      this._resultName = cloneNode(id);
      return this;
    }
    var(name) {
      const id = this._scope.generateUidIdentifier(name);
      let statement = this._statements[this._statements.length - 1];
      if (statement.type !== "ExpressionStatement") {
        _assert(this._resultName);
        statement = expressionStatement(this._resultName);
        this._statements.push(statement);
      }
      this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(id, statement.expression)]);
      this._resultName = cloneNode(id);
      return this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(callee) {
      const statement = this._statements[this._statements.length - 1];
      if (statement.type === "ExpressionStatement") {
        statement.expression = callExpression(callee, [statement.expression]);
      } else if (statement.type === "VariableDeclaration") {
        _assert(statement.declarations.length === 1);
        statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);
      } else {
        _assert.fail("Unexpected type.");
      }
      return this;
    }
    prop(name) {
      const statement = this._statements[this._statements.length - 1];
      if (statement.type === "ExpressionStatement") {
        statement.expression = memberExpression(statement.expression, identifier(name));
      } else if (statement.type === "VariableDeclaration") {
        _assert(statement.declarations.length === 1);
        statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
      } else {
        _assert.fail("Unexpected type:" + statement.type);
      }
      return this;
    }
    read(name) {
      this._resultName = memberExpression(this._resultName, identifier(name));
    }
  }
  exports.default = ImportBuilder;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-imports/lib/is-module.js
var require_is_module = __commonJS((exports) => {
  var isModule = function(path3) {
    return path3.node.sourceType === "module";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isModule;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-imports/lib/import-injector.js
var require_import_injector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _assert = __require("assert");
  var _t = require_lib3();
  var _importBuilder = require_import_builder();
  var _isModule = require_is_module();
  var {
    numericLiteral,
    sequenceExpression
  } = _t;

  class ImportInjector {
    constructor(path3, importedSource, opts) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: false,
        ensureNoContext: false,
        importPosition: "before"
      };
      const programPath = path3.find((p) => p.isProgram());
      this._programPath = programPath;
      this._programScope = programPath.scope;
      this._hub = programPath.hub;
      this._defaultOpts = this._applyDefaults(importedSource, opts, true);
    }
    addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    }
    addNamed(importName, importedSourceIn, opts) {
      _assert(typeof importName === "string");
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    }
    addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    }
    addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), undefined);
    }
    _applyDefaults(importedSource, opts, isInit = false) {
      let newOpts;
      if (typeof importedSource === "string") {
        newOpts = Object.assign({}, this._defaultOpts, {
          importedSource
        }, opts);
      } else {
        _assert(!opts, "Unexpected secondary arguments.");
        newOpts = Object.assign({}, this._defaultOpts, importedSource);
      }
      if (!isInit && opts) {
        if (opts.nameHint !== undefined)
          newOpts.nameHint = opts.nameHint;
        if (opts.blockHoist !== undefined)
          newOpts.blockHoist = opts.blockHoist;
      }
      return newOpts;
    }
    _generateImport(opts, importName) {
      const isDefault = importName === "default";
      const isNamed = !!importName && !isDefault;
      const isNamespace = importName === null;
      const {
        importedSource,
        importedType,
        importedInterop,
        importingInterop,
        ensureLiveReference,
        ensureNoContext,
        nameHint,
        importPosition,
        blockHoist
      } = opts;
      let name = nameHint || importName;
      const isMod = (0, _isModule.default)(this._programPath);
      const isModuleForNode = isMod && importingInterop === "node";
      const isModuleForBabel = isMod && importingInterop === "babel";
      if (importPosition === "after" && !isMod) {
        throw new Error(`"importPosition": "after" is only supported in modules`);
      }
      const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
      if (importedType === "es6") {
        if (!isModuleForNode && !isModuleForBabel) {
          throw new Error("Cannot import an ES6 module from CommonJS");
        }
        builder.import();
        if (isNamespace) {
          builder.namespace(nameHint || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else if (importedType !== "commonjs") {
        throw new Error(`Unexpected interopType "${importedType}"`);
      } else if (importedInterop === "babel") {
        if (isModuleForNode) {
          name = name !== "default" ? name : importedSource;
          const es6Default = `${importedSource}\$es6Default`;
          builder.import();
          if (isNamespace) {
            builder.default(es6Default).var(name || importedSource).wildcardInterop();
          } else if (isDefault) {
            if (ensureLiveReference) {
              builder.default(es6Default).var(name || importedSource).defaultInterop().read("default");
            } else {
              builder.default(es6Default).var(name).defaultInterop().prop(importName);
            }
          } else if (isNamed) {
            builder.default(es6Default).read(importName);
          }
        } else if (isModuleForBabel) {
          builder.import();
          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();
          if (isNamespace) {
            builder.var(name || importedSource).wildcardInterop();
          } else if ((isDefault || isNamed) && ensureLiveReference) {
            if (isDefault) {
              name = name !== "default" ? name : importedSource;
              builder.var(name).read(importName);
              builder.defaultInterop();
            } else {
              builder.var(importedSource).read(importName);
            }
          } else if (isDefault) {
            builder.var(name).defaultInterop().prop(importName);
          } else if (isNamed) {
            builder.var(name).prop(importName);
          }
        }
      } else if (importedInterop === "compiled") {
        if (isModuleForNode) {
          builder.import();
          if (isNamespace) {
            builder.default(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.default(importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder.import();
          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();
          if (isNamespace) {
            builder.var(name || importedSource);
          } else if (isDefault || isNamed) {
            if (ensureLiveReference) {
              builder.var(importedSource).read(name);
            } else {
              builder.prop(importName).var(name);
            }
          }
        }
      } else if (importedInterop === "uncompiled") {
        if (isDefault && ensureLiveReference) {
          throw new Error("No live reference for commonjs default");
        }
        if (isModuleForNode) {
          builder.import();
          if (isNamespace) {
            builder.default(name || importedSource);
          } else if (isDefault) {
            builder.default(name);
          } else if (isNamed) {
            builder.default(importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder.import();
          if (isNamespace) {
            builder.default(name || importedSource);
          } else if (isDefault) {
            builder.default(name);
          } else if (isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();
          if (isNamespace) {
            builder.var(name || importedSource);
          } else if (isDefault) {
            builder.var(name);
          } else if (isNamed) {
            if (ensureLiveReference) {
              builder.var(importedSource).read(name);
            } else {
              builder.var(name).prop(importName);
            }
          }
        }
      } else {
        throw new Error(`Unknown importedInterop "${importedInterop}".`);
      }
      const {
        statements,
        resultName
      } = builder.done();
      this._insertStatements(statements, importPosition, blockHoist);
      if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
        return sequenceExpression([numericLiteral(0), resultName]);
      }
      return resultName;
    }
    _insertStatements(statements, importPosition = "before", blockHoist = 3) {
      const body = this._programPath.get("body");
      if (importPosition === "after") {
        for (let i = body.length - 1;i >= 0; i--) {
          if (body[i].isImportDeclaration()) {
            body[i].insertAfter(statements);
            return;
          }
        }
      } else {
        statements.forEach((node2) => {
          node2._blockHoist = blockHoist;
        });
        const targetPath = body.find((p) => {
          const val = p.node._blockHoist;
          return Number.isFinite(val) && val < 4;
        });
        if (targetPath) {
          targetPath.insertBefore(statements);
          return;
        }
      }
      this._programPath.unshiftContainer("body", statements);
    }
  }
  exports.default = ImportInjector;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-imports/lib/index.js
var require_lib15 = __commonJS((exports) => {
  var addDefault = function(path3, importedSource, opts) {
    return new _importInjector.default(path3).addDefault(importedSource, opts);
  };
  var addNamed = function(path3, name, importedSource, opts) {
    return new _importInjector.default(path3).addNamed(name, importedSource, opts);
  };
  var addNamespace = function(path3, importedSource, opts) {
    return new _importInjector.default(path3).addNamespace(importedSource, opts);
  };
  var addSideEffect = function(path3, importedSource, opts) {
    return new _importInjector.default(path3).addSideEffect(importedSource, opts);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ImportInjector", {
    enumerable: true,
    get: function() {
      return _importInjector.default;
    }
  });
  exports.addDefault = addDefault;
  exports.addNamed = addNamed;
  exports.addNamespace = addNamespace;
  exports.addSideEffect = addSideEffect;
  Object.defineProperty(exports, "isModule", {
    enumerable: true,
    get: function() {
      return _isModule.default;
    }
  });
  var _importInjector = require_import_injector();
  var _isModule = require_is_module();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var require_rewrite_this = __commonJS((exports) => {
  var rewriteThis = function(programPath) {
    (0, _core.traverse)(programPath.node, Object.assign({}, rewriteThisVisitor, {
      noScope: true
    }));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rewriteThis;
  var _helperEnvironmentVisitor = require_lib6();
  var _core = require_lib33();
  var {
    numericLiteral,
    unaryExpression
  } = _core.types;
  var rewriteThisVisitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {
    ThisExpression(path3) {
      path3.replaceWith(unaryExpression("void", numericLiteral(0), true));
    }
  }]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-simple-access/lib/index.js
var require_lib16 = __commonJS((exports) => {
  var simplifyAccess = function(path3, bindingNames) {
    {
      var _arguments$;
      path3.traverse(simpleAssignmentVisitor, {
        scope: path3.scope,
        bindingNames,
        seen: new WeakSet,
        includeUpdateExpression: (_arguments$ = arguments[2]) != null ? _arguments$ : true
      });
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = simplifyAccess;
  var _t = require_lib3();
  var {
    LOGICAL_OPERATORS,
    assignmentExpression,
    binaryExpression,
    cloneNode,
    identifier,
    logicalExpression,
    numericLiteral,
    sequenceExpression,
    unaryExpression
  } = _t;
  var simpleAssignmentVisitor = {
    AssignmentExpression: {
      exit(path3) {
        const {
          scope,
          seen,
          bindingNames
        } = this;
        if (path3.node.operator === "=")
          return;
        if (seen.has(path3.node))
          return;
        seen.add(path3.node);
        const left2 = path3.get("left");
        if (!left2.isIdentifier())
          return;
        const localName = left2.node.name;
        if (!bindingNames.has(localName))
          return;
        if (scope.getBinding(localName) !== path3.scope.getBinding(localName)) {
          return;
        }
        const operator = path3.node.operator.slice(0, -1);
        if (LOGICAL_OPERATORS.includes(operator)) {
          path3.replaceWith(logicalExpression(operator, path3.node.left, assignmentExpression("=", cloneNode(path3.node.left), path3.node.right)));
        } else {
          path3.node.right = binaryExpression(operator, cloneNode(path3.node.left), path3.node.right);
          path3.node.operator = "=";
        }
      }
    }
  };
  {
    simpleAssignmentVisitor.UpdateExpression = {
      exit(path3) {
        if (!this.includeUpdateExpression)
          return;
        const {
          scope,
          bindingNames
        } = this;
        const arg = path3.get("argument");
        if (!arg.isIdentifier())
          return;
        const localName = arg.node.name;
        if (!bindingNames.has(localName))
          return;
        if (scope.getBinding(localName) !== path3.scope.getBinding(localName)) {
          return;
        }
        if (path3.parentPath.isExpressionStatement() && !path3.isCompletionRecord()) {
          const operator = path3.node.operator == "++" ? "+=" : "-=";
          path3.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
        } else if (path3.node.prefix) {
          path3.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path3.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1))));
        } else {
          const old = path3.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
          const varName = old.name;
          path3.scope.push({
            id: old
          });
          const binary = binaryExpression(path3.node.operator[0], identifier(varName), numericLiteral(1));
          path3.replaceWith(sequenceExpression([assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName)]));
        }
      }
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var require_rewrite_live_references = __commonJS((exports) => {
  var isInType = function(path3) {
    do {
      switch (path3.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return true;
        case "ExportSpecifier":
          return path3.parentPath.parent.exportKind === "type";
        default:
          if (path3.parentPath.isStatement() || path3.parentPath.isExpression()) {
            return false;
          }
      }
    } while (path3 = path3.parentPath);
  };
  var rewriteLiveReferences = function(programPath, metadata, wrapReference) {
    const imported = new Map;
    const exported = new Map;
    const requeueInParent = (path3) => {
      programPath.requeue(path3);
    };
    for (const [source, data] of metadata.source) {
      for (const [localName, importName] of data.imports) {
        imported.set(localName, [source, importName, null]);
      }
      for (const localName of data.importsNamespace) {
        imported.set(localName, [source, null, localName]);
      }
    }
    for (const [local, data] of metadata.local) {
      let exportMeta = exported.get(local);
      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }
      exportMeta.push(...data.names);
    }
    const rewriteBindingInitVisitorState = {
      metadata,
      requeueInParent,
      scope: programPath.scope,
      exported
    };
    programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
    const bindingNames = new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]);
    {
      (0, _helperSimpleAccess.default)(programPath, bindingNames, false);
    }
    const rewriteReferencesVisitorState = {
      seen: new WeakSet,
      metadata,
      requeueInParent,
      scope: programPath.scope,
      imported,
      exported,
      buildImportReference([source, importName, localName], identNode) {
        const meta = metadata.source.get(source);
        meta.referenced = true;
        if (localName) {
          if (meta.wrap) {
            var _wrapReference;
            identNode = (_wrapReference = wrapReference(identNode, meta.wrap)) != null ? _wrapReference : identNode;
          }
          return identNode;
        }
        let namespace = identifier(meta.name);
        if (meta.wrap) {
          var _wrapReference2;
          namespace = (_wrapReference2 = wrapReference(namespace, meta.wrap)) != null ? _wrapReference2 : namespace;
        }
        if (importName === "default" && meta.interop === "node-default") {
          return namespace;
        }
        const computed = metadata.stringSpecifiers.has(importName);
        return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);
      }
    };
    programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rewriteLiveReferences;
  var _assert = __require("assert");
  var _core = require_lib33();
  var _helperSimpleAccess = require_lib16();
  var {
    assignmentExpression,
    cloneNode,
    expressionStatement,
    getOuterBindingIdentifiers,
    identifier,
    isArrowFunctionExpression,
    isClassExpression,
    isFunctionExpression,
    isIdentifier,
    isMemberExpression,
    isVariableDeclaration,
    jsxIdentifier,
    jsxMemberExpression,
    memberExpression,
    numericLiteral,
    sequenceExpression,
    stringLiteral,
    variableDeclaration,
    variableDeclarator
  } = _core.types;
  var rewriteBindingInitVisitor = {
    Scope(path3) {
      path3.skip();
    },
    ClassDeclaration(path3) {
      const {
        requeueInParent,
        exported,
        metadata
      } = this;
      const {
        id
      } = path3.node;
      if (!id)
        throw new Error("Expected class to have a name");
      const localName = id.name;
      const exportNames = exported.get(localName) || [];
      if (exportNames.length > 0) {
        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path3.scope));
        statement._blockHoist = path3.node._blockHoist;
        requeueInParent(path3.insertAfter(statement)[0]);
      }
    },
    VariableDeclaration(path3) {
      const {
        requeueInParent,
        exported,
        metadata
      } = this;
      const isVar = path3.node.kind === "var";
      for (const decl of path3.get("declarations")) {
        const {
          id
        } = decl.node;
        let {
          init
        } = decl.node;
        if (isIdentifier(id) && exported.has(id.name) && !isArrowFunctionExpression(init) && (!isFunctionExpression(init) || init.id) && (!isClassExpression(init) || init.id)) {
          if (!init) {
            if (isVar) {
              continue;
            } else {
              init = path3.scope.buildUndefinedNode();
            }
          }
          decl.node.init = buildBindingExportAssignmentExpression(metadata, exported.get(id.name), init, path3.scope);
          requeueInParent(decl.get("init"));
        } else {
          for (const localName of Object.keys(decl.getOuterBindingIdentifiers())) {
            if (exported.has(localName)) {
              const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exported.get(localName), identifier(localName), path3.scope));
              statement._blockHoist = path3.node._blockHoist;
              requeueInParent(path3.insertAfter(statement)[0]);
            }
          }
        }
      }
    }
  };
  var buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {
    const exportsObjectName = metadata.exportName;
    for (let currentScope = scope;currentScope != null; currentScope = currentScope.parent) {
      if (currentScope.hasOwnBinding(exportsObjectName)) {
        currentScope.rename(exportsObjectName);
      }
    }
    return (exportNames || []).reduce((expr, exportName) => {
      const {
        stringSpecifiers
      } = metadata;
      const computed = stringSpecifiers.has(exportName);
      return assignmentExpression("=", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
    }, localExpr);
  };
  var buildImportThrow = (localName) => {
    return _core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `;
  };
  var rewriteReferencesVisitor = {
    ReferencedIdentifier(path3) {
      const {
        seen,
        buildImportReference,
        scope,
        imported,
        requeueInParent
      } = this;
      if (seen.has(path3.node))
        return;
      seen.add(path3.node);
      const localName = path3.node.name;
      const importData = imported.get(localName);
      if (importData) {
        if (isInType(path3)) {
          throw path3.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        }
        const localBinding = path3.scope.getBinding(localName);
        const rootBinding = scope.getBinding(localName);
        if (rootBinding !== localBinding)
          return;
        const ref = buildImportReference(importData, path3.node);
        ref.loc = path3.node.loc;
        if ((path3.parentPath.isCallExpression({
          callee: path3.node
        }) || path3.parentPath.isOptionalCallExpression({
          callee: path3.node
        }) || path3.parentPath.isTaggedTemplateExpression({
          tag: path3.node
        })) && isMemberExpression(ref)) {
          path3.replaceWith(sequenceExpression([numericLiteral(0), ref]));
        } else if (path3.isJSXIdentifier() && isMemberExpression(ref)) {
          const {
            object,
            property: property2
          } = ref;
          path3.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property2.name)));
        } else {
          path3.replaceWith(ref);
        }
        requeueInParent(path3);
        path3.skip();
      }
    },
    UpdateExpression(path3) {
      const {
        scope,
        seen,
        imported,
        exported,
        requeueInParent,
        buildImportReference
      } = this;
      if (seen.has(path3.node))
        return;
      seen.add(path3.node);
      const arg = path3.get("argument");
      if (arg.isMemberExpression())
        return;
      const update = path3.node;
      if (arg.isIdentifier()) {
        const localName = arg.node.name;
        if (scope.getBinding(localName) !== path3.scope.getBinding(localName)) {
          return;
        }
        const exportedNames = exported.get(localName);
        const importData = imported.get(localName);
        if ((exportedNames == null ? undefined : exportedNames.length) > 0 || importData) {
          if (importData) {
            path3.replaceWith(assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
          } else if (update.prefix) {
            path3.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path3.scope));
          } else {
            const ref = scope.generateDeclaredUidIdentifier(localName);
            path3.replaceWith(sequenceExpression([assignmentExpression("=", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path3.scope), cloneNode(ref)]));
          }
        }
      }
      requeueInParent(path3);
      path3.skip();
    },
    AssignmentExpression: {
      exit(path3) {
        const {
          scope,
          seen,
          imported,
          exported,
          requeueInParent,
          buildImportReference
        } = this;
        if (seen.has(path3.node))
          return;
        seen.add(path3.node);
        const left2 = path3.get("left");
        if (left2.isMemberExpression())
          return;
        if (left2.isIdentifier()) {
          const localName = left2.node.name;
          if (scope.getBinding(localName) !== path3.scope.getBinding(localName)) {
            return;
          }
          const exportedNames = exported.get(localName);
          const importData = imported.get(localName);
          if ((exportedNames == null ? undefined : exportedNames.length) > 0 || importData) {
            _assert(path3.node.operator === "=", "Path was not simplified");
            const assignment = path3.node;
            if (importData) {
              assignment.left = buildImportReference(importData, left2.node);
              assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);
            }
            path3.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path3.scope));
            requeueInParent(path3);
          }
        } else {
          const ids = left2.getOuterBindingIdentifiers();
          const programScopeIds = Object.keys(ids).filter((localName) => scope.getBinding(localName) === path3.scope.getBinding(localName));
          const id = programScopeIds.find((localName) => imported.has(localName));
          if (id) {
            path3.node.right = sequenceExpression([path3.node.right, buildImportThrow(id)]);
          }
          const items = [];
          programScopeIds.forEach((localName) => {
            const exportedNames = exported.get(localName) || [];
            if (exportedNames.length > 0) {
              items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path3.scope));
            }
          });
          if (items.length > 0) {
            let node2 = sequenceExpression(items);
            if (path3.parentPath.isExpressionStatement()) {
              node2 = expressionStatement(node2);
              node2._blockHoist = path3.parentPath.node._blockHoist;
            }
            const statement = path3.insertAfter(node2)[0];
            requeueInParent(statement);
          }
        }
      }
    },
    "ForOfStatement|ForInStatement"(path3) {
      const {
        scope,
        node: node2
      } = path3;
      const {
        left: left2
      } = node2;
      const {
        exported,
        imported,
        scope: programScope
      } = this;
      if (!isVariableDeclaration(left2)) {
        let didTransformExport = false, importConstViolationName;
        const loopBodyScope = path3.get("body").scope;
        for (const name of Object.keys(getOuterBindingIdentifiers(left2))) {
          if (programScope.getBinding(name) === scope.getBinding(name)) {
            if (exported.has(name)) {
              didTransformExport = true;
              if (loopBodyScope.hasOwnBinding(name)) {
                loopBodyScope.rename(name);
              }
            }
            if (imported.has(name) && !importConstViolationName) {
              importConstViolationName = name;
            }
          }
        }
        if (!didTransformExport && !importConstViolationName) {
          return;
        }
        path3.ensureBlock();
        const bodyPath = path3.get("body");
        const newLoopId = scope.generateUidIdentifierBasedOnNode(left2);
        path3.get("left").replaceWith(variableDeclaration("let", [variableDeclarator(cloneNode(newLoopId))]));
        scope.registerDeclaration(path3.get("left"));
        if (didTransformExport) {
          bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left2, newLoopId)));
        }
        if (importConstViolationName) {
          bodyPath.unshiftContainer("body", expressionStatement(buildImportThrow(importConstViolationName)));
        }
      }
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var require_normalize_and_load_metadata = __commonJS((exports) => {
  var hasExports = function(metadata) {
    return metadata.hasExports;
  };
  var isSideEffectImport = function(source) {
    return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
  };
  var validateImportInteropOption = function(importInterop) {
    if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
    }
    return importInterop;
  };
  var resolveImportInterop = function(importInterop, source, filename) {
    if (typeof importInterop === "function") {
      return validateImportInteropOption(importInterop(source, filename));
    }
    return importInterop;
  };
  var normalizeModuleAndLoadMetadata = function(programPath, exportName, {
    importInterop,
    initializeReexports = false,
    getWrapperPayload,
    esNamespaceOnly = false,
    filename
  }) {
    if (!exportName) {
      exportName = programPath.scope.generateUidIdentifier("exports").name;
    }
    const stringSpecifiers = new Set;
    nameAnonymousExports(programPath);
    const {
      local,
      sources,
      hasExports: hasExports2
    } = getModuleMetadata(programPath, {
      initializeReexports,
      getWrapperPayload
    }, stringSpecifiers);
    removeImportExportDeclarations(programPath);
    for (const [source, metadata] of sources) {
      const {
        importsNamespace,
        imports
      } = metadata;
      if (importsNamespace.size > 0 && imports.size === 0) {
        const [nameOfnamespace] = importsNamespace;
        metadata.name = nameOfnamespace;
      }
      const resolvedInterop = resolveImportInterop(importInterop, source, filename);
      if (resolvedInterop === "none") {
        metadata.interop = "none";
      } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
        metadata.interop = "node-namespace";
      } else if (resolvedInterop === "node" && metadata.interop === "default") {
        metadata.interop = "node-default";
      } else if (esNamespaceOnly && metadata.interop === "namespace") {
        metadata.interop = "default";
      }
    }
    return {
      exportName,
      exportNameListName: null,
      hasExports: hasExports2,
      local,
      source: sources,
      stringSpecifiers
    };
  };
  var getExportSpecifierName = function(path3, stringSpecifiers) {
    if (path3.isIdentifier()) {
      return path3.node.name;
    } else if (path3.isStringLiteral()) {
      const stringValue = path3.node.value;
      if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
        stringSpecifiers.add(stringValue);
      }
      return stringValue;
    } else {
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path3.node.type}`);
    }
  };
  var assertExportSpecifier = function(path3) {
    if (path3.isExportSpecifier()) {
      return;
    } else if (path3.isExportNamespaceSpecifier()) {
      throw path3.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
    } else {
      throw path3.buildCodeFrameError("Unexpected export specifier type");
    }
  };
  var getModuleMetadata = function(programPath, {
    getWrapperPayload,
    initializeReexports
  }, stringSpecifiers) {
    const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
    const importNodes = new Map;
    const sourceData = new Map;
    const getData = (sourceNode, node2) => {
      const source = sourceNode.value;
      let data = sourceData.get(source);
      if (!data) {
        data = {
          name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
          interop: "none",
          loc: null,
          imports: new Map,
          importsNamespace: new Set,
          reexports: new Map,
          reexportNamespace: new Set,
          reexportAll: null,
          wrap: null,
          get lazy() {
            return this.wrap === "lazy";
          },
          referenced: false
        };
        sourceData.set(source, data);
        importNodes.set(source, [node2]);
      } else {
        importNodes.get(source).push(node2);
      }
      return data;
    };
    let hasExports2 = false;
    programPath.get("body").forEach((child) => {
      if (child.isImportDeclaration()) {
        const data = getData(child.node.source, child.node);
        if (!data.loc)
          data.loc = child.node.loc;
        child.get("specifiers").forEach((spec) => {
          if (spec.isImportDefaultSpecifier()) {
            const localName = spec.get("local").node.name;
            data.imports.set(localName, "default");
            const reexport = localData.get(localName);
            if (reexport) {
              localData.delete(localName);
              reexport.names.forEach((name) => {
                data.reexports.set(name, "default");
              });
              data.referenced = true;
            }
          } else if (spec.isImportNamespaceSpecifier()) {
            const localName = spec.get("local").node.name;
            data.importsNamespace.add(localName);
            const reexport = localData.get(localName);
            if (reexport) {
              localData.delete(localName);
              reexport.names.forEach((name) => {
                data.reexportNamespace.add(name);
              });
              data.referenced = true;
            }
          } else if (spec.isImportSpecifier()) {
            const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
            const localName = spec.get("local").node.name;
            data.imports.set(localName, importName);
            const reexport = localData.get(localName);
            if (reexport) {
              localData.delete(localName);
              reexport.names.forEach((name) => {
                data.reexports.set(name, importName);
              });
              data.referenced = true;
            }
          }
        });
      } else if (child.isExportAllDeclaration()) {
        hasExports2 = true;
        const data = getData(child.node.source, child.node);
        if (!data.loc)
          data.loc = child.node.loc;
        data.reexportAll = {
          loc: child.node.loc
        };
        data.referenced = true;
      } else if (child.isExportNamedDeclaration() && child.node.source) {
        hasExports2 = true;
        const data = getData(child.node.source, child.node);
        if (!data.loc)
          data.loc = child.node.loc;
        child.get("specifiers").forEach((spec) => {
          assertExportSpecifier(spec);
          const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
          const exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
          data.reexports.set(exportName, importName);
          data.referenced = true;
          if (exportName === "__esModule") {
            throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
          }
        });
      } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
        hasExports2 = true;
      }
    });
    for (const metadata of sourceData.values()) {
      let needsDefault = false;
      let needsNamed = false;
      if (metadata.importsNamespace.size > 0) {
        needsDefault = true;
        needsNamed = true;
      }
      if (metadata.reexportAll) {
        needsNamed = true;
      }
      for (const importName of metadata.imports.values()) {
        if (importName === "default")
          needsDefault = true;
        else
          needsNamed = true;
      }
      for (const importName of metadata.reexports.values()) {
        if (importName === "default")
          needsDefault = true;
        else
          needsNamed = true;
      }
      if (needsDefault && needsNamed) {
        metadata.interop = "namespace";
      } else if (needsDefault) {
        metadata.interop = "default";
      }
    }
    if (getWrapperPayload) {
      for (const [source, metadata] of sourceData) {
        metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
      }
    }
    return {
      hasExports: hasExports2,
      local: localData,
      sources: sourceData
    };
  };
  var getLocalExportMetadata = function(programPath, initializeReexports, stringSpecifiers) {
    const bindingKindLookup = new Map;
    programPath.get("body").forEach((child) => {
      let kind;
      if (child.isImportDeclaration()) {
        kind = "import";
      } else {
        if (child.isExportDefaultDeclaration()) {
          child = child.get("declaration");
        }
        if (child.isExportNamedDeclaration()) {
          if (child.node.declaration) {
            child = child.get("declaration");
          } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
            child.get("specifiers").forEach((spec) => {
              assertExportSpecifier(spec);
              bindingKindLookup.set(spec.get("local").node.name, "block");
            });
            return;
          }
        }
        if (child.isFunctionDeclaration()) {
          kind = "hoisted";
        } else if (child.isClassDeclaration()) {
          kind = "block";
        } else if (child.isVariableDeclaration({
          kind: "var"
        })) {
          kind = "var";
        } else if (child.isVariableDeclaration()) {
          kind = "block";
        } else {
          return;
        }
      }
      Object.keys(child.getOuterBindingIdentifiers()).forEach((name) => {
        bindingKindLookup.set(name, kind);
      });
    });
    const localMetadata = new Map;
    const getLocalMetadata = (idPath) => {
      const localName = idPath.node.name;
      let metadata = localMetadata.get(localName);
      if (!metadata) {
        const kind = bindingKindLookup.get(localName);
        if (kind === undefined) {
          throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
        }
        metadata = {
          names: [],
          kind
        };
        localMetadata.set(localName, metadata);
      }
      return metadata;
    };
    programPath.get("body").forEach((child) => {
      if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
        if (child.node.declaration) {
          const declaration = child.get("declaration");
          const ids = declaration.getOuterBindingIdentifierPaths();
          Object.keys(ids).forEach((name) => {
            if (name === "__esModule") {
              throw declaration.buildCodeFrameError('Illegal export "__esModule".');
            }
            getLocalMetadata(ids[name]).names.push(name);
          });
        } else {
          child.get("specifiers").forEach((spec) => {
            const local = spec.get("local");
            const exported = spec.get("exported");
            const localMetadata2 = getLocalMetadata(local);
            const exportName = getExportSpecifierName(exported, stringSpecifiers);
            if (exportName === "__esModule") {
              throw exported.buildCodeFrameError('Illegal export "__esModule".');
            }
            localMetadata2.names.push(exportName);
          });
        }
      } else if (child.isExportDefaultDeclaration()) {
        const declaration = child.get("declaration");
        if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
          getLocalMetadata(declaration.get("id")).names.push("default");
        } else {
          throw declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      }
    });
    return localMetadata;
  };
  var nameAnonymousExports = function(programPath) {
    programPath.get("body").forEach((child) => {
      if (!child.isExportDefaultDeclaration())
        return;
      (0, _helperSplitExportDeclaration.default)(child);
    });
  };
  var removeImportExportDeclarations = function(programPath) {
    programPath.get("body").forEach((child) => {
      if (child.isImportDeclaration()) {
        child.remove();
      } else if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child.node.declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(child.node.declaration);
        } else {
          child.remove();
        }
      } else if (child.isExportDefaultDeclaration()) {
        const declaration = child.get("declaration");
        if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
          declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(declaration);
        } else {
          throw declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      } else if (child.isExportAllDeclaration()) {
        child.remove();
      }
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeModuleAndLoadMetadata;
  exports.hasExports = hasExports;
  exports.isSideEffectImport = isSideEffectImport;
  exports.validateImportInteropOption = validateImportInteropOption;
  var _path = __require("path");
  var _helperValidatorIdentifier = require_lib();
  var _helperSplitExportDeclaration = require_lib5();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var require_lazy_modules = __commonJS((exports) => {
  var toGetWrapperPayload = function(lazy) {
    return (source, metadata) => {
      if (lazy === false)
        return null;
      if ((0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata) || metadata.reexportAll)
        return null;
      if (lazy === true) {
        return /\./.test(source) ? null : "lazy";
      }
      if (Array.isArray(lazy)) {
        return lazy.indexOf(source) === -1 ? null : "lazy";
      }
      if (typeof lazy === "function") {
        return lazy(source) ? "lazy" : null;
      }
      throw new Error(`.lazy must be a boolean, string array, or function`);
    };
  };
  var wrapReference = function(ref, payload) {
    if (payload === "lazy")
      return _core.types.callExpression(ref, []);
    return null;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toGetWrapperPayload = toGetWrapperPayload;
  exports.wrapReference = wrapReference;
  var _core = require_lib33();
  var _normalizeAndLoadMetadata = require_normalize_and_load_metadata();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var require_dynamic_import = __commonJS((exports) => {
  var buildDynamicImport = function(node2, deferToThen, wrapWithPromise, builder) {
    const specifier = _core.types.isCallExpression(node2) ? node2.arguments[0] : node2.source;
    if (_core.types.isStringLiteral(specifier) || _core.types.isTemplateLiteral(specifier) && specifier.quasis.length === 0) {
      if (deferToThen) {
        return _core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `;
      } else
        return builder(specifier);
    }
    const specifierToString = _core.types.isTemplateLiteral(specifier) ? _core.types.identifier("specifier") : _core.types.templateLiteral([_core.types.templateElement({
      raw: ""
    }), _core.types.templateElement({
      raw: ""
    })], [_core.types.identifier("specifier")]);
    if (deferToThen) {
      return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier("s"))})
      )(${specifier})
    `;
    } else if (wrapWithPromise) {
      return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    `;
    } else {
      return _core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildDynamicImport = buildDynamicImport;
  var _core = require_lib33();
  {
    exports.getDynamicImportSource = function getDynamicImportSource(node2) {
      const [source] = node2.arguments;
      return _core.types.isStringLiteral(source) || _core.types.isTemplateLiteral(source) ? source : _core.template.expression.ast`\`\${${source}}\``;
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var require_get_module_name = __commonJS((exports) => {
  var getModuleName = function(rootOpts, pluginOpts) {
    const {
      filename,
      filenameRelative = filename,
      sourceRoot = pluginOpts.moduleRoot
    } = rootOpts;
    const {
      moduleId,
      moduleIds = !!moduleId,
      getModuleId,
      moduleRoot = sourceRoot
    } = pluginOpts;
    if (!moduleIds)
      return null;
    if (moduleId != null && !getModuleId) {
      return moduleId;
    }
    let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
    if (filenameRelative) {
      const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
      moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
    }
    moduleName = moduleName.replace(/\\/g, "/");
    if (getModuleId) {
      return getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getModuleName;
  {
    const originalGetModuleName = getModuleName;
    exports.default = getModuleName = function getModuleName(rootOpts, pluginOpts) {
      var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
      return originalGetModuleName(rootOpts, {
        moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
        moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
        getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
        moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
      });
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-module-transforms/lib/index.js
var require_lib17 = __commonJS((exports) => {
  var rewriteModuleStatementsAndPrepareHeader = function(path3, {
    exportName,
    strict,
    allowTopLevelThis,
    strictMode,
    noInterop,
    importInterop = noInterop ? "none" : "babel",
    lazy,
    getWrapperPayload = Lazy.toGetWrapperPayload(lazy != null ? lazy : false),
    wrapReference = Lazy.wrapReference,
    esNamespaceOnly,
    filename,
    constantReexports = arguments[1].loose,
    enumerableModuleMeta = arguments[1].loose,
    noIncompleteNsImportDetection
  }) {
    (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);
    _assert((0, _helperModuleImports.isModule)(path3), "Cannot process module statements in a script");
    path3.node.sourceType = "script";
    const meta = (0, _normalizeAndLoadMetadata.default)(path3, exportName, {
      importInterop,
      initializeReexports: constantReexports,
      getWrapperPayload,
      esNamespaceOnly,
      filename
    });
    if (!allowTopLevelThis) {
      (0, _rewriteThis.default)(path3);
    }
    (0, _rewriteLiveReferences.default)(path3, meta, wrapReference);
    if (strictMode !== false) {
      const hasStrict = path3.node.directives.some((directive2) => {
        return directive2.value.value === "use strict";
      });
      if (!hasStrict) {
        path3.unshiftContainer("directives", directive(directiveLiteral("use strict")));
      }
    }
    const headers = [];
    if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
      headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
    }
    const nameList = buildExportNameListDeclaration(path3, meta);
    if (nameList) {
      meta.exportNameListName = nameList.name;
      headers.push(nameList.statement);
    }
    headers.push(...buildExportInitializationStatements(path3, meta, wrapReference, constantReexports, noIncompleteNsImportDetection));
    return {
      meta,
      headers
    };
  };
  var ensureStatementsHoisted = function(statements) {
    statements.forEach((header) => {
      header._blockHoist = 3;
    });
  };
  var wrapInterop = function(programPath, expr, type) {
    if (type === "none") {
      return null;
    }
    if (type === "node-namespace") {
      return callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, booleanLiteral(true)]);
    } else if (type === "node-default") {
      return null;
    }
    let helper;
    if (type === "default") {
      helper = "interopRequireDefault";
    } else if (type === "namespace") {
      helper = "interopRequireWildcard";
    } else {
      throw new Error(`Unknown interop: ${type}`);
    }
    return callExpression(programPath.hub.addHelper(helper), [expr]);
  };
  var buildNamespaceInitStatements = function(metadata, sourceMetadata, constantReexports = false, wrapReference = Lazy.wrapReference) {
    var _wrapReference;
    const statements = [];
    const srcNamespaceId = identifier(sourceMetadata.name);
    for (const localName of sourceMetadata.importsNamespace) {
      if (localName === sourceMetadata.name)
        continue;
      statements.push(_core.template.statement`var NAME = SOURCE;`({
        NAME: localName,
        SOURCE: cloneNode(srcNamespaceId)
      }));
    }
    const srcNamespace = (_wrapReference = wrapReference(srcNamespaceId, sourceMetadata.wrap)) != null ? _wrapReference : srcNamespaceId;
    if (constantReexports) {
      statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference));
    }
    for (const exportName of sourceMetadata.reexportNamespace) {
      statements.push((!_core.types.isIdentifier(srcNamespace) ? _core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _core.template.statement`EXPORTS.NAME = NAMESPACE;`)({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: cloneNode(srcNamespace)
      }));
    }
    if (sourceMetadata.reexportAll) {
      const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);
      statement.loc = sourceMetadata.reexportAll.loc;
      statements.push(statement);
    }
    return statements;
  };
  var buildReexportsFromMeta = function(meta, metadata, constantReexports, wrapReference) {
    var _wrapReference2;
    let namespace = identifier(metadata.name);
    namespace = (_wrapReference2 = wrapReference(namespace, metadata.wrap)) != null ? _wrapReference2 : namespace;
    const {
      stringSpecifiers
    } = meta;
    return Array.from(metadata.reexports, ([exportName, importName]) => {
      let NAMESPACE_IMPORT = cloneNode(namespace);
      if (importName === "default" && metadata.interop === "node-default") {
      } else if (stringSpecifiers.has(importName)) {
        NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);
      } else {
        NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));
      }
      const astNodes = {
        EXPORTS: meta.exportName,
        EXPORT_NAME: exportName,
        NAMESPACE_IMPORT
      };
      if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {
        if (stringSpecifiers.has(exportName)) {
          return ReexportTemplate.constantComputed(astNodes);
        } else {
          return ReexportTemplate.constant(astNodes);
        }
      } else {
        return ReexportTemplate.spec(astNodes);
      }
    });
  };
  var buildESModuleHeader = function(metadata, enumerableModuleMeta = false) {
    return (enumerableModuleMeta ? _core.template.statement`
        EXPORTS.__esModule = true;
      ` : _core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
      EXPORTS: metadata.exportName
    });
  };
  var buildNamespaceReexport = function(metadata, namespace, constantReexports) {
    return (constantReexports ? _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
      NAMESPACE: namespace,
      EXPORTS: metadata.exportName,
      VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _core.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
        EXPORTS_LIST: metadata.exportNameListName
      }) : null
    });
  };
  var buildExportNameListDeclaration = function(programPath, metadata) {
    const exportedVars = Object.create(null);
    for (const data of metadata.local.values()) {
      for (const name2 of data.names) {
        exportedVars[name2] = true;
      }
    }
    let hasReexport = false;
    for (const data of metadata.source.values()) {
      for (const exportName of data.reexports.keys()) {
        exportedVars[exportName] = true;
      }
      for (const exportName of data.reexportNamespace) {
        exportedVars[exportName] = true;
      }
      hasReexport = hasReexport || !!data.reexportAll;
    }
    if (!hasReexport || Object.keys(exportedVars).length === 0)
      return null;
    const name = programPath.scope.generateUidIdentifier("exportNames");
    delete exportedVars.default;
    return {
      name: name.name,
      statement: variableDeclaration("var", [variableDeclarator(name, valueToNode(exportedVars))])
    };
  };
  var buildExportInitializationStatements = function(programPath, metadata, wrapReference, constantReexports = false, noIncompleteNsImportDetection = false) {
    const initStatements = [];
    for (const [localName, data] of metadata.local) {
      if (data.kind === "import") {
      } else if (data.kind === "hoisted") {
        initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);
      } else if (!noIncompleteNsImportDetection) {
        for (const exportName of data.names) {
          initStatements.push([exportName, null]);
        }
      }
    }
    for (const data of metadata.source.values()) {
      if (!constantReexports) {
        const reexportsStatements = buildReexportsFromMeta(metadata, data, false, wrapReference);
        const reexports = [...data.reexports.keys()];
        for (let i = 0;i < reexportsStatements.length; i++) {
          initStatements.push([reexports[i], reexportsStatements[i]]);
        }
      }
      if (!noIncompleteNsImportDetection) {
        for (const exportName of data.reexportNamespace) {
          initStatements.push([exportName, null]);
        }
      }
    }
    initStatements.sort(([a], [b]) => {
      if (a < b)
        return -1;
      if (b < a)
        return 1;
      return 0;
    });
    const results = [];
    if (noIncompleteNsImportDetection) {
      for (const [, initStatement] of initStatements) {
        results.push(initStatement);
      }
    } else {
      const chunkSize = 100;
      for (let i = 0;i < initStatements.length; i += chunkSize) {
        let uninitializedExportNames = [];
        for (let j = 0;j < chunkSize && i + j < initStatements.length; j++) {
          const [exportName, initStatement] = initStatements[i + j];
          if (initStatement !== null) {
            if (uninitializedExportNames.length > 0) {
              results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
              uninitializedExportNames = [];
            }
            results.push(initStatement);
          } else {
            uninitializedExportNames.push(exportName);
          }
        }
        if (uninitializedExportNames.length > 0) {
          results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
        }
      }
    }
    return results;
  };
  var buildInitStatement = function(metadata, exportNames, initExpr) {
    const {
      stringSpecifiers,
      exportName: EXPORTS
    } = metadata;
    return expressionStatement(exportNames.reduce((acc, exportName) => {
      const params = {
        EXPORTS,
        NAME: exportName,
        VALUE: acc
      };
      if (exportName === "__proto__") {
        return InitTemplate.define(params);
      }
      if (stringSpecifiers.has(exportName)) {
        return InitTemplate.computed(params);
      }
      return InitTemplate.default(params);
    }, initExpr));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "buildDynamicImport", {
    enumerable: true,
    get: function() {
      return _dynamicImport.buildDynamicImport;
    }
  });
  exports.buildNamespaceInitStatements = buildNamespaceInitStatements;
  exports.ensureStatementsHoisted = ensureStatementsHoisted;
  Object.defineProperty(exports, "getModuleName", {
    enumerable: true,
    get: function() {
      return _getModuleName.default;
    }
  });
  Object.defineProperty(exports, "hasExports", {
    enumerable: true,
    get: function() {
      return _normalizeAndLoadMetadata.hasExports;
    }
  });
  Object.defineProperty(exports, "isModule", {
    enumerable: true,
    get: function() {
      return _helperModuleImports.isModule;
    }
  });
  Object.defineProperty(exports, "isSideEffectImport", {
    enumerable: true,
    get: function() {
      return _normalizeAndLoadMetadata.isSideEffectImport;
    }
  });
  exports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
  Object.defineProperty(exports, "rewriteThis", {
    enumerable: true,
    get: function() {
      return _rewriteThis.default;
    }
  });
  exports.wrapInterop = wrapInterop;
  var _assert = __require("assert");
  var _core = require_lib33();
  var _helperModuleImports = require_lib15();
  var _rewriteThis = require_rewrite_this();
  var _rewriteLiveReferences = require_rewrite_live_references();
  var _normalizeAndLoadMetadata = require_normalize_and_load_metadata();
  var Lazy = require_lazy_modules();
  var _dynamicImport = require_dynamic_import();
  var _getModuleName = require_get_module_name();
  var {
    booleanLiteral,
    callExpression,
    cloneNode,
    directive,
    directiveLiteral,
    expressionStatement,
    identifier,
    isIdentifier,
    memberExpression,
    stringLiteral,
    valueToNode,
    variableDeclaration,
    variableDeclarator
  } = _core.types;
  {
    exports.getDynamicImportSource = require_dynamic_import().getDynamicImportSource;
  }
  var ReexportTemplate = {
    constant: _core.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,
    constantComputed: _core.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,
    spec: _core.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    `
  };
  var InitTemplate = {
    computed: _core.template.expression`EXPORTS["NAME"] = VALUE`,
    default: _core.template.expression`EXPORTS.NAME = VALUE`,
    define: _core.template.expression`Object.defineProperty(EXPORTS, "NAME", { enumerable:true, value: void 0, writable: true })["NAME"] = VALUE`
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/node_modules/semver/semver.js
var require_semver = __commonJS((exports, module) => {
  var tok = function(n) {
    t[n] = R++;
  };
  var makeSafeRe = function(value2) {
    for (var i2 = 0;i2 < safeRegexReplacements.length; i2++) {
      var token = safeRegexReplacements[i2][0];
      var max = safeRegexReplacements[i2][1];
      value2 = value2.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value2;
  };
  var parse2 = function(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  };
  var valid = function(version2, options) {
    var v = parse2(version2, options);
    return v ? v.version : null;
  };
  var clean = function(version2, options) {
    var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  var SemVer = function(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      if (version2.loose === options.loose) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: " + version2);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version2, options);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version2);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  };
  var inc = function(version2, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version2, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  var diff = function(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v12 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v12.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v12) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v12[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  var compareIdentifiers = function(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
  };
  var major = function(a, loose) {
    return new SemVer(a, loose).major;
  };
  var minor = function(a, loose) {
    return new SemVer(a, loose).minor;
  };
  var patch = function(a, loose) {
    return new SemVer(a, loose).patch;
  };
  var compare = function(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  };
  var compareLoose = function(a, b) {
    return compare(a, b, true);
  };
  var compareBuild = function(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  var rcompare = function(a, b, loose) {
    return compare(b, a, loose);
  };
  var sort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(a, b, loose);
    });
  };
  var rsort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(b, a, loose);
    });
  };
  var gt = function(a, b, loose) {
    return compare(a, b, loose) > 0;
  };
  var lt = function(a, b, loose) {
    return compare(a, b, loose) < 0;
  };
  var eq = function(a, b, loose) {
    return compare(a, b, loose) === 0;
  };
  var neq = function(a, b, loose) {
    return compare(a, b, loose) !== 0;
  };
  var gte = function(a, b, loose) {
    return compare(a, b, loose) >= 0;
  };
  var lte = function(a, b, loose) {
    return compare(a, b, loose) <= 0;
  };
  var cmp = function(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };
  var Comparator = function(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  };
  var Range = function(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  };
  var isSatisfiable = function(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var toComparators = function(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  };
  var parseComparator = function(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = function(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  };
  var replaceTildes = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  };
  var replaceTilde = function(comp, options) {
    var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  };
  var replaceCaret = function(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = function(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = function(comp, options) {
    comp = comp.trim();
    var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = function(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(safeRe[t.STAR], "");
  };
  var hyphenReplace = function($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  };
  var testSet = function(set, version2, options) {
    for (var i2 = 0;i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0;i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  var satisfies = function(version2, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  var maxSatisfying = function(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  var minSatisfying = function(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  var minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  var validRange = function(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  var ltr = function(version2, range, options) {
    return outside(version2, range, "<", options);
  };
  var gtr = function(version2, range, options) {
    return outside(version2, range, ">", options);
  };
  var outside = function(version2, range, hilo, options) {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  var prerelease = function(version2, options) {
    var parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  var intersects = function(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  };
  var coerce2 = function(version2, options) {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version2.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  };
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0;i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
      safeRe[i] = new RegExp(makeSafeRe(src[i]));
    }
  }
  var i;
  exports.parse = parse2;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    debug("Comparator.test", version2, this.options.loose);
    if (this.semver === ANY || version2 === ANY) {
      return true;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version2) {
    if (!version2) {
      return false;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0;i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version2, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/file/file.js
var require_file = __commonJS((exports) => {
  var helpers = function() {
    const data = require_lib14();
    helpers = function() {
      return data;
    };
    return data;
  };
  var _traverse = function() {
    const data = require_lib13();
    _traverse = function() {
      return data;
    };
    return data;
  };
  var _codeFrame = function() {
    const data = require_lib9();
    _codeFrame = function() {
      return data;
    };
    return data;
  };
  var _t = function() {
    const data = require_lib3();
    _t = function() {
      return data;
    };
    return data;
  };
  var _helperModuleTransforms = function() {
    const data = require_lib17();
    _helperModuleTransforms = function() {
      return data;
    };
    return data;
  };
  var _semver = function() {
    const data = require_semver();
    _semver = function() {
      return data;
    };
    return data;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var {
    cloneNode,
    interpreterDirective
  } = _t();
  var errorVisitor = {
    enter(path3, state) {
      const loc = path3.node.loc;
      if (loc) {
        state.loc = loc;
        path3.stop();
      }
    }
  };

  class File {
    constructor(options, {
      code,
      ast,
      inputMap
    }) {
      this._map = new Map;
      this.opts = undefined;
      this.declarations = {};
      this.path = undefined;
      this.ast = undefined;
      this.scope = undefined;
      this.metadata = {};
      this.code = "";
      this.inputMap = undefined;
      this.hub = {
        file: this,
        getCode: () => this.code,
        getScope: () => this.scope,
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      };
      this.opts = options;
      this.code = code;
      this.ast = ast;
      this.inputMap = inputMap;
      this.path = _traverse().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext();
      this.scope = this.path.scope;
    }
    get shebang() {
      const {
        interpreter
      } = this.path.node;
      return interpreter ? interpreter.value : "";
    }
    set shebang(value2) {
      if (value2) {
        this.path.get("interpreter").replaceWith(interpreterDirective(value2));
      } else {
        this.path.get("interpreter").remove();
      }
    }
    set(key, val) {
      if (key === "helpersNamespace") {
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      }
      this._map.set(key, val);
    }
    get(key) {
      return this._map.get(key);
    }
    has(key) {
      return this._map.has(key);
    }
    getModuleName() {
      return (0, _helperModuleTransforms().getModuleName)(this.opts, this.opts);
    }
    addImport() {
      throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
    }
    availableHelper(name, versionRange) {
      let minVersion;
      try {
        minVersion = helpers().minVersion(name);
      } catch (err) {
        if (err.code !== "BABEL_HELPER_UNKNOWN")
          throw err;
        return false;
      }
      if (typeof versionRange !== "string")
        return true;
      if (_semver().valid(versionRange))
        versionRange = `^${versionRange}`;
      return !_semver().intersects(`<${minVersion}`, versionRange) && !_semver().intersects(`>=8.0.0`, versionRange);
    }
    addHelper(name) {
      const declar = this.declarations[name];
      if (declar)
        return cloneNode(declar);
      const generator = this.get("helperGenerator");
      if (generator) {
        const res = generator(name);
        if (res)
          return res;
      }
      helpers().ensure(name, File);
      const uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
      const dependencies = {};
      for (const dep of helpers().getDependencies(name)) {
        dependencies[dep] = this.addHelper(dep);
      }
      const {
        nodes,
        globals
      } = helpers().get(name, (dep) => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));
      globals.forEach((name2) => {
        if (this.path.scope.hasBinding(name2, true)) {
          this.path.scope.rename(name2);
        }
      });
      nodes.forEach((node2) => {
        node2._compact = true;
      });
      this.path.unshiftContainer("body", nodes);
      this.path.get("body").forEach((path3) => {
        if (nodes.indexOf(path3.node) === -1)
          return;
        if (path3.isVariableDeclaration())
          this.scope.registerDeclaration(path3);
      });
      return uid;
    }
    addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    }
    buildCodeFrameError(node2, msg, _Error = SyntaxError) {
      let loc = node2 && (node2.loc || node2._loc);
      if (!loc && node2) {
        const state = {
          loc: null
        };
        (0, _traverse().default)(node2, errorVisitor, this.scope, state);
        loc = state.loc;
        let txt = "This is an error on an internal node. Probably an internal error.";
        if (loc)
          txt += " Location has been estimated.";
        msg += ` (${txt})`;
      }
      if (loc) {
        const {
          highlightCode = true
        } = this.opts;
        msg += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, {
          start: {
            line: loc.start.line,
            column: loc.start.column + 1
          },
          end: loc.end && loc.start.line === loc.end.line ? {
            line: loc.end.line,
            column: loc.end.column + 1
          } : undefined
        }, {
          highlightCode
        });
      }
      return new _Error(msg);
    }
  }
  exports.default = File;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/tools/build-external-helpers.js
var require_build_external_helpers = __commonJS((exports) => {
  var helpers = function() {
    const data = require_lib14();
    helpers = function() {
      return data;
    };
    return data;
  };
  var _generator = function() {
    const data = require_lib7();
    _generator = function() {
      return data;
    };
    return data;
  };
  var _template = function() {
    const data = require_lib11();
    _template = function() {
      return data;
    };
    return data;
  };
  var _t = function() {
    const data = require_lib3();
    _t = function() {
      return data;
    };
    return data;
  };
  var buildGlobal = function(allowlist) {
    const namespace = identifier("babelHelpers");
    const body = [];
    const container = functionExpression(null, [identifier("global")], blockStatement(body));
    const tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
    body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))]));
    buildHelpers(body, namespace, allowlist);
    return tree;
  };
  var buildModule = function(allowlist) {
    const body = [];
    const refs = buildHelpers(body, null, allowlist);
    body.unshift(exportNamedDeclaration(null, Object.keys(refs).map((name) => {
      return exportSpecifier(cloneNode(refs[name]), identifier(name));
    })));
    return program(body, [], "module");
  };
  var buildUmd = function(allowlist) {
    const namespace = identifier("babelHelpers");
    const body = [];
    body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))]));
    buildHelpers(body, namespace, allowlist);
    return program([buildUmdWrapper({
      FACTORY_PARAMETERS: identifier("global"),
      BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
      COMMON_ARGUMENTS: identifier("exports"),
      AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
      FACTORY_BODY: body,
      UMD_ROOT: identifier("this")
    })]);
  };
  var buildVar = function(allowlist) {
    const namespace = identifier("babelHelpers");
    const body = [];
    body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
    const tree = program(body);
    buildHelpers(body, namespace, allowlist);
    body.push(expressionStatement(namespace));
    return tree;
  };
  var buildHelpers = function(body, namespace, allowlist) {
    const getHelperReference = (name) => {
      return namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`);
    };
    const refs = {};
    helpers().list.forEach(function(name) {
      if (allowlist && allowlist.indexOf(name) < 0)
        return;
      const ref = refs[name] = getHelperReference(name);
      helpers().ensure(name, _file.default);
      const {
        nodes
      } = helpers().get(name, getHelperReference, ref);
      body.push(...nodes);
    });
    return refs;
  };
  var _default = function(allowlist, outputType = "global") {
    let tree;
    const build2 = {
      global: buildGlobal,
      module: buildModule,
      umd: buildUmd,
      var: buildVar
    }[outputType];
    if (build2) {
      tree = build2(allowlist);
    } else {
      throw new Error(`Unsupported output type ${outputType}`);
    }
    return (0, _generator().default)(tree).code;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _file = require_file();
  var {
    arrayExpression,
    assignmentExpression,
    binaryExpression,
    blockStatement,
    callExpression,
    cloneNode,
    conditionalExpression,
    exportNamedDeclaration,
    exportSpecifier,
    expressionStatement,
    functionExpression,
    identifier,
    memberExpression,
    objectExpression,
    program,
    stringLiteral,
    unaryExpression,
    variableDeclaration,
    variableDeclarator
  } = _t();
  var buildUmdWrapper = (replacements) => _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/gensync/index.js
var require_gensync = __commonJS((exports, module) => {
  var makeFunctionAPI = function(genFn) {
    const fns = {
      sync: function(...args) {
        return evaluateSync(genFn.apply(this, args));
      },
      async: function(...args) {
        return new Promise((resolve6, reject) => {
          evaluateAsync(genFn.apply(this, args), resolve6, reject);
        });
      },
      errback: function(...args) {
        const cb = args.pop();
        if (typeof cb !== "function") {
          throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
        }
        let gen;
        try {
          gen = genFn.apply(this, args);
        } catch (err) {
          cb(err);
          return;
        }
        evaluateAsync(gen, (val) => cb(undefined, val), (err) => cb(err));
      }
    };
    return fns;
  };
  var assertTypeof = function(type, name, value2, allowUndefined) {
    if (typeof value2 === type || allowUndefined && typeof value2 === "undefined") {
      return;
    }
    let msg;
    if (allowUndefined) {
      msg = `Expected opts.${name} to be either a ${type}, or undefined.`;
    } else {
      msg = `Expected opts.${name} to be a ${type}.`;
    }
    throw makeError(msg, GENSYNC_OPTIONS_ERROR);
  };
  var makeError = function(msg, code) {
    return Object.assign(new Error(msg), { code });
  };
  var newGenerator = function({ name, arity, sync: sync2, async, errback }) {
    assertTypeof("string", "name", name, true);
    assertTypeof("number", "arity", arity, true);
    assertTypeof("function", "sync", sync2);
    assertTypeof("function", "async", async, true);
    assertTypeof("function", "errback", errback, true);
    if (async && errback) {
      throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
    }
    if (typeof name !== "string") {
      let fnName;
      if (errback && errback.name && errback.name !== "errback") {
        fnName = errback.name;
      }
      if (async && async.name && async.name !== "async") {
        fnName = async.name.replace(/Async$/, "");
      }
      if (sync2 && sync2.name && sync2.name !== "sync") {
        fnName = sync2.name.replace(/Sync$/, "");
      }
      if (typeof fnName === "string") {
        name = fnName;
      }
    }
    if (typeof arity !== "number") {
      arity = sync2.length;
    }
    return buildOperation({
      name,
      arity,
      sync: function(args) {
        return sync2.apply(this, args);
      },
      async: function(args, resolve6, reject) {
        if (async) {
          async.apply(this, args).then(resolve6, reject);
        } else if (errback) {
          errback.call(this, ...args, (err, value2) => {
            if (err == null)
              resolve6(value2);
            else
              reject(err);
          });
        } else {
          resolve6(sync2.apply(this, args));
        }
      }
    });
  };
  var wrapGenerator = function(genFn) {
    return setFunctionMetadata(genFn.name, genFn.length, function(...args) {
      return genFn.apply(this, args);
    });
  };
  var buildOperation = function({ name, arity, sync: sync2, async }) {
    return setFunctionMetadata(name, arity, function* (...args) {
      const resume = yield GENSYNC_START;
      if (!resume) {
        const res = sync2.call(this, args);
        return res;
      }
      let result;
      try {
        async.call(this, args, (value2) => {
          if (result)
            return;
          result = { value: value2 };
          resume();
        }, (err) => {
          if (result)
            return;
          result = { err };
          resume();
        });
      } catch (err) {
        result = { err };
        resume();
      }
      yield GENSYNC_SUSPEND;
      if (result.hasOwnProperty("err")) {
        throw result.err;
      }
      return result.value;
    });
  };
  var evaluateSync = function(gen) {
    let value2;
    while (!({ value: value2 } = gen.next()).done) {
      assertStart(value2, gen);
    }
    return value2;
  };
  var evaluateAsync = function(gen, resolve6, reject) {
    (function step() {
      try {
        let value2;
        while (!({ value: value2 } = gen.next()).done) {
          assertStart(value2, gen);
          let sync2 = true;
          let didSyncResume = false;
          const out = gen.next(() => {
            if (sync2) {
              didSyncResume = true;
            } else {
              step();
            }
          });
          sync2 = false;
          assertSuspend(out, gen);
          if (!didSyncResume) {
            return;
          }
        }
        return resolve6(value2);
      } catch (err) {
        return reject(err);
      }
    })();
  };
  var assertStart = function(value2, gen) {
    if (value2 === GENSYNC_START)
      return;
    throwError(gen, makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(value2)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, GENSYNC_EXPECTED_START));
  };
  var assertSuspend = function({ value: value2, done }, gen) {
    if (!done && value2 === GENSYNC_SUSPEND)
      return;
    throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(value2)}. If you get this, it is probably a gensync bug.`, GENSYNC_EXPECTED_SUSPEND));
  };
  var throwError = function(gen, err) {
    if (gen.throw)
      gen.throw(err);
    throw err;
  };
  var setFunctionMetadata = function(name, arity, fn) {
    if (typeof name === "string") {
      const nameDesc = Object.getOwnPropertyDescriptor(fn, "name");
      if (!nameDesc || nameDesc.configurable) {
        Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
          configurable: true,
          value: name
        }));
      }
    }
    if (typeof arity === "number") {
      const lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");
      if (!lengthDesc || lengthDesc.configurable) {
        Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
          configurable: true,
          value: arity
        }));
      }
    }
    return fn;
  };
  var GENSYNC_START = Symbol.for("gensync:v1:start");
  var GENSYNC_SUSPEND = Symbol.for("gensync:v1:suspend");
  var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
  var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
  var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
  var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
  var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
  module.exports = Object.assign(function gensync(optsOrFn) {
    let genFn = optsOrFn;
    if (typeof optsOrFn !== "function") {
      genFn = newGenerator(optsOrFn);
    } else {
      genFn = wrapGenerator(optsOrFn);
    }
    return Object.assign(genFn, makeFunctionAPI(genFn));
  }, {
    all: buildOperation({
      name: "all",
      arity: 1,
      sync: function(args) {
        const items = Array.from(args[0]);
        return items.map((item) => evaluateSync(item));
      },
      async: function(args, resolve6, reject) {
        const items = Array.from(args[0]);
        if (items.length === 0) {
          Promise.resolve().then(() => resolve6([]));
          return;
        }
        let count = 0;
        const results = items.map(() => {
          return;
        });
        items.forEach((item, i) => {
          evaluateAsync(item, (val) => {
            results[i] = val;
            count += 1;
            if (count === results.length)
              resolve6(results);
          }, reject);
        });
      }
    }),
    race: buildOperation({
      name: "race",
      arity: 1,
      sync: function(args) {
        const items = Array.from(args[0]);
        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }
        return evaluateSync(items[0]);
      },
      async: function(args, resolve6, reject) {
        const items = Array.from(args[0]);
        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }
        for (const item of items) {
          evaluateAsync(item, resolve6, reject);
        }
      }
    })
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/gensync-utils/async.js
var require_async = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var asyncGeneratorStep = function(gen, resolve6, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value2 = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve6(value2);
    } else {
      Promise.resolve(value2).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve6, reject) {
        var gen = fn.apply(self2, args);
        function _next(value2) {
          asyncGeneratorStep(gen, resolve6, reject, _next, _throw, "next", value2);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve6, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  };
  var maybeAsync = function(fn, message) {
    return _gensync()({
      sync(...args) {
        const result = fn.apply(this, args);
        if (isThenable(result))
          throw new Error(message);
        return result;
      },
      async(...args) {
        return Promise.resolve(fn.apply(this, args));
      }
    });
  };
  var forwardAsync = function(action, cb) {
    const g = _gensync()(action);
    return withKind((kind) => {
      const adapted = g[kind];
      return cb(adapted);
    });
  };
  var isThenable = function(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.forwardAsync = forwardAsync;
  exports.isAsync = undefined;
  exports.isThenable = isThenable;
  exports.maybeAsync = maybeAsync;
  exports.waitFor = exports.onFirstPause = undefined;
  var runGenerator = _gensync()(function* (item) {
    return yield* item;
  });
  var isAsync2 = exports.isAsync = _gensync()({
    sync: () => false,
    errback: (cb) => cb(null, true)
  });
  var withKind = _gensync()({
    sync: (cb) => cb("sync"),
    async: function() {
      var _ref = _asyncToGenerator(function* (cb) {
        return cb("async");
      });
      return function async(_x) {
        return _ref.apply(this, arguments);
      };
    }()
  });
  var onFirstPause = exports.onFirstPause = _gensync()({
    name: "onFirstPause",
    arity: 2,
    sync: function(item) {
      return runGenerator.sync(item);
    },
    errback: function(item, firstPause, cb) {
      let completed = false;
      runGenerator.errback(item, (err, value2) => {
        completed = true;
        cb(err, value2);
      });
      if (!completed) {
        firstPause();
      }
    }
  });
  var waitFor = exports.waitFor = _gensync()({
    sync: (x) => x,
    async: function() {
      var _ref2 = _asyncToGenerator(function* (x) {
        return x;
      });
      return function async(_x2) {
        return _ref2.apply(this, arguments);
      };
    }()
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/util.js
var require_util2 = __commonJS((exports) => {
  var mergeOptions = function(target, source) {
    for (const k of Object.keys(source)) {
      if ((k === "parserOpts" || k === "generatorOpts" || k === "assumptions") && source[k]) {
        const parserOpts = source[k];
        const targetObj = target[k] || (target[k] = {});
        mergeDefaultFields(targetObj, parserOpts);
      } else {
        const val = source[k];
        if (val !== undefined)
          target[k] = val;
      }
    }
  };
  var mergeDefaultFields = function(target, source) {
    for (const k of Object.keys(source)) {
      const val = source[k];
      if (val !== undefined)
        target[k] = val;
    }
  };
  var isIterableIterator = function(value2) {
    return !!value2 && typeof value2.next === "function" && typeof value2[Symbol.iterator] === "function";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIterableIterator = isIterableIterator;
  exports.mergeOptions = mergeOptions;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/caching.js
var require_caching = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  function* genTrue() {
    return true;
  }
  var makeWeakCache = function(handler) {
    return makeCachedFunction(WeakMap, handler);
  };
  var makeWeakCacheSync = function(handler) {
    return synchronize(makeWeakCache(handler));
  };
  var makeStrongCache = function(handler) {
    return makeCachedFunction(Map, handler);
  };
  var makeStrongCacheSync = function(handler) {
    return synchronize(makeStrongCache(handler));
  };
  var makeCachedFunction = function(CallCache, handler) {
    const callCacheSync = new CallCache;
    const callCacheAsync = new CallCache;
    const futureCache = new CallCache;
    return function* cachedFunction(arg, data) {
      const asyncContext = yield* (0, _async.isAsync)();
      const callCache = asyncContext ? callCacheAsync : callCacheSync;
      const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);
      if (cached.valid)
        return cached.value;
      const cache = new CacheConfigurator(data);
      const handlerResult = handler(arg, cache);
      let finishLock;
      let value2;
      if ((0, _util.isIterableIterator)(handlerResult)) {
        value2 = yield* (0, _async.onFirstPause)(handlerResult, () => {
          finishLock = setupAsyncLocks(cache, futureCache, arg);
        });
      } else {
        value2 = handlerResult;
      }
      updateFunctionCache(callCache, cache, arg, value2);
      if (finishLock) {
        futureCache.delete(arg);
        finishLock.release(value2);
      }
      return value2;
    };
  };
  function* getCachedValue(cache, arg, data) {
    const cachedValue = cache.get(arg);
    if (cachedValue) {
      for (const {
        value: value2,
        valid
      } of cachedValue) {
        if (yield* valid(data))
          return {
            valid: true,
            value: value2
          };
      }
    }
    return {
      valid: false,
      value: null
    };
  }
  function* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
    const cached = yield* getCachedValue(callCache, arg, data);
    if (cached.valid) {
      return cached;
    }
    if (asyncContext) {
      const cached2 = yield* getCachedValue(futureCache, arg, data);
      if (cached2.valid) {
        const value2 = yield* (0, _async.waitFor)(cached2.value.promise);
        return {
          valid: true,
          value: value2
        };
      }
    }
    return {
      valid: false,
      value: null
    };
  }
  var setupAsyncLocks = function(config2, futureCache, arg) {
    const finishLock = new Lock;
    updateFunctionCache(futureCache, config2, arg, finishLock);
    return finishLock;
  };
  var updateFunctionCache = function(cache, config2, arg, value2) {
    if (!config2.configured())
      config2.forever();
    let cachedValue = cache.get(arg);
    config2.deactivate();
    switch (config2.mode()) {
      case "forever":
        cachedValue = [{
          value: value2,
          valid: genTrue
        }];
        cache.set(arg, cachedValue);
        break;
      case "invalidate":
        cachedValue = [{
          value: value2,
          valid: config2.validator()
        }];
        cache.set(arg, cachedValue);
        break;
      case "valid":
        if (cachedValue) {
          cachedValue.push({
            value: value2,
            valid: config2.validator()
          });
        } else {
          cachedValue = [{
            value: value2,
            valid: config2.validator()
          }];
          cache.set(arg, cachedValue);
        }
    }
  };
  var makeSimpleConfigurator = function(cache) {
    function cacheFn(val) {
      if (typeof val === "boolean") {
        if (val)
          cache.forever();
        else
          cache.never();
        return;
      }
      return cache.using(() => assertSimpleType(val()));
    }
    cacheFn.forever = () => cache.forever();
    cacheFn.never = () => cache.never();
    cacheFn.using = (cb) => cache.using(() => assertSimpleType(cb()));
    cacheFn.invalidate = (cb) => cache.invalidate(() => assertSimpleType(cb()));
    return cacheFn;
  };
  var assertSimpleType = function(value2) {
    if ((0, _async.isThenable)(value2)) {
      throw new Error(`You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.`);
    }
    if (value2 != null && typeof value2 !== "string" && typeof value2 !== "boolean" && typeof value2 !== "number") {
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    }
    return value2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertSimpleType = assertSimpleType;
  exports.makeStrongCache = makeStrongCache;
  exports.makeStrongCacheSync = makeStrongCacheSync;
  exports.makeWeakCache = makeWeakCache;
  exports.makeWeakCacheSync = makeWeakCacheSync;
  var _async = require_async();
  var _util = require_util2();
  var synchronize = (gen) => {
    return _gensync()(gen).sync;
  };

  class CacheConfigurator {
    constructor(data) {
      this._active = true;
      this._never = false;
      this._forever = false;
      this._invalidate = false;
      this._configured = false;
      this._pairs = [];
      this._data = undefined;
      this._data = data;
    }
    simple() {
      return makeSimpleConfigurator(this);
    }
    mode() {
      if (this._never)
        return "never";
      if (this._forever)
        return "forever";
      if (this._invalidate)
        return "invalidate";
      return "valid";
    }
    forever() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }
      if (this._never) {
        throw new Error("Caching has already been configured with .never()");
      }
      this._forever = true;
      this._configured = true;
    }
    never() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }
      if (this._forever) {
        throw new Error("Caching has already been configured with .forever()");
      }
      this._never = true;
      this._configured = true;
    }
    using(handler) {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }
      if (this._never || this._forever) {
        throw new Error("Caching has already been configured with .never or .forever()");
      }
      this._configured = true;
      const key = handler(this._data);
      const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);
      if ((0, _async.isThenable)(key)) {
        return key.then((key2) => {
          this._pairs.push([key2, fn]);
          return key2;
        });
      }
      this._pairs.push([key, fn]);
      return key;
    }
    invalidate(handler) {
      this._invalidate = true;
      return this.using(handler);
    }
    validator() {
      const pairs = this._pairs;
      return function* (data) {
        for (const [key, fn] of pairs) {
          if (key !== (yield* fn(data)))
            return false;
        }
        return true;
      };
    }
    deactivate() {
      this._active = false;
    }
    configured() {
      return this._configured;
    }
  }

  class Lock {
    constructor() {
      this.released = false;
      this.promise = undefined;
      this._resolve = undefined;
      this.promise = new Promise((resolve6) => {
        this._resolve = resolve6;
      });
    }
    release(value2) {
      this.released = true;
      this._resolve(value2);
    }
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/gensync-utils/fs.js
var require_fs = __commonJS((exports) => {
  var _fs = function() {
    const data = __require("fs");
    _fs = function() {
      return data;
    };
    return data;
  };
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.stat = exports.readFile = undefined;
  var readFile = exports.readFile = _gensync()({
    sync: _fs().readFileSync,
    errback: _fs().readFile
  });
  var stat = exports.stat = _gensync()({
    sync: _fs().statSync,
    errback: _fs().stat
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/utils.js
var require_utils2 = __commonJS((exports) => {
  var _fs2 = function() {
    const data = __require("fs");
    _fs2 = function() {
      return data;
    };
    return data;
  };
  var makeStaticFileCache = function(fn) {
    return (0, _caching.makeStrongCache)(function* (filepath, cache) {
      const cached = cache.invalidate(() => fileMtime(filepath));
      if (cached === null) {
        return null;
      }
      return fn(filepath, yield* fs3.readFile(filepath, "utf8"));
    });
  };
  var fileMtime = function(filepath) {
    if (!_fs2().existsSync(filepath))
      return null;
    try {
      return +_fs2().statSync(filepath).mtime;
    } catch (e) {
      if (e.code !== "ENOENT" && e.code !== "ENOTDIR")
        throw e;
    }
    return null;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.makeStaticFileCache = makeStaticFileCache;
  var _caching = require_caching();
  var fs3 = require_fs();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var require_rewrite_stack_trace = __commonJS((exports) => {
  var CallSite = function(filename) {
    return Object.create({
      isNative: () => false,
      isConstructor: () => false,
      isToplevel: () => true,
      getFileName: () => filename,
      getLineNumber: () => {
        return;
      },
      getColumnNumber: () => {
        return;
      },
      getFunctionName: () => {
        return;
      },
      getMethodName: () => {
        return;
      },
      getTypeName: () => {
        return;
      },
      toString: () => filename
    });
  };
  var injectVirtualStackFrame = function(error, filename) {
    if (!SUPPORTED)
      return;
    let frames = virtualFrames.get(error);
    if (!frames)
      virtualFrames.set(error, frames = []);
    frames.push(CallSite(filename));
    return error;
  };
  var expectedError = function(error) {
    if (!SUPPORTED)
      return;
    expectedErrors.add(error);
    return error;
  };
  var beginHiddenCallStack = function(fn) {
    if (!SUPPORTED)
      return fn;
    return Object.defineProperty(function(...args) {
      setupPrepareStackTrace();
      return fn(...args);
    }, "name", {
      value: STOP_HIDING
    });
  };
  var endHiddenCallStack = function(fn) {
    if (!SUPPORTED)
      return fn;
    return Object.defineProperty(function(...args) {
      return fn(...args);
    }, "name", {
      value: START_HIDING
    });
  };
  var setupPrepareStackTrace = function() {
    setupPrepareStackTrace = () => {
    };
    const {
      prepareStackTrace = defaultPrepareStackTrace
    } = Error;
    const MIN_STACK_TRACE_LIMIT = 50;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));
    Error.prepareStackTrace = function stackTraceRewriter(err, trace) {
      let newTrace = [];
      const isExpected = expectedErrors.has(err);
      let status = isExpected ? "hiding" : "unknown";
      for (let i = 0;i < trace.length; i++) {
        const name = trace[i].getFunctionName();
        if (name === START_HIDING) {
          status = "hiding";
        } else if (name === STOP_HIDING) {
          if (status === "hiding") {
            status = "showing";
            if (virtualFrames.has(err)) {
              newTrace.unshift(...virtualFrames.get(err));
            }
          } else if (status === "unknown") {
            newTrace = trace;
            break;
          }
        } else if (status !== "hiding") {
          newTrace.push(trace[i]);
        }
      }
      return prepareStackTrace(err, newTrace);
    };
  };
  var defaultPrepareStackTrace = function(err, trace) {
    if (trace.length === 0)
      return ErrorToString(err);
    return `${ErrorToString(err)}\n    at ${trace.join("\n    at ")}`;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.beginHiddenCallStack = beginHiddenCallStack;
  exports.endHiddenCallStack = endHiddenCallStack;
  exports.expectedError = expectedError;
  exports.injectVirtualStackFrame = injectVirtualStackFrame;
  var _Object$getOwnPropert;
  var ErrorToString = Function.call.bind(Error.prototype.toString);
  var SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? undefined : _Object$getOwnPropert.writable) === true;
  var START_HIDING = "startHiding - secret - don't use this - v1";
  var STOP_HIDING = "stopHiding - secret - don't use this - v1";
  var expectedErrors = new WeakSet;
  var virtualFrames = new WeakMap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/errors/config-error.js
var require_config_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rewriteStackTrace = require_rewrite_stack_trace();

  class ConfigError extends Error {
    constructor(message, filename) {
      super(message);
      (0, _rewriteStackTrace.expectedError)(this);
      if (filename)
        (0, _rewriteStackTrace.injectVirtualStackFrame)(this, filename);
    }
  }
  exports.default = ConfigError;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/package.js
var require_package = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  function* findPackageData(filepath) {
    let pkg = null;
    const directories = [];
    let isPackage = true;
    let dirname4 = _path().dirname(filepath);
    while (!pkg && _path().basename(dirname4) !== "node_modules") {
      directories.push(dirname4);
      pkg = yield* readConfigPackage(_path().join(dirname4, PACKAGE_FILENAME));
      const nextLoc = _path().dirname(dirname4);
      if (dirname4 === nextLoc) {
        isPackage = false;
        break;
      }
      dirname4 = nextLoc;
    }
    return {
      filepath,
      directories,
      pkg,
      isPackage
    };
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findPackageData = findPackageData;
  var _utils = require_utils2();
  var _configError = require_config_error();
  var PACKAGE_FILENAME = "package.json";
  var readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {
    let options;
    try {
      options = JSON.parse(content);
    } catch (err) {
      throw new _configError.default(`Error while parsing JSON - ${err.message}`, filepath);
    }
    if (!options)
      throw new Error(`${filepath}: No config detected`);
    if (typeof options !== "object") {
      throw new _configError.default(`Config returned typeof ${typeof options}`, filepath);
    }
    if (Array.isArray(options)) {
      throw new _configError.default(`Expected config object but found array`, filepath);
    }
    return {
      filepath,
      dirname: _path().dirname(filepath),
      options
    };
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/json5/lib/unicode.js
var require_unicode = __commonJS((exports, module) => {
  exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/json5/lib/util.js
var require_util3 = __commonJS((exports, module) => {
  var unicode = require_unicode();
  module.exports = {
    isSpaceSeparator(c) {
      return typeof c === "string" && unicode.Space_Separator.test(c);
    },
    isIdStartChar(c) {
      return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
    },
    isIdContinueChar(c) {
      return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
    },
    isDigit(c) {
      return typeof c === "string" && /[0-9]/.test(c);
    },
    isHexDigit(c) {
      return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/json5/lib/parse.js
var require_parse3 = __commonJS((exports, module) => {
  var internalize = function(holder, name, reviver) {
    const value2 = holder[name];
    if (value2 != null && typeof value2 === "object") {
      if (Array.isArray(value2)) {
        for (let i = 0;i < value2.length; i++) {
          const key2 = String(i);
          const replacement = internalize(value2, key2, reviver);
          if (replacement === undefined) {
            delete value2[key2];
          } else {
            Object.defineProperty(value2, key2, {
              value: replacement,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        }
      } else {
        for (const key2 in value2) {
          const replacement = internalize(value2, key2, reviver);
          if (replacement === undefined) {
            delete value2[key2];
          } else {
            Object.defineProperty(value2, key2, {
              value: replacement,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        }
      }
    }
    return reviver.call(holder, name, value2);
  };
  var lex = function() {
    lexState = "default";
    buffer = "";
    doubleQuote = false;
    sign = 1;
    for (;; ) {
      c = peek();
      const token2 = lexStates[lexState]();
      if (token2) {
        return token2;
      }
    }
  };
  var peek = function() {
    if (source[pos]) {
      return String.fromCodePoint(source.codePointAt(pos));
    }
  };
  var read = function() {
    const c2 = peek();
    if (c2 === "\n") {
      line++;
      column = 0;
    } else if (c2) {
      column += c2.length;
    } else {
      column++;
    }
    if (c2) {
      pos += c2.length;
    }
    return c2;
  };
  var newToken = function(type, value2) {
    return {
      type,
      value: value2,
      line,
      column
    };
  };
  var literal = function(s) {
    for (const c2 of s) {
      const p = peek();
      if (p !== c2) {
        throw invalidChar(read());
      }
      read();
    }
  };
  var escape2 = function() {
    const c2 = peek();
    switch (c2) {
      case "b":
        read();
        return "\b";
      case "f":
        read();
        return "\f";
      case "n":
        read();
        return "\n";
      case "r":
        read();
        return "\r";
      case "t":
        read();
        return "\t";
      case "v":
        read();
        return "\v";
      case "0":
        read();
        if (util2.isDigit(peek())) {
          throw invalidChar(read());
        }
        return "\0";
      case "x":
        read();
        return hexEscape();
      case "u":
        read();
        return unicodeEscape();
      case "\n":
      case "\u2028":
      case "\u2029":
        read();
        return "";
      case "\r":
        read();
        if (peek() === "\n") {
          read();
        }
        return "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw invalidChar(read());
      case undefined:
        throw invalidChar(read());
    }
    return read();
  };
  var hexEscape = function() {
    let buffer2 = "";
    let c2 = peek();
    if (!util2.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
    c2 = peek();
    if (!util2.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
    return String.fromCodePoint(parseInt(buffer2, 16));
  };
  var unicodeEscape = function() {
    let buffer2 = "";
    let count = 4;
    while (count-- > 0) {
      const c2 = peek();
      if (!util2.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
    }
    return String.fromCodePoint(parseInt(buffer2, 16));
  };
  var push = function() {
    let value2;
    switch (token.type) {
      case "punctuator":
        switch (token.value) {
          case "{":
            value2 = {};
            break;
          case "[":
            value2 = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        value2 = token.value;
        break;
    }
    if (root === undefined) {
      root = value2;
    } else {
      const parent = stack[stack.length - 1];
      if (Array.isArray(parent)) {
        parent.push(value2);
      } else {
        Object.defineProperty(parent, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    if (value2 !== null && typeof value2 === "object") {
      stack.push(value2);
      if (Array.isArray(value2)) {
        parseState = "beforeArrayValue";
      } else {
        parseState = "beforePropertyName";
      }
    } else {
      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
  };
  var pop = function() {
    stack.pop();
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  };
  var invalidChar = function(c2) {
    if (c2 === undefined) {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
  };
  var invalidEOF = function() {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  };
  var invalidIdentifier = function() {
    column -= 5;
    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
  };
  var separatorChar = function(c2) {
    console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
  };
  var formatChar = function(c2) {
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "\t": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (replacements[c2]) {
      return replacements[c2];
    }
    if (c2 < " ") {
      const hexString = c2.charCodeAt(0).toString(16);
      return "\\x" + ("00" + hexString).substring(hexString.length);
    }
    return c2;
  };
  var syntaxError = function(message) {
    const err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err;
  };
  var util2 = require_util3();
  var source;
  var parseState;
  var stack;
  var pos;
  var line;
  var column;
  var token;
  var key;
  var root;
  module.exports = function parse(text, reviver) {
    source = String(text);
    parseState = "start";
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = undefined;
    key = undefined;
    root = undefined;
    do {
      token = lex();
      parseStates[parseState]();
    } while (token.type !== "eof");
    if (typeof reviver === "function") {
      return internalize({ "": root }, "", reviver);
    }
    return root;
  };
  var lexState;
  var buffer;
  var doubleQuote;
  var sign;
  var c;
  var lexStates = {
    default() {
      switch (c) {
        case "\t":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          read();
          return;
        case "/":
          read();
          lexState = "comment";
          return;
        case undefined:
          read();
          return newToken("eof");
      }
      if (util2.isSpaceSeparator(c)) {
        read();
        return;
      }
      return lexStates[parseState]();
    },
    comment() {
      switch (c) {
        case "*":
          read();
          lexState = "multiLineComment";
          return;
        case "/":
          read();
          lexState = "singleLineComment";
          return;
      }
      throw invalidChar(read());
    },
    multiLineComment() {
      switch (c) {
        case "*":
          read();
          lexState = "multiLineCommentAsterisk";
          return;
        case undefined:
          throw invalidChar(read());
      }
      read();
    },
    multiLineCommentAsterisk() {
      switch (c) {
        case "*":
          read();
          return;
        case "/":
          read();
          lexState = "default";
          return;
        case undefined:
          throw invalidChar(read());
      }
      read();
      lexState = "multiLineComment";
    },
    singleLineComment() {
      switch (c) {
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          read();
          lexState = "default";
          return;
        case undefined:
          read();
          return newToken("eof");
      }
      read();
    },
    value() {
      switch (c) {
        case "{":
        case "[":
          return newToken("punctuator", read());
        case "n":
          read();
          literal("ull");
          return newToken("null", null);
        case "t":
          read();
          literal("rue");
          return newToken("boolean", true);
        case "f":
          read();
          literal("alse");
          return newToken("boolean", false);
        case "-":
        case "+":
          if (read() === "-") {
            sign = -1;
          }
          lexState = "sign";
          return;
        case ".":
          buffer = read();
          lexState = "decimalPointLeading";
          return;
        case "0":
          buffer = read();
          lexState = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          buffer = read();
          lexState = "decimalInteger";
          return;
        case "I":
          read();
          literal("nfinity");
          return newToken("numeric", Infinity);
        case "N":
          read();
          literal("aN");
          return newToken("numeric", NaN);
        case '"':
        case "'":
          doubleQuote = read() === '"';
          buffer = "";
          lexState = "string";
          return;
      }
      throw invalidChar(read());
    },
    identifierNameStartEscape() {
      if (c !== "u") {
        throw invalidChar(read());
      }
      read();
      const u = unicodeEscape();
      switch (u) {
        case "$":
        case "_":
          break;
        default:
          if (!util2.isIdStartChar(u)) {
            throw invalidIdentifier();
          }
          break;
      }
      buffer += u;
      lexState = "identifierName";
    },
    identifierName() {
      switch (c) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          buffer += read();
          return;
        case "\\":
          read();
          lexState = "identifierNameEscape";
          return;
      }
      if (util2.isIdContinueChar(c)) {
        buffer += read();
        return;
      }
      return newToken("identifier", buffer);
    },
    identifierNameEscape() {
      if (c !== "u") {
        throw invalidChar(read());
      }
      read();
      const u = unicodeEscape();
      switch (u) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!util2.isIdContinueChar(u)) {
            throw invalidIdentifier();
          }
          break;
      }
      buffer += u;
      lexState = "identifierName";
    },
    sign() {
      switch (c) {
        case ".":
          buffer = read();
          lexState = "decimalPointLeading";
          return;
        case "0":
          buffer = read();
          lexState = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          buffer = read();
          lexState = "decimalInteger";
          return;
        case "I":
          read();
          literal("nfinity");
          return newToken("numeric", sign * Infinity);
        case "N":
          read();
          literal("aN");
          return newToken("numeric", NaN);
      }
      throw invalidChar(read());
    },
    zero() {
      switch (c) {
        case ".":
          buffer += read();
          lexState = "decimalPoint";
          return;
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
        case "x":
        case "X":
          buffer += read();
          lexState = "hexadecimal";
          return;
      }
      return newToken("numeric", sign * 0);
    },
    decimalInteger() {
      switch (c) {
        case ".":
          buffer += read();
          lexState = "decimalPoint";
          return;
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
      }
      if (util2.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    },
    decimalPointLeading() {
      if (util2.isDigit(c)) {
        buffer += read();
        lexState = "decimalFraction";
        return;
      }
      throw invalidChar(read());
    },
    decimalPoint() {
      switch (c) {
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
      }
      if (util2.isDigit(c)) {
        buffer += read();
        lexState = "decimalFraction";
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    },
    decimalFraction() {
      switch (c) {
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
      }
      if (util2.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    },
    decimalExponent() {
      switch (c) {
        case "+":
        case "-":
          buffer += read();
          lexState = "decimalExponentSign";
          return;
      }
      if (util2.isDigit(c)) {
        buffer += read();
        lexState = "decimalExponentInteger";
        return;
      }
      throw invalidChar(read());
    },
    decimalExponentSign() {
      if (util2.isDigit(c)) {
        buffer += read();
        lexState = "decimalExponentInteger";
        return;
      }
      throw invalidChar(read());
    },
    decimalExponentInteger() {
      if (util2.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    },
    hexadecimal() {
      if (util2.isHexDigit(c)) {
        buffer += read();
        lexState = "hexadecimalInteger";
        return;
      }
      throw invalidChar(read());
    },
    hexadecimalInteger() {
      if (util2.isHexDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", sign * Number(buffer));
    },
    string() {
      switch (c) {
        case "\\":
          read();
          buffer += escape2();
          return;
        case '"':
          if (doubleQuote) {
            read();
            return newToken("string", buffer);
          }
          buffer += read();
          return;
        case "'":
          if (!doubleQuote) {
            read();
            return newToken("string", buffer);
          }
          buffer += read();
          return;
        case "\n":
        case "\r":
          throw invalidChar(read());
        case "\u2028":
        case "\u2029":
          separatorChar(c);
          break;
        case undefined:
          throw invalidChar(read());
      }
      buffer += read();
    },
    start() {
      switch (c) {
        case "{":
        case "[":
          return newToken("punctuator", read());
      }
      lexState = "value";
    },
    beforePropertyName() {
      switch (c) {
        case "$":
        case "_":
          buffer = read();
          lexState = "identifierName";
          return;
        case "\\":
          read();
          lexState = "identifierNameStartEscape";
          return;
        case "}":
          return newToken("punctuator", read());
        case '"':
        case "'":
          doubleQuote = read() === '"';
          lexState = "string";
          return;
      }
      if (util2.isIdStartChar(c)) {
        buffer += read();
        lexState = "identifierName";
        return;
      }
      throw invalidChar(read());
    },
    afterPropertyName() {
      if (c === ":") {
        return newToken("punctuator", read());
      }
      throw invalidChar(read());
    },
    beforePropertyValue() {
      lexState = "value";
    },
    afterPropertyValue() {
      switch (c) {
        case ",":
        case "}":
          return newToken("punctuator", read());
      }
      throw invalidChar(read());
    },
    beforeArrayValue() {
      if (c === "]") {
        return newToken("punctuator", read());
      }
      lexState = "value";
    },
    afterArrayValue() {
      switch (c) {
        case ",":
        case "]":
          return newToken("punctuator", read());
      }
      throw invalidChar(read());
    },
    end() {
      throw invalidChar(read());
    }
  };
  var parseStates = {
    start() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      push();
    },
    beforePropertyName() {
      switch (token.type) {
        case "identifier":
        case "string":
          key = token.value;
          parseState = "afterPropertyName";
          return;
        case "punctuator":
          pop();
          return;
        case "eof":
          throw invalidEOF();
      }
    },
    afterPropertyName() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      parseState = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      push();
    },
    beforeArrayValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      if (token.type === "punctuator" && token.value === "]") {
        pop();
        return;
      }
      push();
    },
    afterPropertyValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      switch (token.value) {
        case ",":
          parseState = "beforePropertyName";
          return;
        case "}":
          pop();
      }
    },
    afterArrayValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      switch (token.value) {
        case ",":
          parseState = "beforeArrayValue";
          return;
        case "]":
          pop();
      }
    },
    end() {
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/json5/lib/stringify.js
var require_stringify3 = __commonJS((exports, module) => {
  var util2 = require_util3();
  module.exports = function stringify(value2, replacer, space) {
    const stack = [];
    let indent = "";
    let propertyList;
    let replacerFunc;
    let gap = "";
    let quote;
    if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
      space = replacer.space;
      quote = replacer.quote;
      replacer = replacer.replacer;
    }
    if (typeof replacer === "function") {
      replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
      propertyList = [];
      for (const v of replacer) {
        let item;
        if (typeof v === "string") {
          item = v;
        } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
          item = String(v);
        }
        if (item !== undefined && propertyList.indexOf(item) < 0) {
          propertyList.push(item);
        }
      }
    }
    if (space instanceof Number) {
      space = Number(space);
    } else if (space instanceof String) {
      space = String(space);
    }
    if (typeof space === "number") {
      if (space > 0) {
        space = Math.min(10, Math.floor(space));
        gap = "          ".substr(0, space);
      }
    } else if (typeof space === "string") {
      gap = space.substr(0, 10);
    }
    return serializeProperty("", { "": value2 });
    function serializeProperty(key, holder) {
      let value3 = holder[key];
      if (value3 != null) {
        if (typeof value3.toJSON5 === "function") {
          value3 = value3.toJSON5(key);
        } else if (typeof value3.toJSON === "function") {
          value3 = value3.toJSON(key);
        }
      }
      if (replacerFunc) {
        value3 = replacerFunc.call(holder, key, value3);
      }
      if (value3 instanceof Number) {
        value3 = Number(value3);
      } else if (value3 instanceof String) {
        value3 = String(value3);
      } else if (value3 instanceof Boolean) {
        value3 = value3.valueOf();
      }
      switch (value3) {
        case null:
          return "null";
        case true:
          return "true";
        case false:
          return "false";
      }
      if (typeof value3 === "string") {
        return quoteString(value3, false);
      }
      if (typeof value3 === "number") {
        return String(value3);
      }
      if (typeof value3 === "object") {
        return Array.isArray(value3) ? serializeArray(value3) : serializeObject(value3);
      }
      return;
    }
    function quoteString(value3) {
      const quotes = {
        "'": 0.1,
        '"': 0.2
      };
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "\t": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      let product = "";
      for (let i = 0;i < value3.length; i++) {
        const c = value3[i];
        switch (c) {
          case "'":
          case '"':
            quotes[c]++;
            product += c;
            continue;
          case "\0":
            if (util2.isDigit(value3[i + 1])) {
              product += "\\x00";
              continue;
            }
        }
        if (replacements[c]) {
          product += replacements[c];
          continue;
        }
        if (c < " ") {
          let hexString = c.charCodeAt(0).toString(16);
          product += "\\x" + ("00" + hexString).substring(hexString.length);
          continue;
        }
        product += c;
      }
      const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
      product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
      return quoteChar + product + quoteChar;
    }
    function serializeObject(value3) {
      if (stack.indexOf(value3) >= 0) {
        throw TypeError("Converting circular structure to JSON5");
      }
      stack.push(value3);
      let stepback = indent;
      indent = indent + gap;
      let keys = propertyList || Object.keys(value3);
      let partial = [];
      for (const key of keys) {
        const propertyString = serializeProperty(key, value3);
        if (propertyString !== undefined) {
          let member = serializeKey(key) + ":";
          if (gap !== "") {
            member += " ";
          }
          member += propertyString;
          partial.push(member);
        }
      }
      let final;
      if (partial.length === 0) {
        final = "{}";
      } else {
        let properties;
        if (gap === "") {
          properties = partial.join(",");
          final = "{" + properties + "}";
        } else {
          let separator = ",\n" + indent;
          properties = partial.join(separator);
          final = "{\n" + indent + properties + ",\n" + stepback + "}";
        }
      }
      stack.pop();
      indent = stepback;
      return final;
    }
    function serializeKey(key) {
      if (key.length === 0) {
        return quoteString(key, true);
      }
      const firstChar = String.fromCodePoint(key.codePointAt(0));
      if (!util2.isIdStartChar(firstChar)) {
        return quoteString(key, true);
      }
      for (let i = firstChar.length;i < key.length; i++) {
        if (!util2.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
          return quoteString(key, true);
        }
      }
      return key;
    }
    function serializeArray(value3) {
      if (stack.indexOf(value3) >= 0) {
        throw TypeError("Converting circular structure to JSON5");
      }
      stack.push(value3);
      let stepback = indent;
      indent = indent + gap;
      let partial = [];
      for (let i = 0;i < value3.length; i++) {
        const propertyString = serializeProperty(String(i), value3);
        partial.push(propertyString !== undefined ? propertyString : "null");
      }
      let final;
      if (partial.length === 0) {
        final = "[]";
      } else {
        if (gap === "") {
          let properties = partial.join(",");
          final = "[" + properties + "]";
        } else {
          let separator = ",\n" + indent;
          let properties = partial.join(separator);
          final = "[\n" + indent + properties + ",\n" + stepback + "]";
        }
      }
      stack.pop();
      indent = stepback;
      return final;
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/json5/lib/index.js
var require_lib18 = __commonJS((exports, module) => {
  var parse2 = require_parse3();
  var stringify2 = require_stringify3();
  var JSON5 = {
    parse: parse2,
    stringify: stringify2
  };
  module.exports = JSON5;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/helpers/config-api.js
var require_config_api = __commonJS((exports) => {
  var _semver = function() {
    const data = require_semver();
    _semver = function() {
      return data;
    };
    return data;
  };
  var makeConfigAPI = function(cache) {
    const env2 = (value2) => cache.using((data) => {
      if (typeof value2 === "undefined")
        return data.envName;
      if (typeof value2 === "function") {
        return (0, _caching.assertSimpleType)(value2(data.envName));
      }
      return (Array.isArray(value2) ? value2 : [value2]).some((entry) => {
        if (typeof entry !== "string") {
          throw new Error("Unexpected non-string value");
        }
        return entry === data.envName;
      });
    });
    const caller = (cb) => cache.using((data) => (0, _caching.assertSimpleType)(cb(data.caller)));
    return {
      version: _index.version,
      cache: cache.simple(),
      env: env2,
      async: () => false,
      caller,
      assertVersion
    };
  };
  var makePresetAPI = function(cache, externalDependencies) {
    const targets = () => JSON.parse(cache.using((data) => JSON.stringify(data.targets)));
    const addExternalDependency = (ref) => {
      externalDependencies.push(ref);
    };
    return Object.assign({}, makeConfigAPI(cache), {
      targets,
      addExternalDependency
    });
  };
  var makePluginAPI = function(cache, externalDependencies) {
    const assumption = (name) => cache.using((data) => data.assumptions[name]);
    return Object.assign({}, makePresetAPI(cache, externalDependencies), {
      assumption
    });
  };
  var assertVersion = function(range) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }
      range = `^${range}.0.0-0`;
    }
    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }
    if (_semver().satisfies(_index.version, range))
      return;
    const limit = Error.stackTraceLimit;
    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }
    const err = new Error(`Requires Babel "${range}", but was loaded with "${_index.version}". ` + `If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }
    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: _index.version,
      range
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.makeConfigAPI = makeConfigAPI;
  exports.makePluginAPI = makePluginAPI;
  exports.makePresetAPI = makePresetAPI;
  var _index = require_lib33();
  var _caching = require_caching();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/preset-typescript/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@babel/preset-typescript",
    version: "7.23.3",
    description: "Babel preset for TypeScript.",
    repository: {
      type: "git",
      url: "https://github.com/babel/babel.git",
      directory: "packages/babel-preset-typescript"
    },
    license: "MIT",
    publishConfig: {
      access: "public"
    },
    main: "./lib/index.js",
    keywords: [
      "babel-preset",
      "typescript"
    ],
    dependencies: {
      "@babel/helper-plugin-utils": "^7.22.5",
      "@babel/helper-validator-option": "^7.22.15",
      "@babel/plugin-syntax-jsx": "^7.23.3",
      "@babel/plugin-transform-modules-commonjs": "^7.23.3",
      "@babel/plugin-transform-typescript": "^7.23.3"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0-0"
    },
    devDependencies: {
      "@babel/core": "^7.23.3",
      "@babel/helper-plugin-test-runner": "^7.22.5"
    },
    homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
    bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
    engines: {
      node: ">=6.9.0"
    },
    author: "The Babel Team (https://babel.dev/team)",
    type: "commonjs"
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-plugin-utils/lib/index.js
var require_lib19 = __commonJS((exports) => {
  var declare = function(builder) {
    return (api, options, dirname4) => {
      var _clonedApi2;
      let clonedApi;
      for (const name of Object.keys(apiPolyfills)) {
        var _clonedApi;
        if (api[name])
          continue;
        (_clonedApi = clonedApi) != null || (clonedApi = copyApiObject(api));
        clonedApi[name] = apiPolyfills[name](clonedApi);
      }
      return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname4);
    };
  };
  var copyApiObject = function(api) {
    let proto = null;
    if (typeof api.version === "string" && /^7\./.test(api.version)) {
      proto = Object.getPrototypeOf(api);
      if (proto && (!has(proto, "version") || !has(proto, "transform") || !has(proto, "template") || !has(proto, "types"))) {
        proto = null;
      }
    }
    return Object.assign({}, proto, api);
  };
  var has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var throwVersionError = function(range, version2) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }
      range = `^${range}.0.0-0`;
    }
    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }
    const limit = Error.stackTraceLimit;
    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }
    let err;
    if (version2.slice(0, 2) === "7.") {
      err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version2}". ` + `You'll need to update your @babel/core version.`);
    } else {
      err = new Error(`Requires Babel "${range}", but was loaded with "${version2}". ` + `If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    }
    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }
    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version2,
      range
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.declare = declare;
  exports.declarePreset = undefined;
  var apiPolyfills = {
    assertVersion: (api) => (range) => {
      throwVersionError(range, api.version);
    }
  };
  {
    Object.assign(apiPolyfills, {
      targets: () => () => {
        return {};
      },
      assumption: () => () => {
        return;
      }
    });
  }
  var declarePreset = declare;
  exports.declarePreset = declarePreset;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-syntax-typescript/lib/index.js
var require_lib20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _helperPluginUtils = require_lib19();
  {
    removePlugin = function(plugins, name) {
      const indices = [];
      plugins.forEach((plugin, i) => {
        const n = Array.isArray(plugin) ? plugin[0] : plugin;
        if (n === name) {
          indices.unshift(i);
        }
      });
      for (const i of indices) {
        plugins.splice(i, 1);
      }
    };
  }
  var removePlugin;
  var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
    api.assertVersion(7);
    const {
      disallowAmbiguousJSXLike,
      dts
    } = opts;
    {
      var {
        isTSX
      } = opts;
    }
    return {
      name: "syntax-typescript",
      manipulateOptions(opts2, parserOpts) {
        {
          const {
            plugins
          } = parserOpts;
          removePlugin(plugins, "flow");
          removePlugin(plugins, "jsx");
          plugins.push("objectRestSpread", "classProperties");
          if (isTSX) {
            plugins.push("jsx");
          }
        }
        parserOpts.plugins.push(["typescript", {
          disallowAmbiguousJSXLike,
          dts
        }]);
      }
    };
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-member-expression-to-functions/lib/index.js
var require_lib21 = __commonJS((exports) => {
  var _interopNamespace = function(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  };
  var willPathCastToBoolean = function(path3) {
    const maybeWrapped = path3;
    const {
      node: node2,
      parentPath
    } = maybeWrapped;
    if (parentPath.isLogicalExpression()) {
      const {
        operator,
        right: right2
      } = parentPath.node;
      if (operator === "&&" || operator === "||" || operator === "??" && node2 === right2) {
        return willPathCastToBoolean(parentPath);
      }
    }
    if (parentPath.isSequenceExpression()) {
      const {
        expressions
      } = parentPath.node;
      if (expressions[expressions.length - 1] === node2) {
        return willPathCastToBoolean(parentPath);
      } else {
        return true;
      }
    }
    return parentPath.isConditional({
      test: node2
    }) || parentPath.isUnaryExpression({
      operator: "!"
    }) || parentPath.isLoop({
      test: node2
    });
  };
  var toNonOptional = function(path3, base) {
    const {
      node: node2
    } = path3;
    if (isOptionalMemberExpression(node2)) {
      return memberExpression(base, node2.property, node2.computed);
    }
    if (path3.isOptionalCallExpression()) {
      const callee = path3.get("callee");
      if (path3.node.optional && callee.isOptionalMemberExpression()) {
        const object = callee.node.object;
        const context = path3.scope.maybeGenerateMemoised(object);
        callee.get("object").replaceWith(assignmentExpression("=", context, object));
        return callExpression(memberExpression(base, identifier("call")), [context, ...path3.node.arguments]);
      }
      return callExpression(base, path3.node.arguments);
    }
    return path3.node;
  };
  var isInDetachedTree = function(path3) {
    while (path3) {
      if (path3.isProgram())
        break;
      const {
        parentPath,
        container,
        listKey
      } = path3;
      const parentNode = parentPath.node;
      if (listKey) {
        if (container !== parentNode[listKey]) {
          return true;
        }
      } else {
        if (container !== parentNode)
          return true;
      }
      path3 = parentPath;
    }
    return false;
  };
  var handleAssignment = function(state, member, parentPath) {
    if (state.simpleSet) {
      member.replaceWith(state.simpleSet(member));
      return;
    }
    const {
      operator,
      right: value2
    } = parentPath.node;
    if (operator === "=") {
      parentPath.replaceWith(state.set(member, value2));
    } else {
      const operatorTrunc = operator.slice(0, -1);
      if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
        state.memoise(member, 1);
        parentPath.replaceWith(logicalExpression(operatorTrunc, state.get(member), state.set(member, value2)));
      } else {
        state.memoise(member, 2);
        parentPath.replaceWith(state.set(member, binaryExpression(operatorTrunc, state.get(member), value2)));
      }
    }
  };
  var memberExpressionToFunctions = function(path3, visitor, state) {
    path3.traverse(visitor, Object.assign({}, handle, state, {
      memoiser: new AssignmentMemoiser
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _t = require_lib3();
  var _t__namespace = _interopNamespace(_t);
  var {
    LOGICAL_OPERATORS,
    arrowFunctionExpression,
    assignmentExpression,
    binaryExpression,
    booleanLiteral,
    callExpression,
    cloneNode,
    conditionalExpression,
    identifier,
    isMemberExpression,
    isOptionalCallExpression,
    isOptionalMemberExpression,
    isUpdateExpression,
    logicalExpression,
    memberExpression,
    nullLiteral,
    optionalCallExpression,
    optionalMemberExpression,
    sequenceExpression,
    updateExpression
  } = _t__namespace;

  class AssignmentMemoiser {
    constructor() {
      this._map = undefined;
      this._map = new WeakMap;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key) {
      if (!this.has(key))
        return;
      const record = this._map.get(key);
      const {
        value: value2
      } = record;
      record.count--;
      if (record.count === 0) {
        return assignmentExpression("=", value2, key);
      }
      return value2;
    }
    set(key, value2, count) {
      return this._map.set(key, {
        count,
        value: value2
      });
    }
  }
  var handle = {
    memoise() {
    },
    handle(member, noDocumentAll) {
      const {
        node: node2,
        parent,
        parentPath,
        scope
      } = member;
      if (member.isOptionalMemberExpression()) {
        if (isInDetachedTree(member))
          return;
        const endPath = member.find(({
          node: node3,
          parent: parent2
        }) => {
          if (isOptionalMemberExpression(parent2)) {
            return parent2.optional || parent2.object !== node3;
          }
          if (isOptionalCallExpression(parent2)) {
            return node3 !== member.node && parent2.optional || parent2.callee !== node3;
          }
          return true;
        });
        if (scope.path.isPattern()) {
          endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
          return;
        }
        const willEndPathCastToBoolean = willPathCastToBoolean(endPath);
        const rootParentPath = endPath.parentPath;
        if (rootParentPath.isUpdateExpression({
          argument: node2
        })) {
          throw member.buildCodeFrameError(`can't handle update expression`);
        }
        const isAssignment = rootParentPath.isAssignmentExpression({
          left: endPath.node
        });
        const isDeleteOperation = rootParentPath.isUnaryExpression({
          operator: "delete"
        });
        if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) {
          throw member.buildCodeFrameError(`can't delete a private class element`);
        }
        let startingOptional = member;
        for (;; ) {
          if (startingOptional.isOptionalMemberExpression()) {
            if (startingOptional.node.optional)
              break;
            startingOptional = startingOptional.get("object");
            continue;
          } else if (startingOptional.isOptionalCallExpression()) {
            if (startingOptional.node.optional)
              break;
            startingOptional = startingOptional.get("callee");
            continue;
          }
          throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
        }
        const startingNode = startingOptional.isOptionalMemberExpression() ? startingOptional.node.object : startingOptional.node.callee;
        const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);
        const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;
        const parentIsOptionalCall = parentPath.isOptionalCallExpression({
          callee: node2
        });
        const isOptionalCall = (parent2) => parentIsOptionalCall;
        const parentIsCall = parentPath.isCallExpression({
          callee: node2
        });
        startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));
        if (isOptionalCall()) {
          if (parent.optional) {
            parentPath.replaceWith(this.optionalCall(member, parent.arguments));
          } else {
            parentPath.replaceWith(this.call(member, parent.arguments));
          }
        } else if (parentIsCall) {
          member.replaceWith(this.boundGet(member));
        } else if (this.delete && parentPath.isUnaryExpression({
          operator: "delete"
        })) {
          parentPath.replaceWith(this.delete(member));
        } else if (parentPath.isAssignmentExpression()) {
          handleAssignment(this, member, parentPath);
        } else {
          member.replaceWith(this.get(member));
        }
        let regular = member.node;
        for (let current = member;current !== endPath; ) {
          const parentPath2 = current.parentPath;
          if (parentPath2 === endPath && isOptionalCall() && parent.optional) {
            regular = parentPath2.node;
            break;
          }
          regular = toNonOptional(parentPath2, regular);
          current = parentPath2;
        }
        let context;
        const endParentPath = endPath.parentPath;
        if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
          callee: endPath.node,
          optional: true
        })) {
          const {
            object
          } = regular;
          context = member.scope.maybeGenerateMemoised(object);
          if (context) {
            regular.object = assignmentExpression("=", context, object);
          }
        }
        let replacementPath = endPath;
        if (isDeleteOperation || isAssignment) {
          replacementPath = endParentPath;
          regular = endParentPath.node;
        }
        const baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
        if (willEndPathCastToBoolean) {
          let nonNullishCheck;
          if (noDocumentAll) {
            nonNullishCheck = binaryExpression("!=", baseMemoised, nullLiteral());
          } else {
            nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode()));
          }
          replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
        } else {
          let nullishCheck;
          if (noDocumentAll) {
            nullishCheck = binaryExpression("==", baseMemoised, nullLiteral());
          } else {
            nullishCheck = logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode()));
          }
          replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
        }
        if (context) {
          const endParent = endParentPath.node;
          endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [cloneNode(context), ...endParent.arguments], false));
        }
        return;
      }
      if (isUpdateExpression(parent, {
        argument: node2
      })) {
        if (this.simpleSet) {
          member.replaceWith(this.simpleSet(member));
          return;
        }
        const {
          operator,
          prefix
        } = parent;
        this.memoise(member, 2);
        const ref = scope.generateUidIdentifierBasedOnNode(node2);
        scope.push({
          id: ref
        });
        const seq = [assignmentExpression("=", cloneNode(ref), this.get(member))];
        if (prefix) {
          seq.push(updateExpression(operator, cloneNode(ref), prefix));
          const value2 = sequenceExpression(seq);
          parentPath.replaceWith(this.set(member, value2));
          return;
        } else {
          const ref2 = scope.generateUidIdentifierBasedOnNode(node2);
          scope.push({
            id: ref2
          });
          seq.push(assignmentExpression("=", cloneNode(ref2), updateExpression(operator, cloneNode(ref), prefix)), cloneNode(ref));
          const value2 = sequenceExpression(seq);
          parentPath.replaceWith(sequenceExpression([this.set(member, value2), cloneNode(ref2)]));
          return;
        }
      }
      if (parentPath.isAssignmentExpression({
        left: node2
      })) {
        handleAssignment(this, member, parentPath);
        return;
      }
      if (parentPath.isCallExpression({
        callee: node2
      })) {
        parentPath.replaceWith(this.call(member, parentPath.node.arguments));
        return;
      }
      if (parentPath.isOptionalCallExpression({
        callee: node2
      })) {
        if (scope.path.isPattern()) {
          parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));
          return;
        }
        parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));
        return;
      }
      if (this.delete && parentPath.isUnaryExpression({
        operator: "delete"
      })) {
        parentPath.replaceWith(this.delete(member));
        return;
      }
      if (parentPath.isForXStatement({
        left: node2
      }) || parentPath.isObjectProperty({
        value: node2
      }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
        left: node2
      }) && parentPath.parentPath.isObjectProperty({
        value: parent
      }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
        left: node2
      }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
        member.replaceWith(this.destructureSet(member));
        return;
      }
      if (parentPath.isTaggedTemplateExpression()) {
        member.replaceWith(this.boundGet(member));
      } else {
        member.replaceWith(this.get(member));
      }
    }
  };
  exports.default = memberExpressionToFunctions;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-optimise-call-expression/lib/index.js
var require_lib22 = __commonJS((exports) => {
  var optimiseCallExpression = function(callee, thisNode, args, optional) {
    if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
      name: "arguments"
    })) {
      if (optional) {
        return optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [thisNode, args[0].argument], false);
      }
      return callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]);
    } else {
      if (optional) {
        return optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [thisNode, ...args], false);
      }
      return callExpression(memberExpression(callee, identifier("call")), [thisNode, ...args]);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = optimiseCallExpression;
  var _t = require_lib3();
  var {
    callExpression,
    identifier,
    isIdentifier,
    isSpreadElement,
    memberExpression,
    optionalCallExpression,
    optionalMemberExpression
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-replace-supers/lib/index.js
var require_lib23 = __commonJS((exports) => {
  var getPrototypeOfExpression = function(objectRef, isStatic, file, isPrivateMethod) {
    objectRef = cloneNode(objectRef);
    const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
    return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _helperEnvironmentVisitor = require_lib6();
  var _helperMemberExpressionToFunctions = require_lib21();
  var _helperOptimiseCallExpression = require_lib22();
  var _core = require_lib33();
  var {
    assignmentExpression,
    booleanLiteral,
    callExpression,
    cloneNode,
    identifier,
    memberExpression,
    sequenceExpression,
    stringLiteral,
    thisExpression
  } = _core.types;
  {
    const ns = require_lib6();
    exports.environmentVisitor = ns.default;
    exports.skipAllButComputedKey = ns.skipAllButComputedKey;
  }
  var visitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {
    Super(path3, state) {
      const {
        node: node2,
        parentPath
      } = path3;
      if (!parentPath.isMemberExpression({
        object: node2
      }))
        return;
      state.handle(parentPath);
    }
  }]);
  var unshadowSuperBindingVisitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {
    Scopable(path3, {
      refName
    }) {
      const binding = path3.scope.getOwnBinding(refName);
      if (binding && binding.identifier.name === refName) {
        path3.scope.rename(refName);
      }
    }
  }]);
  var specHandlers = {
    memoise(superMember, count) {
      const {
        scope,
        node: node2
      } = superMember;
      const {
        computed,
        property: property2
      } = node2;
      if (!computed) {
        return;
      }
      const memo = scope.maybeGenerateMemoised(property2);
      if (!memo) {
        return;
      }
      this.memoiser.set(property2, memo, count);
    },
    prop(superMember) {
      const {
        computed,
        property: property2
      } = superMember.node;
      if (this.memoiser.has(property2)) {
        return cloneNode(this.memoiser.get(property2));
      }
      if (computed) {
        return cloneNode(property2);
      }
      return stringLiteral(property2.name);
    },
    get(superMember) {
      return this._get(superMember, this._getThisRefs());
    },
    _get(superMember, thisRefs) {
      const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);
    },
    _getThisRefs() {
      if (!this.isDerivedConstructor) {
        return {
          this: thisExpression()
        };
      }
      const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
      return {
        memo: assignmentExpression("=", thisRef, thisExpression()),
        this: cloneNode(thisRef)
      };
    },
    set(superMember, value2) {
      const thisRefs = this._getThisRefs();
      const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value2, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);
    },
    destructureSet(superMember) {
      throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
    },
    call(superMember, args) {
      const thisRefs = this._getThisRefs();
      return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);
    },
    optionalCall(superMember, args) {
      const thisRefs = this._getThisRefs();
      return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);
    },
    delete(superMember) {
      if (superMember.node.computed) {
        return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]);
      } else {
        return _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
      }
    }
  };
  var looseHandlers = Object.assign({}, specHandlers, {
    prop(superMember) {
      const {
        property: property2
      } = superMember.node;
      if (this.memoiser.has(property2)) {
        return cloneNode(this.memoiser.get(property2));
      }
      return cloneNode(property2);
    },
    get(superMember) {
      const {
        isStatic,
        getSuperRef
      } = this;
      const {
        computed
      } = superMember.node;
      const prop = this.prop(superMember);
      let object;
      if (isStatic) {
        var _getSuperRef;
        object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
      } else {
        var _getSuperRef2;
        object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
      }
      return memberExpression(object, prop, computed);
    },
    set(superMember, value2) {
      const {
        computed
      } = superMember.node;
      const prop = this.prop(superMember);
      return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value2);
    },
    destructureSet(superMember) {
      const {
        computed
      } = superMember.node;
      const prop = this.prop(superMember);
      return memberExpression(thisExpression(), prop, computed);
    },
    call(superMember, args) {
      return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);
    },
    optionalCall(superMember, args) {
      return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);
    }
  });

  class ReplaceSupers {
    constructor(opts) {
      var _opts$constantSuper;
      const path3 = opts.methodPath;
      this.methodPath = path3;
      this.isDerivedConstructor = path3.isClassMethod({
        kind: "constructor"
      }) && !!opts.superRef;
      this.isStatic = path3.isObjectMethod() || path3.node.static || (path3.isStaticBlock == null ? undefined : path3.isStaticBlock());
      this.isPrivateMethod = path3.isPrivate() && path3.isMethod();
      this.file = opts.file;
      this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
      this.opts = opts;
    }
    getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      if (this.opts.superRef)
        return cloneNode(this.opts.superRef);
      if (this.opts.getSuperRef) {
        return cloneNode(this.opts.getSuperRef());
      }
    }
    replace() {
      if (this.opts.refToPreserve) {
        this.methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
      }
      const handler = this.constantSuper ? looseHandlers : specHandlers;
      (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: handler.get
      }, handler));
    }
  }
  exports.default = ReplaceSupers;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js
var require_lib24 = __commonJS((exports) => {
  var isTransparentExprWrapper = function(node2) {
    return isTSAsExpression(node2) || isTSSatisfiesExpression(node2) || isTSTypeAssertion(node2) || isTSNonNullExpression(node2) || isTypeCastExpression(node2) || isParenthesizedExpression(node2);
  };
  var skipTransparentExprWrappers = function(path3) {
    while (isTransparentExprWrapper(path3.node)) {
      path3 = path3.get("expression");
    }
    return path3;
  };
  var skipTransparentExprWrapperNodes = function(node2) {
    while (isTransparentExprWrapper(node2)) {
      node2 = node2.expression;
    }
    return node2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isTransparentExprWrapper = isTransparentExprWrapper;
  exports.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;
  exports.skipTransparentExprWrappers = skipTransparentExprWrappers;
  var _t = require_lib3();
  var {
    isParenthesizedExpression,
    isTSAsExpression,
    isTSNonNullExpression,
    isTSSatisfiesExpression,
    isTSTypeAssertion,
    isTypeCastExpression
  } = _t;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js
var require_decorators = __commonJS((exports) => {
  var incrementId = function(id, idx = id.length - 1) {
    if (idx === -1) {
      id.unshift(65);
      return;
    }
    const current = id[idx];
    if (current === 90) {
      id[idx] = 97;
    } else if (current === 122) {
      id[idx] = 65;
      incrementId(id, idx - 1);
    } else {
      id[idx] = current + 1;
    }
  };
  var createPrivateUidGeneratorForClass = function(classPath) {
    const currentPrivateId = [];
    const privateNames = new Set;
    classPath.traverse({
      PrivateName(path3) {
        privateNames.add(path3.node.id.name);
      }
    });
    return () => {
      let reifiedId;
      do {
        incrementId(currentPrivateId);
        reifiedId = String.fromCharCode(...currentPrivateId);
      } while (privateNames.has(reifiedId));
      return _core.types.privateName(_core.types.identifier(reifiedId));
    };
  };
  var createLazyPrivateUidGeneratorForClass = function(classPath) {
    let generator;
    return () => {
      if (!generator) {
        generator = createPrivateUidGeneratorForClass(classPath);
      }
      return generator();
    };
  };
  var replaceClassWithVar = function(path3, className) {
    if (path3.type === "ClassDeclaration") {
      const id = path3.node.id;
      const className2 = id.name;
      const varId = path3.scope.generateUidIdentifierBasedOnNode(id);
      const classId = _core.types.identifier(className2);
      path3.scope.rename(className2, varId.name);
      path3.get("id").replaceWith(classId);
      return {
        id: _core.types.cloneNode(varId),
        path: path3
      };
    } else {
      let varId;
      if (path3.node.id) {
        className = path3.node.id.name;
        varId = path3.scope.parent.generateDeclaredUidIdentifier(className);
        path3.scope.rename(className, varId.name);
      } else {
        varId = path3.scope.parent.generateDeclaredUidIdentifier(typeof className === "string" ? className : "decorated_class");
      }
      const newClassExpr = _core.types.classExpression(typeof className === "string" ? _core.types.identifier(className) : null, path3.node.superClass, path3.node.body);
      const [newPath] = path3.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));
      return {
        id: _core.types.cloneNode(varId),
        path: newPath.get("expressions.0")
      };
    }
  };
  var generateClassProperty = function(key, value2, isStatic) {
    if (key.type === "PrivateName") {
      return _core.types.classPrivateProperty(key, value2, undefined, isStatic);
    } else {
      return _core.types.classProperty(key, value2, undefined, undefined, isStatic);
    }
  };
  var addProxyAccessorsFor = function(className, element, originalKey, targetKey, version2, isComputed = false) {
    const {
      static: isStatic
    } = element.node;
    const thisArg = version2 === "2023-05" && isStatic ? className : _core.types.thisExpression();
    const getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)))]);
    const setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)), _core.types.identifier("v")))]);
    let getter, setter;
    if (originalKey.type === "PrivateName") {
      getter = _core.types.classPrivateMethod("get", _core.types.cloneNode(originalKey), [], getterBody, isStatic);
      setter = _core.types.classPrivateMethod("set", _core.types.cloneNode(originalKey), [_core.types.identifier("v")], setterBody, isStatic);
    } else {
      getter = _core.types.classMethod("get", _core.types.cloneNode(originalKey), [], getterBody, isComputed, isStatic);
      setter = _core.types.classMethod("set", _core.types.cloneNode(originalKey), [_core.types.identifier("v")], setterBody, isComputed, isStatic);
    }
    element.insertAfter(setter);
    element.insertAfter(getter);
  };
  var extractProxyAccessorsFor = function(targetKey, version2) {
    if (version2 !== "2023-05" && version2 !== "2023-01") {
      return [_core.template.expression.ast`
        function () {
          return this.${_core.types.cloneNode(targetKey)};
        }
      `, _core.template.expression.ast`
        function (value) {
          this.${_core.types.cloneNode(targetKey)} = value;
        }
      `];
    }
    return [_core.template.expression.ast`
      o => o.${_core.types.cloneNode(targetKey)}
    `, _core.template.expression.ast`
      (o, v) => o.${_core.types.cloneNode(targetKey)} = v
    `];
  };
  var getElementKind = function(element) {
    switch (element.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return FIELD;
      case "ClassAccessorProperty":
        return ACCESSOR;
      case "ClassMethod":
      case "ClassPrivateMethod":
        if (element.node.kind === "get") {
          return GETTER;
        } else if (element.node.kind === "set") {
          return SETTER;
        } else {
          return METHOD;
        }
    }
  };
  var isDecoratorInfo = function(info) {
    return "decorators" in info;
  };
  var filteredOrderedDecoratorInfo = function(info) {
    const filtered = info.filter(isDecoratorInfo);
    return [...filtered.filter((el) => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter((el) => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter((el) => el.isStatic && el.kind === FIELD), ...filtered.filter((el) => !el.isStatic && el.kind === FIELD)];
  };
  var generateDecorationList = function(decorators, decoratorsThis, version2) {
    const decsCount = decorators.length;
    const hasOneThis = decoratorsThis.some(Boolean);
    const decs = [];
    for (let i = 0;i < decsCount; i++) {
      if (version2 === "2023-05" && hasOneThis) {
        decs.push(decoratorsThis[i] || _core.types.unaryExpression("void", _core.types.numericLiteral(0)));
      }
      decs.push(decorators[i]);
    }
    return {
      hasThis: hasOneThis,
      decs
    };
  };
  var generateDecorationExprs = function(info, version2) {
    return _core.types.arrayExpression(filteredOrderedDecoratorInfo(info).map((el) => {
      const {
        decs,
        hasThis
      } = generateDecorationList(el.decorators, el.decoratorsThis, version2);
      let flag = el.kind;
      if (el.isStatic) {
        flag += version2 === "2023-05" ? STATIC : STATIC_OLD_VERSION;
      }
      if (hasThis)
        flag += DECORATORS_HAVE_THIS;
      return _core.types.arrayExpression([decs.length === 1 ? decs[0] : _core.types.arrayExpression(decs), _core.types.numericLiteral(flag), el.name, ...el.privateMethods || []]);
    }));
  };
  var extractElementLocalAssignments = function(decorationInfo) {
    const localIds = [];
    for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {
      const {
        locals
      } = el;
      if (Array.isArray(locals)) {
        localIds.push(...locals);
      } else if (locals !== undefined) {
        localIds.push(locals);
      }
    }
    return localIds;
  };
  var addCallAccessorsFor = function(element, key, getId, setId) {
    element.insertAfter(_core.types.classPrivateMethod("get", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), [_core.types.thisExpression()]))])));
    element.insertAfter(_core.types.classPrivateMethod("set", _core.types.cloneNode(key), [_core.types.identifier("v")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), [_core.types.thisExpression(), _core.types.identifier("v")]))])));
  };
  var isNotTsParameter = function(node2) {
    return node2.type !== "TSParameterProperty";
  };
  var movePrivateAccessor = function(element, key, methodLocalVar, isStatic) {
    let params;
    let block;
    if (element.node.kind === "set") {
      params = [_core.types.identifier("v")];
      block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier("v")]))];
    } else {
      params = [];
      block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))];
    }
    element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));
  };
  var isClassDecoratableElementPath = function(path3) {
    const {
      type
    } = path3;
    return type !== "TSDeclareMethod" && type !== "TSIndexSignature" && type !== "StaticBlock";
  };
  var staticBlockToIIFE = function(block) {
    return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);
  };
  var maybeSequenceExpression = function(exprs) {
    if (exprs.length === 0)
      return _core.types.unaryExpression("void", _core.types.numericLiteral(0));
    if (exprs.length === 1)
      return exprs[0];
    return _core.types.sequenceExpression(exprs);
  };
  var createSetFunctionNameCall = function(state, className) {
    return _core.types.callExpression(state.addHelper("setFunctionName"), [_core.types.thisExpression(), className]);
  };
  var createToPropertyKeyCall = function(state, propertyKey) {
    return _core.types.callExpression(state.addHelper("toPropertyKey"), [propertyKey]);
  };
  var transformClass = function(path3, state, constantSuper, version2, className, propertyVisitor) {
    const body = path3.get("body.body");
    const classDecorators = path3.node.decorators;
    let hasElementDecorators = false;
    const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path3);
    const assignments = [];
    const scopeParent = path3.scope.parent;
    const memoiseExpression = (expression, hint) => {
      const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);
      assignments.push(_core.types.assignmentExpression("=", localEvaluatedId, expression));
      return _core.types.cloneNode(localEvaluatedId);
    };
    for (const element of body) {
      if (!isClassDecoratableElementPath(element)) {
        continue;
      }
      if (element.node.decorators && element.node.decorators.length > 0) {
        switch (element.node.type) {
          case "ClassProperty":
            propertyVisitor.ClassProperty(element, state);
            break;
          case "ClassPrivateProperty":
            propertyVisitor.ClassPrivateProperty(element, state);
            break;
          case "ClassAccessorProperty":
            propertyVisitor.ClassAccessorProperty(element, state);
            break;
        }
        hasElementDecorators = true;
      } else if (element.node.type === "ClassAccessorProperty") {
        propertyVisitor.ClassAccessorProperty(element, state);
        const {
          key,
          value: value2,
          static: isStatic,
          computed
        } = element.node;
        const newId = generateClassPrivateUid();
        const newField = generateClassProperty(newId, value2, isStatic);
        const keyPath = element.get("key");
        const [newPath] = element.replaceWith(newField);
        addProxyAccessorsFor(path3.node.id, newPath, computed && !keyPath.isConstantExpression() ? memoiseExpression(createToPropertyKeyCall(state, key), "computedKey") : key, newId, version2, computed);
      }
    }
    if (!classDecorators && !hasElementDecorators) {
      if (assignments.length > 0) {
        path3.insertBefore(assignments.map((expr) => _core.types.expressionStatement(expr)));
        path3.scope.crawl();
      }
      return;
    }
    const elementDecoratorInfo = [];
    let firstFieldPath;
    let constructorPath;
    let requiresProtoInit = false;
    let requiresStaticInit = false;
    const decoratedPrivateMethods = new Set;
    let protoInitLocal, staticInitLocal, classInitLocal, classIdLocal;
    const decoratorsThis = new Map;
    const maybeExtractDecorator = (decorator) => {
      const {
        expression
      } = decorator;
      if (version2 === "2023-05" && _core.types.isMemberExpression(expression)) {
        let object;
        if (_core.types.isSuper(expression.object) || _core.types.isThisExpression(expression.object)) {
          object = memoiseExpression(_core.types.thisExpression(), "obj");
        } else if (!scopeParent.isStatic(expression.object)) {
          object = memoiseExpression(expression.object, "obj");
          expression.object = object;
        } else {
          object = expression.object;
        }
        decoratorsThis.set(decorator, _core.types.cloneNode(object));
      }
      if (!scopeParent.isStatic(expression)) {
        decorator.expression = memoiseExpression(expression, "dec");
      }
    };
    let needsDeclaraionForClassBinding = false;
    if (classDecorators) {
      classInitLocal = scopeParent.generateDeclaredUidIdentifier("initClass");
      needsDeclaraionForClassBinding = path3.isClassDeclaration();
      ({
        id: classIdLocal,
        path: path3
      } = replaceClassWithVar(path3, className));
      path3.node.decorators = null;
      for (const classDecorator of classDecorators) {
        maybeExtractDecorator(classDecorator);
      }
    } else {
      if (!path3.node.id) {
        path3.node.id = path3.scope.generateUidIdentifier("Class");
      }
      classIdLocal = _core.types.cloneNode(path3.node.id);
    }
    let lastInstancePrivateName;
    let needsInstancePrivateBrandCheck = false;
    if (hasElementDecorators) {
      for (const element of body) {
        if (!isClassDecoratableElementPath(element)) {
          continue;
        }
        const {
          node: node2
        } = element;
        const decorators = element.get("decorators");
        const hasDecorators = Array.isArray(decorators) && decorators.length > 0;
        if (hasDecorators) {
          for (const decoratorPath of decorators) {
            maybeExtractDecorator(decoratorPath.node);
          }
        }
        const isComputed = "computed" in element.node && element.node.computed === true;
        if (isComputed) {
          if (!element.get("key").isConstantExpression()) {
            node2.key = memoiseExpression(createToPropertyKeyCall(state, node2.key), "computedKey");
          }
        }
        const kind = getElementKind(element);
        const {
          key
        } = node2;
        const isPrivate = key.type === "PrivateName";
        const isStatic = !!element.node.static;
        let name = "computedKey";
        if (isPrivate) {
          name = key.id.name;
        } else if (!isComputed && key.type === "Identifier") {
          name = key.name;
        }
        if (isPrivate && !isStatic) {
          if (hasDecorators) {
            needsInstancePrivateBrandCheck = true;
          }
          if (_core.types.isClassPrivateProperty(node2) || !lastInstancePrivateName) {
            lastInstancePrivateName = key;
          }
        }
        if (element.isClassMethod({
          kind: "constructor"
        })) {
          constructorPath = element;
        }
        if (hasDecorators) {
          let locals;
          let privateMethods;
          if (kind === ACCESSOR) {
            const {
              value: value2
            } = element.node;
            const params = [_core.types.thisExpression()];
            if (value2) {
              params.push(_core.types.cloneNode(value2));
            }
            const newId = generateClassPrivateUid();
            const newFieldInitId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);
            const newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params);
            const newField = generateClassProperty(newId, newValue, isStatic);
            const [newPath] = element.replaceWith(newField);
            if (isPrivate) {
              privateMethods = extractProxyAccessorsFor(newId, version2);
              const getId = newPath.scope.parent.generateDeclaredUidIdentifier(`get_${name}`);
              const setId = newPath.scope.parent.generateDeclaredUidIdentifier(`set_${name}`);
              addCallAccessorsFor(newPath, key, getId, setId);
              locals = [newFieldInitId, getId, setId];
            } else {
              addProxyAccessorsFor(path3.node.id, newPath, key, newId, version2, isComputed);
              locals = newFieldInitId;
            }
          } else if (kind === FIELD) {
            const initId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);
            const valuePath = element.get("value");
            valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), [_core.types.thisExpression(), valuePath.node].filter((v) => v)));
            locals = initId;
            if (isPrivate) {
              privateMethods = extractProxyAccessorsFor(key, version2);
            }
          } else if (isPrivate) {
            locals = element.scope.parent.generateDeclaredUidIdentifier(`call_${name}`);
            const replaceSupers = new _helperReplaceSupers.default({
              constantSuper,
              methodPath: element,
              objectRef: classIdLocal,
              superRef: path3.node.superClass,
              file: state.file,
              refToPreserve: classIdLocal
            });
            replaceSupers.replace();
            const {
              params,
              body: body2,
              async: isAsync2
            } = element.node;
            privateMethods = [_core.types.functionExpression(undefined, params.filter(isNotTsParameter), body2, isAsync2)];
            if (kind === GETTER || kind === SETTER) {
              movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(locals), isStatic);
            } else {
              const node3 = element.node;
              path3.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(locals), [], node3.static));
              decoratedPrivateMethods.add(key.id.name);
              element.remove();
            }
          }
          let nameExpr;
          if (isComputed) {
            nameExpr = _core.types.cloneNode(key);
          } else if (key.type === "PrivateName") {
            nameExpr = _core.types.stringLiteral(key.id.name);
          } else if (key.type === "Identifier") {
            nameExpr = _core.types.stringLiteral(key.name);
          } else {
            nameExpr = _core.types.cloneNode(key);
          }
          elementDecoratorInfo.push({
            kind,
            decorators: decorators.map((d) => d.node.expression),
            decoratorsThis: decorators.map((d) => decoratorsThis.get(d.node)),
            name: nameExpr,
            isStatic,
            privateMethods,
            locals
          });
          if (kind !== FIELD) {
            if (isStatic) {
              requiresStaticInit = true;
            } else {
              requiresProtoInit = true;
            }
          }
          if (element.node) {
            element.node.decorators = null;
          }
          if (!firstFieldPath && !isStatic && (kind === FIELD || kind === ACCESSOR)) {
            firstFieldPath = element;
          }
        }
      }
    }
    const elementDecorations = generateDecorationExprs(elementDecoratorInfo, version2);
    let classDecorationsFlag = 0;
    let classDecorations = [];
    if (classDecorators) {
      const {
        hasThis,
        decs
      } = generateDecorationList(classDecorators.map((el) => el.expression), classDecorators.map((dec) => decoratorsThis.get(dec)), version2);
      classDecorationsFlag = hasThis ? 1 : 0;
      classDecorations = decs;
    }
    const elementLocals = extractElementLocalAssignments(elementDecoratorInfo);
    if (requiresProtoInit) {
      protoInitLocal = scopeParent.generateDeclaredUidIdentifier("initProto");
      elementLocals.push(protoInitLocal);
      const protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);
      if (firstFieldPath) {
        const value2 = firstFieldPath.get("value");
        const body2 = [protoInitCall];
        if (value2.node) {
          body2.push(value2.node);
        }
        value2.replaceWith(_core.types.sequenceExpression(body2));
      } else if (constructorPath) {
        if (path3.node.superClass) {
          constructorPath.traverse({
            CallExpression: {
              exit(path4) {
                if (!path4.get("callee").isSuper())
                  return;
                path4.replaceWith(_core.types.callExpression(_core.types.cloneNode(protoInitLocal), [path4.node]));
                path4.skip();
              }
            },
            ClassMethod(path4) {
              if (path4.node.kind === "constructor") {
                path4.skip();
              }
            }
          });
        } else {
          constructorPath.node.body.body.unshift(_core.types.expressionStatement(protoInitCall));
        }
      } else {
        const body2 = [_core.types.expressionStatement(protoInitCall)];
        if (path3.node.superClass) {
          body2.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier("args"))])));
        }
        path3.node.body.body.unshift(_core.types.classMethod("constructor", _core.types.identifier("constructor"), [_core.types.restElement(_core.types.identifier("args"))], _core.types.blockStatement(body2)));
      }
    }
    if (requiresStaticInit) {
      staticInitLocal = scopeParent.generateDeclaredUidIdentifier("initStatic");
      elementLocals.push(staticInitLocal);
    }
    if (decoratedPrivateMethods.size > 0) {
      path3.traverse({
        PrivateName(path4) {
          if (!decoratedPrivateMethods.has(path4.node.id.name))
            return;
          const parentPath = path4.parentPath;
          const parentParentPath = parentPath.parentPath;
          if (parentParentPath.node.type === "AssignmentExpression" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === "UpdateExpression" || parentParentPath.node.type === "RestElement" || parentParentPath.node.type === "ArrayPattern" || parentParentPath.node.type === "ObjectProperty" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === "ObjectPattern" || parentParentPath.node.type === "ForOfStatement" && parentParentPath.node.left === parentPath.node) {
            throw path4.buildCodeFrameError(`Decorated private methods are not updatable, but "#${path4.node.id.name}" is updated via this expression.`);
          }
        }
      });
    }
    const classLocals = [];
    let classInitInjected = false;
    const classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []);
    const originalClass = path3.node;
    if (classDecorators) {
      classLocals.push(classIdLocal, classInitLocal);
      const statics = [];
      let staticBlocks = [];
      path3.get("body.body").forEach((element) => {
        if (element.isStaticBlock()) {
          staticBlocks.push(element.node);
          element.remove();
          return;
        }
        const isProperty = element.isClassProperty() || element.isClassPrivateProperty();
        if ((isProperty || element.isClassPrivateMethod()) && element.node.static) {
          if (isProperty && staticBlocks.length > 0) {
            const allValues = staticBlocks.map(staticBlockToIIFE);
            if (element.node.value)
              allValues.push(element.node.value);
            element.node.value = maybeSequenceExpression(allValues);
            staticBlocks = [];
          }
          element.node.static = false;
          statics.push(element.node);
          element.remove();
        }
      });
      if (statics.length > 0 || staticBlocks.length > 0) {
        const staticsClass = _core.template.expression.ast`
        class extends ${state.addHelper("identity")} {}
      `;
        staticsClass.body.body = [_core.types.staticBlock([_core.types.toStatement(originalClass, true) || _core.types.expressionStatement(originalClass)]), ...statics];
        const constructorBody = [];
        const newExpr = _core.types.newExpression(staticsClass, []);
        if (staticBlocks.length > 0) {
          constructorBody.push(...staticBlocks.map(staticBlockToIIFE));
        }
        if (classInitCall) {
          classInitInjected = true;
          constructorBody.push(classInitCall);
        }
        if (constructorBody.length > 0) {
          constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classIdLocal)]));
          staticsClass.body.body.push(_core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([_core.types.expressionStatement(_core.types.sequenceExpression(constructorBody))])));
        } else {
          newExpr.arguments.push(_core.types.cloneNode(classIdLocal));
        }
        path3.replaceWith(newExpr);
      }
    }
    if (!classInitInjected && classInitCall) {
      path3.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));
    }
    let {
      superClass
    } = originalClass;
    if (superClass && version2 === "2023-05") {
      const id = path3.scope.maybeGenerateMemoised(superClass);
      if (id) {
        originalClass.superClass = _core.types.assignmentExpression("=", id, superClass);
        superClass = id;
      }
    }
    originalClass.body.body.unshift(_core.types.staticBlock([_core.types.expressionStatement(createLocalsAssignment(elementLocals, classLocals, elementDecorations, _core.types.arrayExpression(classDecorations), _core.types.numericLiteral(classDecorationsFlag), needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, typeof className === "object" ? className : undefined, _core.types.cloneNode(superClass), state, version2)), requiresStaticInit && _core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()]))].filter(Boolean)));
    path3.insertBefore(assignments.map((expr) => _core.types.expressionStatement(expr)));
    if (needsDeclaraionForClassBinding) {
      path3.insertBefore(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]));
    }
    path3.scope.crawl();
    return path3;
  };
  var createLocalsAssignment = function(elementLocals, classLocals, elementDecorations, classDecorations, classDecorationsFlag, maybePrivateBranName, setClassName, superClass, state, version2) {
    let lhs, rhs;
    const args = [setClassName ? createSetFunctionNameCall(state, setClassName) : _core.types.thisExpression(), elementDecorations, classDecorations];
    {
      if (version2 === "2021-12" || version2 === "2022-03" && !state.availableHelper("applyDecs2203R")) {
        const lhs2 = _core.types.arrayPattern([...elementLocals, ...classLocals]);
        const rhs2 = _core.types.callExpression(state.addHelper(version2 === "2021-12" ? "applyDecs" : "applyDecs2203"), args);
        return _core.types.assignmentExpression("=", lhs2, rhs2);
      }
    }
    if (version2 === "2023-05") {
      if (maybePrivateBranName || superClass || classDecorationsFlag.value !== 0) {
        args.push(classDecorationsFlag);
      }
      if (maybePrivateBranName) {
        args.push(_core.template.expression.ast`
            _ => ${_core.types.cloneNode(maybePrivateBranName)} in _
          `);
      } else if (superClass) {
        args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0)));
      }
      if (superClass)
        args.push(superClass);
      rhs = _core.types.callExpression(state.addHelper("applyDecs2305"), args);
    } else if (version2 === "2023-01") {
      if (maybePrivateBranName) {
        args.push(_core.template.expression.ast`
            _ => ${_core.types.cloneNode(maybePrivateBranName)} in _
          `);
      }
      rhs = _core.types.callExpression(state.addHelper("applyDecs2301"), args);
    } else {
      rhs = _core.types.callExpression(state.addHelper("applyDecs2203R"), args);
    }
    if (elementLocals.length > 0) {
      if (classLocals.length > 0) {
        lhs = _core.types.objectPattern([_core.types.objectProperty(_core.types.identifier("e"), _core.types.arrayPattern(elementLocals)), _core.types.objectProperty(_core.types.identifier("c"), _core.types.arrayPattern(classLocals))]);
      } else {
        lhs = _core.types.arrayPattern(elementLocals);
        rhs = _core.types.memberExpression(rhs, _core.types.identifier("e"), false, false);
      }
    } else {
      lhs = _core.types.arrayPattern(classLocals);
      rhs = _core.types.memberExpression(rhs, _core.types.identifier("c"), false, false);
    }
    return _core.types.assignmentExpression("=", lhs, rhs);
  };
  var isProtoKey = function(node2) {
    return node2.type === "Identifier" ? node2.name === "__proto__" : node2.value === "__proto__";
  };
  var isDecorated = function(node2) {
    return node2.decorators && node2.decorators.length > 0;
  };
  var shouldTransformElement = function(node2) {
    switch (node2.type) {
      case "ClassAccessorProperty":
        return true;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return isDecorated(node2);
      default:
        return false;
    }
  };
  var shouldTransformClass = function(node2) {
    return isDecorated(node2) || node2.body.body.some(shouldTransformElement);
  };
  var NamedEvaluationVisitoryFactory = function(isAnonymous, visitor) {
    function handleComputedProperty(propertyPath, key, state) {
      switch (key.type) {
        case "StringLiteral":
          return _core.types.stringLiteral(key.value);
        case "NumericLiteral":
        case "BigIntLiteral": {
          const keyValue = key.value + "";
          propertyPath.get("key").replaceWith(_core.types.stringLiteral(keyValue));
          return _core.types.stringLiteral(keyValue);
        }
        default: {
          const ref = propertyPath.scope.maybeGenerateMemoised(key);
          propertyPath.get("key").replaceWith(_core.types.assignmentExpression("=", ref, createToPropertyKeyCall(state, key)));
          return _core.types.cloneNode(ref);
        }
      }
    }
    return {
      VariableDeclarator(path3, state) {
        const id = path3.node.id;
        if (id.type === "Identifier") {
          const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path3.get("init"));
          if (isAnonymous(initializer)) {
            const name = id.name;
            visitor(initializer, state, name);
          }
        }
      },
      AssignmentExpression(path3, state) {
        const id = path3.node.left;
        if (id.type === "Identifier") {
          const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path3.get("right"));
          if (isAnonymous(initializer)) {
            switch (path3.node.operator) {
              case "=":
              case "&&=":
              case "||=":
              case "??=":
                visitor(initializer, state, id.name);
            }
          }
        }
      },
      AssignmentPattern(path3, state) {
        const id = path3.node.left;
        if (id.type === "Identifier") {
          const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path3.get("right"));
          if (isAnonymous(initializer)) {
            const name = id.name;
            visitor(initializer, state, name);
          }
        }
      },
      ObjectExpression(path3, state) {
        for (const propertyPath of path3.get("properties")) {
          const {
            node: node2
          } = propertyPath;
          if (node2.type !== "ObjectProperty")
            continue;
          const id = node2.key;
          const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(propertyPath.get("value"));
          if (isAnonymous(initializer)) {
            if (!node2.computed) {
              if (!isProtoKey(id)) {
                if (id.type === "Identifier") {
                  visitor(initializer, state, id.name);
                } else {
                  const className = _core.types.stringLiteral(id.value + "");
                  visitor(initializer, state, className);
                }
              }
            } else {
              const ref = handleComputedProperty(propertyPath, id, state);
              visitor(initializer, state, ref);
            }
          }
        }
      },
      ClassPrivateProperty(path3, state) {
        const {
          node: node2
        } = path3;
        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path3.get("value"));
        if (isAnonymous(initializer)) {
          const className = _core.types.stringLiteral("#" + node2.key.id.name);
          visitor(initializer, state, className);
        }
      },
      ClassAccessorProperty(path3, state) {
        const {
          node: node2
        } = path3;
        const id = node2.key;
        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path3.get("value"));
        if (isAnonymous(initializer)) {
          if (!node2.computed) {
            if (id.type === "Identifier") {
              visitor(initializer, state, id.name);
            } else if (id.type === "PrivateName") {
              const className = _core.types.stringLiteral("#" + id.id.name);
              visitor(initializer, state, className);
            } else {
              const className = _core.types.stringLiteral(id.value + "");
              visitor(initializer, state, className);
            }
          } else {
            const ref = handleComputedProperty(path3, id, state);
            visitor(initializer, state, ref);
          }
        }
      },
      ClassProperty(path3, state) {
        const {
          node: node2
        } = path3;
        const id = node2.key;
        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path3.get("value"));
        if (isAnonymous(initializer)) {
          if (!node2.computed) {
            if (id.type === "Identifier") {
              visitor(initializer, state, id.name);
            } else {
              const className = _core.types.stringLiteral(id.value + "");
              visitor(initializer, state, className);
            }
          } else {
            const ref = handleComputedProperty(path3, id, state);
            visitor(initializer, state, ref);
          }
        }
      }
    };
  };
  var isDecoratedAnonymousClassExpression = function(path3) {
    return path3.isClassExpression({
      id: null
    }) && shouldTransformClass(path3.node);
  };
  var _default = function({
    assertVersion,
    assumption
  }, {
    loose
  }, version2, inherits) {
    var _assumption;
    {
      if (version2 === "2023-05" || version2 === "2023-01") {
        assertVersion("^7.21.0");
      } else if (version2 === "2021-12") {
        assertVersion("^7.16.0");
      } else {
        assertVersion("^7.19.0");
      }
    }
    const VISITED = new WeakSet;
    const constantSuper = (_assumption = assumption("constantSuper")) != null ? _assumption : loose;
    const namedEvaluationVisitor = NamedEvaluationVisitoryFactory(isDecoratedAnonymousClassExpression, visitClass);
    function visitClass(path3, state, className) {
      var _className, _node$id;
      if (VISITED.has(path3))
        return;
      const {
        node: node2
      } = path3;
      (_className = className) != null || (className = (_node$id = node2.id) == null ? undefined : _node$id.name);
      const newPath = transformClass(path3, state, constantSuper, version2, className, namedEvaluationVisitor);
      if (newPath) {
        VISITED.add(newPath);
        return;
      }
      VISITED.add(path3);
    }
    return {
      name: "proposal-decorators",
      inherits,
      visitor: Object.assign({
        ExportDefaultDeclaration(path3, state) {
          const {
            declaration
          } = path3.node;
          if ((declaration == null ? undefined : declaration.type) === "ClassDeclaration" && isDecorated(declaration)) {
            const isAnonymous = !declaration.id;
            const updatedVarDeclarationPath = (0, _helperSplitExportDeclaration.default)(path3);
            if (isAnonymous) {
              visitClass(updatedVarDeclarationPath, state, _core.types.stringLiteral("default"));
            }
          }
        },
        ExportNamedDeclaration(path3) {
          const {
            declaration
          } = path3.node;
          if ((declaration == null ? undefined : declaration.type) === "ClassDeclaration" && isDecorated(declaration)) {
            (0, _helperSplitExportDeclaration.default)(path3);
          }
        },
        Class(path3, state) {
          visitClass(path3, state, undefined);
        }
      }, namedEvaluationVisitor)
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _core = require_lib33();
  var _helperReplaceSupers = require_lib23();
  var _helperSplitExportDeclaration = require_lib5();
  var _helperSkipTransparentExpressionWrappers = require_lib24();
  var FIELD = 0;
  var ACCESSOR = 1;
  var METHOD = 2;
  var GETTER = 3;
  var SETTER = 4;
  var STATIC_OLD_VERSION = 5;
  var STATIC = 8;
  var DECORATORS_HAVE_THIS = 16;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/node_modules/semver/semver.js
var require_semver2 = __commonJS((exports, module) => {
  var tok = function(n) {
    t[n] = R++;
  };
  var makeSafeRe = function(value2) {
    for (var i2 = 0;i2 < safeRegexReplacements.length; i2++) {
      var token = safeRegexReplacements[i2][0];
      var max = safeRegexReplacements[i2][1];
      value2 = value2.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value2;
  };
  var parse2 = function(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  };
  var valid = function(version2, options) {
    var v = parse2(version2, options);
    return v ? v.version : null;
  };
  var clean = function(version2, options) {
    var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  var SemVer = function(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      if (version2.loose === options.loose) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: " + version2);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version2, options);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version2);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  };
  var inc = function(version2, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version2, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  var diff = function(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v12 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v12.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v12) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v12[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  var compareIdentifiers = function(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
  };
  var major = function(a, loose) {
    return new SemVer(a, loose).major;
  };
  var minor = function(a, loose) {
    return new SemVer(a, loose).minor;
  };
  var patch = function(a, loose) {
    return new SemVer(a, loose).patch;
  };
  var compare = function(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  };
  var compareLoose = function(a, b) {
    return compare(a, b, true);
  };
  var compareBuild = function(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  var rcompare = function(a, b, loose) {
    return compare(b, a, loose);
  };
  var sort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(a, b, loose);
    });
  };
  var rsort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(b, a, loose);
    });
  };
  var gt = function(a, b, loose) {
    return compare(a, b, loose) > 0;
  };
  var lt = function(a, b, loose) {
    return compare(a, b, loose) < 0;
  };
  var eq = function(a, b, loose) {
    return compare(a, b, loose) === 0;
  };
  var neq = function(a, b, loose) {
    return compare(a, b, loose) !== 0;
  };
  var gte = function(a, b, loose) {
    return compare(a, b, loose) >= 0;
  };
  var lte = function(a, b, loose) {
    return compare(a, b, loose) <= 0;
  };
  var cmp = function(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };
  var Comparator = function(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  };
  var Range = function(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  };
  var isSatisfiable = function(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var toComparators = function(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  };
  var parseComparator = function(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = function(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  };
  var replaceTildes = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  };
  var replaceTilde = function(comp, options) {
    var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  };
  var replaceCaret = function(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = function(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = function(comp, options) {
    comp = comp.trim();
    var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = function(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(safeRe[t.STAR], "");
  };
  var hyphenReplace = function($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  };
  var testSet = function(set, version2, options) {
    for (var i2 = 0;i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0;i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  var satisfies = function(version2, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  var maxSatisfying = function(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  var minSatisfying = function(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  var minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  var validRange = function(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  var ltr = function(version2, range, options) {
    return outside(version2, range, "<", options);
  };
  var gtr = function(version2, range, options) {
    return outside(version2, range, ">", options);
  };
  var outside = function(version2, range, hilo, options) {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  var prerelease = function(version2, options) {
    var parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  var intersects = function(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  };
  var coerce2 = function(version2, options) {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version2.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  };
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0;i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
      safeRe[i] = new RegExp(makeSafeRe(src[i]));
    }
  }
  var i;
  exports.parse = parse2;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    debug("Comparator.test", version2, this.options.loose);
    if (this.semver === ANY || version2 === ANY) {
      return true;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version2) {
    if (!version2) {
      return false;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0;i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version2, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-annotate-as-pure/lib/index.js
var require_lib25 = __commonJS((exports) => {
  var annotateAsPure = function(pathOrNode) {
    const node2 = pathOrNode["node"] || pathOrNode;
    if (isPureAnnotated(node2)) {
      return;
    }
    addComment(node2, "leading", PURE_ANNOTATION);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = annotateAsPure;
  var _t = require_lib3();
  var {
    addComment
  } = _t;
  var PURE_ANNOTATION = "#__PURE__";
  var isPureAnnotated = ({
    leadingComments
  }) => !!leadingComments && leadingComments.some((comment) => /[@#]__PURE__/.test(comment.value));
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js
var require_typescript3 = __commonJS((exports) => {
  var assertFieldTransformed = function(path3) {
    if (path3.node.declare || false) {
      throw path3.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators`);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertFieldTransformed = assertFieldTransformed;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js
var require_fields = __commonJS((exports) => {
  var buildPrivateNamesMap = function(props) {
    const privateNamesMap = new Map;
    for (const prop of props) {
      if (prop.isPrivate()) {
        const {
          name
        } = prop.node.key.id;
        const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
          id: prop.scope.generateUidIdentifier(name),
          static: prop.node.static,
          method: !prop.isProperty()
        };
        if (prop.isClassPrivateMethod()) {
          if (prop.node.kind === "get") {
            update.getId = prop.scope.generateUidIdentifier(`get_${name}`);
          } else if (prop.node.kind === "set") {
            update.setId = prop.scope.generateUidIdentifier(`set_${name}`);
          } else if (prop.node.kind === "method") {
            update.methodId = prop.scope.generateUidIdentifier(name);
          }
        }
        privateNamesMap.set(name, update);
      }
    }
    return privateNamesMap;
  };
  var buildPrivateNamesNodes = function(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {
    const initNodes = [];
    for (const [name, value2] of privateNamesMap) {
      const {
        static: isStatic,
        method: isMethod,
        getId,
        setId
      } = value2;
      const isAccessor = getId || setId;
      const id = _core.types.cloneNode(value2.id);
      let init;
      if (privateFieldsAsProperties) {
        init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]);
      } else if (privateFieldsAsSymbols) {
        init = _core.types.callExpression(_core.types.identifier("Symbol"), [_core.types.stringLiteral(name)]);
      } else if (!isStatic) {
        init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), []);
      }
      if (init) {
        (0, _helperAnnotateAsPure.default)(init);
        initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);
      }
    }
    return initNodes;
  };
  var privateNameVisitorFactory = function(visitor) {
    const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.default]);
    const privateNameVisitor2 = Object.assign({}, visitor, {
      Class(path3) {
        const {
          privateNamesMap
        } = this;
        const body = path3.get("body.body");
        const visiblePrivateNames = new Map(privateNamesMap);
        const redeclared = [];
        for (const prop of body) {
          if (!prop.isPrivate())
            continue;
          const {
            name
          } = prop.node.key.id;
          visiblePrivateNames.delete(name);
          redeclared.push(name);
        }
        if (!redeclared.length) {
          return;
        }
        path3.get("body").traverse(nestedVisitor, Object.assign({}, this, {
          redeclared
        }));
        path3.traverse(privateNameVisitor2, Object.assign({}, this, {
          privateNamesMap: visiblePrivateNames
        }));
        path3.skipKey("body");
      }
    });
    return privateNameVisitor2;
  };
  var unshadow = function(name, scope, innerBinding) {
    while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {
      var _scope;
      scope.rename(name);
      scope = scope.parent;
    }
  };
  var buildCheckInRHS = function(rhs, file, inRHSIsObject) {
    if (inRHSIsObject || !(file.availableHelper != null && file.availableHelper("checkInRHS")))
      return rhs;
    return _core.types.callExpression(file.addHelper("checkInRHS"), [rhs]);
  };
  var transformPrivateNamesUsage = function(ref, path3, privateNamesMap, {
    privateFieldsAsProperties,
    noDocumentAll,
    innerBinding
  }, state) {
    if (!privateNamesMap.size)
      return;
    const body = path3.get("body");
    const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
    (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({
      privateNamesMap,
      classRef: ref,
      file: state
    }, handler, {
      noDocumentAll,
      innerBinding
    }));
    body.traverse(privateInVisitor, {
      privateNamesMap,
      classRef: ref,
      file: state,
      privateFieldsAsProperties,
      innerBinding
    });
  };
  var buildPrivateFieldInitLoose = function(ref, prop, privateNamesMap) {
    const {
      id
    } = privateNamesMap.get(prop.node.key.id.name);
    const value2 = prop.node.value || prop.scope.buildUndefinedNode();
    return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value2}
      });
    `, prop);
  };
  var buildPrivateInstanceFieldInitSpec = function(ref, prop, privateNamesMap, state) {
    const {
      id
    } = privateNamesMap.get(prop.node.key.id.name);
    const value2 = prop.node.value || prop.scope.buildUndefinedNode();
    {
      if (!state.availableHelper("classPrivateFieldInitSpec")) {
        return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${value2},
        })`, prop);
      }
    }
    const helper = state.addHelper("classPrivateFieldInitSpec");
    return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        writable: true,
        value: ${value2}
      },
    )`, prop);
  };
  var buildPrivateStaticFieldInitSpec = function(prop, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      id,
      getId,
      setId,
      initAdded
    } = privateName;
    const isAccessor = getId || setId;
    if (!prop.isProperty() && (initAdded || !isAccessor))
      return;
    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return inheritPropComments(_core.template.statement.ast`
        var ${_core.types.cloneNode(id)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        }
      `, prop);
    }
    const value2 = prop.node.value || prop.scope.buildUndefinedNode();
    return inheritPropComments(_core.template.statement.ast`
      var ${_core.types.cloneNode(id)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value2}
      };
    `, prop);
  };
  var buildPrivateMethodInitLoose = function(ref, prop, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      methodId,
      id,
      getId,
      setId,
      initAdded
    } = privateName;
    if (initAdded)
      return;
    if (methodId) {
      return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `, prop);
    }
    const isAccessor = getId || setId;
    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        });
      `, prop);
    }
  };
  var buildPrivateInstanceMethodInitSpec = function(ref, prop, privateNamesMap, state) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      getId,
      setId,
      initAdded
    } = privateName;
    if (initAdded)
      return;
    const isAccessor = getId || setId;
    if (isAccessor) {
      return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);
    }
    return buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);
  };
  var buildPrivateAccessorInitialization = function(ref, prop, privateNamesMap, state) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      id,
      getId,
      setId
    } = privateName;
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    {
      if (!state.availableHelper("classPrivateFieldInitSpec")) {
        return inheritPropComments(_core.template.statement.ast`
          ${id}.set(${ref}, {
            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
          });
        `, prop);
      }
    }
    const helper = state.addHelper("classPrivateFieldInitSpec");
    return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      },
    )`, prop);
  };
  var buildPrivateInstanceMethodInitialization = function(ref, prop, privateNamesMap, state) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      id
    } = privateName;
    {
      if (!state.availableHelper("classPrivateMethodInitSpec")) {
        return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);
      }
    }
    const helper = state.addHelper("classPrivateMethodInitSpec");
    return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)}
    )`, prop);
  };
  var buildPublicFieldInitLoose = function(ref, prop) {
    const {
      key,
      computed
    } = prop.node;
    const value2 = prop.node.value || prop.scope.buildUndefinedNode();
    return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value2)), prop);
  };
  var buildPublicFieldInitSpec = function(ref, prop, state) {
    const {
      key,
      computed
    } = prop.node;
    const value2 = prop.node.value || prop.scope.buildUndefinedNode();
    return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value2])), prop);
  };
  var buildPrivateStaticMethodInitLoose = function(ref, prop, state, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      id,
      methodId,
      getId,
      setId,
      initAdded
    } = privateName;
    if (initAdded)
      return;
    const isAccessor = getId || setId;
    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        })
      `, prop);
    }
    return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${methodId.name}
      });
    `, prop);
  };
  var buildPrivateMethodDeclaration = function(prop, privateNamesMap, privateFieldsAsProperties = false) {
    const privateName = privateNamesMap.get(prop.node.key.id.name);
    const {
      id,
      methodId,
      getId,
      setId,
      getterDeclared,
      setterDeclared,
      static: isStatic
    } = privateName;
    const {
      params,
      body,
      generator,
      async
    } = prop.node;
    const isGetter = getId && !getterDeclared && params.length === 0;
    const isSetter = setId && !setterDeclared && params.length > 0;
    let declId = methodId;
    if (isGetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        getterDeclared: true
      }));
      declId = getId;
    } else if (isSetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        setterDeclared: true
      }));
      declId = setId;
    } else if (isStatic && !privateFieldsAsProperties) {
      declId = id;
    }
    return inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);
  };
  var replaceThisContext = function(path3, ref, innerBindingRef) {
    var _state$classRef;
    const state = {
      classRef: ref,
      needsClassRef: false,
      innerBinding: innerBindingRef
    };
    if (!path3.isMethod()) {
      path3.traverse(thisContextVisitor, state);
    }
    if (innerBindingRef != null && (_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== innerBindingRef.name) {
      path3.traverse(innerReferencesVisitor, state);
    }
    return state.needsClassRef;
  };
  var isNameOrLength = function({
    key,
    computed
  }) {
    if (key.type === "Identifier") {
      return !computed && (key.name === "name" || key.name === "length");
    }
    if (key.type === "StringLiteral") {
      return key.value === "name" || key.value === "length";
    }
    return false;
  };
  var inheritPropComments = function(node2, prop) {
    _core.types.inheritLeadingComments(node2, prop.node);
    _core.types.inheritInnerComments(node2, prop.node);
    return node2;
  };
  var buildFieldsInitNodes = function(ref, superRef, props, privateNamesMap, file, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
    var _ref, _ref2;
    let classRefFlags = 0;
    let injectSuperRef;
    const staticNodes = [];
    const instanceNodes = [];
    let lastInstanceNodeReturnsThis = false;
    const pureStaticNodes = [];
    let classBindingNode = null;
    const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {
      var _injectSuperRef;
      (_injectSuperRef = injectSuperRef) != null || (injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef));
      return injectSuperRef;
    };
    const classRefForInnerBinding = (_ref = ref) != null ? _ref : props[0].scope.generateUidIdentifier("class");
    (_ref2 = ref) != null || (ref = _core.types.cloneNode(innerBindingRef));
    for (const prop of props) {
      prop.isClassProperty() && ts.assertFieldTransformed(prop);
      const isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static;
      const isInstance = !isStatic;
      const isPrivate = prop.isPrivate();
      const isPublic = !isPrivate;
      const isField = prop.isProperty();
      const isMethod = !isField;
      const isStaticBlock = prop.isStaticBlock == null ? undefined : prop.isStaticBlock();
      if (isStatic)
        classRefFlags |= 1;
      if (isStatic || isMethod && isPrivate || isStaticBlock) {
        new _helperReplaceSupers.default({
          methodPath: prop,
          constantSuper,
          file,
          refToPreserve: innerBindingRef,
          getSuperRef,
          getObjectRef() {
            classRefFlags |= 2;
            if (isStatic || isStaticBlock) {
              return classRefForInnerBinding;
            } else {
              return _core.types.memberExpression(classRefForInnerBinding, _core.types.identifier("prototype"));
            }
          }
        }).replace();
        const replaced = replaceThisContext(prop, classRefForInnerBinding, innerBindingRef);
        if (replaced) {
          classRefFlags |= 2;
        }
      }
      lastInstanceNodeReturnsThis = false;
      switch (true) {
        case isStaticBlock: {
          const blockBody = prop.node.body;
          if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {
            staticNodes.push(inheritPropComments(blockBody[0], prop));
          } else {
            staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));
          }
          break;
        }
        case (isStatic && isPrivate && isField && privateFieldsAsProperties):
          staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
          break;
        case (isStatic && isPrivate && isField && !privateFieldsAsProperties):
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          break;
        case (isStatic && isPublic && isField && setPublicClassFields):
          if (!isNameOrLength(prop.node)) {
            staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
            break;
          }
        case (isStatic && isPublic && isField && !setPublicClassFields):
          staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, file));
          break;
        case (isInstance && isPrivate && isField && privateFieldsAsProperties):
          instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
          break;
        case (isInstance && isPrivate && isField && !privateFieldsAsProperties):
          instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
          break;
        case (isInstance && isPrivate && isMethod && privateFieldsAsProperties):
          instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;
        case (isInstance && isPrivate && isMethod && !privateFieldsAsProperties):
          instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;
        case (isStatic && isPrivate && isMethod && !privateFieldsAsProperties):
          staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;
        case (isStatic && isPrivate && isMethod && privateFieldsAsProperties):
          staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, file, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;
        case (isInstance && isPublic && isField && setPublicClassFields):
          instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
          break;
        case (isInstance && isPublic && isField && !setPublicClassFields):
          lastInstanceNodeReturnsThis = true;
          instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, file));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    if (classRefFlags & 2 && innerBindingRef != null) {
      classBindingNode = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classRefForInnerBinding), _core.types.cloneNode(innerBindingRef)));
    }
    return {
      staticNodes: staticNodes.filter(Boolean),
      instanceNodes: instanceNodes.filter(Boolean),
      lastInstanceNodeReturnsThis,
      pureStaticNodes: pureStaticNodes.filter(Boolean),
      classBindingNode,
      wrapClass(path3) {
        for (const prop of props) {
          prop.node.leadingComments = null;
          prop.remove();
        }
        if (injectSuperRef) {
          path3.scope.push({
            id: _core.types.cloneNode(injectSuperRef)
          });
          path3.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path3.node.superClass));
        }
        if (classRefFlags !== 0) {
          if (path3.isClassExpression()) {
            path3.scope.push({
              id: ref
            });
            path3.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path3.node));
          } else {
            if (innerBindingRef == null) {
              path3.node.id = ref;
            }
            if (classBindingNode != null) {
              path3.scope.push({
                id: classRefForInnerBinding
              });
            }
          }
        }
        return path3;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildCheckInRHS = buildCheckInRHS;
  exports.buildFieldsInitNodes = buildFieldsInitNodes;
  exports.buildPrivateNamesMap = buildPrivateNamesMap;
  exports.buildPrivateNamesNodes = buildPrivateNamesNodes;
  exports.transformPrivateNamesUsage = transformPrivateNamesUsage;
  var _core = require_lib33();
  var _helperReplaceSupers = require_lib23();
  var _helperEnvironmentVisitor = require_lib6();
  var _helperMemberExpressionToFunctions = require_lib21();
  var _helperOptimiseCallExpression = require_lib22();
  var _helperAnnotateAsPure = require_lib25();
  var _helperSkipTransparentExpressionWrappers = require_lib24();
  var ts = require_typescript3();
  var privateNameVisitor = privateNameVisitorFactory({
    PrivateName(path3, {
      noDocumentAll
    }) {
      const {
        privateNamesMap,
        redeclared
      } = this;
      const {
        node: node2,
        parentPath
      } = path3;
      if (!parentPath.isMemberExpression({
        property: node2
      }) && !parentPath.isOptionalMemberExpression({
        property: node2
      })) {
        return;
      }
      const {
        name
      } = node2.id;
      if (!privateNamesMap.has(name))
        return;
      if (redeclared && redeclared.includes(name))
        return;
      this.handle(parentPath, noDocumentAll);
    }
  });
  var privateInVisitor = privateNameVisitorFactory({
    BinaryExpression(path3, {
      file
    }) {
      const {
        operator,
        left: left2,
        right: right2
      } = path3.node;
      if (operator !== "in")
        return;
      if (!_core.types.isPrivateName(left2))
        return;
      const {
        privateFieldsAsProperties,
        privateNamesMap,
        redeclared
      } = this;
      const {
        name
      } = left2.id;
      if (!privateNamesMap.has(name))
        return;
      if (redeclared && redeclared.includes(name))
        return;
      unshadow(this.classRef.name, path3.scope, this.innerBinding);
      if (privateFieldsAsProperties) {
        const {
          id: id2
        } = privateNamesMap.get(name);
        path3.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right2, file)}, ${_core.types.cloneNode(id2)})
      `);
        return;
      }
      const {
        id,
        static: isStatic
      } = privateNamesMap.get(name);
      if (isStatic) {
        path3.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right2, file)} === ${_core.types.cloneNode(this.classRef)}`);
        return;
      }
      path3.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right2, file)})`);
    }
  });
  var privateNameHandlerSpec = {
    memoise(member, count) {
      const {
        scope
      } = member;
      const {
        object
      } = member.node;
      const memo = scope.maybeGenerateMemoised(object);
      if (!memo) {
        return;
      }
      this.memoiser.set(object, memo, count);
    },
    receiver(member) {
      const {
        object
      } = member.node;
      if (this.memoiser.has(object)) {
        return _core.types.cloneNode(this.memoiser.get(object));
      }
      return _core.types.cloneNode(object);
    },
    get(member) {
      const {
        classRef,
        privateNamesMap,
        file,
        innerBinding
      } = this;
      const {
        name
      } = member.node.property.id;
      const {
        id,
        static: isStatic,
        method: isMethod,
        methodId,
        getId,
        setId
      } = privateNamesMap.get(name);
      const isAccessor = getId || setId;
      if (isStatic) {
        const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
        unshadow(classRef.name, member.scope, innerBinding);
        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);
      }
      if (isMethod) {
        if (isAccessor) {
          if (!getId && setId) {
            if (file.availableHelper("writeOnlyError")) {
              return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral(`#${name}`)])]);
            }
            console.warn(`@babel/helpers is outdated, update it to silence this warning.`);
          }
          return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
        }
        return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);
      }
      return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
    },
    boundGet(member) {
      this.memoise(member, 1);
      return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
    },
    set(member, value2) {
      const {
        classRef,
        privateNamesMap,
        file
      } = this;
      const {
        name
      } = member.node.property.id;
      const {
        id,
        static: isStatic,
        method: isMethod,
        setId,
        getId
      } = privateNamesMap.get(name);
      const isAccessor = getId || setId;
      if (isStatic) {
        const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value2]);
      }
      if (isMethod) {
        if (setId) {
          return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value2]);
        }
        return _core.types.sequenceExpression([this.receiver(member), value2, _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral(`#${name}`)])]);
      }
      return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value2]);
    },
    destructureSet(member) {
      const {
        classRef,
        privateNamesMap,
        file
      } = this;
      const {
        name
      } = member.node.property.id;
      const {
        id,
        static: isStatic
      } = privateNamesMap.get(name);
      if (isStatic) {
        try {
          var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
        } catch (_unused) {
          throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
        }
        return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier("value"));
      }
      return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier("value"));
    },
    call(member, args) {
      this.memoise(member, 1);
      return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);
    },
    optionalCall(member, args) {
      this.memoise(member, 1);
      return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  };
  var privateNameHandlerLoose = {
    get(member) {
      const {
        privateNamesMap,
        file
      } = this;
      const {
        object
      } = member.node;
      const {
        name
      } = member.node.property.id;
      return _core.template.expression`BASE(REF, PROP)[PROP]`({
        BASE: file.addHelper("classPrivateFieldLooseBase"),
        REF: _core.types.cloneNode(object),
        PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
      });
    },
    set() {
      throw new Error("private name handler with loose = true don't need set()");
    },
    boundGet(member) {
      return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
    },
    simpleSet(member) {
      return this.get(member);
    },
    destructureSet(member) {
      return this.get(member);
    },
    call(member, args) {
      return _core.types.callExpression(this.get(member), args);
    },
    optionalCall(member, args) {
      return _core.types.optionalCallExpression(this.get(member), args, true);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  };
  var thisContextVisitor = _core.traverse.visitors.merge([{
    UnaryExpression(path3) {
      const {
        node: node2
      } = path3;
      if (node2.operator === "delete") {
        const argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node2.argument);
        if (_core.types.isThisExpression(argument)) {
          path3.replaceWith(_core.types.booleanLiteral(true));
        }
      }
    },
    ThisExpression(path3, state) {
      state.needsClassRef = true;
      path3.replaceWith(_core.types.cloneNode(state.classRef));
    },
    MetaProperty(path3) {
      const {
        node: node2,
        scope
      } = path3;
      if (node2.meta.name === "new" && node2.property.name === "target") {
        path3.replaceWith(scope.buildUndefinedNode());
      }
    }
  }, _helperEnvironmentVisitor.default]);
  var innerReferencesVisitor = {
    ReferencedIdentifier(path3, state) {
      if (path3.scope.bindingIdentifierEquals(path3.node.name, state.innerBinding)) {
        state.needsClassRef = true;
        path3.node.name = state.classRef.name;
      }
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js
var require_decorators_2018_09 = __commonJS((exports) => {
  var hasOwnDecorators = function(node2) {
    var _node$decorators;
    return !!((_node$decorators = node2.decorators) != null && _node$decorators.length);
  };
  var hasDecorators = function(node2) {
    return hasOwnDecorators(node2) || node2.body.body.some(hasOwnDecorators);
  };
  var prop = function(key, value2) {
    if (!value2)
      return null;
    return _core.types.objectProperty(_core.types.identifier(key), value2);
  };
  var method = function(key, body) {
    return _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body));
  };
  var takeDecorators = function(node2) {
    let result;
    if (node2.decorators && node2.decorators.length > 0) {
      result = _core.types.arrayExpression(node2.decorators.map((decorator) => decorator.expression));
    }
    node2.decorators = undefined;
    return result;
  };
  var getKey = function(node2) {
    if (node2.computed) {
      return node2.key;
    } else if (_core.types.isIdentifier(node2.key)) {
      return _core.types.stringLiteral(node2.key.name);
    } else {
      return _core.types.stringLiteral(String(node2.key.value));
    }
  };
  var extractElementDescriptor = function(file, classRef, superRef, path3) {
    const isMethod = path3.isClassMethod();
    if (path3.isPrivate()) {
      throw path3.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
    }
    if (path3.node.type === "ClassAccessorProperty") {
      throw path3.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`);
    }
    if (path3.node.type === "StaticBlock") {
      throw path3.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`);
    }
    const {
      node: node2,
      scope
    } = path3;
    if (!path3.isTSDeclareMethod()) {
      new _helperReplaceSupers.default({
        methodPath: path3,
        objectRef: classRef,
        superRef,
        file,
        refToPreserve: classRef
      }).replace();
    }
    const properties = [prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node2) ? node2.kind : "field")), prop("decorators", takeDecorators(node2)), prop("static", node2.static && _core.types.booleanLiteral(true)), prop("key", getKey(node2))].filter(Boolean);
    if (_core.types.isClassMethod(node2)) {
      const id = node2.computed ? null : node2.key;
      const transformed = _core.types.toExpression(node2);
      properties.push(prop("value", (0, _helperFunctionName.default)({
        node: transformed,
        id,
        scope
      }) || transformed));
    } else if (_core.types.isClassProperty(node2) && node2.value) {
      properties.push(method("value", _core.template.statements.ast`return ${node2.value}`));
    } else {
      properties.push(prop("value", scope.buildUndefinedNode()));
    }
    path3.remove();
    return _core.types.objectExpression(properties);
  };
  var addDecorateHelper = function(file) {
    return file.addHelper("decorate");
  };
  var buildDecoratedClass = function(ref, path3, elements, file) {
    const {
      node: node2,
      scope
    } = path3;
    const initializeId = scope.generateUidIdentifier("initialize");
    const isDeclaration = node2.id && path3.isDeclaration();
    const isStrict = path3.isInStrictMode();
    const {
      superClass
    } = node2;
    node2.type = "ClassDeclaration";
    if (!node2.id)
      node2.id = _core.types.cloneNode(ref);
    let superId;
    if (superClass) {
      superId = scope.generateUidIdentifierBasedOnNode(node2.superClass, "super");
      node2.superClass = superId;
    }
    const classDecorators = takeDecorators(node2);
    const definitions = _core.types.arrayExpression(elements.filter((element) => !element.node.abstract && element.node.type !== "TSIndexSignature").map((path4) => extractElementDescriptor(file, node2.id, superId, path4)));
    const wrapperCall = _core.template.expression.ast`
    ${addDecorateHelper(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node2}
        return { F: ${_core.types.cloneNode(node2.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
    if (!isStrict) {
      wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
    }
    let replacement = wrapperCall;
    let classPathDesc = "arguments.1.body.body.0";
    if (isDeclaration) {
      replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`;
      classPathDesc = "declarations.0.init." + classPathDesc;
    }
    return {
      instanceNodes: [_core.template.statement.ast`
        ${_core.types.cloneNode(initializeId)}(this)
      `],
      wrapClass(path4) {
        path4.replaceWith(replacement);
        return path4.get(classPathDesc);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildDecoratedClass = buildDecoratedClass;
  exports.hasDecorators = hasDecorators;
  exports.hasOwnDecorators = hasOwnDecorators;
  var _core = require_lib33();
  var _helperReplaceSupers = require_lib23();
  var _helperFunctionName = require_lib12();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js
var require_misc2 = __commonJS((exports) => {
  var handleClassTDZ = function(path3, state) {
    if (state.classBinding && state.classBinding === path3.scope.getBinding(path3.node.name)) {
      const classNameTDZError = state.file.addHelper("classNameTDZError");
      const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path3.node.name)]);
      path3.replaceWith(_core.types.sequenceExpression([throwNode, path3.node]));
      path3.skip();
    }
  };
  var injectInitialization = function(path3, constructor, nodes, renamer, lastReturnsThis) {
    if (!nodes.length)
      return;
    const isDerived = !!path3.node.superClass;
    if (!constructor) {
      const newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
      if (isDerived) {
        newConstructor.params = [_core.types.restElement(_core.types.identifier("args"))];
        newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);
      }
      [constructor] = path3.get("body").unshiftContainer("body", newConstructor);
    }
    if (renamer) {
      renamer(referenceVisitor, {
        scope: constructor.scope
      });
    }
    if (isDerived) {
      const bareSupers = [];
      constructor.traverse(findBareSupers, bareSupers);
      let isFirst = true;
      for (const bareSuper of bareSupers) {
        if (isFirst) {
          isFirst = false;
        } else {
          nodes = nodes.map((n) => _core.types.cloneNode(n));
        }
        if (!bareSuper.parentPath.isExpressionStatement()) {
          const allNodes = [bareSuper.node, ...nodes.map((n) => _core.types.toExpression(n))];
          if (!lastReturnsThis)
            allNodes.push(_core.types.thisExpression());
          bareSuper.replaceWith(_core.types.sequenceExpression(allNodes));
        } else {
          bareSuper.insertAfter(nodes);
        }
      }
    } else {
      constructor.get("body").unshiftContainer("body", nodes);
    }
  };
  var extractComputedKeys = function(path3, computedPaths, file) {
    const declarations = [];
    const state = {
      classBinding: path3.node.id && path3.scope.getBinding(path3.node.id.name),
      file
    };
    for (const computedPath of computedPaths) {
      const computedKey = computedPath.get("key");
      if (computedKey.isReferencedIdentifier()) {
        handleClassTDZ(computedKey, state);
      } else {
        computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
      }
      const computedNode = computedPath.node;
      if (!computedKey.isConstantExpression()) {
        const scope = path3.scope;
        const isUidReference = _core.types.isIdentifier(computedKey.node) && scope.hasUid(computedKey.node.name);
        const isMemoiseAssignment = computedKey.isAssignmentExpression({
          operator: "="
        }) && _core.types.isIdentifier(computedKey.node.left) && scope.hasUid(computedKey.node.left.name);
        if (isUidReference) {
          continue;
        } else if (isMemoiseAssignment) {
          declarations.push(_core.types.expressionStatement(_core.types.cloneNode(computedNode.key)));
          computedNode.key = _core.types.cloneNode(computedNode.key.left);
        } else {
          const ident = path3.scope.generateUidIdentifierBasedOnNode(computedNode.key);
          scope.push({
            id: ident,
            kind: "let"
          });
          declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(ident), computedNode.key)));
          computedNode.key = _core.types.cloneNode(ident);
        }
      }
    }
    return declarations;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.extractComputedKeys = extractComputedKeys;
  exports.injectInitialization = injectInitialization;
  var _core = require_lib33();
  var _helperEnvironmentVisitor = require_lib6();
  var findBareSupers = _core.traverse.visitors.merge([{
    Super(path3) {
      const {
        node: node2,
        parentPath
      } = path3;
      if (parentPath.isCallExpression({
        callee: node2
      })) {
        this.push(parentPath);
      }
    }
  }, _helperEnvironmentVisitor.default]);
  var referenceVisitor = {
    "TSTypeAnnotation|TypeAnnotation"(path3) {
      path3.skip();
    },
    ReferencedIdentifier(path3, {
      scope
    }) {
      if (scope.hasOwnBinding(path3.node.name)) {
        scope.rename(path3.node.name);
        path3.skip();
      }
    }
  };
  var classFieldDefinitionEvaluationTDZVisitor = {
    ReferencedIdentifier: handleClassTDZ
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/features.js
var require_features = __commonJS((exports) => {
  var enableFeature = function(file, feature, loose) {
    if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {
      file.set(featuresKey, file.get(featuresKey) | feature);
      if (loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
        setLoose(file, feature, true);
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
      } else if (loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
        setLoose(file, feature, false);
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
      } else {
        setLoose(file, feature, loose);
      }
    }
    let resolvedLoose;
    for (const [mask, name] of featuresSameLoose) {
      if (!hasFeature(file, mask))
        continue;
      {
        if (canIgnoreLoose(file, mask))
          continue;
      }
      const loose2 = isLoose(file, mask);
      if (resolvedLoose === !loose2) {
        throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");
      } else {
        resolvedLoose = loose2;
        {
          var higherPriorityPluginName = name;
        }
      }
    }
    if (resolvedLoose !== undefined) {
      for (const [mask, name] of featuresSameLoose) {
        if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {
          setLoose(file, mask, resolvedLoose);
          console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env ` + `config, it will not be used for ${name} since the "loose" mode option was set to ` + `"${resolvedLoose}" for ${higherPriorityPluginName}.\nThe "loose" option must be the ` + `same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n` + `\t["${name}", { "loose": ${resolvedLoose} }]\n` + `to the "plugins" section of your Babel config.`);
        }
      }
    }
  };
  var hasFeature = function(file, feature) {
    return !!(file.get(featuresKey) & feature);
  };
  var isLoose = function(file, feature) {
    return !!(file.get(looseKey) & feature);
  };
  var setLoose = function(file, feature, loose) {
    if (loose)
      file.set(looseKey, file.get(looseKey) | feature);
    else
      file.set(looseKey, file.get(looseKey) & ~feature);
    {
      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
    }
  };
  var shouldTransform = function(path3, file) {
    let decoratorPath = null;
    let publicFieldPath = null;
    let privateFieldPath = null;
    let privateMethodPath = null;
    let staticBlockPath = null;
    if ((0, _decorators.hasOwnDecorators)(path3.node)) {
      decoratorPath = path3.get("decorators.0");
    }
    for (const el of path3.get("body.body")) {
      if (!decoratorPath && (0, _decorators.hasOwnDecorators)(el.node)) {
        decoratorPath = el.get("decorators.0");
      }
      if (!publicFieldPath && el.isClassProperty()) {
        publicFieldPath = el;
      }
      if (!privateFieldPath && el.isClassPrivateProperty()) {
        privateFieldPath = el;
      }
      if (!privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod()) {
        privateMethodPath = el;
      }
      if (!staticBlockPath && el.isStaticBlock != null && el.isStaticBlock()) {
        staticBlockPath = el;
      }
    }
    if (decoratorPath && privateFieldPath) {
      throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    }
    if (decoratorPath && privateMethodPath) {
      throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    }
    if (decoratorPath && !hasFeature(file, FEATURES.decorators)) {
      throw path3.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n\t["@babel/plugin-transform-class-properties", { "loose": true }]');
    }
    if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods)) {
      throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
    }
    if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods)) {
      throw path3.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
    }
    if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks)) {
      throw path3.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
    }
    if (decoratorPath || privateMethodPath || staticBlockPath) {
      return true;
    }
    if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields)) {
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FEATURES = undefined;
  exports.enableFeature = enableFeature;
  exports.isLoose = isLoose;
  exports.shouldTransform = shouldTransform;
  var _decorators = require_decorators_2018_09();
  var FEATURES = exports.FEATURES = Object.freeze({
    fields: 1 << 1,
    privateMethods: 1 << 2,
    decorators: 1 << 3,
    privateIn: 1 << 4,
    staticBlocks: 1 << 5
  });
  var featuresSameLoose = new Map([[FEATURES.fields, "@babel/plugin-transform-class-properties"], [FEATURES.privateMethods, "@babel/plugin-transform-private-methods"], [FEATURES.privateIn, "@babel/plugin-transform-private-property-in-object"]]);
  var featuresKey = "@babel/plugin-class-features/featuresKey";
  var looseKey = "@babel/plugin-class-features/looseKey";
  {
    looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  }
  var looseLowPriorityKey;
  {
    canIgnoreLoose = function(file, feature) {
      return !!(file.get(looseLowPriorityKey) & feature);
    };
  }
  var canIgnoreLoose;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-create-class-features-plugin/lib/index.js
var require_lib26 = __commonJS((exports) => {
  var createClassFeaturePlugin = function({
    name,
    feature,
    loose,
    manipulateOptions,
    api,
    inherits,
    decoratorVersion
  }) {
    if (feature & _features.FEATURES.decorators) {
      {
        if (decoratorVersion === "2021-12" || decoratorVersion === "2022-03" || decoratorVersion === "2023-01" || decoratorVersion === "2023-05") {
          return (0, _decorators.default)(api, {
            loose
          }, decoratorVersion, inherits);
        }
      }
    }
    {
      var _api;
      (_api = api) != null || (api = {
        assumption: () => {
          return;
        }
      });
    }
    const setPublicClassFields = api.assumption("setPublicClassFields");
    const privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols");
    const privateFieldsAsProperties = api.assumption("privateFieldsAsProperties");
    const constantSuper = api.assumption("constantSuper");
    const noDocumentAll = api.assumption("noDocumentAll");
    if (privateFieldsAsProperties && privateFieldsAsSymbols) {
      throw new Error(`Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.`);
    }
    const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;
    if (loose === true) {
      const explicit = [];
      if (setPublicClassFields !== undefined) {
        explicit.push(`"setPublicClassFields"`);
      }
      if (privateFieldsAsProperties !== undefined) {
        explicit.push(`"privateFieldsAsProperties"`);
      }
      if (privateFieldsAsSymbols !== undefined) {
        explicit.push(`"privateFieldsAsSymbols"`);
      }
      if (explicit.length !== 0) {
        console.warn(`[${name}]: You are using the "loose: true" option and you are` + ` explicitly setting a value for the ${explicit.join(" and ")}` + ` assumption${explicit.length > 1 ? "s" : ""}. The "loose" option` + ` can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsSymbols": true\n\t}`);
      }
    }
    return {
      name,
      manipulateOptions,
      inherits,
      pre(file) {
        (0, _features.enableFeature)(file, feature, loose);
        {
          if (typeof file.get(versionKey) === "number") {
            file.set(versionKey, "7.23.7");
            return;
          }
        }
        if (!file.get(versionKey) || _semver.lt(file.get(versionKey), "7.23.7")) {
          file.set(versionKey, "7.23.7");
        }
      },
      visitor: {
        Class(path3, {
          file
        }) {
          var _ref;
          if (file.get(versionKey) !== "7.23.7")
            return;
          if (!(0, _features.shouldTransform)(path3, file))
            return;
          const pathIsClassDeclaration = path3.isClassDeclaration();
          if (pathIsClassDeclaration)
            (0, _typescript.assertFieldTransformed)(path3);
          const loose2 = (0, _features.isLoose)(file, feature);
          let constructor;
          const isDecorated = (0, _decorators2.hasDecorators)(path3.node);
          const props = [];
          const elements = [];
          const computedPaths = [];
          const privateNames = new Set;
          const body = path3.get("body");
          for (const path4 of body.get("body")) {
            if ((path4.isClassProperty() || path4.isClassMethod()) && path4.node.computed) {
              computedPaths.push(path4);
            }
            if (path4.isPrivate()) {
              const {
                name: name2
              } = path4.node.key.id;
              const getName = `get ${name2}`;
              const setName = `set ${name2}`;
              if (path4.isClassPrivateMethod()) {
                if (path4.node.kind === "get") {
                  if (privateNames.has(getName) || privateNames.has(name2) && !privateNames.has(setName)) {
                    throw path4.buildCodeFrameError("Duplicate private field");
                  }
                  privateNames.add(getName).add(name2);
                } else if (path4.node.kind === "set") {
                  if (privateNames.has(setName) || privateNames.has(name2) && !privateNames.has(getName)) {
                    throw path4.buildCodeFrameError("Duplicate private field");
                  }
                  privateNames.add(setName).add(name2);
                }
              } else {
                if (privateNames.has(name2) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name2) && (privateNames.has(getName) || privateNames.has(setName))) {
                  throw path4.buildCodeFrameError("Duplicate private field");
                }
                privateNames.add(name2);
              }
            }
            if (path4.isClassMethod({
              kind: "constructor"
            })) {
              constructor = path4;
            } else {
              elements.push(path4);
              if (path4.isProperty() || path4.isPrivate() || path4.isStaticBlock != null && path4.isStaticBlock()) {
                props.push(path4);
              }
            }
          }
          {
            if (!props.length && !isDecorated)
              return;
          }
          const innerBinding = path3.node.id;
          let ref;
          if (!innerBinding || !pathIsClassDeclaration) {
            (0, _helperFunctionName.default)(path3);
            ref = path3.scope.generateUidIdentifier("class");
          }
          const classRefForDefine = (_ref = ref) != null ? _ref : _core.types.cloneNode(innerBinding);
          const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);
          const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose2, privateFieldsAsSymbols != null ? privateFieldsAsSymbols : false, file);
          (0, _fields.transformPrivateNamesUsage)(classRefForDefine, path3, privateNamesMap, {
            privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose2,
            noDocumentAll,
            innerBinding
          }, file);
          let keysNodes, staticNodes, instanceNodes, lastInstanceNodeReturnsThis, pureStaticNodes, classBindingNode, wrapClass;
          {
            if (isDecorated) {
              staticNodes = pureStaticNodes = keysNodes = [];
              ({
                instanceNodes,
                wrapClass
              } = (0, _decorators2.buildDecoratedClass)(classRefForDefine, path3, elements, file));
            } else {
              keysNodes = (0, _misc.extractComputedKeys)(path3, computedPaths, file);
              ({
                staticNodes,
                pureStaticNodes,
                instanceNodes,
                lastInstanceNodeReturnsThis,
                classBindingNode,
                wrapClass
              } = (0, _fields.buildFieldsInitNodes)(ref, path3.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose2, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose2, constantSuper != null ? constantSuper : loose2, innerBinding));
            }
          }
          if (instanceNodes.length > 0) {
            (0, _misc.injectInitialization)(path3, constructor, instanceNodes, (referenceVisitor, state) => {
              {
                if (isDecorated)
                  return;
              }
              for (const prop of props) {
                if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static)
                  continue;
                prop.traverse(referenceVisitor, state);
              }
            }, lastInstanceNodeReturnsThis);
          }
          const wrappedPath = wrapClass(path3);
          wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);
          if (staticNodes.length > 0) {
            wrappedPath.insertAfter(staticNodes);
          }
          if (pureStaticNodes.length > 0) {
            wrappedPath.find((parent) => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);
          }
          if (classBindingNode != null && pathIsClassDeclaration) {
            wrappedPath.insertAfter(classBindingNode);
          }
        },
        ExportDefaultDeclaration(path3, {
          file
        }) {
          {
            if (file.get(versionKey) !== "7.23.7")
              return;
            const decl = path3.get("declaration");
            if (decl.isClassDeclaration() && (0, _decorators2.hasDecorators)(decl.node)) {
              if (decl.node.id) {
                (0, _helperSplitExportDeclaration.default)(path3);
              } else {
                decl.node.type = "ClassExpression";
              }
            }
          }
        }
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "FEATURES", {
    enumerable: true,
    get: function() {
      return _features.FEATURES;
    }
  });
  Object.defineProperty(exports, "buildCheckInRHS", {
    enumerable: true,
    get: function() {
      return _fields.buildCheckInRHS;
    }
  });
  exports.createClassFeaturePlugin = createClassFeaturePlugin;
  Object.defineProperty(exports, "enableFeature", {
    enumerable: true,
    get: function() {
      return _features.enableFeature;
    }
  });
  Object.defineProperty(exports, "injectInitialization", {
    enumerable: true,
    get: function() {
      return _misc.injectInitialization;
    }
  });
  var _core = require_lib33();
  var _helperFunctionName = require_lib12();
  var _helperSplitExportDeclaration = require_lib5();
  var _decorators = require_decorators();
  var _semver = require_semver2();
  var _fields = require_fields();
  var _decorators2 = require_decorators_2018_09();
  var _misc = require_misc2();
  var _features = require_features();
  var _typescript = require_typescript3();
  var versionKey = "@babel/plugin-class-features/version";
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-typescript/lib/enum.js
var require_enum = __commonJS((exports) => {
  var transpileEnum = function(path3, t) {
    const {
      node: node2,
      parentPath
    } = path3;
    if (node2.declare) {
      path3.remove();
      return;
    }
    const name = node2.id.name;
    const {
      fill,
      data,
      isPure
    } = enumFill(path3, t, node2.id);
    switch (parentPath.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        const isGlobal = t.isProgram(path3.parent);
        const isSeen = seen(parentPath);
        let init = t.objectExpression([]);
        if (isSeen || isGlobal) {
          init = t.logicalExpression("||", t.cloneNode(fill.ID), init);
        }
        const enumIIFE = buildEnumWrapper(Object.assign({}, fill, {
          INIT: init
        }));
        if (isPure)
          (0, _helperAnnotateAsPure.default)(enumIIFE);
        if (isSeen) {
          const toReplace = parentPath.isExportDeclaration() ? parentPath : path3;
          toReplace.replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(node2.id), enumIIFE)));
        } else {
          path3.scope.registerDeclaration(path3.replaceWith(t.variableDeclaration(isGlobal ? "var" : "let", [t.variableDeclarator(node2.id, enumIIFE)]))[0]);
        }
        ENUMS.set(path3.scope.getBindingIdentifier(name), data);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${path3.parent.type}`);
    }
    function seen(parentPath2) {
      if (parentPath2.isExportDeclaration()) {
        return seen(parentPath2.parentPath);
      }
      if (parentPath2.getData(name)) {
        return true;
      } else {
        parentPath2.setData(name, true);
        return false;
      }
    }
  };
  var enumFill = function(path3, t, id) {
    const {
      enumValues: x,
      data,
      isPure
    } = translateEnumValues(path3, t);
    const assignments = x.map(([memberName, memberValue]) => buildEnumMember(t.isStringLiteral(memberValue), {
      ENUM: t.cloneNode(id),
      NAME: memberName,
      VALUE: memberValue
    }));
    return {
      fill: {
        ID: t.cloneNode(id),
        ASSIGNMENTS: assignments
      },
      data,
      isPure
    };
  };
  var ReferencedIdentifier = function(expr, state) {
    const {
      seen,
      path: path3,
      t
    } = state;
    const name = expr.node.name;
    if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {
      expr.replaceWith(t.memberExpression(t.cloneNode(path3.node.id), t.cloneNode(expr.node)));
      expr.skip();
    }
  };
  var translateEnumValues = function(path3, t) {
    var _ENUMS$get;
    const bindingIdentifier = path3.scope.getBindingIdentifier(path3.node.id.name);
    const seen = (_ENUMS$get = ENUMS.get(bindingIdentifier)) != null ? _ENUMS$get : new Map;
    let constValue = -1;
    let lastName;
    let isPure = true;
    const enumValues = path3.get("members").map((memberPath) => {
      const member = memberPath.node;
      const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
      const initializerPath = memberPath.get("initializer");
      const initializer = member.initializer;
      let value2;
      if (initializer) {
        constValue = computeConstantValue(initializerPath, seen);
        if (constValue !== undefined) {
          seen.set(name, constValue);
          _assert(typeof constValue === "number" || typeof constValue === "string");
          if (constValue === Infinity || Number.isNaN(constValue)) {
            value2 = t.identifier(String(constValue));
          } else if (constValue === (-Infinity)) {
            value2 = t.unaryExpression("-", t.identifier("Infinity"));
          } else {
            value2 = t.valueToNode(constValue);
          }
        } else {
          isPure && (isPure = initializerPath.isPure());
          if (initializerPath.isReferencedIdentifier()) {
            ReferencedIdentifier(initializerPath, {
              t,
              seen,
              path: path3
            });
          } else {
            initializerPath.traverse(enumSelfReferenceVisitor, {
              t,
              seen,
              path: path3
            });
          }
          value2 = initializerPath.node;
          seen.set(name, undefined);
        }
      } else if (typeof constValue === "number") {
        constValue += 1;
        value2 = t.numericLiteral(constValue);
        seen.set(name, constValue);
      } else if (typeof constValue === "string") {
        throw path3.buildCodeFrameError("Enum member must have initializer.");
      } else {
        const lastRef = t.memberExpression(t.cloneNode(path3.node.id), t.stringLiteral(lastName), true);
        value2 = t.binaryExpression("+", t.numericLiteral(1), lastRef);
        seen.set(name, undefined);
      }
      lastName = name;
      return [name, value2];
    });
    return {
      isPure,
      data: seen,
      enumValues
    };
  };
  var computeConstantValue = function(path3, prevMembers, seen = new Set) {
    return evaluate(path3);
    function evaluate(path4) {
      const expr = path4.node;
      switch (expr.type) {
        case "MemberExpression":
          return evaluateRef(path4, prevMembers, seen);
        case "StringLiteral":
          return expr.value;
        case "UnaryExpression":
          return evalUnaryExpression(path4);
        case "BinaryExpression":
          return evalBinaryExpression(path4);
        case "NumericLiteral":
          return expr.value;
        case "ParenthesizedExpression":
          return evaluate(path4.get("expression"));
        case "Identifier":
          return evaluateRef(path4, prevMembers, seen);
        case "TemplateLiteral": {
          if (expr.quasis.length === 1) {
            return expr.quasis[0].value.cooked;
          }
          const paths = path4.get("expressions");
          const quasis = expr.quasis;
          let str = "";
          for (let i = 0;i < quasis.length; i++) {
            str += quasis[i].value.cooked;
            if (i + 1 < quasis.length) {
              const value2 = evaluateRef(paths[i], prevMembers, seen);
              if (value2 === undefined)
                return;
              str += value2;
            }
          }
          return str;
        }
        default:
          return;
      }
    }
    function evaluateRef(path4, prevMembers2, seen2) {
      if (path4.isMemberExpression()) {
        const expr = path4.node;
        const obj = expr.object;
        const prop = expr.property;
        if (!_core.types.isIdentifier(obj) || (expr.computed ? !_core.types.isStringLiteral(prop) : !_core.types.isIdentifier(prop))) {
          return;
        }
        const bindingIdentifier = path4.scope.getBindingIdentifier(obj.name);
        const data = ENUMS.get(bindingIdentifier);
        if (!data)
          return;
        return data.get(prop.computed ? prop.value : prop.name);
      } else if (path4.isIdentifier()) {
        const name = path4.node.name;
        if (["Infinity", "NaN"].includes(name)) {
          return Number(name);
        }
        let value2 = prevMembers2 == null ? undefined : prevMembers2.get(name);
        if (value2 !== undefined) {
          return value2;
        }
        if (seen2.has(path4.node))
          return;
        seen2.add(path4.node);
        value2 = computeConstantValue(path4.resolve(), prevMembers2, seen2);
        prevMembers2 == null || prevMembers2.set(name, value2);
        return value2;
      }
    }
    function evalUnaryExpression(path4) {
      const value2 = evaluate(path4.get("argument"));
      if (value2 === undefined) {
        return;
      }
      switch (path4.node.operator) {
        case "+":
          return value2;
        case "-":
          return -value2;
        case "~":
          return ~value2;
        default:
          return;
      }
    }
    function evalBinaryExpression(path4) {
      const left2 = evaluate(path4.get("left"));
      if (left2 === undefined) {
        return;
      }
      const right2 = evaluate(path4.get("right"));
      if (right2 === undefined) {
        return;
      }
      switch (path4.node.operator) {
        case "|":
          return left2 | right2;
        case "&":
          return left2 & right2;
        case ">>":
          return left2 >> right2;
        case ">>>":
          return left2 >>> right2;
        case "<<":
          return left2 << right2;
        case "^":
          return left2 ^ right2;
        case "*":
          return left2 * right2;
        case "/":
          return left2 / right2;
        case "+":
          return left2 + right2;
        case "-":
          return left2 - right2;
        case "%":
          return left2 % right2;
        case "**":
          return Math.pow(left2, right2);
        default:
          return;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transpileEnum;
  exports.translateEnumValues = translateEnumValues;
  var _core = require_lib33();
  var _assert = __require("assert");
  var _helperAnnotateAsPure = require_lib25();
  var ENUMS = new WeakMap;
  var buildEnumWrapper = _core.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
  var buildStringAssignment = (0, _core.template)(`
  ENUM["NAME"] = VALUE;
`);
  var buildNumericAssignment = (0, _core.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`);
  var buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);
  var enumSelfReferenceVisitor = {
    ReferencedIdentifier
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js
var require_const_enum = __commonJS((exports) => {
  var transpileConstEnum = function(path3, t) {
    const {
      name
    } = path3.node.id;
    const parentIsExport = path3.parentPath.isExportNamedDeclaration();
    let isExported = parentIsExport;
    if (!isExported && t.isProgram(path3.parent)) {
      isExported = path3.parent.body.some((stmt) => t.isExportNamedDeclaration(stmt) && stmt.exportKind !== "type" && !stmt.source && stmt.specifiers.some((spec) => t.isExportSpecifier(spec) && spec.exportKind !== "type" && spec.local.name === name));
    }
    const {
      enumValues: entries
    } = (0, _enum.translateEnumValues)(path3, t);
    if (isExported) {
      const obj = t.objectExpression(entries.map(([name2, value2]) => t.objectProperty(t.isValidIdentifier(name2) ? t.identifier(name2) : t.stringLiteral(name2), value2)));
      if (path3.scope.hasOwnBinding(name)) {
        (parentIsExport ? path3.parentPath : path3).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [path3.node.id, obj])));
      } else {
        path3.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(path3.node.id, obj)]));
        path3.scope.registerDeclaration(path3);
      }
      return;
    }
    const entriesMap = new Map(entries);
    path3.scope.path.traverse({
      Scope(path4) {
        if (path4.scope.hasOwnBinding(name))
          path4.skip();
      },
      MemberExpression(path4) {
        if (!t.isIdentifier(path4.node.object, {
          name
        }))
          return;
        let key;
        if (path4.node.computed) {
          if (t.isStringLiteral(path4.node.property)) {
            key = path4.node.property.value;
          } else {
            return;
          }
        } else if (t.isIdentifier(path4.node.property)) {
          key = path4.node.property.name;
        } else {
          return;
        }
        if (!entriesMap.has(key))
          return;
        path4.replaceWith(t.cloneNode(entriesMap.get(key)));
      }
    });
    path3.remove();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transpileConstEnum;
  var _enum = require_enum();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-typescript/lib/global-types.js
var require_global_types = __commonJS((exports) => {
  var isGlobalType = function({
    scope
  }, name) {
    if (scope.hasBinding(name))
      return false;
    if (GLOBAL_TYPES.get(scope).has(name))
      return true;
    console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker\n` + `as a JavaScript value binding, and "@babel/plugin-transform-typescript"\nnever encountered it as a TypeScript type declaration.\nIt will be treated as a JavaScript value.\n\nThis problem is likely caused by another plugin injecting\n` + `"${name}" without registering it in the scope tracker. If you are the author\n` + ` of that plugin, please use "scope.registerDeclaration(declarationPath)".`);
    return false;
  };
  var registerGlobalType = function(programScope, name) {
    GLOBAL_TYPES.get(programScope).add(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GLOBAL_TYPES = undefined;
  exports.isGlobalType = isGlobalType;
  exports.registerGlobalType = registerGlobalType;
  var GLOBAL_TYPES = exports.GLOBAL_TYPES = new WeakMap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-typescript/lib/namespace.js
var require_namespace = __commonJS((exports) => {
  var transpileNamespace = function(path3, allowNamespaces) {
    if (path3.node.declare || path3.node.id.type === "StringLiteral") {
      path3.remove();
      return;
    }
    if (!allowNamespaces) {
      throw path3.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }
    const name = path3.node.id.name;
    const value2 = handleNested(path3, _core.types.cloneNode(path3.node, true));
    if (value2 === null) {
      const program = path3.findParent((p) => p.isProgram());
      (0, _globalTypes.registerGlobalType)(program.scope, name);
      path3.remove();
    } else if (path3.scope.hasOwnBinding(name)) {
      path3.replaceWith(value2);
    } else {
      path3.scope.registerDeclaration(path3.replaceWithMultiple([getDeclaration(name), value2])[0]);
    }
  };
  var getDeclaration = function(name) {
    return _core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.identifier(name))]);
  };
  var getMemberExpression = function(name, itemName) {
    return _core.types.memberExpression(_core.types.identifier(name), _core.types.identifier(itemName));
  };
  var handleVariableDeclaration = function(node2, name, hub) {
    if (node2.kind !== "const") {
      throw hub.file.buildCodeFrameError(node2, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }
    const {
      declarations
    } = node2;
    if (declarations.every((declarator) => _core.types.isIdentifier(declarator.id))) {
      for (const declarator of declarations) {
        declarator.init = _core.types.assignmentExpression("=", getMemberExpression(name, declarator.id.name), declarator.init);
      }
      return [node2];
    }
    const bindingIdentifiers = _core.types.getBindingIdentifiers(node2);
    const assignments = [];
    for (const idName in bindingIdentifiers) {
      assignments.push(_core.types.assignmentExpression("=", getMemberExpression(name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));
    }
    return [node2, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];
  };
  var buildNestedAmbientModuleError = function(path3, node2) {
    return path3.hub.buildError(node2, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  };
  var handleNested = function(path3, node2, parentExport) {
    const names = new Set;
    const realName = node2.id;
    _core.types.assertIdentifier(realName);
    const name = path3.scope.generateUid(realName.name);
    const namespaceTopLevel = _core.types.isTSModuleBlock(node2.body) ? node2.body.body : [_core.types.exportNamedDeclaration(node2.body)];
    let isEmpty = true;
    for (let i = 0;i < namespaceTopLevel.length; i++) {
      const subNode = namespaceTopLevel[i];
      switch (subNode.type) {
        case "TSModuleDeclaration": {
          if (!_core.types.isIdentifier(subNode.id)) {
            throw buildNestedAmbientModuleError(path3, subNode);
          }
          const transformed = handleNested(path3, subNode);
          if (transformed !== null) {
            isEmpty = false;
            const moduleName = subNode.id.name;
            if (names.has(moduleName)) {
              namespaceTopLevel[i] = transformed;
            } else {
              names.add(moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);
            }
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          isEmpty = false;
          names.add(subNode.id.name);
          continue;
        case "VariableDeclaration": {
          isEmpty = false;
          for (const name2 in _core.types.getBindingIdentifiers(subNode)) {
            names.add(name2);
          }
          continue;
        }
        default:
          isEmpty && (isEmpty = _core.types.isTypeScript(subNode));
          continue;
        case "ExportNamedDeclaration":
      }
      if ("declare" in subNode.declaration && subNode.declaration.declare) {
        continue;
      }
      switch (subNode.declaration.type) {
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration": {
          isEmpty = false;
          const itemName = subNode.declaration.id.name;
          names.add(itemName);
          namespaceTopLevel.splice(i++, 1, subNode.declaration, _core.types.expressionStatement(_core.types.assignmentExpression("=", getMemberExpression(name, itemName), _core.types.identifier(itemName))));
          break;
        }
        case "VariableDeclaration": {
          isEmpty = false;
          const nodes = handleVariableDeclaration(subNode.declaration, name, path3.hub);
          namespaceTopLevel.splice(i, nodes.length, ...nodes);
          i += nodes.length - 1;
          break;
        }
        case "TSModuleDeclaration": {
          if (!_core.types.isIdentifier(subNode.declaration.id)) {
            throw buildNestedAmbientModuleError(path3, subNode.declaration);
          }
          const transformed = handleNested(path3, subNode.declaration, _core.types.identifier(name));
          if (transformed !== null) {
            isEmpty = false;
            const moduleName = subNode.declaration.id.name;
            if (names.has(moduleName)) {
              namespaceTopLevel[i] = transformed;
            } else {
              names.add(moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);
            }
          } else {
            namespaceTopLevel.splice(i, 1);
            i--;
          }
        }
      }
    }
    if (isEmpty)
      return null;
    let fallthroughValue = _core.types.objectExpression([]);
    if (parentExport) {
      const memberExpr = _core.types.memberExpression(parentExport, realName);
      fallthroughValue = _core.template.expression.ast`
      ${_core.types.cloneNode(memberExpr)} ||
        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})
    `;
    }
    return _core.template.statement.ast`
    (function (${_core.types.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));
  `;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transpileNamespace;
  var _core = require_lib33();
  var _globalTypes = require_global_types();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-typescript/lib/index.js
var require_lib27 = __commonJS((exports) => {
  var isInType = function(path3) {
    switch (path3.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return true;
      case "TSQualifiedName":
        return path3.parentPath.findParent((path4) => path4.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
      case "ExportSpecifier":
        return path3.parent.exportKind === "type" || path3.parentPath.parent.exportKind === "type";
      default:
        return false;
    }
  };
  var safeRemove = function(path3) {
    const ids = path3.getBindingIdentifiers();
    for (const name of Object.keys(ids)) {
      const binding = path3.scope.getBinding(name);
      if (binding && binding.identifier === ids[name]) {
        binding.scope.removeBinding(name);
      }
    }
    path3.opts.noScope = true;
    path3.remove();
    path3.opts.noScope = false;
  };
  var assertCjsTransformEnabled = function(path3, pass, wrong, suggestion, extra = "") {
    if (pass.file.get("@babel/plugin-transform-modules-*") !== "commonjs") {
      throw path3.buildCodeFrameError(`\`${wrong}\` is only supported when compiling modules to CommonJS.\n` + `Please consider using \`${suggestion}\`${extra}, or add ` + `@babel/plugin-transform-modules-commonjs to your Babel config.`);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _helperPluginUtils = require_lib19();
  var _pluginSyntaxTypescript = require_lib20();
  var _helperCreateClassFeaturesPlugin = require_lib26();
  var _constEnum = require_const_enum();
  var _enum = require_enum();
  var _globalTypes = require_global_types();
  var _namespace = require_namespace();
  var NEEDS_EXPLICIT_ESM = new WeakMap;
  var PARSED_PARAMS = new WeakSet;
  var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
    const {
      types: t,
      template
    } = api;
    api.assertVersion(7);
    const JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
    const {
      allowNamespaces = true,
      jsxPragma = "React.createElement",
      jsxPragmaFrag = "React.Fragment",
      onlyRemoveTypeImports = false,
      optimizeConstEnums = false
    } = opts;
    {
      var {
        allowDeclareFields = false
      } = opts;
    }
    const classMemberVisitors = {
      field(path3) {
        const {
          node: node2
        } = path3;
        {
          if (!allowDeclareFields && node2.declare) {
            throw path3.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);
          }
        }
        if (node2.declare) {
          if (node2.value) {
            throw path3.buildCodeFrameError(`Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`);
          }
          if (!node2.decorators) {
            path3.remove();
          }
        } else if (node2.definite) {
          if (node2.value) {
            throw path3.buildCodeFrameError(`Definitely assigned fields cannot be initialized here, but only in the constructor`);
          }
          {
            if (!allowDeclareFields && !node2.decorators && !t.isClassPrivateProperty(node2)) {
              path3.remove();
            }
          }
        } else if (node2.abstract) {
          path3.remove();
        } else {
          if (!allowDeclareFields && !node2.value && !node2.decorators && !t.isClassPrivateProperty(node2)) {
            path3.remove();
          }
        }
        if (node2.accessibility)
          node2.accessibility = null;
        if (node2.abstract)
          node2.abstract = null;
        if (node2.readonly)
          node2.readonly = null;
        if (node2.optional)
          node2.optional = null;
        if (node2.typeAnnotation)
          node2.typeAnnotation = null;
        if (node2.definite)
          node2.definite = null;
        if (node2.declare)
          node2.declare = null;
        if (node2.override)
          node2.override = null;
      },
      method({
        node: node2
      }) {
        if (node2.accessibility)
          node2.accessibility = null;
        if (node2.abstract)
          node2.abstract = null;
        if (node2.optional)
          node2.optional = null;
        if (node2.override)
          node2.override = null;
      },
      constructor(path3, classPath) {
        if (path3.node.accessibility)
          path3.node.accessibility = null;
        const assigns = [];
        const {
          scope
        } = path3;
        for (const paramPath of path3.get("params")) {
          const param = paramPath.node;
          if (param.type === "TSParameterProperty") {
            const parameter = param.parameter;
            if (PARSED_PARAMS.has(parameter))
              continue;
            PARSED_PARAMS.add(parameter);
            let id;
            if (t.isIdentifier(parameter)) {
              id = parameter;
            } else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left)) {
              id = parameter.left;
            } else {
              throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            }
            assigns.push(template.statement.ast`
              this.${t.cloneNode(id)} = ${t.cloneNode(id)}
            `);
            paramPath.replaceWith(paramPath.get("parameter"));
            scope.registerBinding("param", paramPath);
          }
        }
        (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path3, assigns);
      }
    };
    return {
      name: "transform-typescript",
      inherits: _pluginSyntaxTypescript.default,
      visitor: {
        Pattern: visitPattern,
        Identifier: visitPattern,
        RestElement: visitPattern,
        Program: {
          enter(path3, state) {
            const {
              file
            } = state;
            let fileJsxPragma = null;
            let fileJsxPragmaFrag = null;
            const programScope = path3.scope;
            if (!_globalTypes.GLOBAL_TYPES.has(programScope)) {
              _globalTypes.GLOBAL_TYPES.set(programScope, new Set);
            }
            if (file.ast.comments) {
              for (const comment of file.ast.comments) {
                const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
                if (jsxMatches) {
                  if (jsxMatches[1]) {
                    fileJsxPragmaFrag = jsxMatches[2];
                  } else {
                    fileJsxPragma = jsxMatches[2];
                  }
                }
              }
            }
            let pragmaImportName = fileJsxPragma || jsxPragma;
            if (pragmaImportName) {
              [pragmaImportName] = pragmaImportName.split(".");
            }
            let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
            if (pragmaFragImportName) {
              [pragmaFragImportName] = pragmaFragImportName.split(".");
            }
            for (let stmt of path3.get("body")) {
              if (stmt.isImportDeclaration()) {
                if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                  NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
                }
                if (stmt.node.importKind === "type") {
                  for (const specifier of stmt.node.specifiers) {
                    (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                  }
                  stmt.remove();
                  continue;
                }
                const importsToRemove = new Set;
                const specifiersLength = stmt.node.specifiers.length;
                const isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;
                for (const specifier of stmt.node.specifiers) {
                  if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                    (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                    const binding = stmt.scope.getBinding(specifier.local.name);
                    if (binding) {
                      importsToRemove.add(binding.path);
                    }
                  }
                }
                if (onlyRemoveTypeImports) {
                  NEEDS_EXPLICIT_ESM.set(path3.node, false);
                } else {
                  if (stmt.node.specifiers.length === 0) {
                    NEEDS_EXPLICIT_ESM.set(path3.node, false);
                    continue;
                  }
                  for (const specifier of stmt.node.specifiers) {
                    const binding = stmt.scope.getBinding(specifier.local.name);
                    if (binding && !importsToRemove.has(binding.path)) {
                      if (isImportTypeOnly({
                        binding,
                        programPath: path3,
                        pragmaImportName,
                        pragmaFragImportName
                      })) {
                        importsToRemove.add(binding.path);
                      } else {
                        NEEDS_EXPLICIT_ESM.set(path3.node, false);
                      }
                    }
                  }
                }
                if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {
                  stmt.remove();
                } else {
                  for (const importPath of importsToRemove) {
                    importPath.remove();
                  }
                }
                continue;
              }
              if (stmt.isExportDeclaration()) {
                stmt = stmt.get("declaration");
              }
              if (stmt.isVariableDeclaration({
                declare: true
              })) {
                for (const name of Object.keys(stmt.getBindingIdentifiers())) {
                  (0, _globalTypes.registerGlobalType)(programScope, name);
                }
              } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
                declare: true
              }) || stmt.isTSEnumDeclaration({
                declare: true
              }) || stmt.isTSModuleDeclaration({
                declare: true
              }) && stmt.get("id").isIdentifier()) {
                (0, _globalTypes.registerGlobalType)(programScope, stmt.node.id.name);
              }
            }
          },
          exit(path3) {
            if (path3.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path3.node)) {
              path3.pushContainer("body", t.exportNamedDeclaration());
            }
          }
        },
        ExportNamedDeclaration(path3, state) {
          if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
            NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
          }
          if (path3.node.exportKind === "type") {
            path3.remove();
            return;
          }
          if (path3.node.source && path3.node.specifiers.length > 0 && path3.node.specifiers.every((specifier) => specifier.type === "ExportSpecifier" && specifier.exportKind === "type")) {
            path3.remove();
            return;
          }
          if (!path3.node.source && path3.node.specifiers.length > 0 && path3.node.specifiers.every((specifier) => t.isExportSpecifier(specifier) && (0, _globalTypes.isGlobalType)(path3, specifier.local.name))) {
            path3.remove();
            return;
          }
          if (t.isTSModuleDeclaration(path3.node.declaration)) {
            const namespace = path3.node.declaration;
            const {
              id
            } = namespace;
            if (t.isIdentifier(id)) {
              if (path3.scope.hasOwnBinding(id.name)) {
                path3.replaceWith(namespace);
              } else {
                const [newExport] = path3.replaceWithMultiple([t.exportNamedDeclaration(t.variableDeclaration("let", [t.variableDeclarator(t.cloneNode(id))])), namespace]);
                path3.scope.registerDeclaration(newExport);
              }
            }
          }
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
        },
        ExportAllDeclaration(path3) {
          if (path3.node.exportKind === "type")
            path3.remove();
        },
        ExportSpecifier(path3) {
          const parent = path3.parent;
          if (!parent.source && (0, _globalTypes.isGlobalType)(path3, path3.node.local.name) || path3.node.exportKind === "type") {
            path3.remove();
          }
        },
        ExportDefaultDeclaration(path3, state) {
          if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
            NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
          }
          if (t.isIdentifier(path3.node.declaration) && (0, _globalTypes.isGlobalType)(path3, path3.node.declaration.name)) {
            path3.remove();
            return;
          }
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
        },
        TSDeclareFunction(path3) {
          safeRemove(path3);
        },
        TSDeclareMethod(path3) {
          safeRemove(path3);
        },
        VariableDeclaration(path3) {
          if (path3.node.declare) {
            safeRemove(path3);
          }
        },
        VariableDeclarator({
          node: node2
        }) {
          if (node2.definite)
            node2.definite = null;
        },
        TSIndexSignature(path3) {
          path3.remove();
        },
        ClassDeclaration(path3) {
          const {
            node: node2
          } = path3;
          if (node2.declare) {
            safeRemove(path3);
          }
        },
        Class(path3) {
          const {
            node: node2
          } = path3;
          if (node2.typeParameters)
            node2.typeParameters = null;
          if (node2.superTypeParameters)
            node2.superTypeParameters = null;
          if (node2.implements)
            node2.implements = null;
          if (node2.abstract)
            node2.abstract = null;
          path3.get("body.body").forEach((child) => {
            if (child.isClassMethod() || child.isClassPrivateMethod()) {
              if (child.node.kind === "constructor") {
                classMemberVisitors.constructor(child, path3);
              } else {
                classMemberVisitors.method(child);
              }
            } else if (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) {
              classMemberVisitors.field(child);
            }
          });
        },
        Function(path3) {
          const {
            node: node2
          } = path3;
          if (node2.typeParameters)
            node2.typeParameters = null;
          if (node2.returnType)
            node2.returnType = null;
          const params = node2.params;
          if (params.length > 0 && t.isIdentifier(params[0], {
            name: "this"
          })) {
            params.shift();
          }
        },
        TSModuleDeclaration(path3) {
          (0, _namespace.default)(path3, allowNamespaces);
        },
        TSInterfaceDeclaration(path3) {
          path3.remove();
        },
        TSTypeAliasDeclaration(path3) {
          path3.remove();
        },
        TSEnumDeclaration(path3) {
          if (optimizeConstEnums && path3.node.const) {
            (0, _constEnum.default)(path3, t);
          } else {
            (0, _enum.default)(path3, t);
          }
        },
        TSImportEqualsDeclaration(path3, pass) {
          const {
            id,
            moduleReference
          } = path3.node;
          let init;
          let varKind;
          if (t.isTSExternalModuleReference(moduleReference)) {
            assertCjsTransformEnabled(path3, pass, `import ${id.name} = require(...);`, `import ${id.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option");
            init = t.callExpression(t.identifier("require"), [moduleReference.expression]);
            varKind = "const";
          } else {
            init = entityNameToExpr(moduleReference);
            varKind = "var";
          }
          path3.replaceWith(t.variableDeclaration(varKind, [t.variableDeclarator(id, init)]));
          path3.scope.registerDeclaration(path3);
        },
        TSExportAssignment(path3, pass) {
          assertCjsTransformEnabled(path3, pass, `export = <value>;`, `export default <value>;`);
          path3.replaceWith(template.statement.ast`module.exports = ${path3.node.expression}`);
        },
        TSTypeAssertion(path3) {
          path3.replaceWith(path3.node.expression);
        },
        [`TSAsExpression${t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](path3) {
          let {
            node: node2
          } = path3;
          do {
            node2 = node2.expression;
          } while (t.isTSAsExpression(node2) || t.isTSSatisfiesExpression != null && t.isTSSatisfiesExpression(node2));
          path3.replaceWith(node2);
        },
        [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](path3) {
          path3.replaceWith(path3.node.expression);
        },
        CallExpression(path3) {
          path3.node.typeParameters = null;
        },
        OptionalCallExpression(path3) {
          path3.node.typeParameters = null;
        },
        NewExpression(path3) {
          path3.node.typeParameters = null;
        },
        JSXOpeningElement(path3) {
          path3.node.typeParameters = null;
        },
        TaggedTemplateExpression(path3) {
          path3.node.typeParameters = null;
        }
      }
    };
    function entityNameToExpr(node2) {
      if (t.isTSQualifiedName(node2)) {
        return t.memberExpression(entityNameToExpr(node2.left), node2.right);
      }
      return node2;
    }
    function visitPattern({
      node: node2
    }) {
      if (node2.typeAnnotation)
        node2.typeAnnotation = null;
      if (t.isIdentifier(node2) && node2.optional)
        node2.optional = null;
    }
    function isImportTypeOnly({
      binding,
      programPath,
      pragmaImportName,
      pragmaFragImportName
    }) {
      for (const path3 of binding.referencePaths) {
        if (!isInType(path3)) {
          return false;
        }
      }
      if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
        return true;
      }
      let sourceFileHasJsx = false;
      programPath.traverse({
        "JSXElement|JSXFragment"(path3) {
          sourceFileHasJsx = true;
          path3.stop();
        }
      });
      return !sourceFileHasJsx;
    }
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-syntax-jsx/lib/index.js
var require_lib28 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _helperPluginUtils = require_lib19();
  var _default = exports.default = (0, _helperPluginUtils.declare)((api) => {
    api.assertVersion(7);
    return {
      name: "syntax-jsx",
      manipulateOptions(opts, parserOpts) {
        {
          if (parserOpts.plugins.some((p) => (Array.isArray(p) ? p[0] : p) === "typescript")) {
            return;
          }
        }
        parserOpts.plugins.push("jsx");
      }
    };
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js
var require_dynamic_import2 = __commonJS((exports) => {
  var transformDynamicImport = function(path3, noInterop, file) {
    const buildRequire = noInterop ? requireNoInterop : requireInterop;
    path3.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path3.node, true, false, (specifier) => buildRequire(specifier, file)));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.transformDynamicImport = transformDynamicImport;
  var _core = require_lib33();
  var _helperModuleTransforms = require_lib17();
  var requireNoInterop = (source) => _core.template.expression.ast`require(${source})`;
  var requireInterop = (source, file) => _core.types.callExpression(file.addHelper("interopRequireWildcard"), [requireNoInterop(source)]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js
var require_lazy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.lazyImportsHook = undefined;
  var _core = require_lib33();
  var _helperModuleTransforms = require_lib17();
  var lazyImportsHook = (lazy) => ({
    name: `${"@babel/plugin-transform-modules-commonjs"}/lazy`,
    version: "7.23.3",
    getWrapperPayload(source, metadata) {
      if ((0, _helperModuleTransforms.isSideEffectImport)(metadata) || metadata.reexportAll) {
        return null;
      }
      if (lazy === true) {
        return /\./.test(source) ? null : "lazy/function";
      }
      if (Array.isArray(lazy)) {
        return lazy.indexOf(source) === -1 ? null : "lazy/function";
      }
      if (typeof lazy === "function") {
        return lazy(source) ? "lazy/function" : null;
      }
    },
    buildRequireWrapper(name, init, payload, referenced) {
      if (payload === "lazy/function") {
        if (!referenced)
          return false;
        return _core.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      `;
      }
    },
    wrapReference(ref, payload) {
      if (payload === "lazy/function")
        return _core.types.callExpression(ref, []);
    }
  });
  exports.lazyImportsHook = lazyImportsHook;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js
var require_hooks = __commonJS((exports) => {
  var defineCommonJSHook = function(file, hook) {
    let hooks = file.get(commonJSHooksKey);
    if (!hooks)
      file.set(commonJSHooksKey, hooks = []);
    hooks.push(hook);
  };
  var findMap = function(arr, cb) {
    if (arr) {
      for (const el of arr) {
        const res = cb(el);
        if (res != null)
          return res;
      }
    }
  };
  var makeInvokers = function(file) {
    const hooks = file.get(commonJSHooksKey);
    return {
      getWrapperPayload(...args) {
        return findMap(hooks, (hook) => hook.getWrapperPayload == null ? undefined : hook.getWrapperPayload(...args));
      },
      wrapReference(...args) {
        return findMap(hooks, (hook) => hook.wrapReference == null ? undefined : hook.wrapReference(...args));
      },
      buildRequireWrapper(...args) {
        return findMap(hooks, (hook) => hook.buildRequireWrapper == null ? undefined : hook.buildRequireWrapper(...args));
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.defineCommonJSHook = defineCommonJSHook;
  exports.makeInvokers = makeInvokers;
  var commonJSHooksKey = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js
var require_lib29 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  Object.defineProperty(exports, "defineCommonJSHook", {
    enumerable: true,
    get: function() {
      return _hooks.defineCommonJSHook;
    }
  });
  var _helperPluginUtils = require_lib19();
  var _helperModuleTransforms = require_lib17();
  var _helperSimpleAccess = require_lib16();
  var _core = require_lib33();
  var _dynamicImport = require_dynamic_import2();
  var _lazy = require_lazy();
  var _hooks = require_hooks();
  var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
    var _api$assumption, _api$assumption2, _api$assumption3;
    api.assertVersion(7);
    const {
      strictNamespace = false,
      mjsStrictNamespace = strictNamespace,
      allowTopLevelThis,
      strict,
      strictMode,
      noInterop,
      importInterop,
      lazy = false,
      allowCommonJSExports = true,
      loose = false
    } = options;
    const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : loose;
    const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : loose;
    const noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null ? _api$assumption3 : false;
    if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every((item) => typeof item === "string"))) {
      throw new Error(`.lazy must be a boolean, array of strings, or a function`);
    }
    if (typeof strictNamespace !== "boolean") {
      throw new Error(`.strictNamespace must be a boolean, or undefined`);
    }
    if (typeof mjsStrictNamespace !== "boolean") {
      throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);
    }
    const getAssertion = (localName) => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `;
    const moduleExportsVisitor = {
      ReferencedIdentifier(path3) {
        const localName = path3.node.name;
        if (localName !== "module" && localName !== "exports")
          return;
        const localBinding = path3.scope.getBinding(localName);
        const rootBinding = this.scope.getBinding(localName);
        if (rootBinding !== localBinding || path3.parentPath.isObjectProperty({
          value: path3.node
        }) && path3.parentPath.parentPath.isObjectPattern() || path3.parentPath.isAssignmentExpression({
          left: path3.node
        }) || path3.isAssignmentExpression({
          left: path3.node
        })) {
          return;
        }
        path3.replaceWith(getAssertion(localName));
      },
      UpdateExpression(path3) {
        const arg = path3.get("argument");
        if (!arg.isIdentifier())
          return;
        const localName = arg.node.name;
        if (localName !== "module" && localName !== "exports")
          return;
        const localBinding = path3.scope.getBinding(localName);
        const rootBinding = this.scope.getBinding(localName);
        if (rootBinding !== localBinding)
          return;
        path3.replaceWith(_core.types.assignmentExpression(path3.node.operator[0] + "=", arg.node, getAssertion(localName)));
      },
      AssignmentExpression(path3) {
        const left2 = path3.get("left");
        if (left2.isIdentifier()) {
          const localName = left2.node.name;
          if (localName !== "module" && localName !== "exports")
            return;
          const localBinding = path3.scope.getBinding(localName);
          const rootBinding = this.scope.getBinding(localName);
          if (rootBinding !== localBinding)
            return;
          const right2 = path3.get("right");
          right2.replaceWith(_core.types.sequenceExpression([right2.node, getAssertion(localName)]));
        } else if (left2.isPattern()) {
          const ids = left2.getOuterBindingIdentifiers();
          const localName = Object.keys(ids).filter((localName2) => {
            if (localName2 !== "module" && localName2 !== "exports")
              return false;
            return this.scope.getBinding(localName2) === path3.scope.getBinding(localName2);
          })[0];
          if (localName) {
            const right2 = path3.get("right");
            right2.replaceWith(_core.types.sequenceExpression([right2.node, getAssertion(localName)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
        if (lazy)
          (0, _hooks.defineCommonJSHook)(this.file, (0, _lazy.lazyImportsHook)(lazy));
      },
      visitor: {
        ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path3) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import"))
            return;
          if (path3.isCallExpression() && !_core.types.isImport(path3.node.callee))
            return;
          let {
            scope
          } = path3;
          do {
            scope.rename("require");
          } while (scope = scope.parent);
          (0, _dynamicImport.transformDynamicImport)(path3, noInterop, this.file);
        },
        Program: {
          exit(path3, state) {
            if (!(0, _helperModuleTransforms.isModule)(path3))
              return;
            path3.scope.rename("exports");
            path3.scope.rename("module");
            path3.scope.rename("require");
            path3.scope.rename("__filename");
            path3.scope.rename("__dirname");
            if (!allowCommonJSExports) {
              {
                (0, _helperSimpleAccess.default)(path3, new Set(["module", "exports"]), false);
              }
              path3.traverse(moduleExportsVisitor, {
                scope: path3.scope
              });
            }
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            if (moduleName)
              moduleName = _core.types.stringLiteral(moduleName);
            const hooks = (0, _hooks.makeInvokers)(this.file);
            const {
              meta,
              headers
            } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path3, {
              exportName: "exports",
              constantReexports,
              enumerableModuleMeta,
              strict,
              strictMode,
              allowTopLevelThis,
              noInterop,
              importInterop,
              wrapReference: hooks.wrapReference,
              getWrapperPayload: hooks.getWrapperPayload,
              esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
              noIncompleteNsImportDetection,
              filename: this.file.opts.filename
            });
            for (const [source, metadata] of meta.source) {
              const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]);
              let header;
              if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                if (lazy && metadata.wrap === "function") {
                  throw new Error("Assertion failure");
                }
                header = _core.types.expressionStatement(loadExpr);
              } else {
                var _header;
                const init = (0, _helperModuleTransforms.wrapInterop)(path3, loadExpr, metadata.interop) || loadExpr;
                if (metadata.wrap) {
                  const res = hooks.buildRequireWrapper(metadata.name, init, metadata.wrap, metadata.referenced);
                  if (res === false)
                    continue;
                  else
                    header = res;
                }
                (_header = header) != null || (header = _core.template.statement.ast`
                var ${metadata.name} = ${init};
              `);
              }
              header.loc = metadata.loc;
              headers.push(header);
              headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports, hooks.wrapReference));
            }
            (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
            path3.unshiftContainer("body", headers);
            path3.get("body").forEach((path4) => {
              if (headers.indexOf(path4.node) === -1)
                return;
              if (path4.isVariableDeclaration()) {
                path4.scope.registerDeclaration(path4);
              }
            });
          }
        }
      }
    };
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var require_find_suggestion = __commonJS((exports) => {
  var levenshtein3 = function(a, b) {
    let t = [], u = [], i, j;
    const m = a.length, n = b.length;
    if (!m) {
      return n;
    }
    if (!n) {
      return m;
    }
    for (j = 0;j <= n; j++) {
      t[j] = j;
    }
    for (i = 1;i <= m; i++) {
      for (u = [i], j = 1;j <= n; j++) {
        u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
      }
      t = u;
    }
    return u[n];
  };
  var findSuggestion = function(str, arr) {
    const distances = arr.map((el) => levenshtein3(el, str));
    return arr[distances.indexOf(min(...distances))];
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findSuggestion = findSuggestion;
  var {
    min
  } = Math;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-validator-option/lib/validator.js
var require_validator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.OptionValidator = undefined;
  var _findSuggestion = require_find_suggestion();

  class OptionValidator {
    constructor(descriptor) {
      this.descriptor = descriptor;
    }
    validateTopLevelOptions(options, TopLevelOptionShape) {
      const validOptionNames = Object.keys(TopLevelOptionShape);
      for (const option of Object.keys(options)) {
        if (!validOptionNames.includes(option)) {
          throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${(0, _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
        }
      }
    }
    validateBooleanOption(name, value2, defaultValue) {
      if (value2 === undefined) {
        return defaultValue;
      } else {
        this.invariant(typeof value2 === "boolean", `'${name}' option must be a boolean.`);
      }
      return value2;
    }
    validateStringOption(name, value2, defaultValue) {
      if (value2 === undefined) {
        return defaultValue;
      } else {
        this.invariant(typeof value2 === "string", `'${name}' option must be a string.`);
      }
      return value2;
    }
    invariant(condition, message) {
      if (!condition) {
        throw new Error(this.formatMessage(message));
      }
    }
    formatMessage(message) {
      return `${this.descriptor}: ${message}`;
    }
  }
  exports.OptionValidator = OptionValidator;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-validator-option/lib/index.js
var require_lib30 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "OptionValidator", {
    enumerable: true,
    get: function() {
      return _validator.OptionValidator;
    }
  });
  Object.defineProperty(exports, "findSuggestion", {
    enumerable: true,
    get: function() {
      return _findSuggestion.findSuggestion;
    }
  });
  var _validator = require_validator();
  var _findSuggestion = require_find_suggestion();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/preset-typescript/lib/index.js
var require_lib31 = __commonJS((exports) => {
  var _interopDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var normalizeOptions = function(options = {}) {
    let {
      allowNamespaces = true,
      jsxPragma,
      onlyRemoveTypeImports
    } = options;
    const TopLevelOptions = {
      ignoreExtensions: "ignoreExtensions",
      allowNamespaces: "allowNamespaces",
      disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
      jsxPragma: "jsxPragma",
      jsxPragmaFrag: "jsxPragmaFrag",
      onlyRemoveTypeImports: "onlyRemoveTypeImports",
      optimizeConstEnums: "optimizeConstEnums",
      rewriteImportExtensions: "rewriteImportExtensions",
      allExtensions: "allExtensions",
      isTSX: "isTSX"
    };
    const jsxPragmaFrag = v.validateStringOption(TopLevelOptions.jsxPragmaFrag, options.jsxPragmaFrag, "React.Fragment");
    {
      var allExtensions = v.validateBooleanOption(TopLevelOptions.allExtensions, options.allExtensions, false);
      var isTSX = v.validateBooleanOption(TopLevelOptions.isTSX, options.isTSX, false);
      if (isTSX) {
        v.invariant(allExtensions, "isTSX:true requires allExtensions:true");
      }
    }
    const ignoreExtensions = v.validateBooleanOption(TopLevelOptions.ignoreExtensions, options.ignoreExtensions, false);
    const disallowAmbiguousJSXLike = v.validateBooleanOption(TopLevelOptions.disallowAmbiguousJSXLike, options.disallowAmbiguousJSXLike, false);
    if (disallowAmbiguousJSXLike) {
      {
        v.invariant(allExtensions, "disallowAmbiguousJSXLike:true requires allExtensions:true");
      }
    }
    const optimizeConstEnums = v.validateBooleanOption(TopLevelOptions.optimizeConstEnums, options.optimizeConstEnums, false);
    const rewriteImportExtensions = v.validateBooleanOption(TopLevelOptions.rewriteImportExtensions, options.rewriteImportExtensions, false);
    const normalized = {
      ignoreExtensions,
      allowNamespaces,
      disallowAmbiguousJSXLike,
      jsxPragma,
      jsxPragmaFrag,
      onlyRemoveTypeImports,
      optimizeConstEnums,
      rewriteImportExtensions
    };
    {
      normalized.allExtensions = allExtensions;
      normalized.isTSX = isTSX;
    }
    return normalized;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var helperPluginUtils = require_lib19();
  var transformTypeScript = require_lib27();
  require_lib28();
  var transformModulesCommonJS = require_lib29();
  var helperValidatorOption = require_lib30();
  var transformTypeScript__default = _interopDefault(transformTypeScript);
  var transformModulesCommonJS__default = _interopDefault(transformModulesCommonJS);
  var v = new helperValidatorOption.OptionValidator("@babel/preset-typescript");
  var pluginRewriteTSImports = helperPluginUtils.declare(function({
    types: t
  }) {
    return {
      name: "preset-typescript/plugin-rewrite-ts-imports",
      visitor: {
        "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"({
          node: node2
        }) {
          const {
            source
          } = node2;
          const kind = t.isImportDeclaration(node2) ? node2.importKind : node2.exportKind;
          if (kind === "value" && source && /[\\/]/.test(source.value)) {
            source.value = source.value.replace(/(\.[mc]?)ts$/, "$1js").replace(/\.tsx$/, ".js");
          }
        }
      }
    };
  });
  var index = helperPluginUtils.declarePreset((api, opts) => {
    api.assertVersion(7);
    const {
      allExtensions,
      ignoreExtensions,
      allowNamespaces,
      disallowAmbiguousJSXLike,
      isTSX,
      jsxPragma,
      jsxPragmaFrag,
      onlyRemoveTypeImports,
      optimizeConstEnums,
      rewriteImportExtensions
    } = normalizeOptions(opts);
    const pluginOptions = (disallowAmbiguousJSXLike2) => ({
      allowDeclareFields: opts.allowDeclareFields,
      allowNamespaces,
      disallowAmbiguousJSXLike: disallowAmbiguousJSXLike2,
      jsxPragma,
      jsxPragmaFrag,
      onlyRemoveTypeImports,
      optimizeConstEnums
    });
    const getPlugins = (isTSX2, disallowAmbiguousJSXLike2) => {
      {
        return [[transformTypeScript__default.default, Object.assign({
          isTSX: isTSX2
        }, pluginOptions(disallowAmbiguousJSXLike2))]];
      }
    };
    const disableExtensionDetect = allExtensions || ignoreExtensions;
    return {
      plugins: rewriteImportExtensions ? [pluginRewriteTSImports] : [],
      overrides: disableExtensionDetect ? [{
        plugins: getPlugins(isTSX, disallowAmbiguousJSXLike)
      }] : [{
        test: /\.ts$/,
        plugins: getPlugins(false, false)
      }, {
        test: /\.mts$/,
        sourceType: "module",
        plugins: getPlugins(false, true)
      }, {
        test: /\.cts$/,
        sourceType: "unambiguous",
        plugins: [[transformModulesCommonJS__default.default, {
          allowTopLevelThis: true
        }], [transformTypeScript__default.default, pluginOptions(true)]]
      }, {
        test: /\.tsx$/,
        plugins: getPlugins(true, false)
      }]
    };
  });
  exports.default = index;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/helpers/deep-array.js
var require_deep_array = __commonJS((exports) => {
  var finalize = function(deepArr) {
    return Object.freeze(deepArr);
  };
  var flattenToSet = function(arr) {
    const result = new Set;
    const stack = [arr];
    while (stack.length > 0) {
      for (const el of stack.pop()) {
        if (Array.isArray(el))
          stack.push(el);
        else
          result.add(el);
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.finalize = finalize;
  exports.flattenToSet = flattenToSet;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/plugin.js
var require_plugin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _deepArray = require_deep_array();

  class Plugin {
    constructor(plugin, options, key, externalDependencies = (0, _deepArray.finalize)([])) {
      this.key = undefined;
      this.manipulateOptions = undefined;
      this.post = undefined;
      this.pre = undefined;
      this.visitor = undefined;
      this.parserOverride = undefined;
      this.generatorOverride = undefined;
      this.options = undefined;
      this.externalDependencies = undefined;
      this.key = plugin.name || key;
      this.manipulateOptions = plugin.manipulateOptions;
      this.post = plugin.post;
      this.pre = plugin.pre;
      this.visitor = plugin.visitor || {};
      this.parserOverride = plugin.parserOverride;
      this.generatorOverride = plugin.generatorOverride;
      this.options = options;
      this.externalDependencies = externalDependencies;
    }
  }
  exports.default = Plugin;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/gensync-utils/functional.js
var require_functional = __commonJS((exports) => {
  var once = function(fn) {
    let result;
    let resultP;
    let promiseReferenced = false;
    return function* () {
      if (!result) {
        if (resultP) {
          promiseReferenced = true;
          return yield* (0, _async.waitFor)(resultP);
        }
        if (!(yield* (0, _async.isAsync)())) {
          try {
            result = {
              ok: true,
              value: yield* fn()
            };
          } catch (error) {
            result = {
              ok: false,
              value: error
            };
          }
        } else {
          let resolve6, reject;
          resultP = new Promise((res, rej) => {
            resolve6 = res;
            reject = rej;
          });
          try {
            result = {
              ok: true,
              value: yield* fn()
            };
            resultP = null;
            if (promiseReferenced)
              resolve6(result.value);
          } catch (error) {
            result = {
              ok: false,
              value: error
            };
            resultP = null;
            if (promiseReferenced)
              reject(error);
          }
        }
      }
      if (result.ok)
        return result.value;
      else
        throw result.value;
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.once = once;
  var _async = require_async();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/node-releases/data/processed/envs.json
var require_envs = __commonJS((exports, module) => {
  module.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: false, security: false, v8: "2.3.8.0" }, { name: "nodejs", version: "0.3.0", date: "2011-08-26", lts: false, security: false, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: false, security: false, v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: false, security: false, v8: "3.1.8.25" }, { name: "nodejs", version: "0.6.0", date: "2011-11-04", lts: false, security: false, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: false, security: false, v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: false, security: false, v8: "3.11.10.10" }, { name: "nodejs", version: "0.9.0", date: "2012-07-20", lts: false, security: false, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: false, security: false, v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: false, security: false, v8: "3.17.13.0" }, { name: "nodejs", version: "0.12.0", date: "2015-02-06", lts: false, security: false, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: false, security: false, v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: false, security: false, v8: "4.5.103.33" }, { name: "nodejs", version: "4.2.0", date: "2015-10-12", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: false, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0", date: "2016-09-27", lts: "Argon", security: true, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: false, v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: false, v8: "4.5.103.45" }, { name: "nodejs", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: true, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10-29", lts: false, security: false, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "2015-12-15", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.6.0", date: "2016-02-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.9.0", date: "2016-03-16", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.12.0", date: "2016-06-23", lts: false, security: false, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: false, security: false, v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: false, security: false, v8: "5.0.71.35" }, { name: "nodejs", version: "6.2.0", date: "2016-05-17", lts: false, security: false, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: false, security: false, v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: false, security: false, v8: "5.0.71.60" }, { name: "nodejs", version: "6.5.0", date: "2016-08-26", lts: false, security: false, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: false, security: false, v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: false, security: true, v8: "5.1.281.83" }, { name: "nodejs", version: "6.8.0", date: "2016-10-12", lts: false, security: false, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron", security: false, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: false, v8: "5.1.281.93" }, { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: false, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12.0", date: "2017-11-06", lts: "Boron", security: false, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Boron", security: false, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "6.16.0", date: "2018-12-26", lts: "Boron", security: false, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: false, security: false, v8: "5.4.500.36" }, { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: false, security: false, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "2016-11-22", lts: false, security: false, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: false, security: false, v8: "5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: false, security: false, v8: "5.4.500.45" }, { name: "nodejs", version: "7.5.0", date: "2017-01-31", lts: false, security: false, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: false, security: false, v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: false, security: false, v8: "5.5.372.41" }, { name: "nodejs", version: "7.8.0", date: "2017-03-29", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "8.0.0", date: "2017-05-30", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.3.0", date: "2017-08-08", lts: false, security: false, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: false, security: false, v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: false, security: false, v8: "6.0.287.53" }, { name: "nodejs", version: "8.6.0", date: "2017-09-26", lts: false, security: false, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: false, security: false, v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: false, security: false, v8: "6.1.534.42" }, { name: "nodejs", version: "8.9.0", date: "2017-10-31", lts: "Carbon", security: false, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "Carbon", security: false, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: true, v8: "6.2.414.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: false, v8: "6.2.414.66" }, { name: "nodejs", version: "8.13.0", date: "2018-11-20", lts: "Carbon", security: false, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "Carbon", security: true, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: false, v8: "6.2.414.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: false, v8: "6.2.414.77" }, { name: "nodejs", version: "8.17.0", date: "2019-12-17", lts: "Carbon", security: true, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: false, security: false, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: false, security: false, v8: "6.2.414.32" }, { name: "nodejs", version: "9.2.0", date: "2017-11-14", lts: false, security: false, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12-12", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0", date: "2018-02-21", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.9.0", date: "2018-03-21", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: false, security: true, v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "10.0.0", date: "2018-04-24", lts: false, security: false, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: false, security: false, v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: false, security: false, v8: "6.6.346.32" }, { name: "nodejs", version: "10.3.0", date: "2018-05-29", lts: false, security: false, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: false, security: false, v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: false, security: false, v8: "6.7.288.46" }, { name: "nodejs", version: "10.6.0", date: "2018-07-04", lts: false, security: false, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: false, security: false, v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: false, security: false, v8: "6.7.288.49" }, { name: "nodejs", version: "10.9.0", date: "2018-08-15", lts: false, security: false, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: false, security: false, v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: false, security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.12.0", date: "2018-10-10", lts: false, security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "2019-10-22", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "2020-06-02", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "2018-10-23", lts: false, security: false, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: false, security: false, v8: "7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.3.0", date: "2018-11-27", lts: false, security: true, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.6.0", date: "2018-12-26", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.9.0", date: "2019-01-30", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.12.0", date: "2019-03-14", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.0", date: "2019-04-23", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.3.0", date: "2019-05-21", lts: false, security: false, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: false, security: false, v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.6.0", date: "2019-07-03", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.9.0", date: "2019-08-20", lts: false, security: false, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: false, security: false, v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: false, security: false, v8: "7.7.299.11" }, { name: "nodejs", version: "12.12.0", date: "2019-10-11", lts: false, security: false, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21", lts: "Erbium", security: false, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: true, v8: "7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: true, v8: "7.7.299.13" }, { name: "nodejs", version: "12.16.0", date: "2020-02-11", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: true, v8: "7.8.279.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.20.0", date: "2020-11-24", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "Erbium", security: true, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: false, security: false, v8: "7.8.279.17" }, { name: "nodejs", version: "13.1.0", date: "2019-11-05", lts: false, security: false, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: false, security: false, v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.4.0", date: "2019-12-17", lts: false, security: true, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.7.0", date: "2020-01-21", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: false, security: true, v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.10.0", date: "2020-03-04", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.13.0", date: "2020-04-14", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: false, security: false, v8: "8.1.307.30" }, { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "2020-05-05", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: false, security: true, v8: "8.1.307.31" }, { name: "nodejs", version: "14.5.0", date: "2020-06-30", lts: false, security: false, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.8.0", date: "2020-08-11", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.11.0", date: "2020-09-15", lts: false, security: true, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15.0", date: "2020-10-27", lts: "Fermium", security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "Fermium", security: true, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.19.0", date: "2022-02-01", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "Fermium", security: true, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: false, security: false, v8: "8.6.395.16" }, { name: "nodejs", version: "15.1.0", date: "2020-11-04", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.4.0", date: "2020-12-09", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.7.0", date: "2021-01-25", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.10.0", date: "2021-02-23", lts: false, security: true, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.13.0", date: "2021-03-31", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: false, security: false, v8: "9.0.257.17" }, { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: false, security: false, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "2021-05-19", lts: false, security: false, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: false, security: false, v8: "9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: false, security: false, v8: "9.1.269.36" }, { name: "nodejs", version: "16.5.0", date: "2021-07-14", lts: false, security: false, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: false, security: true, v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: false, security: false, v8: "9.2.230.21" }, { name: "nodejs", version: "16.8.0", date: "2021-08-25", lts: false, security: false, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: false, security: false, v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: false, security: false, v8: "9.3.345.19" }, { name: "nodejs", version: "16.11.0", date: "2021-10-08", lts: false, security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20", lts: false, security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: false, v8: "9.4.146.24" }, { name: "nodejs", version: "16.15.0", date: "2022-04-26", lts: "Gallium", security: false, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "Gallium", security: true, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.19.0", date: "2022-12-13", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: false, security: false, v8: "9.5.172.21" }, { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: false, security: false, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "2021-11-30", lts: false, security: false, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.5.0", date: "2022-02-10", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.8.0", date: "2022-03-22", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.1.0", date: "2022-05-03", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: false, security: false, v8: "10.2.154.4" }, { name: "nodejs", version: "18.4.0", date: "2022-06-16", lts: false, security: false, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: false, security: true, v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.7.0", date: "2022-07-26", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.11.0", date: "2022-10-13", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydrogen", security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: false, v8: "10.2.154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: false, v8: "10.2.154.23" }, { name: "nodejs", version: "18.15.0", date: "2023-03-05", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: false, security: false, v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: false, security: false, v8: "10.7.193.20" }, { name: "nodejs", version: "19.2.0", date: "2022-11-29", lts: false, security: false, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14", lts: false, security: false, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6.0", date: "2023-02-01", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.9.0", date: "2023-04-10", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17", lts: false, security: false, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "2023-06-08", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.6.0", date: "2023-08-23", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.9.0", date: "2023-10-24", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: false, security: false, v8: "11.8.172.13" }, { name: "nodejs", version: "21.1.0", date: "2023-10-24", lts: false, security: false, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "2023-11-14", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: false, security: false, v8: "11.8.172.17" }];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/data/browsers.js
var require_browsers = __commonJS((exports, module) => {
  module.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/unpacker/browsers.js
var require_browsers2 = __commonJS((exports, module) => {
  exports.browsers = require_browsers();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/data/browserVersions.js
var require_browserVersions = __commonJS((exports, module) => {
  module.exports = { "0": "111", "1": "112", "2": "113", "3": "114", "4": "115", "5": "116", "6": "117", "7": "118", "8": "5", "9": "19", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "120", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "79", Q: "80", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "119", r: "20", s: "21", t: "22", u: "23", v: "73", w: "107", x: "108", y: "109", z: "110", AB: "24", BB: "25", CB: "26", DB: "27", EB: "28", FB: "29", GB: "30", HB: "31", IB: "32", JB: "33", KB: "34", LB: "35", MB: "36", NB: "37", OB: "38", PB: "39", QB: "40", RB: "41", SB: "42", TB: "43", UB: "44", VB: "45", WB: "46", XB: "47", YB: "48", ZB: "49", aB: "50", bB: "51", cB: "52", dB: "53", eB: "54", fB: "55", gB: "56", hB: "57", iB: "58", jB: "60", kB: "62", lB: "63", mB: "64", nB: "65", oB: "66", pB: "67", qB: "68", rB: "69", sB: "70", tB: "71", uB: "72", vB: "74", wB: "75", xB: "76", yB: "77", zB: "78", "0B": "11.1", "1B": "12.1", "2B": "15.5", "3B": "16.0", "4B": "17.0", "5B": "3", "6B": "59", "7B": "61", "8B": "82", "9B": "121", AC: "122", BC: "123", CC: "3.2", DC: "10.1", EC: "13.1", FC: "15.2-15.3", GC: "15.4", HC: "16.1", IC: "16.2", JC: "16.3", KC: "16.4", LC: "16.5", MC: "17.1", NC: "17.2", OC: "17.3", PC: "11.5", QC: "4.2-4.3", RC: "5.5", SC: "2", TC: "124", UC: "3.5", VC: "3.6", WC: "3.1", XC: "5.1", YC: "6.1", ZC: "7.1", aC: "9.1", bC: "14.1", cC: "15.1", dC: "15.6", eC: "16.6", fC: "TP", gC: "9.5-9.6", hC: "10.0-10.1", iC: "10.5", jC: "10.6", kC: "11.6", lC: "4.0-4.1", mC: "5.0-5.1", nC: "6.0-6.1", oC: "7.0-7.1", pC: "8.1-8.4", qC: "9.0-9.2", rC: "9.3", sC: "10.0-10.2", tC: "10.3", uC: "11.0-11.2", vC: "11.3-11.4", wC: "12.0-12.1", xC: "12.2-12.5", yC: "13.0-13.1", zC: "13.2", "0C": "13.3", "1C": "13.4-13.7", "2C": "14.0-14.4", "3C": "14.5-14.8", "4C": "15.0-15.1", "5C": "15.6-15.8", "6C": "16.6-16.7", "7C": "all", "8C": "2.1", "9C": "2.2", AD: "2.3", BD: "4.1", CD: "4.4", DD: "4.4.3-4.4.4", ED: "5.0-5.4", FD: "6.2-6.4", GD: "7.2-7.4", HD: "8.2", ID: "9.2", JD: "11.1-11.2", KD: "12.0", LD: "13.0", MD: "14.0", ND: "15.0", OD: "18.0", PD: "19.0", QD: "13.18", RD: "2.5", SD: "3.0-3.1" };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var require_browserVersions2 = __commonJS((exports, module) => {
  exports.browserVersions = require_browserVersions();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/data/agents.js
var require_agents = __commonJS((exports, module) => {
  module.exports = { A: { A: { J: 0, D: 0, E: 0.0223482, F: 0.0446964, A: 0, B: 0.424615, RC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "J", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { RC: 962323200, J: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968000 } }, B: { A: { "0": 0.01209, "1": 0.00806, "2": 0.01209, "3": 0.02015, "4": 0.01209, "5": 0.02015, "6": 0.02821, "7": 0.05239, C: 0.00403, K: 0.00403, L: 0.00403, G: 0.00403, M: 0, N: 0.00806, O: 0.01209, P: 0, Q: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0.31434, X: 0, Y: 0, Z: 0, a: 0, b: 0.01209, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0.02015, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0.00806, w: 0.01612, x: 0.01612, y: 0.07657, z: 0.01612, q: 1.56364, H: 2.5389 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "G", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "", "", ""], E: "Edge", F: { "0": 1678665600, "1": 1680825600, "2": 1683158400, "3": 1685664000, "4": 1689897600, "5": 1692576000, "6": 1694649600, "7": 1697155200, C: 1438128000, K: 1447286400, L: 1470096000, G: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, P: 1579046400, Q: 1581033600, R: 1586736000, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 1611360000, Y: 1614816000, Z: 1618358400, a: 1622073600, b: 1626912000, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, w: 1666915200, x: 1670198400, y: 1673481600, z: 1675900800, q: 1698969600, H: 1701993600 }, D: { C: "ms", K: "ms", L: "ms", G: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { "0": 0.00806, "1": 0.00403, "2": 0.01209, "3": 0.01612, "4": 0.43927, "5": 0.00806, "6": 0.01209, "7": 0.10881, "8": 0, "9": 0, SC: 0, "5B": 0, I: 0.00403, J: 0, D: 0, E: 0, F: 0, A: 0, B: 0.0403, C: 0.0403, K: 0, L: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0.00806, UB: 0.00806, VB: 0, WB: 0, XB: 0, YB: 0.00806, ZB: 0, aB: 0.00806, bB: 0, cB: 0.06448, dB: 0.00806, eB: 0.00806, fB: 0.00806, gB: 0.01612, hB: 0, iB: 0, "6B": 0.00403, jB: 0, "7B": 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0.00403, v: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0.02015, P: 0, Q: 0, R: 0, "8B": 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0.00806, Y: 0, Z: 0, a: 0.01612, b: 0, c: 0, d: 0.00806, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0.01209, l: 0.03224, m: 0.02418, n: 0.01209, o: 0.00806, p: 0.00403, w: 0.00806, x: 0.00806, y: 0.01209, z: 0.00806, q: 0.27807, H: 1.24124, "9B": 0.41912, AC: 0, BC: 0, TC: 0, UC: 0, VC: 0 }, B: "moz", C: ["SC", "5B", "UC", "VC", "I", "8", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "6B", "jB", "7B", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "8B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "9B", "AC", "BC", "TC"], E: "Firefox", F: { "0": 1678752000, "1": 1681171200, "2": 1683590400, "3": 1686009600, "4": 1688428800, "5": 1690848000, "6": 1693267200, "7": 1695686400, "8": 1308614400, "9": 1357603200, SC: 1161648000, "5B": 1213660800, UC: 1246320000, VC: 1264032000, I: 1300752000, J: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968000, C: 1331596800, K: 1335225600, L: 1338854400, G: 1342483200, M: 1346112000, N: 1349740800, O: 1353628800, r: 1361232000, s: 1364860800, t: 1368489600, u: 1372118400, AB: 1375747200, BB: 1379376000, CB: 1386633600, DB: 1391472000, EB: 1395100800, FB: 1398729600, GB: 1402358400, HB: 1405987200, IB: 1409616000, JB: 1413244800, KB: 1417392000, LB: 1421107200, MB: 1424736000, NB: 1428278400, OB: 1431475200, PB: 1435881600, QB: 1439251200, RB: 1442880000, SB: 1446508800, TB: 1450137600, UB: 1453852800, VB: 1457395200, WB: 1461628800, XB: 1465257600, YB: 1470096000, ZB: 1474329600, aB: 1479168000, bB: 1485216000, cB: 1488844800, dB: 1492560000, eB: 1497312000, fB: 1502150400, gB: 1506556800, hB: 1510617600, iB: 1516665600, "6B": 1520985600, jB: 1525824000, "7B": 1529971200, kB: 1536105600, lB: 1540252800, mB: 1544486400, nB: 1548720000, oB: 1552953600, pB: 1558396800, qB: 1562630400, rB: 1567468800, sB: 1571788800, tB: 1575331200, uB: 1578355200, v: 1581379200, vB: 1583798400, wB: 1586304000, xB: 1588636800, yB: 1591056000, zB: 1593475200, P: 1595894400, Q: 1598313600, R: 1600732800, "8B": 1603152000, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392000, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536000, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632000, p: 1666051200, w: 1668470400, x: 1670889600, y: 1673913600, z: 1676332800, q: 1698105600, H: 1700524800, "9B": 1702944000, AC: null, BC: null, TC: null } }, D: { A: { "0": 0.10478, "1": 0.12896, "2": 0.21359, "3": 0.14508, "4": 0.10075, "5": 0.2821, "6": 0.26598, "7": 0.82615, "8": 0, "9": 0, I: 0, J: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, K: 0, L: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0.00806, LB: 0, MB: 0, NB: 0, OB: 0.01612, PB: 0, QB: 0, RB: 0.00403, SB: 0, TB: 0, UB: 0, VB: 0.00806, WB: 0, XB: 0.00806, YB: 0.03627, ZB: 0.02821, aB: 0.01209, bB: 0, cB: 0, dB: 0.00806, eB: 0.00806, fB: 0.00403, gB: 0.01612, hB: 0.00806, iB: 0.00403, "6B": 0, jB: 0.03224, "7B": 0.00403, kB: 0, lB: 0.00403, mB: 0, nB: 0.00403, oB: 0.03224, pB: 0.00403, qB: 0.00403, rB: 0.04836, sB: 0.0806, tB: 0.00806, uB: 0.00806, v: 0.01209, vB: 0.01209, wB: 0.01209, xB: 0.02015, yB: 0.01209, zB: 0.01612, P: 0.13299, Q: 0.02821, R: 0.02821, S: 0.04433, T: 0.01209, U: 0.03627, V: 0.04433, W: 0.06851, X: 0.01612, Y: 0.01612, Z: 0.01612, a: 0.06448, b: 0.03627, c: 0.09672, d: 0.04836, e: 0.02418, f: 0.01612, g: 0.02015, h: 0.07254, i: 0.0403, j: 0.03224, k: 0.04433, l: 0.03627, m: 0.26598, n: 0.06851, o: 0.08463, p: 0.0806, w: 0.0806, x: 0.12896, y: 1.7732, z: 0.10075, q: 8.53554, H: 10.1596, "9B": 0.01612, AC: 0.01209, BC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "I", "8", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "6B", "jB", "7B", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "9B", "AC", "BC"], E: "Chrome", F: { "0": 1678147200, "1": 1680566400, "2": 1682985600, "3": 1685404800, "4": 1689724800, "5": 1692057600, "6": 1694476800, "7": 1696896000, "8": 1274745600, "9": 1332892800, I: 1264377600, J: 1283385600, D: 1287619200, E: 1291248000, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, G: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, r: 1337040000, s: 1340668800, t: 1343692800, u: 1348531200, AB: 1352246400, BB: 1357862400, CB: 1361404800, DB: 1364428800, EB: 1369094400, FB: 1374105600, GB: 1376956800, HB: 1384214400, IB: 1389657600, JB: 1392940800, KB: 1397001600, LB: 1400544000, MB: 1405468800, NB: 1409011200, OB: 1412640000, PB: 1416268800, QB: 1421798400, RB: 1425513600, SB: 1429401600, TB: 1432080000, UB: 1437523200, VB: 1441152000, WB: 1444780800, XB: 1449014400, YB: 1453248000, ZB: 1456963200, aB: 1460592000, bB: 1464134400, cB: 1469059200, dB: 1472601600, eB: 1476230400, fB: 1480550400, gB: 1485302400, hB: 1489017600, iB: 1492560000, "6B": 1496707200, jB: 1500940800, "7B": 1504569600, kB: 1508198400, lB: 1512518400, mB: 1516752000, nB: 1520294400, oB: 1523923200, pB: 1527552000, qB: 1532390400, rB: 1536019200, sB: 1539648000, tB: 1543968000, uB: 1548720000, v: 1552348800, vB: 1555977600, wB: 1559606400, xB: 1564444800, yB: 1568073600, zB: 1571702400, P: 1575936000, Q: 1580860800, R: 1586304000, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272000, a: 1621987200, b: 1626739200, c: 1630368000, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512000, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, w: 1666656000, x: 1669680000, y: 1673308800, z: 1675728000, q: 1698710400, H: 1701993600, "9B": null, AC: null, BC: null } }, E: { A: { "8": 0, I: 0, J: 0, D: 0.00806, E: 0.00403, F: 0.00403, A: 0, B: 0, C: 0, K: 0.00806, L: 0.05239, G: 0.00806, WC: 0, CC: 0, XC: 0.00806, YC: 0, ZC: 0, aC: 0.01209, DC: 0, "0B": 0.01612, "1B": 0.02015, EC: 0.0806, bC: 0.12493, cC: 0.02821, FC: 0.01612, GC: 0.03224, "2B": 0.04836, dC: 0.3224, "3B": 0.03224, HC: 0.0806, IC: 0.06448, JC: 0.1612, KC: 0.07254, LC: 0.12493, eC: 0.59241, "4B": 0.14911, MC: 1.26139, NC: 0.1612, OC: 0.00403, fC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "WC", "CC", "I", "8", "XC", "J", "YC", "D", "ZC", "E", "F", "aC", "A", "DC", "B", "0B", "C", "1B", "K", "EC", "L", "bC", "G", "cC", "FC", "GC", "2B", "dC", "3B", "HC", "IC", "JC", "KC", "LC", "eC", "4B", "MC", "NC", "OC", "fC", ""], E: "Safari", F: { "8": 1275868800, WC: 1205798400, CC: 1226534400, I: 1244419200, XC: 1311120000, J: 1343174400, YC: 1382400000, D: 1382400000, ZC: 1410998400, E: 1413417600, F: 1443657600, aC: 1458518400, A: 1474329600, DC: 1490572800, B: 1505779200, "0B": 1522281600, C: 1537142400, "1B": 1553472000, K: 1568851200, EC: 1585008000, L: 1600214400, bC: 1619395200, G: 1632096000, cC: 1635292800, FC: 1639353600, GC: 1647216000, "2B": 1652745600, dC: 1658275200, "3B": 1662940800, HC: 1666569600, IC: 1670889600, JC: 1674432000, KC: 1679875200, LC: 1684368000, eC: 1690156800, "4B": 1695686400, MC: 1698192000, NC: 1702252800, OC: null, fC: null } }, F: { A: { "9": 0, F: 0, B: 0, C: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0.01612, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, v: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, P: 0, Q: 0, R: 0, "8B": 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0.00403, e: 0.05642, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.02015, m: 0, n: 0.50778, o: 0.78585, p: 0.01612, gC: 0, hC: 0, iC: 0, jC: 0, "0B": 0, PC: 0, kC: 0, "1B": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "gC", "hC", "iC", "jC", "B", "0B", "PC", "kC", "C", "1B", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "8B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "", "", ""], E: "Opera", F: { "9": 1390867200, F: 1150761600, gC: 1223424000, hC: 1251763200, iC: 1267488000, jC: 1277942400, B: 1292457600, "0B": 1302566400, PC: 1309219200, kC: 1323129600, C: 1323129600, "1B": 1352073600, G: 1372723200, M: 1377561600, N: 1381104000, O: 1386288000, r: 1393891200, s: 1399334400, t: 1401753600, u: 1405987200, AB: 1409616000, BB: 1413331200, CB: 1417132800, DB: 1422316800, EB: 1425945600, FB: 1430179200, GB: 1433808000, HB: 1438646400, IB: 1442448000, JB: 1445904000, KB: 1449100800, LB: 1454371200, MB: 1457308800, NB: 1462320000, OB: 1465344000, PB: 1470096000, QB: 1474329600, RB: 1477267200, SB: 1481587200, TB: 1486425600, UB: 1490054400, VB: 1494374400, WB: 1498003200, XB: 1502236800, YB: 1506470400, ZB: 1510099200, aB: 1515024000, bB: 1517961600, cB: 1521676800, dB: 1525910400, eB: 1530144000, fB: 1534982400, gB: 1537833600, hB: 1543363200, iB: 1548201600, jB: 1554768000, kB: 1561593600, lB: 1566259200, mB: 1570406400, nB: 1573689600, oB: 1578441600, pB: 1583971200, qB: 1587513600, rB: 1592956800, sB: 1595894400, tB: 1600128000, uB: 1603238400, v: 1613520000, vB: 1612224000, wB: 1616544000, xB: 1619568000, yB: 1623715200, zB: 1627948800, P: 1631577600, Q: 1633392000, R: 1635984000, "8B": 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152000, Z: 1660780800, a: 1663113600, b: 1668816000, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024000, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 1699920000, o: 1699920000, p: 1702944000 }, D: { F: "o", B: "o", C: "o", gC: "o", hC: "o", iC: "o", jC: "o", "0B": "o", PC: "o", kC: "o", "1B": "o" } }, G: { A: { E: 0, CC: 0, lC: 0, QC: 0.00294848, mC: 0.00294848, nC: 0.00589696, oC: 0.0103197, pC: 0.00294848, qC: 0.0103197, rC: 0.0353818, sC: 0.00294848, tC: 0.0545469, uC: 0.0221136, vC: 0.0250621, wC: 0.0132682, xC: 0.27126, yC: 0.00589696, zC: 0.042753, "0C": 0.0147424, "1C": 0.0530726, "2C": 0.106145, "3C": 0.165115, "4C": 0.0707635, FC: 0.0810832, GC: 0.0987741, "2B": 0.126785, "5C": 0.971524, "3B": 0.308116, HC: 0.661934, IC: 0.293374, JC: 0.551366, KC: 0.110568, LC: 0.263889, "6C": 2.32635, "4B": 0.412787, MC: 6.85816, NC: 0.717955, OC: 0.0353818 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CC", "lC", "QC", "mC", "nC", "oC", "E", "pC", "qC", "rC", "sC", "tC", "uC", "vC", "wC", "xC", "yC", "zC", "0C", "1C", "2C", "3C", "4C", "FC", "GC", "2B", "5C", "3B", "HC", "IC", "JC", "KC", "LC", "6C", "4B", "MC", "NC", "OC", "", ""], E: "Safari on iOS", F: { CC: 1270252800, lC: 1283904000, QC: 1299628800, mC: 1331078400, nC: 1359331200, oC: 1394409600, E: 1410912000, pC: 1413763200, qC: 1442361600, rC: 1458518400, sC: 1473724800, tC: 1490572800, uC: 1505779200, vC: 1522281600, wC: 1537142400, xC: 1553472000, yC: 1568851200, zC: 1572220800, "0C": 1580169600, "1C": 1585008000, "2C": 1600214400, "3C": 1619395200, "4C": 1632096000, FC: 1639353600, GC: 1647216000, "2B": 1652659200, "5C": 1658275200, "3B": 1662940800, HC: 1666569600, IC: 1670889600, JC: 1674432000, KC: 1679875200, LC: 1684368000, "6C": 1690156800, "4B": 1694995200, MC: 1698192000, NC: 1702252800, OC: null } }, H: { A: { "7C": 0.07 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "7C", "", "", ""], E: "Opera Mini", F: { "7C": 1426464000 } }, I: { A: { "5B": 0, I: 0.0000489622, H: 0.24366, "8C": 0, "9C": 0.0000244811, AD: 0, BD: 0.0000489622, QC: 0.000171368, CD: 0, DD: 0.000709952 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "8C", "9C", "AD", "5B", "I", "BD", "QC", "CD", "DD", "H", "", "", ""], E: "Android Browser", F: { "8C": 1256515200, "9C": 1274313600, AD: 1291593600, "5B": 1298332800, I: 1318896000, BD: 1341792000, QC: 1374624000, CD: 1386547200, DD: 1401667200, H: 1701734400 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376000, A: 1359504000 } }, K: { A: { A: 0, B: 0, C: 0, v: 1.27348, "0B": 0, PC: 0, "1B": 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "0B", "PC", "C", "1B", "v", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752000, "0B": 1314835200, PC: 1318291200, C: 1330300800, "1B": 1349740800, v: 1673827200 }, D: { v: "webkit" } }, L: { A: { H: 40.1948 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""], E: "Chrome for Android", F: { H: 1701734400 } }, M: { A: { q: 0.310492 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "q", "", "", ""], E: "Firefox for Android", F: { q: 1698105600 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456000 } }, O: { A: { "2B": 0.883708 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "2B", "", "", ""], E: "UC Browser for Android", F: { "2B": 1687132800 }, D: { "2B": "webkit" } }, P: { A: { I: 0.1284, r: 0.0428001, s: 0.0856003, t: 0.1605, u: 2.04371, ED: 0.0107, FD: 0, GD: 0.0535002, HD: 0, ID: 0, DC: 0, JD: 0.0107, KD: 0, LD: 0.0214001, MD: 0, ND: 0, "3B": 0.0214001, "4B": 0.0321001, OD: 0.0214001, PD: 0.0428001 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "ED", "FD", "GD", "HD", "ID", "DC", "JD", "KD", "LD", "MD", "ND", "3B", "4B", "OD", "PD", "r", "s", "t", "u", "", "", ""], E: "Samsung Internet", F: { I: 1461024000, ED: 1481846400, FD: 1509408000, GD: 1528329600, HD: 1546128000, ID: 1554163200, DC: 1567900800, JD: 1582588800, KD: 1593475200, LD: 1605657600, MD: 1618531200, ND: 1629072000, "3B": 1640736000, "4B": 1651708800, OD: 1659657600, PD: 1667260800, r: 1677369600, s: 1684454400, t: 1689292800, u: 1697587200 } }, Q: { A: { EC: 0.167188 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "", "", ""], E: "QQ Browser", F: { EC: 1663718400 } }, R: { A: { QD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "QD", "", "", ""], E: "Baidu Browser", F: { QD: 1663027200 } }, S: { A: { RD: 0.083594, SD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RD", "SD", "", "", ""], E: "KaiOS Browser", F: { RD: 1527811200, SD: 1631664000 } } };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/unpacker/agents.js
var require_agents2 = __commonJS((exports, module) => {
  var unpackBrowserVersions = function(versionsData) {
    return Object.keys(versionsData).reduce((usage3, version2) => {
      usage3[versions[version2]] = versionsData[version2];
      return usage3;
    }, {});
  };
  var browsers = require_browsers2().browsers;
  var versions = require_browserVersions2().browserVersions;
  var agentsData = require_agents();
  exports.agents = Object.keys(agentsData).reduce((map, key) => {
    let versionsData = agentsData[key];
    map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {
      if (entry === "A") {
        data.usage_global = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === "C") {
        data.versions = versionsData[entry].reduce((list, version2) => {
          if (version2 === "") {
            list.push(null);
          } else {
            list.push(versions[version2]);
          }
          return list;
        }, []);
      } else if (entry === "D") {
        data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === "E") {
        data.browser = versionsData[entry];
      } else if (entry === "F") {
        data.release_date = Object.keys(versionsData[entry]).reduce((map2, key2) => {
          map2[versions[key2]] = versionsData[entry][key2];
          return map2;
        }, {});
      } else {
        data.prefix = versionsData[entry];
      }
      return data;
    }, {});
    return map;
  }, {});
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/node-releases/data/release-schedule/release-schedule.json
var require_release_schedule = __commonJS((exports, module) => {
  module.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Argon" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Dubnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Gallium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-23", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "" }, v23: { start: "2024-10-15", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-04-22", lts: "2025-10-28", maintenance: "2026-10-20", end: "2028-04-30", codename: "" } };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/electron-to-chromium/versions.js
var require_versions = __commonJS((exports, module) => {
  module.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "28.0": "120",
    "28.1": "120",
    "29.0": "121"
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/browserslist/error.js
var require_error = __commonJS((exports, module) => {
  var BrowserslistError = function(message) {
    this.name = "BrowserslistError";
    this.message = message;
    this.browserslist = true;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, BrowserslistError);
    }
  };
  BrowserslistError.prototype = Error.prototype;
  module.exports = BrowserslistError;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/browserslist/parse.js
var require_parse4 = __commonJS((exports, module) => {
  var flatten = function(array) {
    if (!Array.isArray(array))
      return [array];
    return array.reduce(function(a, b) {
      return a.concat(flatten(b));
    }, []);
  };
  var find = function(string, predicate) {
    for (var n = 1, max = string.length;n <= max; n++) {
      var parsed = string.substr(-n, n);
      if (predicate(parsed, n, max)) {
        return string.slice(0, -n);
      }
    }
    return "";
  };
  var matchQuery = function(all, query) {
    var node2 = { query };
    if (query.indexOf("not ") === 0) {
      node2.not = true;
      query = query.slice(4);
    }
    for (var name in all) {
      var type = all[name];
      var match = query.match(type.regexp);
      if (match) {
        node2.type = name;
        for (var i = 0;i < type.matches.length; i++) {
          node2[type.matches[i]] = match[i + 1];
        }
        return node2;
      }
    }
    node2.type = "unknown";
    return node2;
  };
  var matchBlock = function(all, string, qs) {
    var node2;
    return find(string, function(parsed, n, max) {
      if (AND_REGEXP.test(parsed)) {
        node2 = matchQuery(all, parsed.match(AND_REGEXP)[1]);
        node2.compose = "and";
        qs.unshift(node2);
        return true;
      } else if (OR_REGEXP.test(parsed)) {
        node2 = matchQuery(all, parsed.match(OR_REGEXP)[1]);
        node2.compose = "or";
        qs.unshift(node2);
        return true;
      } else if (n === max) {
        node2 = matchQuery(all, parsed.trim());
        node2.compose = "or";
        qs.unshift(node2);
        return true;
      }
      return false;
    });
  };
  var AND_REGEXP = /^\s+and\s+(.*)/i;
  var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;
  module.exports = function parse(all, queries) {
    if (!Array.isArray(queries))
      queries = [queries];
    return flatten(queries.map(function(block) {
      var qs = [];
      do {
        block = matchBlock(all, block, qs);
      } while (block);
      return qs;
    }));
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/lib/statuses.js
var require_statuses = __commonJS((exports, module) => {
  module.exports = {
    1: "ls",
    2: "rec",
    3: "pr",
    4: "cr",
    5: "wd",
    6: "other",
    7: "unoff"
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/lib/supported.js
var require_supported = __commonJS((exports, module) => {
  module.exports = {
    y: 1 << 0,
    n: 1 << 1,
    a: 1 << 2,
    p: 1 << 3,
    u: 1 << 4,
    x: 1 << 5,
    d: 1 << 6
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/unpacker/feature.js
var require_feature = __commonJS((exports, module) => {
  var unpackSupport = function(cipher) {
    let stats = Object.keys(supported).reduce((list, support) => {
      if (cipher & supported[support])
        list.push(support);
      return list;
    }, []);
    let notes = cipher >> 7;
    let notesArray = [];
    while (notes) {
      let note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
      notesArray.unshift(`#${note}`);
      notes -= Math.pow(2, note - 1);
    }
    return stats.concat(notesArray).join(" ");
  };
  var unpackFeature = function(packed) {
    let unpacked = {
      status: statuses[packed.B],
      title: packed.C,
      shown: packed.D
    };
    unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
      let browser = packed.A[key];
      browserStats[browsers[key]] = Object.keys(browser).reduce((stats, support) => {
        let packedVersions = browser[support].split(" ");
        let unpacked2 = unpackSupport(support);
        packedVersions.forEach((v) => stats[versions[v]] = unpacked2);
        return stats;
      }, {});
      return browserStats;
    }, {});
    return unpacked;
  };
  var statuses = require_statuses();
  var supported = require_supported();
  var browsers = require_browsers2().browsers;
  var versions = require_browserVersions2().browserVersions;
  var MATH2LOG = Math.log(2);
  module.exports = unpackFeature;
  module.exports.default = unpackFeature;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/caniuse-lite/dist/unpacker/region.js
var require_region = __commonJS((exports, module) => {
  var unpackRegion = function(packed) {
    return Object.keys(packed).reduce((list, browser) => {
      let data = packed[browser];
      list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {
        let stats = data[key];
        if (key === "_") {
          stats.split(" ").forEach((version2) => memo[version2] = null);
        } else {
          memo[key] = stats;
        }
        return memo;
      }, {});
      return list;
    }, {});
  };
  var browsers = require_browsers2().browsers;
  module.exports = unpackRegion;
  module.exports.default = unpackRegion;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/browserslist/node.js
var require_node3 = __commonJS((exports, module) => {
  var checkExtend = function(name) {
    var use = " Use `dangerousExtend` option to disable.";
    if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {
      throw new BrowserslistError("Browserslist config needs `browserslist-config-` prefix. " + use);
    }
    if (name.replace(/^@[^/]+\//, "").indexOf(".") !== -1) {
      throw new BrowserslistError("`.` not allowed in Browserslist config name. " + use);
    }
    if (name.indexOf("node_modules") !== -1) {
      throw new BrowserslistError("`node_modules` not allowed in Browserslist config." + use);
    }
  };
  var isFile = function(file) {
    if (file in filenessCache) {
      return filenessCache[file];
    }
    var result = fs3.existsSync(file) && fs3.statSync(file).isFile();
    if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
      filenessCache[file] = result;
    }
    return result;
  };
  var eachParent = function(file, callback) {
    var dir = isFile(file) ? path3.dirname(file) : file;
    var loc = path3.resolve(dir);
    do {
      var result = callback(loc);
      if (typeof result !== "undefined")
        return result;
    } while (loc !== (loc = path3.dirname(loc)));
    return;
  };
  var check = function(section) {
    if (Array.isArray(section)) {
      for (var i = 0;i < section.length; i++) {
        if (typeof section[i] !== "string") {
          throw new BrowserslistError(FORMAT);
        }
      }
    } else if (typeof section !== "string") {
      throw new BrowserslistError(FORMAT);
    }
  };
  var pickEnv = function(config2, opts) {
    if (typeof config2 !== "object")
      return config2;
    var name;
    if (typeof opts.env === "string") {
      name = opts.env;
    } else if (process.env.BROWSERSLIST_ENV) {
      name = process.env.BROWSERSLIST_ENV;
    } else if ("development") {
      name = "development";
    } else {
    }
    if (opts.throwOnMissing) {
      if (name && name !== "defaults" && !config2[name]) {
        throw new BrowserslistError("Missing config for Browserslist environment `" + name + "`");
      }
    }
    return config2[name] || config2.defaults;
  };
  var parsePackage = function(file) {
    var config2 = JSON.parse(fs3.readFileSync(file).toString().replace(/^\uFEFF/m, ""));
    if (config2.browserlist && !config2.browserslist) {
      throw new BrowserslistError("`browserlist` key instead of `browserslist` in " + file);
    }
    var list = config2.browserslist;
    if (Array.isArray(list) || typeof list === "string") {
      list = { defaults: list };
    }
    for (var i in list) {
      check(list[i]);
    }
    return list;
  };
  var latestReleaseTime = function(agents) {
    var latest = 0;
    for (var name in agents) {
      var dates = agents[name].releaseDate || {};
      for (var key in dates) {
        if (latest < dates[key]) {
          latest = dates[key];
        }
      }
    }
    return latest * 1000;
  };
  var normalizeStats = function(data, stats) {
    if (!data) {
      data = {};
    }
    if (stats && "dataByBrowser" in stats) {
      stats = stats.dataByBrowser;
    }
    if (typeof stats !== "object")
      return;
    var normalized = {};
    for (var i in stats) {
      var versions = Object.keys(stats[i]);
      if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
        var normal = data[i].versions[0];
        normalized[i] = {};
        normalized[i][normal] = stats[i][versions[0]];
      } else {
        normalized[i] = stats[i];
      }
    }
    return normalized;
  };
  var normalizeUsageData = function(usageData, data) {
    for (var browser in usageData) {
      var browserUsage = usageData[browser];
      if ("0" in browserUsage) {
        var versions = data[browser].versions;
        browserUsage[versions[versions.length - 1]] = browserUsage[0];
        delete browserUsage[0];
      }
    }
  };
  var feature = require_feature().default;
  var region = require_region().default;
  var path3 = __require("path");
  var fs3 = __require("fs");
  var BrowserslistError = require_error();
  var IS_SECTION = /^\s*\[(.+)]\s*$/;
  var CONFIG_PATTERN = /^browserslist-config-/;
  var SCOPED_CONFIG__PATTERN = /@[^/]+\/browserslist-config(-|$|\/)/;
  var TIME_TO_UPDATE_CANIUSE = 6 * 30 * 24 * 60 * 60 * 1000;
  var FORMAT = "Browserslist config should be a string or an array of strings with browser queries";
  var dataTimeChecked = false;
  var filenessCache = {};
  var configCache = {};
  module.exports = {
    loadQueries: function loadQueries(ctx, name) {
      if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
        checkExtend(name);
      }
      var queries = require(require.resolve(name, { paths: [".", ctx.path] }));
      if (queries) {
        if (Array.isArray(queries)) {
          return queries;
        } else if (typeof queries === "object") {
          if (!queries.defaults)
            queries.defaults = [];
          return pickEnv(queries, ctx, name);
        }
      }
      throw new BrowserslistError("`" + name + "` config exports not an array of queries or an object of envs");
    },
    loadStat: function loadStat(ctx, name, data) {
      if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
        checkExtend(name);
      }
      var stats = require(require.resolve(path3.join(name, "browserslist-stats.json"), { paths: ["."] }));
      return normalizeStats(data, stats);
    },
    getStat: function getStat(opts, data) {
      var stats;
      if (opts.stats) {
        stats = opts.stats;
      } else if (process.env.BROWSERSLIST_STATS) {
        stats = process.env.BROWSERSLIST_STATS;
      } else if (opts.path && path3.resolve && fs3.existsSync) {
        stats = eachParent(opts.path, function(dir) {
          var file = path3.join(dir, "browserslist-stats.json");
          return isFile(file) ? file : undefined;
        });
      }
      if (typeof stats === "string") {
        try {
          stats = JSON.parse(fs3.readFileSync(stats));
        } catch (e) {
          throw new BrowserslistError("Can't read " + stats);
        }
      }
      return normalizeStats(data, stats);
    },
    loadConfig: function loadConfig(opts) {
      if (process.env.BROWSERSLIST) {
        return process.env.BROWSERSLIST;
      } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
        var file = opts.config || process.env.BROWSERSLIST_CONFIG;
        if (path3.basename(file) === "package.json") {
          return pickEnv(parsePackage(file), opts);
        } else {
          return pickEnv(module.exports.readConfig(file), opts);
        }
      } else if (opts.path) {
        return pickEnv(module.exports.findConfig(opts.path), opts);
      } else {
        return;
      }
    },
    loadCountry: function loadCountry(usage3, country, data) {
      var code = country.replace(/[^\w-]/g, "");
      if (!usage3[code]) {
        var compressed;
        try {
          compressed = require("caniuse-lite/data/regions/" + code + ".js");
        } catch (e) {
          throw new BrowserslistError("Unknown region name `" + code + "`.");
        }
        var usageData = region(compressed);
        normalizeUsageData(usageData, data);
        usage3[country] = {};
        for (var i in usageData) {
          for (var j in usageData[i]) {
            usage3[country][i + " " + j] = usageData[i][j];
          }
        }
      }
    },
    loadFeature: function loadFeature(features, name) {
      name = name.replace(/[^\w-]/g, "");
      if (features[name])
        return;
      var compressed;
      try {
        compressed = require("caniuse-lite/data/features/" + name + ".js");
      } catch (e) {
        throw new BrowserslistError("Unknown feature name `" + name + "`.");
      }
      var stats = feature(compressed).stats;
      features[name] = {};
      for (var i in stats) {
        features[name][i] = {};
        for (var j in stats[i]) {
          features[name][i][j] = stats[i][j];
        }
      }
    },
    parseConfig: function parseConfig(string) {
      var result = { defaults: [] };
      var sections = ["defaults"];
      string.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(line) {
        return line.trim();
      }).filter(function(line) {
        return line !== "";
      }).forEach(function(line) {
        if (IS_SECTION.test(line)) {
          sections = line.match(IS_SECTION)[1].trim().split(" ");
          sections.forEach(function(section) {
            if (result[section]) {
              throw new BrowserslistError("Duplicate section " + section + " in Browserslist config");
            }
            result[section] = [];
          });
        } else {
          sections.forEach(function(section) {
            result[section].push(line);
          });
        }
      });
      return result;
    },
    readConfig: function readConfig(file) {
      if (!isFile(file)) {
        throw new BrowserslistError("Can't read " + file + " config");
      }
      return module.exports.parseConfig(fs3.readFileSync(file));
    },
    findConfig: function findConfig(from) {
      from = path3.resolve(from);
      var passed = [];
      var resolved = eachParent(from, function(dir) {
        if (dir in configCache) {
          return configCache[dir];
        }
        passed.push(dir);
        var config2 = path3.join(dir, "browserslist");
        var pkg = path3.join(dir, "package.json");
        var rc = path3.join(dir, ".browserslistrc");
        var pkgBrowserslist;
        if (isFile(pkg)) {
          try {
            pkgBrowserslist = parsePackage(pkg);
          } catch (e) {
            if (e.name === "BrowserslistError")
              throw e;
            console.warn("[Browserslist] Could not parse " + pkg + ". Ignoring it.");
          }
        }
        if (isFile(config2) && pkgBrowserslist) {
          throw new BrowserslistError(dir + " contains both browserslist and package.json with browsers");
        } else if (isFile(rc) && pkgBrowserslist) {
          throw new BrowserslistError(dir + " contains both .browserslistrc and package.json with browsers");
        } else if (isFile(config2) && isFile(rc)) {
          throw new BrowserslistError(dir + " contains both .browserslistrc and browserslist");
        } else if (isFile(config2)) {
          return module.exports.readConfig(config2);
        } else if (isFile(rc)) {
          return module.exports.readConfig(rc);
        } else {
          return pkgBrowserslist;
        }
      });
      if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
        passed.forEach(function(dir) {
          configCache[dir] = resolved;
        });
      }
      return resolved;
    },
    clearCaches: function clearCaches() {
      dataTimeChecked = false;
      filenessCache = {};
      configCache = {};
      this.cache = {};
    },
    oldDataWarning: function oldDataWarning(agentsObj) {
      if (dataTimeChecked)
        return;
      dataTimeChecked = true;
      if (process.env.BROWSERSLIST_IGNORE_OLD_DATA)
        return;
      var latest = latestReleaseTime(agentsObj);
      var halfYearAgo = Date.now() - TIME_TO_UPDATE_CANIUSE;
      if (latest !== 0 && latest < halfYearAgo) {
        console.warn("Browserslist: caniuse-lite is outdated. Please run:\n  npx update-browserslist-db@latest\n  Why you should do it regularly: https://github.com/browserslist/update-db#readme");
      }
    },
    currentNode: function currentNode() {
      return "node " + process.versions.node;
    },
    env: process.env
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/browserslist/index.js
var require_browserslist = __commonJS((exports, module) => {
  var isVersionsMatch = function(versionA, versionB) {
    return (versionA + ".").indexOf(versionB + ".") === 0;
  };
  var isEolReleased = function(name) {
    var version2 = name.slice(1);
    return browserslist.nodeVersions.some(function(i) {
      return isVersionsMatch(i, version2);
    });
  };
  var normalize2 = function(versions) {
    return versions.filter(function(version2) {
      return typeof version2 === "string";
    });
  };
  var normalizeElectron = function(version2) {
    var versionToUse = version2;
    if (version2.split(".").length === 3) {
      versionToUse = version2.split(".").slice(0, -1).join(".");
    }
    return versionToUse;
  };
  var nameMapper = function(name) {
    return function mapName(version2) {
      return name + " " + version2;
    };
  };
  var getMajor = function(version2) {
    return parseInt(version2.split(".")[0]);
  };
  var getMajorVersions = function(released, number) {
    if (released.length === 0)
      return [];
    var majorVersions = uniq(released.map(getMajor));
    var minimum = majorVersions[majorVersions.length - number];
    if (!minimum) {
      return released;
    }
    var selected = [];
    for (var i = released.length - 1;i >= 0; i--) {
      if (minimum > getMajor(released[i]))
        break;
      selected.unshift(released[i]);
    }
    return selected;
  };
  var uniq = function(array) {
    var filtered = [];
    for (var i = 0;i < array.length; i++) {
      if (filtered.indexOf(array[i]) === -1)
        filtered.push(array[i]);
    }
    return filtered;
  };
  var fillUsage = function(result, name, data) {
    for (var i in data) {
      result[name + " " + i] = data[i];
    }
  };
  var generateFilter = function(sign, version2) {
    version2 = parseFloat(version2);
    if (sign === ">") {
      return function(v) {
        return parseFloat(v) > version2;
      };
    } else if (sign === ">=") {
      return function(v) {
        return parseFloat(v) >= version2;
      };
    } else if (sign === "<") {
      return function(v) {
        return parseFloat(v) < version2;
      };
    } else {
      return function(v) {
        return parseFloat(v) <= version2;
      };
    }
  };
  var generateSemverFilter = function(sign, version2) {
    version2 = version2.split(".").map(parseSimpleInt);
    version2[1] = version2[1] || 0;
    version2[2] = version2[2] || 0;
    if (sign === ">") {
      return function(v) {
        v = v.split(".").map(parseSimpleInt);
        return compareSemver(v, version2) > 0;
      };
    } else if (sign === ">=") {
      return function(v) {
        v = v.split(".").map(parseSimpleInt);
        return compareSemver(v, version2) >= 0;
      };
    } else if (sign === "<") {
      return function(v) {
        v = v.split(".").map(parseSimpleInt);
        return compareSemver(version2, v) > 0;
      };
    } else {
      return function(v) {
        v = v.split(".").map(parseSimpleInt);
        return compareSemver(version2, v) >= 0;
      };
    }
  };
  var parseSimpleInt = function(x) {
    return parseInt(x);
  };
  var compare = function(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  };
  var compareSemver = function(a, b) {
    return compare(parseInt(a[0]), parseInt(b[0])) || compare(parseInt(a[1] || "0"), parseInt(b[1] || "0")) || compare(parseInt(a[2] || "0"), parseInt(b[2] || "0"));
  };
  var semverFilterLoose = function(operator, range) {
    range = range.split(".").map(parseSimpleInt);
    if (typeof range[1] === "undefined") {
      range[1] = "x";
    }
    switch (operator) {
      case "<=":
        return function(version2) {
          version2 = version2.split(".").map(parseSimpleInt);
          return compareSemverLoose(version2, range) <= 0;
        };
      case ">=":
      default:
        return function(version2) {
          version2 = version2.split(".").map(parseSimpleInt);
          return compareSemverLoose(version2, range) >= 0;
        };
    }
  };
  var compareSemverLoose = function(version2, range) {
    if (version2[0] !== range[0]) {
      return version2[0] < range[0] ? -1 : 1;
    }
    if (range[1] === "x") {
      return 0;
    }
    if (version2[1] !== range[1]) {
      return version2[1] < range[1] ? -1 : 1;
    }
    return 0;
  };
  var resolveVersion = function(data, version2) {
    if (data.versions.indexOf(version2) !== -1) {
      return version2;
    } else if (browserslist.versionAliases[data.name][version2]) {
      return browserslist.versionAliases[data.name][version2];
    } else {
      return false;
    }
  };
  var normalizeVersion = function(data, version2) {
    var resolved = resolveVersion(data, version2);
    if (resolved) {
      return resolved;
    } else if (data.versions.length === 1) {
      return data.versions[0];
    } else {
      return false;
    }
  };
  var filterByYear = function(since, context) {
    since = since / 1000;
    return Object.keys(agents).reduce(function(selected, name) {
      var data = byName(name, context);
      if (!data)
        return selected;
      var versions = Object.keys(data.releaseDate).filter(function(v) {
        var date = data.releaseDate[v];
        return date !== null && date >= since;
      });
      return selected.concat(versions.map(nameMapper(data.name)));
    }, []);
  };
  var cloneData = function(data) {
    return {
      name: data.name,
      versions: data.versions,
      released: data.released,
      releaseDate: data.releaseDate
    };
  };
  var byName = function(name, context) {
    name = name.toLowerCase();
    name = browserslist.aliases[name] || name;
    if (context.mobileToDesktop && browserslist.desktopNames[name]) {
      var desktop = browserslist.data[browserslist.desktopNames[name]];
      if (name === "android") {
        return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
      } else {
        var cloned = cloneData(desktop);
        cloned.name = name;
        return cloned;
      }
    }
    return browserslist.data[name];
  };
  var normalizeAndroidVersions = function(androidVersions, chromeVersions) {
    var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST);
    return androidVersions.filter(function(version2) {
      return /^(?:[2-4]\.|[34]$)/.test(version2);
    }).concat(chromeVersions.slice(iFirstEvergreen));
  };
  var copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
      copy[key] = obj[key];
    }
    return copy;
  };
  var normalizeAndroidData = function(android, chrome) {
    android.released = normalizeAndroidVersions(android.released, chrome.released);
    android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
    android.releaseDate = copyObject(android.releaseDate);
    android.released.forEach(function(v) {
      if (android.releaseDate[v] === undefined) {
        android.releaseDate[v] = chrome.releaseDate[v];
      }
    });
    return android;
  };
  var checkName = function(name, context) {
    var data = byName(name, context);
    if (!data)
      throw new BrowserslistError("Unknown browser " + name);
    return data;
  };
  var unknownQuery = function(query) {
    return new BrowserslistError("Unknown browser query `" + query + "`. Maybe you are using old Browserslist or made typo in query.");
  };
  var filterJumps = function(list, name, nVersions, context) {
    var jump = 1;
    switch (name) {
      case "android":
        if (context.mobileToDesktop)
          return list;
        var released = browserslist.data.chrome.released;
        jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST);
        break;
      case "op_mob":
        var latest = browserslist.data.op_mob.released.slice(-1)[0];
        jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1;
        break;
      default:
        return list;
    }
    if (nVersions <= jump) {
      return list.slice(-1);
    }
    return list.slice(jump - 1 - nVersions);
  };
  var isSupported = function(flags, withPartial) {
    return typeof flags === "string" && (flags.indexOf("y") >= 0 || withPartial && flags.indexOf("a") >= 0);
  };
  var resolve6 = function(queries, context) {
    return parse2(QUERIES, queries).reduce(function(result, node2, index) {
      if (node2.not && index === 0) {
        throw new BrowserslistError("Write any browsers query (for instance, `defaults`) before `" + node2.query + "`");
      }
      var type = QUERIES[node2.type];
      var array = type.select.call(browserslist, context, node2).map(function(j) {
        var parts = j.split(" ");
        if (parts[1] === "0") {
          return parts[0] + " " + byName(parts[0], context).versions[0];
        } else {
          return j;
        }
      });
      if (node2.compose === "and") {
        if (node2.not) {
          return result.filter(function(j) {
            return array.indexOf(j) === -1;
          });
        } else {
          return result.filter(function(j) {
            return array.indexOf(j) !== -1;
          });
        }
      } else {
        if (node2.not) {
          var filter = {};
          array.forEach(function(j) {
            filter[j] = true;
          });
          return result.filter(function(j) {
            return !filter[j];
          });
        }
        return result.concat(array);
      }
    }, []);
  };
  var prepareOpts = function(opts) {
    if (typeof opts === "undefined")
      opts = {};
    if (typeof opts.path === "undefined") {
      opts.path = path3.resolve ? path3.resolve(".") : ".";
    }
    return opts;
  };
  var prepareQueries = function(queries, opts) {
    if (typeof queries === "undefined" || queries === null) {
      var config2 = browserslist.loadConfig(opts);
      if (config2) {
        queries = config2;
      } else {
        queries = browserslist.defaults;
      }
    }
    return queries;
  };
  var checkQueries = function(queries) {
    if (!(typeof queries === "string" || Array.isArray(queries))) {
      throw new BrowserslistError("Browser queries must be an array or string. Got " + typeof queries + ".");
    }
  };
  var browserslist = function(queries, opts) {
    opts = prepareOpts(opts);
    queries = prepareQueries(queries, opts);
    checkQueries(queries);
    var context = {
      ignoreUnknownVersions: opts.ignoreUnknownVersions,
      dangerousExtend: opts.dangerousExtend,
      mobileToDesktop: opts.mobileToDesktop,
      path: opts.path,
      env: opts.env
    };
    env2.oldDataWarning(browserslist.data);
    var stats = env2.getStat(opts, browserslist.data);
    if (stats) {
      context.customUsage = {};
      for (var browser in stats) {
        fillUsage(context.customUsage, browser, stats[browser]);
      }
    }
    var cacheKey = JSON.stringify([queries, context]);
    if (cache[cacheKey])
      return cache[cacheKey];
    var result = uniq(resolve6(queries, context)).sort(function(name1, name2) {
      name1 = name1.split(" ");
      name2 = name2.split(" ");
      if (name1[0] === name2[0]) {
        var version1 = name1[1].split("-")[0];
        var version2 = name2[1].split("-")[0];
        return compareSemver(version2.split("."), version1.split("."));
      } else {
        return compare(name1[0], name2[0]);
      }
    });
    if (!env2.env.BROWSERSLIST_DISABLE_CACHE) {
      cache[cacheKey] = result;
    }
    return result;
  };
  var nodeQuery = function(context, node2) {
    var matched = browserslist.nodeVersions.filter(function(i) {
      return isVersionsMatch(i, node2.version);
    });
    if (matched.length === 0) {
      if (context.ignoreUnknownVersions) {
        return [];
      } else {
        throw new BrowserslistError("Unknown version " + node2.version + " of Node.js");
      }
    }
    return ["node " + matched[matched.length - 1]];
  };
  var sinceQuery = function(context, node2) {
    var year = parseInt(node2.year);
    var month = parseInt(node2.month || "01") - 1;
    var day = parseInt(node2.day || "01");
    return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context);
  };
  var coverQuery = function(context, node2) {
    var coverage = parseFloat(node2.coverage);
    var usage3 = browserslist.usage.global;
    if (node2.place) {
      if (node2.place.match(/^my\s+stats$/i)) {
        if (!context.customUsage) {
          throw new BrowserslistError("Custom usage statistics was not provided");
        }
        usage3 = context.customUsage;
      } else {
        var place;
        if (node2.place.length === 2) {
          place = node2.place.toUpperCase();
        } else {
          place = node2.place.toLowerCase();
        }
        env2.loadCountry(browserslist.usage, place, browserslist.data);
        usage3 = browserslist.usage[place];
      }
    }
    var versions = Object.keys(usage3).sort(function(a, b) {
      return usage3[b] - usage3[a];
    });
    var coveraged = 0;
    var result = [];
    var version2;
    for (var i = 0;i < versions.length; i++) {
      version2 = versions[i];
      if (usage3[version2] === 0)
        break;
      coveraged += usage3[version2];
      result.push(version2);
      if (coveraged >= coverage)
        break;
    }
    return result;
  };
  var jsReleases = require_envs();
  var agents = require_agents2().agents;
  var jsEOL = require_release_schedule();
  var path3 = __require("path");
  var e2c = require_versions();
  var BrowserslistError = require_error();
  var parse2 = require_parse4();
  var env2 = require_node3();
  var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
  var ANDROID_EVERGREEN_FIRST = "37";
  var OP_MOB_BLINK_FIRST = 14;
  var cache = {};
  browserslist.parse = function(queries, opts) {
    opts = prepareOpts(opts);
    queries = prepareQueries(queries, opts);
    checkQueries(queries);
    return parse2(QUERIES, queries);
  };
  browserslist.cache = {};
  browserslist.data = {};
  browserslist.usage = {
    global: {},
    custom: null
  };
  browserslist.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
  browserslist.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  };
  browserslist.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    android: "chrome"
  };
  browserslist.versionAliases = {};
  browserslist.clearCaches = env2.clearCaches;
  browserslist.parseConfig = env2.parseConfig;
  browserslist.readConfig = env2.readConfig;
  browserslist.findConfig = env2.findConfig;
  browserslist.loadConfig = env2.loadConfig;
  browserslist.coverage = function(browsers, stats) {
    var data;
    if (typeof stats === "undefined") {
      data = browserslist.usage.global;
    } else if (stats === "my stats") {
      var opts = {};
      opts.path = path3.resolve ? path3.resolve(".") : ".";
      var customStats = env2.getStat(opts);
      if (!customStats) {
        throw new BrowserslistError("Custom usage statistics was not provided");
      }
      data = {};
      for (var browser in customStats) {
        fillUsage(data, browser, customStats[browser]);
      }
    } else if (typeof stats === "string") {
      if (stats.length > 2) {
        stats = stats.toLowerCase();
      } else {
        stats = stats.toUpperCase();
      }
      env2.loadCountry(browserslist.usage, stats, browserslist.data);
      data = browserslist.usage[stats];
    } else {
      if ("dataByBrowser" in stats) {
        stats = stats.dataByBrowser;
      }
      data = {};
      for (var name in stats) {
        for (var version2 in stats[name]) {
          data[name + " " + version2] = stats[name][version2];
        }
      }
    }
    return browsers.reduce(function(all, i) {
      var usage3 = data[i];
      if (usage3 === undefined) {
        usage3 = data[i.replace(/ \S+$/, " 0")];
      }
      return all + (usage3 || 0);
    }, 0);
  };
  var QUERIES = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: function(context, node2) {
        return Object.keys(agents).reduce(function(selected, name) {
          var data = byName(name, context);
          if (!data)
            return selected;
          var list = getMajorVersions(data.released, node2.versions);
          list = list.map(nameMapper(data.name));
          list = filterJumps(list, data.name, node2.versions, context);
          return selected.concat(list);
        }, []);
      }
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: function(context, node2) {
        return Object.keys(agents).reduce(function(selected, name) {
          var data = byName(name, context);
          if (!data)
            return selected;
          var list = data.released.slice(-node2.versions);
          list = list.map(nameMapper(data.name));
          list = filterJumps(list, data.name, node2.versions, context);
          return selected.concat(list);
        }, []);
      }
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: function(context, node2) {
        var validVersions = getMajorVersions(Object.keys(e2c), node2.versions);
        return validVersions.map(function(i) {
          return "chrome " + e2c[i];
        });
      }
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: function(context, node2) {
        return getMajorVersions(browserslist.nodeVersions, node2.versions).map(function(version2) {
          return "node " + version2;
        });
      }
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: function(context, node2) {
        var data = checkName(node2.browser, context);
        var validVersions = getMajorVersions(data.released, node2.versions);
        var list = validVersions.map(nameMapper(data.name));
        list = filterJumps(list, data.name, node2.versions, context);
        return list;
      }
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: function(context, node2) {
        return Object.keys(e2c).slice(-node2.versions).map(function(i) {
          return "chrome " + e2c[i];
        });
      }
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: function(context, node2) {
        return browserslist.nodeVersions.slice(-node2.versions).map(function(version2) {
          return "node " + version2;
        });
      }
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: function(context, node2) {
        var data = checkName(node2.browser, context);
        var list = data.released.slice(-node2.versions).map(nameMapper(data.name));
        list = filterJumps(list, data.name, node2.versions, context);
        return list;
      }
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: function(context) {
        return Object.keys(agents).reduce(function(selected, name) {
          var data = byName(name, context);
          if (!data)
            return selected;
          var list = data.versions.filter(function(v) {
            return data.released.indexOf(v) === -1;
          });
          list = list.map(nameMapper(data.name));
          return selected.concat(list);
        }, []);
      }
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: function() {
        return [];
      }
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: function(context, node2) {
        var data = checkName(node2.browser, context);
        return data.versions.filter(function(v) {
          return data.released.indexOf(v) === -1;
        }).map(nameMapper(data.name));
      }
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
      select: function(context, node2) {
        return filterByYear(Date.now() - YEAR * node2.years, context);
      }
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: sinceQuery
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: sinceQuery
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: sinceQuery
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: function(context, node2) {
        var popularity = parseFloat(node2.popularity);
        var usage3 = browserslist.usage.global;
        return Object.keys(usage3).reduce(function(result, version2) {
          if (node2.sign === ">") {
            if (usage3[version2] > popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<") {
            if (usage3[version2] < popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<=") {
            if (usage3[version2] <= popularity) {
              result.push(version2);
            }
          } else if (usage3[version2] >= popularity) {
            result.push(version2);
          }
          return result;
        }, []);
      }
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: function(context, node2) {
        var popularity = parseFloat(node2.popularity);
        if (!context.customUsage) {
          throw new BrowserslistError("Custom usage statistics was not provided");
        }
        var usage3 = context.customUsage;
        return Object.keys(usage3).reduce(function(result, version2) {
          var percentage = usage3[version2];
          if (percentage == null) {
            return result;
          }
          if (node2.sign === ">") {
            if (percentage > popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<") {
            if (percentage < popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<=") {
            if (percentage <= popularity) {
              result.push(version2);
            }
          } else if (percentage >= popularity) {
            result.push(version2);
          }
          return result;
        }, []);
      }
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: function(context, node2) {
        var popularity = parseFloat(node2.popularity);
        var stats = env2.loadStat(context, node2.config, browserslist.data);
        if (stats) {
          context.customUsage = {};
          for (var browser in stats) {
            fillUsage(context.customUsage, browser, stats[browser]);
          }
        }
        if (!context.customUsage) {
          throw new BrowserslistError("Custom usage statistics was not provided");
        }
        var usage3 = context.customUsage;
        return Object.keys(usage3).reduce(function(result, version2) {
          var percentage = usage3[version2];
          if (percentage == null) {
            return result;
          }
          if (node2.sign === ">") {
            if (percentage > popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<") {
            if (percentage < popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<=") {
            if (percentage <= popularity) {
              result.push(version2);
            }
          } else if (percentage >= popularity) {
            result.push(version2);
          }
          return result;
        }, []);
      }
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: function(context, node2) {
        var popularity = parseFloat(node2.popularity);
        var place = node2.place;
        if (place.length === 2) {
          place = place.toUpperCase();
        } else {
          place = place.toLowerCase();
        }
        env2.loadCountry(browserslist.usage, place, browserslist.data);
        var usage3 = browserslist.usage[place];
        return Object.keys(usage3).reduce(function(result, version2) {
          var percentage = usage3[version2];
          if (percentage == null) {
            return result;
          }
          if (node2.sign === ">") {
            if (percentage > popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<") {
            if (percentage < popularity) {
              result.push(version2);
            }
          } else if (node2.sign === "<=") {
            if (percentage <= popularity) {
              result.push(version2);
            }
          } else if (percentage >= popularity) {
            result.push(version2);
          }
          return result;
        }, []);
      }
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: coverQuery
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: coverQuery
    },
    supports: {
      matches: ["supportType", "feature"],
      regexp: /^(?:(fully|partially) )?supports\s+([\w-]+)$/,
      select: function(context, node2) {
        env2.loadFeature(browserslist.cache, node2.feature);
        var withPartial = node2.supportType !== "fully";
        var features = browserslist.cache[node2.feature];
        var result = [];
        for (var name in features) {
          var data = byName(name, context);
          var checkDesktop = context.mobileToDesktop && name in browserslist.desktopNames && isSupported(features[name][data.released.slice(-1)[0]], withPartial);
          data.versions.forEach(function(version2) {
            var flags = features[name][version2];
            if (flags === undefined && checkDesktop) {
              flags = features[browserslist.desktopNames[name]][version2];
            }
            if (isSupported(flags, withPartial)) {
              result.push(name + " " + version2);
            }
          });
        }
        return result;
      }
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function(context, node2) {
        var fromToUse = normalizeElectron(node2.from);
        var toToUse = normalizeElectron(node2.to);
        var from = parseFloat(node2.from);
        var to = parseFloat(node2.to);
        if (!e2c[fromToUse]) {
          throw new BrowserslistError("Unknown version " + from + " of electron");
        }
        if (!e2c[toToUse]) {
          throw new BrowserslistError("Unknown version " + to + " of electron");
        }
        return Object.keys(e2c).filter(function(i) {
          var parsed = parseFloat(i);
          return parsed >= from && parsed <= to;
        }).map(function(i) {
          return "chrome " + e2c[i];
        });
      }
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function(context, node2) {
        return browserslist.nodeVersions.filter(semverFilterLoose(">=", node2.from)).filter(semverFilterLoose("<=", node2.to)).map(function(v) {
          return "node " + v;
        });
      }
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function(context, node2) {
        var data = checkName(node2.browser, context);
        var from = parseFloat(normalizeVersion(data, node2.from) || node2.from);
        var to = parseFloat(normalizeVersion(data, node2.to) || node2.to);
        function filter(v) {
          var parsed = parseFloat(v);
          return parsed >= from && parsed <= to;
        }
        return data.released.filter(filter).map(nameMapper(data.name));
      }
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: function(context, node2) {
        var versionToUse = normalizeElectron(node2.version);
        return Object.keys(e2c).filter(generateFilter(node2.sign, versionToUse)).map(function(i) {
          return "chrome " + e2c[i];
        });
      }
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: function(context, node2) {
        return browserslist.nodeVersions.filter(generateSemverFilter(node2.sign, node2.version)).map(function(v) {
          return "node " + v;
        });
      }
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: function(context, node2) {
        var version2 = node2.version;
        var data = checkName(node2.browser, context);
        var alias = browserslist.versionAliases[data.name][version2];
        if (alias)
          version2 = alias;
        return data.released.filter(generateFilter(node2.sign, version2)).map(function(v) {
          return data.name + " " + v;
        });
      }
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: function() {
        return ["firefox 115"];
      }
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: function() {
        return ["op_mini all"];
      }
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: function(context, node2) {
        var versionToUse = normalizeElectron(node2.version);
        var chrome = e2c[versionToUse];
        if (!chrome) {
          throw new BrowserslistError("Unknown version " + node2.version + " of electron");
        }
        return ["chrome " + chrome];
      }
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: nodeQuery
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: nodeQuery
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: nodeQuery
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: function(context) {
        return [env2.currentNode(resolve6, context)];
      }
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: function(context) {
        var now = Date.now();
        var queries = Object.keys(jsEOL).filter(function(key) {
          return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
        }).map(function(key) {
          return "node " + key.slice(1);
        });
        return resolve6(queries, context);
      }
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: function() {
        return ["safari 5"];
      }
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: function() {
        return ["safari 6"];
      }
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: function(context, node2) {
        var version2 = node2.version;
        if (/^tp$/i.test(version2))
          version2 = "TP";
        var data = checkName(node2.browser, context);
        var alias = normalizeVersion(data, version2);
        if (alias) {
          version2 = alias;
        } else {
          if (version2.indexOf(".") === -1) {
            alias = version2 + ".0";
          } else {
            alias = version2.replace(/\.0$/, "");
          }
          alias = normalizeVersion(data, alias);
          if (alias) {
            version2 = alias;
          } else if (context.ignoreUnknownVersions) {
            return [];
          } else {
            throw new BrowserslistError("Unknown version " + version2 + " of " + node2.browser);
          }
        }
        return [data.name + " " + version2];
      }
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      select: function(context) {
        return browserslist(undefined, context);
      }
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      select: function(context, node2) {
        return resolve6(env2.loadQueries(context, node2.config), context);
      }
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: function(context) {
        return resolve6(browserslist.defaults, context);
      }
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: function(context) {
        var dead = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return resolve6(dead, context);
      }
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: function(context, node2) {
        if (byName(node2.query, context)) {
          throw new BrowserslistError("Specify versions in Browserslist query for browser " + node2.query);
        } else {
          throw unknownQuery(node2.query);
        }
      }
    }
  };
  (function() {
    for (var name in agents) {
      var browser = agents[name];
      browserslist.data[name] = {
        name,
        versions: normalize2(agents[name].versions),
        released: normalize2(agents[name].versions.slice(0, -3)),
        releaseDate: agents[name].release_date
      };
      fillUsage(browserslist.usage.global, name, browser.usage_global);
      browserslist.versionAliases[name] = {};
      for (var i = 0;i < browser.versions.length; i++) {
        var full = browser.versions[i];
        if (!full)
          continue;
        if (full.indexOf("-") !== -1) {
          var interval = full.split("-");
          for (var j = 0;j < interval.length; j++) {
            browserslist.versionAliases[name][interval[j]] = full;
          }
        }
      }
    }
    browserslist.nodeVersions = jsReleases.map(function(release) {
      return release.version;
    });
  })();
  module.exports = browserslist;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/compat-data/data/native-modules.json
var require_native_modules = __commonJS((exports, module) => {
  module.exports = {
    "es6.module": {
      chrome: "61",
      and_chr: "61",
      edge: "16",
      firefox: "60",
      and_ff: "60",
      node: "13.2.0",
      opera: "48",
      op_mob: "45",
      safari: "10.1",
      ios: "10.3",
      samsung: "8.2",
      android: "61",
      electron: "2.0",
      ios_saf: "10.3"
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node2, value2) {
    var inserted = node2 === self2.head ? new Node(value2, null, node2, self2) : new Node(value2, node2, node2.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value2, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value2, prev, next, list);
    }
    this.list = list;
    this.value = value2;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node2) {
    if (node2.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node2.next;
    var prev = node2.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node2 === this.head) {
      this.head = next;
    }
    if (node2 === this.tail) {
      this.tail = prev;
    }
    node2.list.length--;
    node2.next = null;
    node2.prev = null;
    node2.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node2) {
    if (node2 === this.head) {
      return;
    }
    if (node2.list) {
      node2.list.removeNode(node2);
    }
    var head = this.head;
    node2.list = this;
    node2.next = head;
    if (head) {
      head.prev = node2;
    }
    this.head = node2;
    if (!this.tail) {
      this.tail = node2;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node2) {
    if (node2 === this.tail) {
      return;
    }
    if (node2.list) {
      node2.list.removeNode(node2);
    }
    var tail = this.tail;
    node2.list = this;
    node2.prev = tail;
    if (tail) {
      tail.next = node2;
    }
    this.tail = node2;
    if (!this.head) {
      this.head = node2;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 2;i < arguments.length; i++) {
      walker = insert(this, walker, arguments[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value2, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value2, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node2 = this[CACHE].get(key);
        const item = node2.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value2;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value2, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value2);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node2 = this[LRU_LIST].tail;
      if (!node2)
        return null;
      del(this, node2);
      return node2.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value2, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node2 = self2[CACHE].get(key);
    if (node2) {
      const hit = node2.value;
      if (isStale(self2, hit)) {
        del(self2, node2);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node2.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node2);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node2) => {
    if (node2) {
      const hit = node2.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node2);
    }
  };

  class Entry {
    constructor(key, value2, length, now, maxAge) {
      this.key = key;
      this.value = value2;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node2, thisp) => {
    let hit = node2.value;
    if (isStale(self2, hit)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js
var require_semver3 = __commonJS((exports, module) => {
  var tok = function(n) {
    t[n] = R++;
  };
  var makeSafeRe = function(value2) {
    for (var i2 = 0;i2 < safeRegexReplacements.length; i2++) {
      var token = safeRegexReplacements[i2][0];
      var max = safeRegexReplacements[i2][1];
      value2 = value2.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value2;
  };
  var parse2 = function(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  };
  var valid = function(version2, options) {
    var v = parse2(version2, options);
    return v ? v.version : null;
  };
  var clean = function(version2, options) {
    var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  var SemVer = function(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      if (version2.loose === options.loose) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: " + version2);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version2, options);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version2);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  };
  var inc = function(version2, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version2, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  var diff = function(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v12 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v12.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v12) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v12[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  var compareIdentifiers = function(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
  };
  var major = function(a, loose) {
    return new SemVer(a, loose).major;
  };
  var minor = function(a, loose) {
    return new SemVer(a, loose).minor;
  };
  var patch = function(a, loose) {
    return new SemVer(a, loose).patch;
  };
  var compare = function(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  };
  var compareLoose = function(a, b) {
    return compare(a, b, true);
  };
  var compareBuild = function(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  var rcompare = function(a, b, loose) {
    return compare(b, a, loose);
  };
  var sort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(a, b, loose);
    });
  };
  var rsort = function(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(b, a, loose);
    });
  };
  var gt = function(a, b, loose) {
    return compare(a, b, loose) > 0;
  };
  var lt = function(a, b, loose) {
    return compare(a, b, loose) < 0;
  };
  var eq = function(a, b, loose) {
    return compare(a, b, loose) === 0;
  };
  var neq = function(a, b, loose) {
    return compare(a, b, loose) !== 0;
  };
  var gte = function(a, b, loose) {
    return compare(a, b, loose) >= 0;
  };
  var lte = function(a, b, loose) {
    return compare(a, b, loose) <= 0;
  };
  var cmp = function(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };
  var Comparator = function(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  };
  var Range = function(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  };
  var isSatisfiable = function(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var toComparators = function(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  };
  var parseComparator = function(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = function(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  };
  var replaceTildes = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  };
  var replaceTilde = function(comp, options) {
    var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = function(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  };
  var replaceCaret = function(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = function(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = function(comp, options) {
    comp = comp.trim();
    var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = function(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(safeRe[t.STAR], "");
  };
  var hyphenReplace = function($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  };
  var testSet = function(set, version2, options) {
    for (var i2 = 0;i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0;i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  var satisfies = function(version2, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  var maxSatisfying = function(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  var minSatisfying = function(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  var minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  var validRange = function(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  var ltr = function(version2, range, options) {
    return outside(version2, range, "<", options);
  };
  var gtr = function(version2, range, options) {
    return outside(version2, range, ">", options);
  };
  var outside = function(version2, range, hilo, options) {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  var prerelease = function(version2, options) {
    var parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  var intersects = function(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  };
  var coerce2 = function(version2, options) {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version2.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  };
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0;i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
      safeRe[i] = new RegExp(makeSafeRe(src[i]));
    }
  }
  var i;
  exports.parse = parse2;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    debug("Comparator.test", version2, this.options.loose);
    if (this.semver === ANY || version2 === ANY) {
      return true;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version2) {
    if (!version2) {
      return false;
    }
    if (typeof version2 === "string") {
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0;i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version2, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce2;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/targets.js
var require_targets = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.unreleasedLabels = exports.browserNameMap = undefined;
  var unreleasedLabels = exports.unreleasedLabels = {
    safari: "tp"
  };
  var browserNameMap = exports.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/utils.js
var require_utils3 = __commonJS((exports) => {
  var semverMin = function(first, second) {
    return first && _semver.lt(first, second) ? first : second;
  };
  var semverify = function(version2) {
    if (typeof version2 === "string" && _semver.valid(version2)) {
      return version2;
    }
    v.invariant(typeof version2 === "number" || typeof version2 === "string" && versionRegExp.test(version2), `'${version2}' is not a valid version`);
    version2 = version2.toString();
    let pos = 0;
    let num = 0;
    while ((pos = version2.indexOf(".", pos + 1)) > 0) {
      num++;
    }
    return version2 + ".0".repeat(2 - num);
  };
  var isUnreleasedVersion = function(version2, env2) {
    const unreleasedLabel = _targets.unreleasedLabels[env2];
    return !!unreleasedLabel && unreleasedLabel === version2.toString().toLowerCase();
  };
  var getLowestUnreleased = function(a, b, env2) {
    const unreleasedLabel = _targets.unreleasedLabels[env2];
    if (a === unreleasedLabel) {
      return b;
    }
    if (b === unreleasedLabel) {
      return a;
    }
    return semverMin(a, b);
  };
  var getHighestUnreleased = function(a, b, env2) {
    return getLowestUnreleased(a, b, env2) === a ? b : a;
  };
  var getLowestImplementedVersion = function(plugin, environment) {
    const result = plugin[environment];
    if (!result && environment === "android") {
      return plugin.chrome;
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getHighestUnreleased = getHighestUnreleased;
  exports.getLowestImplementedVersion = getLowestImplementedVersion;
  exports.getLowestUnreleased = getLowestUnreleased;
  exports.isUnreleasedVersion = isUnreleasedVersion;
  exports.semverMin = semverMin;
  exports.semverify = semverify;
  var _semver = require_semver3();
  var _helperValidatorOption = require_lib30();
  var _targets = require_targets();
  var versionRegExp = /^(\d+|\d+.\d+)$/;
  var v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/options.js
var require_options2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TargetNames = undefined;
  var TargetNames = exports.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/pretty.js
var require_pretty = __commonJS((exports) => {
  var prettifyVersion = function(version2) {
    if (typeof version2 !== "string") {
      return version2;
    }
    const {
      major,
      minor,
      patch
    } = _semver.parse(version2);
    const parts = [major];
    if (minor || patch) {
      parts.push(minor);
    }
    if (patch) {
      parts.push(patch);
    }
    return parts.join(".");
  };
  var prettifyTargets = function(targets) {
    return Object.keys(targets).reduce((results, target) => {
      let value2 = targets[target];
      const unreleasedLabel = _targets.unreleasedLabels[target];
      if (typeof value2 === "string" && unreleasedLabel !== value2) {
        value2 = prettifyVersion(value2);
      }
      results[target] = value2;
      return results;
    }, {});
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.prettifyTargets = prettifyTargets;
  exports.prettifyVersion = prettifyVersion;
  var _semver = require_semver3();
  var _targets = require_targets();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/debug.js
var require_debug = __commonJS((exports) => {
  var getInclusionReasons = function(item, targetVersions, list) {
    const minVersions = list[item] || {};
    return Object.keys(targetVersions).reduce((result, env2) => {
      const minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env2);
      const targetVersion = targetVersions[env2];
      if (!minVersion) {
        result[env2] = (0, _pretty.prettifyVersion)(targetVersion);
      } else {
        const minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env2);
        const targetIsUnreleased = (0, _utils.isUnreleasedVersion)(targetVersion, env2);
        if (!targetIsUnreleased && (minIsUnreleased || _semver.lt(targetVersion.toString(), (0, _utils.semverify)(minVersion)))) {
          result[env2] = (0, _pretty.prettifyVersion)(targetVersion);
        }
      }
      return result;
    }, {});
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getInclusionReasons = getInclusionReasons;
  var _semver = require_semver3();
  var _pretty = require_pretty();
  var _utils = require_utils3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/compat-data/data/plugins.json
var require_plugins = __commonJS((exports, module) => {
  module.exports = {
    "transform-unicode-sets-regex": {
      chrome: "112",
      opera: "98",
      edge: "112",
      firefox: "116",
      safari: "tp",
      node: "20",
      deno: "1.32",
      opera_mobile: "75",
      electron: "24.0"
    },
    "bugfix/transform-v8-static-class-fields-redefine-readonly": {
      chrome: "98",
      opera: "84",
      edge: "98",
      firefox: "95",
      safari: "15",
      node: "12",
      deno: "1.18",
      ios: "15",
      samsung: "11",
      opera_mobile: "52",
      electron: "17.0"
    },
    "transform-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "proposal-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "transform-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "proposal-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "proposal-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "transform-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "proposal-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "transform-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-parameters": {
      chrome: "49",
      opera: "36",
      edge: "18",
      firefox: "53",
      safari: "16.3",
      node: "6",
      deno: "1",
      ios: "16.3",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "proposal-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "proposal-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "transform-dotall-regex": {
      chrome: "62",
      opera: "49",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "8.10",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-named-capturing-groups-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-async-to-generator": {
      chrome: "55",
      opera: "42",
      edge: "15",
      firefox: "52",
      safari: "11",
      node: "7.6",
      deno: "1",
      ios: "11",
      samsung: "6",
      opera_mobile: "42",
      electron: "1.6"
    },
    "transform-exponentiation-operator": {
      chrome: "52",
      opera: "39",
      edge: "14",
      firefox: "52",
      safari: "10.1",
      node: "7",
      deno: "1",
      ios: "10.3",
      samsung: "6",
      rhino: "1.7.14",
      opera_mobile: "41",
      electron: "1.3"
    },
    "transform-template-literals": {
      chrome: "41",
      opera: "28",
      edge: "13",
      firefox: "34",
      safari: "13",
      node: "4",
      deno: "1",
      ios: "13",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-literals": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-function-name": {
      chrome: "51",
      opera: "38",
      edge: "79",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-arrow-functions": {
      chrome: "47",
      opera: "34",
      edge: "13",
      firefox: "43",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.13",
      opera_mobile: "34",
      electron: "0.36"
    },
    "transform-block-scoped-functions": {
      chrome: "41",
      opera: "28",
      edge: "12",
      firefox: "46",
      safari: "10",
      node: "4",
      deno: "1",
      ie: "11",
      ios: "10",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-classes": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-object-super": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-shorthand-properties": {
      chrome: "43",
      opera: "30",
      edge: "12",
      firefox: "33",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.14",
      opera_mobile: "30",
      electron: "0.27"
    },
    "transform-duplicate-keys": {
      chrome: "42",
      opera: "29",
      edge: "12",
      firefox: "34",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "3.4",
      opera_mobile: "29",
      electron: "0.25"
    },
    "transform-computed-properties": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "34",
      safari: "7.1",
      node: "4",
      deno: "1",
      ios: "8",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-for-of": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-sticky-regex": {
      chrome: "49",
      opera: "36",
      edge: "13",
      firefox: "3",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-unicode-escapes": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-unicode-regex": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "46",
      safari: "12",
      node: "6",
      deno: "1",
      ios: "12",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-spread": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-destructuring": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-block-scoping": {
      chrome: "50",
      opera: "37",
      edge: "14",
      firefox: "53",
      safari: "11",
      node: "6",
      deno: "1",
      ios: "11",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-typeof-symbol": {
      chrome: "38",
      opera: "25",
      edge: "12",
      firefox: "36",
      safari: "9",
      node: "0.12",
      deno: "1",
      ios: "9",
      samsung: "3",
      rhino: "1.7.13",
      opera_mobile: "25",
      electron: "0.20"
    },
    "transform-new-target": {
      chrome: "46",
      opera: "33",
      edge: "14",
      firefox: "41",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-regenerator": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "53",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-member-expression-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-property-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-reserved-words": {
      chrome: "13",
      opera: "10.50",
      edge: "12",
      firefox: "2",
      safari: "3.1",
      node: "0.6",
      deno: "1",
      ie: "9",
      android: "4.4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "10.1",
      electron: "0.20"
    },
    "transform-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    },
    "proposal-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var require_filter_items = __commonJS((exports) => {
  var targetsSupported = function(target, support) {
    const targetEnvironments = Object.keys(target);
    if (targetEnvironments.length === 0) {
      return false;
    }
    const unsupportedEnvironments = targetEnvironments.filter((environment) => {
      const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
      if (!lowestImplementedVersion) {
        return true;
      }
      const lowestTargetedVersion = target[environment];
      if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {
        return false;
      }
      if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {
        return true;
      }
      if (!_semver.valid(lowestTargetedVersion.toString())) {
        throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". ` + "Versions must be in semver format (major.minor.patch)");
      }
      return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
    });
    return unsupportedEnvironments.length === 0;
  };
  var isRequired = function(name, targets, {
    compatData = _plugins,
    includes,
    excludes
  } = {}) {
    if (excludes != null && excludes.has(name))
      return false;
    if (includes != null && includes.has(name))
      return true;
    return !targetsSupported(targets, compatData[name]);
  };
  var filterItems = function(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
    const result = new Set;
    const options = {
      compatData: list,
      includes,
      excludes
    };
    for (const item in list) {
      if (isRequired(item, targets, options)) {
        result.add(item);
      } else if (pluginSyntaxMap) {
        const shippedProposalsSyntax = pluginSyntaxMap.get(item);
        if (shippedProposalsSyntax) {
          result.add(shippedProposalsSyntax);
        }
      }
    }
    defaultIncludes == null || defaultIncludes.forEach((item) => !excludes.has(item) && result.add(item));
    defaultExcludes == null || defaultExcludes.forEach((item) => !includes.has(item) && result.delete(item));
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = filterItems;
  exports.isRequired = isRequired;
  exports.targetsSupported = targetsSupported;
  var _semver = require_semver3();
  var _plugins = require_plugins();
  var _utils = require_utils3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/helper-compilation-targets/lib/index.js
var require_lib32 = __commonJS((exports) => {
  var validateTargetNames = function(targets) {
    const validTargets = Object.keys(_options.TargetNames);
    for (const target of Object.keys(targets)) {
      if (!(target in _options.TargetNames)) {
        throw new Error(v.formatMessage(`'${target}' is not a valid target
- Did you mean '${(0, _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));
      }
    }
    return targets;
  };
  var isBrowsersQueryValid = function(browsers) {
    return typeof browsers === "string" || Array.isArray(browsers) && browsers.every((b) => typeof b === "string");
  };
  var validateBrowsers = function(browsers) {
    v.invariant(browsers === undefined || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`);
    return browsers;
  };
  var getLowestVersions = function(browsers) {
    return browsers.reduce((all, browser) => {
      const [browserName, browserVersion] = browser.split(" ");
      const target = _targets.browserNameMap[browserName];
      if (!target) {
        return all;
      }
      try {
        const splitVersion = browserVersion.split("-")[0].toLowerCase();
        const isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, target);
        if (!all[target]) {
          all[target] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion);
          return all;
        }
        const version2 = all[target];
        const isUnreleased = (0, _utils.isUnreleasedVersion)(version2, target);
        if (isUnreleased && isSplitUnreleased) {
          all[target] = (0, _utils.getLowestUnreleased)(version2, splitVersion, target);
        } else if (isUnreleased) {
          all[target] = (0, _utils.semverify)(splitVersion);
        } else if (!isUnreleased && !isSplitUnreleased) {
          const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
          all[target] = (0, _utils.semverMin)(version2, parsedBrowserVersion);
        }
      } catch (e) {
      }
      return all;
    }, {});
  };
  var outputDecimalWarning = function(decimalTargets) {
    if (!decimalTargets.length) {
      return;
    }
    console.warn("Warning, the following targets are using a decimal version:\n");
    decimalTargets.forEach(({
      target,
      value: value2
    }) => console.warn(`  ${target}: ${value2}`));
    console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`);
  };
  var semverifyTarget = function(target, value2) {
    try {
      return (0, _utils.semverify)(value2);
    } catch (error) {
      throw new Error(v.formatMessage(`'${value2}' is not a valid value for 'targets.${target}'.`));
    }
  };
  var nodeTargetParser = function(value2) {
    const parsed = value2 === true || value2 === "current" ? process.versions.node : semverifyTarget("node", value2);
    return ["node", parsed];
  };
  var defaultTargetParser = function(target, value2) {
    const version2 = (0, _utils.isUnreleasedVersion)(value2, target) ? value2.toLowerCase() : semverifyTarget(target, value2);
    return [target, version2];
  };
  var generateTargets = function(inputTargets) {
    const input = Object.assign({}, inputTargets);
    delete input.esmodules;
    delete input.browsers;
    return input;
  };
  var resolveTargets = function(queries, env2) {
    const resolved = _browserslist(queries, {
      mobileToDesktop: true,
      env: env2
    });
    return getLowestVersions(resolved);
  };
  var resolveTargetsCached = function(queries, env2) {
    const cacheKey = typeof queries === "string" ? queries : queries.join() + env2;
    let cached = targetsCache.get(cacheKey);
    if (!cached) {
      cached = resolveTargets(queries, env2);
      targetsCache.set(cacheKey, cached);
    }
    return Object.assign({}, cached);
  };
  var getTargets = function(inputTargets = {}, options = {}) {
    var _browsers, _browsers2;
    let {
      browsers,
      esmodules
    } = inputTargets;
    const {
      configPath = "."
    } = options;
    validateBrowsers(browsers);
    const input = generateTargets(inputTargets);
    let targets = validateTargetNames(input);
    const shouldParseBrowsers = !!browsers;
    const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
    const shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
    if (!browsers && shouldSearchForConfig) {
      browsers = _browserslist.loadConfig({
        config: options.configFile,
        path: configPath,
        env: options.browserslistEnv
      });
      if (browsers == null) {
        {
          browsers = [];
        }
      }
    }
    if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
      browsers = Object.keys(ESM_SUPPORT).map((browser) => `${browser} >= ${ESM_SUPPORT[browser]}`).join(", ");
      esmodules = false;
    }
    if ((_browsers2 = browsers) != null && _browsers2.length) {
      const queryBrowsers = resolveTargetsCached(browsers, options.browserslistEnv);
      if (esmodules === "intersect") {
        for (const browser of Object.keys(queryBrowsers)) {
          if (browser !== "deno" && browser !== "ie") {
            const esmSupportVersion = ESM_SUPPORT[browser === "opera_mobile" ? "op_mob" : browser];
            if (esmSupportVersion) {
              const version2 = queryBrowsers[browser];
              queryBrowsers[browser] = (0, _utils.getHighestUnreleased)(version2, (0, _utils.semverify)(esmSupportVersion), browser);
            } else {
              delete queryBrowsers[browser];
            }
          } else {
            delete queryBrowsers[browser];
          }
        }
      }
      targets = Object.assign(queryBrowsers, targets);
    }
    const result = {};
    const decimalWarnings = [];
    for (const target of Object.keys(targets).sort()) {
      const value2 = targets[target];
      if (typeof value2 === "number" && value2 % 1 !== 0) {
        decimalWarnings.push({
          target,
          value: value2
        });
      }
      const [parsedTarget, parsedValue] = target === "node" ? nodeTargetParser(value2) : defaultTargetParser(target, value2);
      if (parsedValue) {
        result[parsedTarget] = parsedValue;
      }
    }
    outputDecimalWarning(decimalWarnings);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "TargetNames", {
    enumerable: true,
    get: function() {
      return _options.TargetNames;
    }
  });
  exports.default = getTargets;
  Object.defineProperty(exports, "filterItems", {
    enumerable: true,
    get: function() {
      return _filterItems.default;
    }
  });
  Object.defineProperty(exports, "getInclusionReasons", {
    enumerable: true,
    get: function() {
      return _debug.getInclusionReasons;
    }
  });
  exports.isBrowsersQueryValid = isBrowsersQueryValid;
  Object.defineProperty(exports, "isRequired", {
    enumerable: true,
    get: function() {
      return _filterItems.isRequired;
    }
  });
  Object.defineProperty(exports, "prettifyTargets", {
    enumerable: true,
    get: function() {
      return _pretty.prettifyTargets;
    }
  });
  Object.defineProperty(exports, "unreleasedLabels", {
    enumerable: true,
    get: function() {
      return _targets.unreleasedLabels;
    }
  });
  var _browserslist = require_browserslist();
  var _helperValidatorOption = require_lib30();
  var _nativeModules = require_native_modules();
  var _lruCache = require_lru_cache();
  var _utils = require_utils3();
  var _targets = require_targets();
  var _options = require_options2();
  var _pretty = require_pretty();
  var _debug = require_debug();
  var _filterItems = require_filter_items();
  var ESM_SUPPORT = _nativeModules["es6.module"];
  var v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
  var targetsCache = new _lruCache({
    max: 64
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/resolve-targets.js
var require_resolve_targets = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _helperCompilationTargets = function() {
    const data = require_lib32();
    _helperCompilationTargets = function() {
      return data;
    };
    return data;
  };
  var resolveBrowserslistConfigFile = function(browserslistConfigFile, configFileDir) {
    return _path().resolve(configFileDir, browserslistConfigFile);
  };
  var resolveTargets = function(options, root) {
    const optTargets = options.targets;
    let targets;
    if (typeof optTargets === "string" || Array.isArray(optTargets)) {
      targets = {
        browsers: optTargets
      };
    } else if (optTargets) {
      if ("esmodules" in optTargets) {
        targets = Object.assign({}, optTargets, {
          esmodules: "intersect"
        });
      } else {
        targets = optTargets;
      }
    }
    const {
      browserslistConfigFile
    } = options;
    let configFile;
    let ignoreBrowserslistConfig = false;
    if (typeof browserslistConfigFile === "string") {
      configFile = browserslistConfigFile;
    } else {
      ignoreBrowserslistConfig = browserslistConfigFile === false;
    }
    return (0, _helperCompilationTargets().default)(targets, {
      ignoreBrowserslistConfig,
      configFile,
      configPath: root,
      browserslistEnv: options.browserslistEnv
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;
  exports.resolveTargets = resolveTargets;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/config-descriptors.js
var require_config_descriptors = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var isEqualDescriptor = function(a, b) {
    var _a$file, _b$file, _a$file2, _b$file2;
    return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && ((_a$file = a.file) == null ? undefined : _a$file.request) === ((_b$file = b.file) == null ? undefined : _b$file.request) && ((_a$file2 = a.file) == null ? undefined : _a$file2.resolved) === ((_b$file2 = b.file) == null ? undefined : _b$file2.resolved);
  };
  function* handlerOf(value2) {
    return value2;
  }
  var optionsWithResolvedBrowserslistConfigFile = function(options, dirname4) {
    if (typeof options.browserslistConfigFile === "string") {
      options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname4);
    }
    return options;
  };
  var createCachedDescriptors = function(dirname4, options, alias) {
    const {
      plugins,
      presets,
      passPerPreset
    } = options;
    return {
      options: optionsWithResolvedBrowserslistConfigFile(options, dirname4),
      plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname4)(alias) : () => handlerOf([]),
      presets: presets ? () => createCachedPresetDescriptors(presets, dirname4)(alias)(!!passPerPreset) : () => handlerOf([])
    };
  };
  var createUncachedDescriptors = function(dirname4, options, alias) {
    return {
      options: optionsWithResolvedBrowserslistConfigFile(options, dirname4),
      plugins: (0, _functional.once)(() => createPluginDescriptors(options.plugins || [], dirname4, alias)),
      presets: (0, _functional.once)(() => createPresetDescriptors(options.presets || [], dirname4, alias, !!options.passPerPreset))
    };
  };
  var loadCachedDescriptor = function(cache, desc) {
    const {
      value: value2,
      options = DEFAULT_OPTIONS
    } = desc;
    if (options === false)
      return desc;
    let cacheByOptions = cache.get(value2);
    if (!cacheByOptions) {
      cacheByOptions = new WeakMap;
      cache.set(value2, cacheByOptions);
    }
    let possibilities = cacheByOptions.get(options);
    if (!possibilities) {
      possibilities = [];
      cacheByOptions.set(options, possibilities);
    }
    if (possibilities.indexOf(desc) === -1) {
      const matches = possibilities.filter((possibility) => isEqualDescriptor(possibility, desc));
      if (matches.length > 0) {
        return matches[0];
      }
      possibilities.push(desc);
    }
    return desc;
  };
  function* createPresetDescriptors(items, dirname4, alias, passPerPreset) {
    return yield* createDescriptors("preset", items, dirname4, alias, passPerPreset);
  }
  function* createPluginDescriptors(items, dirname4, alias) {
    return yield* createDescriptors("plugin", items, dirname4, alias);
  }
  function* createDescriptors(type, items, dirname4, alias, ownPass) {
    const descriptors = yield* _gensync().all(items.map((item, index) => createDescriptor(item, dirname4, {
      type,
      alias: `${alias}\$${index}`,
      ownPass: !!ownPass
    })));
    assertNoDuplicates(descriptors);
    return descriptors;
  }
  function* createDescriptor(pair, dirname4, {
    type,
    alias,
    ownPass
  }) {
    const desc = (0, _item.getItemDescriptor)(pair);
    if (desc) {
      return desc;
    }
    let name;
    let options;
    let value2 = pair;
    if (Array.isArray(value2)) {
      if (value2.length === 3) {
        [value2, options, name] = value2;
      } else {
        [value2, options] = value2;
      }
    }
    let file = undefined;
    let filepath = null;
    if (typeof value2 === "string") {
      if (typeof type !== "string") {
        throw new Error("To resolve a string-based item, the type of item must be given");
      }
      const resolver = type === "plugin" ? _index.loadPlugin : _index.loadPreset;
      const request = value2;
      ({
        filepath,
        value: value2
      } = yield* resolver(value2, dirname4));
      file = {
        request,
        resolved: filepath
      };
    }
    if (!value2) {
      throw new Error(`Unexpected falsy value: ${String(value2)}`);
    }
    if (typeof value2 === "object" && value2.__esModule) {
      if (value2.default) {
        value2 = value2.default;
      } else {
        throw new Error("Must export a default export when using ES6 modules.");
      }
    }
    if (typeof value2 !== "object" && typeof value2 !== "function") {
      throw new Error(`Unsupported format: ${typeof value2}. Expected an object or a function.`);
    }
    if (filepath !== null && typeof value2 === "object" && value2) {
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);
    }
    return {
      name,
      alias: filepath || alias,
      value: value2,
      options,
      dirname: dirname4,
      ownPass,
      file
    };
  }
  var assertNoDuplicates = function(items) {
    const map = new Map;
    for (const item of items) {
      if (typeof item.value !== "function")
        continue;
      let nameMap = map.get(item.value);
      if (!nameMap) {
        nameMap = new Set;
        map.set(item.value, nameMap);
      }
      if (nameMap.has(item.name)) {
        const conflicts = items.filter((i) => i.value === item.value);
        throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`, ``, `Duplicates detected are:`, `${JSON.stringify(conflicts, null, 2)}`].join("\n"));
      }
      nameMap.add(item.name);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createCachedDescriptors = createCachedDescriptors;
  exports.createDescriptor = createDescriptor;
  exports.createUncachedDescriptors = createUncachedDescriptors;
  var _functional = require_functional();
  var _index = require_files();
  var _item = require_item();
  var _caching = require_caching();
  var _resolveTargets = require_resolve_targets();
  var PRESET_DESCRIPTOR_CACHE = new WeakMap;
  var createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
    const dirname4 = cache.using((dir) => dir);
    return (0, _caching.makeStrongCacheSync)((alias) => (0, _caching.makeStrongCache)(function* (passPerPreset) {
      const descriptors = yield* createPresetDescriptors(items, dirname4, alias, passPerPreset);
      return descriptors.map((desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));
    }));
  });
  var PLUGIN_DESCRIPTOR_CACHE = new WeakMap;
  var createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
    const dirname4 = cache.using((dir) => dir);
    return (0, _caching.makeStrongCache)(function* (alias) {
      const descriptors = yield* createPluginDescriptors(items, dirname4, alias);
      return descriptors.map((desc) => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));
    });
  });
  var DEFAULT_OPTIONS = {};
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/item.js
var require_item = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var createItemFromDescriptor = function(desc) {
    return new ConfigItem(desc);
  };
  function* createConfigItem(value2, {
    dirname: dirname4 = ".",
    type
  } = {}) {
    const descriptor = yield* (0, _configDescriptors.createDescriptor)(value2, _path().resolve(dirname4), {
      type,
      alias: "programmatic item"
    });
    return createItemFromDescriptor(descriptor);
  }
  var getItemDescriptor = function(item) {
    if (item != null && item[CONFIG_ITEM_BRAND]) {
      return item._descriptor;
    }
    return;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createConfigItem = createConfigItem;
  exports.createItemFromDescriptor = createItemFromDescriptor;
  exports.getItemDescriptor = getItemDescriptor;
  var _configDescriptors = require_config_descriptors();
  var CONFIG_ITEM_BRAND = Symbol.for("@babel/core@7 - ConfigItem");

  class ConfigItem {
    constructor(descriptor) {
      this._descriptor = undefined;
      this[CONFIG_ITEM_BRAND] = true;
      this.value = undefined;
      this.options = undefined;
      this.dirname = undefined;
      this.name = undefined;
      this.file = undefined;
      this._descriptor = descriptor;
      Object.defineProperty(this, "_descriptor", {
        enumerable: false
      });
      Object.defineProperty(this, CONFIG_ITEM_BRAND, {
        enumerable: false
      });
      this.value = this._descriptor.value;
      this.options = this._descriptor.options;
      this.dirname = this._descriptor.dirname;
      this.name = this._descriptor.name;
      this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : undefined;
      Object.freeze(this);
    }
  }
  Object.freeze(ConfigItem.prototype);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/validation/removed.js
var require_removed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/validation/option-assertions.js
var require_option_assertions = __commonJS((exports) => {
  var _helperCompilationTargets = function() {
    const data = require_lib32();
    _helperCompilationTargets = function() {
      return data;
    };
    return data;
  };
  var msg = function(loc) {
    switch (loc.type) {
      case "root":
        return ``;
      case "env":
        return `${msg(loc.parent)}.env["${loc.name}"]`;
      case "overrides":
        return `${msg(loc.parent)}.overrides[${loc.index}]`;
      case "option":
        return `${msg(loc.parent)}.${loc.name}`;
      case "access":
        return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${loc.type}`);
    }
  };
  var access = function(loc, name) {
    return {
      type: "access",
      name,
      parent: loc
    };
  };
  var assertRootMode = function(loc, value2) {
    if (value2 !== undefined && value2 !== "root" && value2 !== "upward" && value2 !== "upward-optional") {
      throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
    }
    return value2;
  };
  var assertSourceMaps = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "boolean" && value2 !== "inline" && value2 !== "both") {
      throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
    }
    return value2;
  };
  var assertCompact = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "boolean" && value2 !== "auto") {
      throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
    }
    return value2;
  };
  var assertSourceType = function(loc, value2) {
    if (value2 !== undefined && value2 !== "module" && value2 !== "script" && value2 !== "unambiguous") {
      throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);
    }
    return value2;
  };
  var assertCallerMetadata = function(loc, value2) {
    const obj = assertObject(loc, value2);
    if (obj) {
      if (typeof obj.name !== "string") {
        throw new Error(`${msg(loc)} set but does not contain "name" property string`);
      }
      for (const prop of Object.keys(obj)) {
        const propLoc = access(loc, prop);
        const value3 = obj[prop];
        if (value3 != null && typeof value3 !== "boolean" && typeof value3 !== "string" && typeof value3 !== "number") {
          throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
        }
      }
    }
    return value2;
  };
  var assertInputSourceMap = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "boolean" && (typeof value2 !== "object" || !value2)) {
      throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
    }
    return value2;
  };
  var assertString = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "string") {
      throw new Error(`${msg(loc)} must be a string, or undefined`);
    }
    return value2;
  };
  var assertFunction = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "function") {
      throw new Error(`${msg(loc)} must be a function, or undefined`);
    }
    return value2;
  };
  var assertBoolean = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "boolean") {
      throw new Error(`${msg(loc)} must be a boolean, or undefined`);
    }
    return value2;
  };
  var assertObject = function(loc, value2) {
    if (value2 !== undefined && (typeof value2 !== "object" || Array.isArray(value2) || !value2)) {
      throw new Error(`${msg(loc)} must be an object, or undefined`);
    }
    return value2;
  };
  var assertArray = function(loc, value2) {
    if (value2 != null && !Array.isArray(value2)) {
      throw new Error(`${msg(loc)} must be an array, or undefined`);
    }
    return value2;
  };
  var assertIgnoreList = function(loc, value2) {
    const arr = assertArray(loc, value2);
    arr == null || arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));
    return arr;
  };
  var assertIgnoreItem = function(loc, value2) {
    if (typeof value2 !== "string" && typeof value2 !== "function" && !(value2 instanceof RegExp)) {
      throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);
    }
    return value2;
  };
  var assertConfigApplicableTest = function(loc, value2) {
    if (value2 === undefined) {
      return value2;
    }
    if (Array.isArray(value2)) {
      value2.forEach((item, i) => {
        if (!checkValidTest(item)) {
          throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
        }
      });
    } else if (!checkValidTest(value2)) {
      throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);
    }
    return value2;
  };
  var checkValidTest = function(value2) {
    return typeof value2 === "string" || typeof value2 === "function" || value2 instanceof RegExp;
  };
  var assertConfigFileSearch = function(loc, value2) {
    if (value2 !== undefined && typeof value2 !== "boolean" && typeof value2 !== "string") {
      throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value2)}`);
    }
    return value2;
  };
  var assertBabelrcSearch = function(loc, value2) {
    if (value2 === undefined || typeof value2 === "boolean") {
      return value2;
    }
    if (Array.isArray(value2)) {
      value2.forEach((item, i) => {
        if (!checkValidTest(item)) {
          throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
        }
      });
    } else if (!checkValidTest(value2)) {
      throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value2)}`);
    }
    return value2;
  };
  var assertPluginList = function(loc, value2) {
    const arr = assertArray(loc, value2);
    if (arr) {
      arr.forEach((item, i) => assertPluginItem(access(loc, i), item));
    }
    return arr;
  };
  var assertPluginItem = function(loc, value2) {
    if (Array.isArray(value2)) {
      if (value2.length === 0) {
        throw new Error(`${msg(loc)} must include an object`);
      }
      if (value2.length > 3) {
        throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);
      }
      assertPluginTarget(access(loc, 0), value2[0]);
      if (value2.length > 1) {
        const opts = value2[1];
        if (opts !== undefined && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
          throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);
        }
      }
      if (value2.length === 3) {
        const name = value2[2];
        if (name !== undefined && typeof name !== "string") {
          throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);
        }
      }
    } else {
      assertPluginTarget(loc, value2);
    }
    return value2;
  };
  var assertPluginTarget = function(loc, value2) {
    if ((typeof value2 !== "object" || !value2) && typeof value2 !== "string" && typeof value2 !== "function") {
      throw new Error(`${msg(loc)} must be a string, object, function`);
    }
    return value2;
  };
  var assertTargets = function(loc, value2) {
    if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value2))
      return value2;
    if (typeof value2 !== "object" || !value2 || Array.isArray(value2)) {
      throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);
    }
    const browsersLoc = access(loc, "browsers");
    const esmodulesLoc = access(loc, "esmodules");
    assertBrowsersList(browsersLoc, value2.browsers);
    assertBoolean(esmodulesLoc, value2.esmodules);
    for (const key of Object.keys(value2)) {
      const val = value2[key];
      const subLoc = access(loc, key);
      if (key === "esmodules")
        assertBoolean(subLoc, val);
      else if (key === "browsers")
        assertBrowsersList(subLoc, val);
      else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {
        const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
        throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);
      } else
        assertBrowserVersion(subLoc, val);
    }
    return value2;
  };
  var assertBrowsersList = function(loc, value2) {
    if (value2 !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value2)) {
      throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);
    }
  };
  var assertBrowserVersion = function(loc, value2) {
    if (typeof value2 === "number" && Math.round(value2) === value2)
      return;
    if (typeof value2 === "string")
      return;
    throw new Error(`${msg(loc)} must be a string or an integer number`);
  };
  var assertAssumptions = function(loc, value2) {
    if (value2 === undefined)
      return;
    if (typeof value2 !== "object" || value2 === null) {
      throw new Error(`${msg(loc)} must be an object or undefined.`);
    }
    let root = loc;
    do {
      root = root.parent;
    } while (root.type !== "root");
    const inPreset = root.source === "preset";
    for (const name of Object.keys(value2)) {
      const subLoc = access(loc, name);
      if (!_options.assumptionsNames.has(name)) {
        throw new Error(`${msg(subLoc)} is not a supported assumption.`);
      }
      if (typeof value2[name] !== "boolean") {
        throw new Error(`${msg(subLoc)} must be a boolean.`);
      }
      if (inPreset && value2[name] === false) {
        throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);
      }
    }
    return value2;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.access = access;
  exports.assertArray = assertArray;
  exports.assertAssumptions = assertAssumptions;
  exports.assertBabelrcSearch = assertBabelrcSearch;
  exports.assertBoolean = assertBoolean;
  exports.assertCallerMetadata = assertCallerMetadata;
  exports.assertCompact = assertCompact;
  exports.assertConfigApplicableTest = assertConfigApplicableTest;
  exports.assertConfigFileSearch = assertConfigFileSearch;
  exports.assertFunction = assertFunction;
  exports.assertIgnoreList = assertIgnoreList;
  exports.assertInputSourceMap = assertInputSourceMap;
  exports.assertObject = assertObject;
  exports.assertPluginList = assertPluginList;
  exports.assertRootMode = assertRootMode;
  exports.assertSourceMaps = assertSourceMaps;
  exports.assertSourceType = assertSourceType;
  exports.assertString = assertString;
  exports.assertTargets = assertTargets;
  exports.msg = msg;
  var _options = require_options3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/validation/options.js
var require_options3 = __commonJS((exports) => {
  var getSource = function(loc) {
    return loc.type === "root" ? loc.source : getSource(loc.parent);
  };
  var validate2 = function(type, opts, filename) {
    try {
      return validateNested({
        type: "root",
        source: type
      }, opts);
    } catch (error) {
      const configError = new _configError.default(error.message, filename);
      if (error.code)
        configError.code = error.code;
      throw configError;
    }
  };
  var validateNested = function(loc, opts) {
    const type = getSource(loc);
    assertNoDuplicateSourcemap(opts);
    Object.keys(opts).forEach((key) => {
      const optLoc = {
        type: "option",
        name: key,
        parent: loc
      };
      if (type === "preset" && NONPRESET_VALIDATORS[key]) {
        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
      }
      if (type !== "arguments" && ROOT_VALIDATORS[key]) {
        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
      }
      if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
        if (type === "babelrcfile" || type === "extendsfile") {
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ` + `or babel.config.js/config file options`);
        }
        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
      }
      const validator2 = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
      validator2(optLoc, opts[key]);
    });
    return opts;
  };
  var throwUnknownError = function(loc) {
    const key = loc.name;
    if (_removed.default[key]) {
      const {
        message,
        version: version2 = 5
      } = _removed.default[key];
      throw new Error(`Using removed Babel ${version2} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
    } else {
      const unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
      unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
      throw unknownOptErr;
    }
  };
  var has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var assertNoDuplicateSourcemap = function(opts) {
    if (has(opts, "sourceMap") && has(opts, "sourceMaps")) {
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }
  };
  var assertEnvSet = function(loc, value2) {
    if (loc.parent.type === "env") {
      throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
    }
    const parent = loc.parent;
    const obj = (0, _optionAssertions.assertObject)(loc, value2);
    if (obj) {
      for (const envName of Object.keys(obj)) {
        const env2 = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
        if (!env2)
          continue;
        const envLoc = {
          type: "env",
          name: envName,
          parent
        };
        validateNested(envLoc, env2);
      }
    }
    return obj;
  };
  var assertOverridesList = function(loc, value2) {
    if (loc.parent.type === "env") {
      throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
    }
    if (loc.parent.type === "overrides") {
      throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
    }
    const parent = loc.parent;
    const arr = (0, _optionAssertions.assertArray)(loc, value2);
    if (arr) {
      for (const [index, item] of arr.entries()) {
        const objLoc = (0, _optionAssertions.access)(loc, index);
        const env2 = (0, _optionAssertions.assertObject)(objLoc, item);
        if (!env2)
          throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
        const overridesLoc = {
          type: "overrides",
          index,
          parent
        };
        validateNested(overridesLoc, env2);
      }
    }
    return arr;
  };
  var checkNoUnwrappedItemOptionPairs = function(items, index, type, e) {
    if (index === 0)
      return;
    const lastItem = items[index - 1];
    const thisItem = items[index];
    if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === "object") {
      e.message += `\n- Maybe you meant to use\n` + `"${type}s": [\n  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, undefined, 2)}]\n]\n` + `To be a valid ${type}, its name and options should be wrapped in a pair of brackets`;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assumptionsNames = undefined;
  exports.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;
  exports.validate = validate2;
  var _removed = require_removed();
  var _optionAssertions = require_option_assertions();
  var _configError = require_config_error();
  var ROOT_VALIDATORS = {
    cwd: _optionAssertions.assertString,
    root: _optionAssertions.assertString,
    rootMode: _optionAssertions.assertRootMode,
    configFile: _optionAssertions.assertConfigFileSearch,
    caller: _optionAssertions.assertCallerMetadata,
    filename: _optionAssertions.assertString,
    filenameRelative: _optionAssertions.assertString,
    code: _optionAssertions.assertBoolean,
    ast: _optionAssertions.assertBoolean,
    cloneInputAst: _optionAssertions.assertBoolean,
    envName: _optionAssertions.assertString
  };
  var BABELRC_VALIDATORS = {
    babelrc: _optionAssertions.assertBoolean,
    babelrcRoots: _optionAssertions.assertBabelrcSearch
  };
  var NONPRESET_VALIDATORS = {
    extends: _optionAssertions.assertString,
    ignore: _optionAssertions.assertIgnoreList,
    only: _optionAssertions.assertIgnoreList,
    targets: _optionAssertions.assertTargets,
    browserslistConfigFile: _optionAssertions.assertConfigFileSearch,
    browserslistEnv: _optionAssertions.assertString
  };
  var COMMON_VALIDATORS = {
    inputSourceMap: _optionAssertions.assertInputSourceMap,
    presets: _optionAssertions.assertPluginList,
    plugins: _optionAssertions.assertPluginList,
    passPerPreset: _optionAssertions.assertBoolean,
    assumptions: _optionAssertions.assertAssumptions,
    env: assertEnvSet,
    overrides: assertOverridesList,
    test: _optionAssertions.assertConfigApplicableTest,
    include: _optionAssertions.assertConfigApplicableTest,
    exclude: _optionAssertions.assertConfigApplicableTest,
    retainLines: _optionAssertions.assertBoolean,
    comments: _optionAssertions.assertBoolean,
    shouldPrintComment: _optionAssertions.assertFunction,
    compact: _optionAssertions.assertCompact,
    minified: _optionAssertions.assertBoolean,
    auxiliaryCommentBefore: _optionAssertions.assertString,
    auxiliaryCommentAfter: _optionAssertions.assertString,
    sourceType: _optionAssertions.assertSourceType,
    wrapPluginVisitorMethod: _optionAssertions.assertFunction,
    highlightCode: _optionAssertions.assertBoolean,
    sourceMaps: _optionAssertions.assertSourceMaps,
    sourceMap: _optionAssertions.assertSourceMaps,
    sourceFileName: _optionAssertions.assertString,
    sourceRoot: _optionAssertions.assertString,
    parserOpts: _optionAssertions.assertObject,
    generatorOpts: _optionAssertions.assertObject
  };
  {
    Object.assign(COMMON_VALIDATORS, {
      getModuleId: _optionAssertions.assertFunction,
      moduleRoot: _optionAssertions.assertString,
      moduleIds: _optionAssertions.assertBoolean,
      moduleId: _optionAssertions.assertString
    });
  }
  var knownAssumptions = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"];
  var assumptionsNames = exports.assumptionsNames = new Set(knownAssumptions);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/pattern-to-regex.js
var require_pattern_to_regex = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var escapeRegExp = function(string) {
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  };
  var pathToPattern = function(pattern, dirname4) {
    const parts = _path().resolve(dirname4, pattern).split(_path().sep);
    return new RegExp(["^", ...parts.map((part, i) => {
      const last = i === parts.length - 1;
      if (part === "**")
        return last ? starStarPatLast : starStarPat;
      if (part === "*")
        return last ? starPatLast : starPat;
      if (part.indexOf("*.") === 0) {
        return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep);
      }
      return escapeRegExp(part) + (last ? endSep : sep);
    })].join(""));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = pathToPattern;
  var sep = `\\${_path().sep}`;
  var endSep = `(?:${sep}|\$)`;
  var substitution = `[^${sep}]+`;
  var starPat = `(?:${substitution}${sep})`;
  var starPatLast = `(?:${substitution}${endSep})`;
  var starStarPat = `${starPat}*?`;
  var starStarPatLast = `${starPat}*?${starPatLast}?`;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/printer.js
var require_printer2 = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var descriptorToConfig = function(d) {
    var _d$file;
    let name = (_d$file = d.file) == null ? undefined : _d$file.request;
    if (name == null) {
      if (typeof d.value === "object") {
        name = d.value;
      } else if (typeof d.value === "function") {
        name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;
      }
    }
    if (name == null) {
      name = "[Unknown]";
    }
    if (d.options === undefined) {
      return name;
    } else if (d.name == null) {
      return [name, d.options];
    } else {
      return [name, d.options, d.name];
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ConfigPrinter = exports.ChainFormatter = undefined;
  var ChainFormatter = exports.ChainFormatter = {
    Programmatic: 0,
    Config: 1
  };
  var Formatter = {
    title(type, callerName, filepath) {
      let title = "";
      if (type === ChainFormatter.Programmatic) {
        title = "programmatic options";
        if (callerName) {
          title += " from " + callerName;
        }
      } else {
        title = "config " + filepath;
      }
      return title;
    },
    loc(index, envName) {
      let loc = "";
      if (index != null) {
        loc += `.overrides[${index}]`;
      }
      if (envName != null) {
        loc += `.env["${envName}"]`;
      }
      return loc;
    },
    *optionsAndDescriptors(opt) {
      const content = Object.assign({}, opt.options);
      delete content.overrides;
      delete content.env;
      const pluginDescriptors = [...yield* opt.plugins()];
      if (pluginDescriptors.length) {
        content.plugins = pluginDescriptors.map((d) => descriptorToConfig(d));
      }
      const presetDescriptors = [...yield* opt.presets()];
      if (presetDescriptors.length) {
        content.presets = [...presetDescriptors].map((d) => descriptorToConfig(d));
      }
      return JSON.stringify(content, undefined, 2);
    }
  };

  class ConfigPrinter {
    constructor() {
      this._stack = [];
    }
    configure(enabled, type, {
      callerName,
      filepath
    }) {
      if (!enabled)
        return () => {
        };
      return (content, index, envName) => {
        this._stack.push({
          type,
          callerName,
          filepath,
          content,
          index,
          envName
        });
      };
    }
    static *format(config2) {
      let title = Formatter.title(config2.type, config2.callerName, config2.filepath);
      const loc = Formatter.loc(config2.index, config2.envName);
      if (loc)
        title += ` ${loc}`;
      const content = yield* Formatter.optionsAndDescriptors(config2.content);
      return `${title}\n${content}`;
    }
    *output() {
      if (this._stack.length === 0)
        return "";
      const configs = yield* _gensync().all(this._stack.map((s) => ConfigPrinter.format(s)));
      return configs.join("\n\n");
    }
  }
  exports.ConfigPrinter = ConfigPrinter;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/config-chain.js
var require_config_chain = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _debug = function() {
    const data = require_src();
    _debug = function() {
      return data;
    };
    return data;
  };
  function* buildPresetChain(arg, context) {
    const chain = yield* buildPresetChainWalker(arg, context);
    if (!chain)
      return null;
    return {
      plugins: dedupDescriptors(chain.plugins),
      presets: dedupDescriptors(chain.presets),
      options: chain.options.map((o) => normalizeOptions(o)),
      files: new Set
    };
  }
  function* buildRootChain(opts, context) {
    let configReport, babelRcReport;
    const programmaticLogger = new _printer.ConfigPrinter;
    const programmaticChain = yield* loadProgrammaticChain({
      options: opts,
      dirname: context.cwd
    }, context, undefined, programmaticLogger);
    if (!programmaticChain)
      return null;
    const programmaticReport = yield* programmaticLogger.output();
    let configFile;
    if (typeof opts.configFile === "string") {
      configFile = yield* (0, _index.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);
    } else if (opts.configFile !== false) {
      configFile = yield* (0, _index.findRootConfig)(context.root, context.envName, context.caller);
    }
    let {
      babelrc,
      babelrcRoots
    } = opts;
    let babelrcRootsDirectory = context.cwd;
    const configFileChain = emptyChain();
    const configFileLogger = new _printer.ConfigPrinter;
    if (configFile) {
      const validatedFile = validateConfigFile(configFile);
      const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);
      if (!result)
        return null;
      configReport = yield* configFileLogger.output();
      if (babelrc === undefined) {
        babelrc = validatedFile.options.babelrc;
      }
      if (babelrcRoots === undefined) {
        babelrcRootsDirectory = validatedFile.dirname;
        babelrcRoots = validatedFile.options.babelrcRoots;
      }
      mergeChain(configFileChain, result);
    }
    let ignoreFile, babelrcFile;
    let isIgnored = false;
    const fileChain = emptyChain();
    if ((babelrc === true || babelrc === undefined) && typeof context.filename === "string") {
      const pkgData = yield* (0, _index.findPackageData)(context.filename);
      if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
        ({
          ignore: ignoreFile,
          config: babelrcFile
        } = yield* (0, _index.findRelativeConfig)(pkgData, context.envName, context.caller));
        if (ignoreFile) {
          fileChain.files.add(ignoreFile.filepath);
        }
        if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
          isIgnored = true;
        }
        if (babelrcFile && !isIgnored) {
          const validatedFile = validateBabelrcFile(babelrcFile);
          const babelrcLogger = new _printer.ConfigPrinter;
          const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);
          if (!result) {
            isIgnored = true;
          } else {
            babelRcReport = yield* babelrcLogger.output();
            mergeChain(fileChain, result);
          }
        }
        if (babelrcFile && isIgnored) {
          fileChain.files.add(babelrcFile.filepath);
        }
      }
    }
    if (context.showConfig) {
      console.log(`Babel configs on "${context.filename}" (ascending priority):\n` + [configReport, babelRcReport, programmaticReport].filter((x) => !!x).join("\n\n") + "\n-----End Babel configs-----");
    }
    const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
    return {
      plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
      presets: isIgnored ? [] : dedupDescriptors(chain.presets),
      options: isIgnored ? [] : chain.options.map((o) => normalizeOptions(o)),
      fileHandling: isIgnored ? "ignored" : "transpile",
      ignore: ignoreFile || undefined,
      babelrc: babelrcFile || undefined,
      config: configFile || undefined,
      files: chain.files
    };
  }
  var babelrcLoadEnabled = function(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
    if (typeof babelrcRoots === "boolean")
      return babelrcRoots;
    const absoluteRoot = context.root;
    if (babelrcRoots === undefined) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }
    let babelrcPatterns = babelrcRoots;
    if (!Array.isArray(babelrcPatterns)) {
      babelrcPatterns = [babelrcPatterns];
    }
    babelrcPatterns = babelrcPatterns.map((pat) => {
      return typeof pat === "string" ? _path().resolve(babelrcRootsDirectory, pat) : pat;
    });
    if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }
    return babelrcPatterns.some((pat) => {
      if (typeof pat === "string") {
        pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);
      }
      return pkgData.directories.some((directory) => {
        return matchPattern(pat, babelrcRootsDirectory, directory, context);
      });
    });
  };
  function* loadFileChain(input, context, files, baseLogger) {
    const chain = yield* loadFileChainWalker(input, context, files, baseLogger);
    chain == null || chain.files.add(input.filepath);
    return chain;
  }
  var buildFileLogger = function(filepath, context, baseLogger) {
    if (!baseLogger) {
      return () => {
      };
    }
    return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {
      filepath
    });
  };
  var buildRootDescriptors = function({
    dirname: dirname4,
    options
  }, alias, descriptors) {
    return descriptors(dirname4, options, alias);
  };
  var buildProgrammaticLogger = function(_, context, baseLogger) {
    var _context$caller;
    if (!baseLogger) {
      return () => {
      };
    }
    return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {
      callerName: (_context$caller = context.caller) == null ? undefined : _context$caller.name
    });
  };
  var buildEnvDescriptors = function({
    dirname: dirname4,
    options
  }, alias, descriptors, envName) {
    var _options$env;
    const opts = (_options$env = options.env) == null ? undefined : _options$env[envName];
    return opts ? descriptors(dirname4, opts, `${alias}.env["${envName}"]`) : null;
  };
  var buildOverrideDescriptors = function({
    dirname: dirname4,
    options
  }, alias, descriptors, index) {
    var _options$overrides;
    const opts = (_options$overrides = options.overrides) == null ? undefined : _options$overrides[index];
    if (!opts)
      throw new Error("Assertion failure - missing override");
    return descriptors(dirname4, opts, `${alias}.overrides[${index}]`);
  };
  var buildOverrideEnvDescriptors = function({
    dirname: dirname4,
    options
  }, alias, descriptors, index, envName) {
    var _options$overrides2, _override$env;
    const override = (_options$overrides2 = options.overrides) == null ? undefined : _options$overrides2[index];
    if (!override)
      throw new Error("Assertion failure - missing override");
    const opts = (_override$env = override.env) == null ? undefined : _override$env[envName];
    return opts ? descriptors(dirname4, opts, `${alias}.overrides[${index}].env["${envName}"]`) : null;
  };
  var makeChainWalker = function({
    root,
    env: env2,
    overrides,
    overridesEnv,
    createLogger
  }) {
    return function* chainWalker(input, context, files = new Set, baseLogger) {
      const {
        dirname: dirname4
      } = input;
      const flattenedConfigs = [];
      const rootOpts = root(input);
      if (configIsApplicable(rootOpts, dirname4, context, input.filepath)) {
        flattenedConfigs.push({
          config: rootOpts,
          envName: undefined,
          index: undefined
        });
        const envOpts = env2(input, context.envName);
        if (envOpts && configIsApplicable(envOpts, dirname4, context, input.filepath)) {
          flattenedConfigs.push({
            config: envOpts,
            envName: context.envName,
            index: undefined
          });
        }
        (rootOpts.options.overrides || []).forEach((_, index) => {
          const overrideOps = overrides(input, index);
          if (configIsApplicable(overrideOps, dirname4, context, input.filepath)) {
            flattenedConfigs.push({
              config: overrideOps,
              index,
              envName: undefined
            });
            const overrideEnvOpts = overridesEnv(input, index, context.envName);
            if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname4, context, input.filepath)) {
              flattenedConfigs.push({
                config: overrideEnvOpts,
                index,
                envName: context.envName
              });
            }
          }
        });
      }
      if (flattenedConfigs.some(({
        config: {
          options: {
            ignore,
            only
          }
        }
      }) => shouldIgnore(context, ignore, only, dirname4))) {
        return null;
      }
      const chain = emptyChain();
      const logger = createLogger(input, context, baseLogger);
      for (const {
        config: config2,
        index,
        envName
      } of flattenedConfigs) {
        if (!(yield* mergeExtendsChain(chain, config2.options, dirname4, context, files, baseLogger))) {
          return null;
        }
        logger(config2, index, envName);
        yield* mergeChainOpts(chain, config2);
      }
      return chain;
    };
  };
  function* mergeExtendsChain(chain, opts, dirname4, context, files, baseLogger) {
    if (opts.extends === undefined)
      return true;
    const file = yield* (0, _index.loadConfig)(opts.extends, dirname4, context.envName, context.caller);
    if (files.has(file)) {
      throw new Error(`Configuration cycle detected loading ${file.filepath}.\n` + `File already loaded following the config chain:\n` + Array.from(files, (file2) => ` - ${file2.filepath}`).join("\n"));
    }
    files.add(file);
    const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);
    files.delete(file);
    if (!fileChain)
      return false;
    mergeChain(chain, fileChain);
    return true;
  }
  var mergeChain = function(target, source) {
    target.options.push(...source.options);
    target.plugins.push(...source.plugins);
    target.presets.push(...source.presets);
    for (const file of source.files) {
      target.files.add(file);
    }
    return target;
  };
  function* mergeChainOpts(target, {
    options,
    plugins,
    presets
  }) {
    target.options.push(options);
    target.plugins.push(...yield* plugins());
    target.presets.push(...yield* presets());
    return target;
  }
  var emptyChain = function() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: new Set
    };
  };
  var normalizeOptions = function(opts) {
    const options = Object.assign({}, opts);
    delete options.extends;
    delete options.env;
    delete options.overrides;
    delete options.plugins;
    delete options.presets;
    delete options.passPerPreset;
    delete options.ignore;
    delete options.only;
    delete options.test;
    delete options.include;
    delete options.exclude;
    if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
      options.sourceMaps = options.sourceMap;
      delete options.sourceMap;
    }
    return options;
  };
  var dedupDescriptors = function(items) {
    const map = new Map;
    const descriptors = [];
    for (const item of items) {
      if (typeof item.value === "function") {
        const fnKey = item.value;
        let nameMap = map.get(fnKey);
        if (!nameMap) {
          nameMap = new Map;
          map.set(fnKey, nameMap);
        }
        let desc = nameMap.get(item.name);
        if (!desc) {
          desc = {
            value: item
          };
          descriptors.push(desc);
          if (!item.ownPass)
            nameMap.set(item.name, desc);
        } else {
          desc.value = item;
        }
      } else {
        descriptors.push({
          value: item
        });
      }
    }
    return descriptors.reduce((acc, desc) => {
      acc.push(desc.value);
      return acc;
    }, []);
  };
  var configIsApplicable = function({
    options
  }, dirname4, context, configName) {
    return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname4, configName)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname4, configName)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname4, configName));
  };
  var configFieldIsApplicable = function(context, test, dirname4, configName) {
    const patterns = Array.isArray(test) ? test : [test];
    return matchesPatterns(context, patterns, dirname4, configName);
  };
  var ignoreListReplacer = function(_key, value2) {
    if (value2 instanceof RegExp) {
      return String(value2);
    }
    return value2;
  };
  var shouldIgnore = function(context, ignore, only, dirname4) {
    if (ignore && matchesPatterns(context, ignore, dirname4)) {
      var _context$filename;
      const message = `No config is applied to "${(_context$filename = context.filename) != null ? _context$filename : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\` from "${dirname4}"`;
      debug(message);
      if (context.showConfig) {
        console.log(message);
      }
      return true;
    }
    if (only && !matchesPatterns(context, only, dirname4)) {
      var _context$filename2;
      const message = `No config is applied to "${(_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from "${dirname4}"`;
      debug(message);
      if (context.showConfig) {
        console.log(message);
      }
      return true;
    }
    return false;
  };
  var matchesPatterns = function(context, patterns, dirname4, configName) {
    return patterns.some((pattern) => matchPattern(pattern, dirname4, context.filename, context, configName));
  };
  var matchPattern = function(pattern, dirname4, pathToTest, context, configName) {
    if (typeof pattern === "function") {
      return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, {
        dirname: dirname4,
        envName: context.envName,
        caller: context.caller
      });
    }
    if (typeof pathToTest !== "string") {
      throw new _configError.default(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, configName);
    }
    if (typeof pattern === "string") {
      pattern = (0, _patternToRegex.default)(pattern, dirname4);
    }
    return pattern.test(pathToTest);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildPresetChain = buildPresetChain;
  exports.buildPresetChainWalker = undefined;
  exports.buildRootChain = buildRootChain;
  var _options = require_options3();
  var _patternToRegex = require_pattern_to_regex();
  var _printer = require_printer2();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var _configError = require_config_error();
  var _index = require_files();
  var _caching = require_caching();
  var _configDescriptors = require_config_descriptors();
  var debug = _debug()("babel:config:config-chain");
  var buildPresetChainWalker = exports.buildPresetChainWalker = makeChainWalker({
    root: (preset) => loadPresetDescriptors(preset),
    env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
    overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),
    overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),
    createLogger: () => () => {
    }
  });
  var loadPresetDescriptors = (0, _caching.makeWeakCacheSync)((preset) => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));
  var loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));
  var loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index) => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));
  var loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));
  var validateConfigFile = (0, _caching.makeWeakCacheSync)((file) => ({
    filepath: file.filepath,
    dirname: file.dirname,
    options: (0, _options.validate)("configfile", file.options, file.filepath)
  }));
  var validateBabelrcFile = (0, _caching.makeWeakCacheSync)((file) => ({
    filepath: file.filepath,
    dirname: file.dirname,
    options: (0, _options.validate)("babelrcfile", file.options, file.filepath)
  }));
  var validateExtendFile = (0, _caching.makeWeakCacheSync)((file) => ({
    filepath: file.filepath,
    dirname: file.dirname,
    options: (0, _options.validate)("extendsfile", file.options, file.filepath)
  }));
  var loadProgrammaticChain = makeChainWalker({
    root: (input) => buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors),
    env: (input, envName) => buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName),
    overrides: (input, index) => buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index),
    overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index, envName),
    createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)
  });
  var loadFileChainWalker = makeChainWalker({
    root: (file) => loadFileDescriptors(file),
    env: (file, envName) => loadFileEnvDescriptors(file)(envName),
    overrides: (file, index) => loadFileOverridesDescriptors(file)(index),
    overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),
    createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)
  });
  var loadFileDescriptors = (0, _caching.makeWeakCacheSync)((file) => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));
  var loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));
  var loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index) => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));
  var loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/validation/plugins.js
var require_plugins2 = __commonJS((exports) => {
  var assertVisitorMap = function(loc, value2) {
    const obj = (0, _optionAssertions.assertObject)(loc, value2);
    if (obj) {
      Object.keys(obj).forEach((prop) => {
        if (prop !== "_exploded" && prop !== "_verified") {
          assertVisitorHandler(prop, obj[prop]);
        }
      });
      if (obj.enter || obj.exit) {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
      }
    }
    return obj;
  };
  var assertVisitorHandler = function(key, value2) {
    if (value2 && typeof value2 === "object") {
      Object.keys(value2).forEach((handler) => {
        if (handler !== "enter" && handler !== "exit") {
          throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`);
        }
      });
    } else if (typeof value2 !== "function") {
      throw new Error(`.visitor["${key}"] must be a function`);
    }
  };
  var validatePluginObject = function(obj) {
    const rootPath = {
      type: "root",
      source: "plugin"
    };
    Object.keys(obj).forEach((key) => {
      const validator2 = VALIDATORS[key];
      if (validator2) {
        const optLoc = {
          type: "option",
          name: key,
          parent: rootPath
        };
        validator2(optLoc, obj[key]);
      } else {
        const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);
        invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
        throw invalidPluginPropertyError;
      }
    });
    return obj;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validatePluginObject = validatePluginObject;
  var _optionAssertions = require_option_assertions();
  var VALIDATORS = {
    name: _optionAssertions.assertString,
    manipulateOptions: _optionAssertions.assertFunction,
    pre: _optionAssertions.assertFunction,
    post: _optionAssertions.assertFunction,
    inherits: _optionAssertions.assertFunction,
    visitor: assertVisitorMap,
    parserOverride: _optionAssertions.assertFunction,
    generatorOverride: _optionAssertions.assertFunction
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/helpers/environment.js
var require_environment = __commonJS((exports) => {
  var getEnv = function(defaultValue = "development") {
    return process.env.BABEL_ENV || "development";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getEnv = getEnv;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/partial.js
var require_partial = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _objectWithoutPropertiesLoose = function(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0;i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  };
  var resolveRootMode = function(rootDir, rootMode) {
    switch (rootMode) {
      case "root":
        return rootDir;
      case "upward-optional": {
        const upwardRootDir = (0, _index.findConfigUpwards)(rootDir);
        return upwardRootDir === null ? rootDir : upwardRootDir;
      }
      case "upward": {
        const upwardRootDir = (0, _index.findConfigUpwards)(rootDir);
        if (upwardRootDir !== null)
          return upwardRootDir;
        throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not ` + `be found when searching upward from "${rootDir}".\n` + `One of the following config files must be in the directory tree: ` + `"${_index.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: rootDir
        });
      }
      default:
        throw new Error(`Assertion failure - unknown rootMode value.`);
    }
  };
  function* loadPrivatePartialConfig(inputOpts) {
    if (inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts))) {
      throw new Error("Babel options must be an object, null, or undefined");
    }
    const args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
    const {
      envName = (0, _environment.getEnv)(),
      cwd = ".",
      root: rootDir = ".",
      rootMode = "root",
      caller,
      cloneInputAst = true
    } = args;
    const absoluteCwd = _path().resolve(cwd);
    const absoluteRootDir = resolveRootMode(_path().resolve(absoluteCwd, rootDir), rootMode);
    const filename = typeof args.filename === "string" ? _path().resolve(cwd, args.filename) : undefined;
    const showConfigPath = yield* (0, _index.resolveShowConfigPath)(absoluteCwd);
    const context = {
      filename,
      cwd: absoluteCwd,
      root: absoluteRootDir,
      envName,
      caller,
      showConfig: showConfigPath === filename
    };
    const configChain = yield* (0, _configChain.buildRootChain)(args, context);
    if (!configChain)
      return null;
    const merged = {
      assumptions: {}
    };
    configChain.options.forEach((opts) => {
      (0, _util.mergeOptions)(merged, opts);
    });
    const options = Object.assign({}, merged, {
      targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir),
      cloneInputAst,
      babelrc: false,
      configFile: false,
      browserslistConfigFile: false,
      passPerPreset: false,
      envName: context.envName,
      cwd: context.cwd,
      root: context.root,
      rootMode: "root",
      filename: typeof context.filename === "string" ? context.filename : undefined,
      plugins: configChain.plugins.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)),
      presets: configChain.presets.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor))
    });
    return {
      options,
      context,
      fileHandling: configChain.fileHandling,
      ignore: configChain.ignore,
      babelrc: configChain.babelrc,
      config: configChain.config,
      files: configChain.files
    };
  }
  function* loadPartialConfig(opts) {
    let showIgnoredFiles = false;
    if (typeof opts === "object" && opts !== null && !Array.isArray(opts)) {
      var _opts = opts;
      ({
        showIgnoredFiles
      } = _opts);
      opts = _objectWithoutPropertiesLoose(_opts, _excluded);
    }
    const result = yield* loadPrivatePartialConfig(opts);
    if (!result)
      return null;
    const {
      options,
      babelrc,
      ignore,
      config: config2,
      fileHandling,
      files
    } = result;
    if (fileHandling === "ignored" && !showIgnoredFiles) {
      return null;
    }
    (options.plugins || []).forEach((item) => {
      if (item.value instanceof _plugin.default) {
        throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
      }
    });
    return new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config2 ? config2.filepath : undefined, fileHandling, files);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = loadPrivatePartialConfig;
  exports.loadPartialConfig = loadPartialConfig;
  var _plugin = require_plugin();
  var _util = require_util2();
  var _item = require_item();
  var _configChain = require_config_chain();
  var _environment = require_environment();
  var _options = require_options3();
  var _index = require_files();
  var _resolveTargets = require_resolve_targets();
  var _excluded = ["showIgnoredFiles"];

  class PartialConfig {
    constructor(options, babelrc, ignore, config2, fileHandling, files) {
      this.options = undefined;
      this.babelrc = undefined;
      this.babelignore = undefined;
      this.config = undefined;
      this.fileHandling = undefined;
      this.files = undefined;
      this.options = options;
      this.babelignore = ignore;
      this.babelrc = babelrc;
      this.config = config2;
      this.fileHandling = fileHandling;
      this.files = files;
      Object.freeze(this);
    }
    hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    }
  }
  Object.freeze(PartialConfig.prototype);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/full.js
var require_full = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var _traverse = function() {
    const data = require_lib13();
    _traverse = function() {
      return data;
    };
    return data;
  };
  var enhanceError = function(context2, fn) {
    return function* (arg1, arg2) {
      try {
        return yield* fn(arg1, arg2);
      } catch (e) {
        if (!/^\[BABEL\]/.test(e.message)) {
          var _context$filename;
          e.message = `[BABEL] ${(_context$filename = context2.filename) != null ? _context$filename : "unknown file"}: ${e.message}`;
        }
        throw e;
      }
    };
  };
  function* loadPluginDescriptor(descriptor, context2) {
    if (descriptor.value instanceof _plugin.default) {
      if (descriptor.options) {
        throw new Error("Passed options to an existing Plugin instance will not work.");
      }
      return descriptor.value;
    }
    return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context2), context2);
  }
  function* loadPresetDescriptor(descriptor, context2) {
    const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context2));
    validatePreset(preset, context2, descriptor);
    return {
      chain: yield* (0, _configChain.buildPresetChain)(preset, context2),
      externalDependencies: preset.externalDependencies
    };
  }
  var chain = function(a, b) {
    const fns = [a, b].filter(Boolean);
    if (fns.length <= 1)
      return fns[0];
    return function(...args) {
      for (const fn of fns) {
        fn.apply(this, args);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _async = require_async();
  var _util = require_util2();
  var context = require_lib33();
  var _plugin = require_plugin();
  var _item = require_item();
  var _configChain = require_config_chain();
  var _deepArray = require_deep_array();
  var _caching = require_caching();
  var _options = require_options3();
  var _plugins = require_plugins2();
  var _configApi = require_config_api();
  var _partial = require_partial();
  var _configError = require_config_error();
  var _default = exports.default = _gensync()(function* loadFullConfig(inputOpts) {
    var _opts$assumptions;
    const result = yield* (0, _partial.default)(inputOpts);
    if (!result) {
      return null;
    }
    const {
      options,
      context: context2,
      fileHandling
    } = result;
    if (fileHandling === "ignored") {
      return null;
    }
    const optionDefaults = {};
    const {
      plugins,
      presets
    } = options;
    if (!plugins || !presets) {
      throw new Error("Assertion failure - plugins and presets exist");
    }
    const presetContext = Object.assign({}, context2, {
      targets: options.targets
    });
    const toDescriptor = (item) => {
      const desc = (0, _item.getItemDescriptor)(item);
      if (!desc) {
        throw new Error("Assertion failure - must be config item");
      }
      return desc;
    };
    const presetsDescriptors = presets.map(toDescriptor);
    const initialPluginsDescriptors = plugins.map(toDescriptor);
    const pluginDescriptorsByPass = [[]];
    const passes = [];
    const externalDependencies = [];
    const ignored = yield* enhanceError(context2, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
      const presets2 = [];
      for (let i = 0;i < rawPresets.length; i++) {
        const descriptor = rawPresets[i];
        if (descriptor.options !== false) {
          try {
            var preset = yield* loadPresetDescriptor(descriptor, presetContext);
          } catch (e) {
            if (e.code === "BABEL_UNKNOWN_OPTION") {
              (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, "preset", e);
            }
            throw e;
          }
          externalDependencies.push(preset.externalDependencies);
          if (descriptor.ownPass) {
            presets2.push({
              preset: preset.chain,
              pass: []
            });
          } else {
            presets2.unshift({
              preset: preset.chain,
              pass: pluginDescriptorsPass
            });
          }
        }
      }
      if (presets2.length > 0) {
        pluginDescriptorsByPass.splice(1, 0, ...presets2.map((o) => o.pass).filter((p) => p !== pluginDescriptorsPass));
        for (const {
          preset: preset2,
          pass
        } of presets2) {
          if (!preset2)
            return true;
          pass.push(...preset2.plugins);
          const ignored2 = yield* recursePresetDescriptors(preset2.presets, pass);
          if (ignored2)
            return true;
          preset2.options.forEach((opts2) => {
            (0, _util.mergeOptions)(optionDefaults, opts2);
          });
        }
      }
    })(presetsDescriptors, pluginDescriptorsByPass[0]);
    if (ignored)
      return null;
    const opts = optionDefaults;
    (0, _util.mergeOptions)(opts, options);
    const pluginContext = Object.assign({}, presetContext, {
      assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}
    });
    yield* enhanceError(context2, function* loadPluginDescriptors() {
      pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
      for (const descs of pluginDescriptorsByPass) {
        const pass = [];
        passes.push(pass);
        for (let i = 0;i < descs.length; i++) {
          const descriptor = descs[i];
          if (descriptor.options !== false) {
            try {
              var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);
            } catch (e) {
              if (e.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, "plugin", e);
              }
              throw e;
            }
            pass.push(plugin);
            externalDependencies.push(plugin.externalDependencies);
          }
        }
      }
    })();
    opts.plugins = passes[0];
    opts.presets = passes.slice(1).filter((plugins2) => plugins2.length > 0).map((plugins2) => ({
      plugins: plugins2
    }));
    opts.passPerPreset = opts.presets.length > 0;
    return {
      options: opts,
      passes,
      externalDependencies: (0, _deepArray.finalize)(externalDependencies)
    };
  });
  var makeDescriptorLoader = (apiFactory) => (0, _caching.makeWeakCache)(function* ({
    value: value2,
    options,
    dirname: dirname4,
    alias
  }, cache) {
    if (options === false)
      throw new Error("Assertion failure");
    options = options || {};
    const externalDependencies = [];
    let item = value2;
    if (typeof value2 === "function") {
      const factory = (0, _async.maybeAsync)(value2, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);
      const api = Object.assign({}, context, apiFactory(cache, externalDependencies));
      try {
        item = yield* factory(api, options, dirname4);
      } catch (e) {
        if (alias) {
          e.message += ` (While processing: ${JSON.stringify(alias)})`;
        }
        throw e;
      }
    }
    if (!item || typeof item !== "object") {
      throw new Error("Plugin/Preset did not return an object.");
    }
    if ((0, _async.isThenable)(item)) {
      yield* [];
      throw new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". ` + `(While processing: ${JSON.stringify(alias)})`);
    }
    if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === "forever")) {
      let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;
      if (!cache.configured()) {
        error += `has not been configured to be invalidated when the external dependencies change. `;
      } else {
        error += ` has been configured to never be invalidated. `;
      }
      error += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`\n` + `(While processing: ${JSON.stringify(alias)})`;
      throw new Error(error);
    }
    return {
      value: item,
      options,
      dirname: dirname4,
      alias,
      externalDependencies: (0, _deepArray.finalize)(externalDependencies)
    };
  });
  var pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);
  var presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);
  var instantiatePlugin = (0, _caching.makeWeakCache)(function* ({
    value: value2,
    options,
    dirname: dirname4,
    alias,
    externalDependencies
  }, cache) {
    const pluginObj = (0, _plugins.validatePluginObject)(value2);
    const plugin = Object.assign({}, pluginObj);
    if (plugin.visitor) {
      plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));
    }
    if (plugin.inherits) {
      const inheritsDescriptor = {
        name: undefined,
        alias: `${alias}\$inherits`,
        value: plugin.inherits,
        options,
        dirname: dirname4
      };
      const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, (run) => {
        return cache.invalidate((data) => run(inheritsDescriptor, data));
      });
      plugin.pre = chain(inherits.pre, plugin.pre);
      plugin.post = chain(inherits.post, plugin.post);
      plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
      plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);
      if (inherits.externalDependencies.length > 0) {
        if (externalDependencies.length === 0) {
          externalDependencies = inherits.externalDependencies;
        } else {
          externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);
        }
      }
    }
    return new _plugin.default(plugin, options, alias, externalDependencies);
  });
  var needsFilename = (val) => val && typeof val !== "function";
  var validateIfOptionNeedsFilename = (options, descriptor) => {
    if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {
      const formattedPresetName = descriptor.name ? `"${descriptor.name}"` : "/* your preset */";
      throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\`\`\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\`\`\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join("\n"));
    }
  };
  var validatePreset = (preset, context2, descriptor) => {
    if (!context2.filename) {
      var _options$overrides;
      const {
        options
      } = preset;
      validateIfOptionNeedsFilename(options, descriptor);
      (_options$overrides = options.overrides) == null || _options$overrides.forEach((overrideOptions) => validateIfOptionNeedsFilename(overrideOptions, descriptor));
    }
  };
  var instantiatePreset = (0, _caching.makeWeakCacheSync)(({
    value: value2,
    dirname: dirname4,
    alias,
    externalDependencies
  }) => {
    return {
      options: (0, _options.validate)("preset", value2),
      alias,
      dirname: dirname4,
      externalDependencies
    };
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/index.js
var require_config = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var loadPartialConfigAsync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.async)(...args);
  };
  var loadPartialConfigSync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.sync)(...args);
  };
  var loadPartialConfig = function(opts, callback) {
    if (callback !== undefined) {
      (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(opts, callback);
    } else if (typeof opts === "function") {
      (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(undefined, opts);
    } else {
      {
        return loadPartialConfigSync(opts);
      }
    }
  };
  function* loadOptionsImpl(opts) {
    var _config$options;
    const config2 = yield* (0, _full.default)(opts);
    return (_config$options = config2 == null ? undefined : config2.options) != null ? _config$options : null;
  }
  var loadOptionsAsync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.async)(...args);
  };
  var loadOptionsSync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.sync)(...args);
  };
  var loadOptions = function(opts, callback) {
    if (callback !== undefined) {
      (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(opts, callback);
    } else if (typeof opts === "function") {
      (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(undefined, opts);
    } else {
      {
        return loadOptionsSync(opts);
      }
    }
  };
  var createConfigItemAsync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.async)(...args);
  };
  var createConfigItemSync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.sync)(...args);
  };
  var createConfigItem = function(target, options, callback) {
    if (callback !== undefined) {
      (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, options, callback);
    } else if (typeof options === "function") {
      (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, undefined, callback);
    } else {
      {
        return createConfigItemSync(target, options);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createConfigItem = createConfigItem;
  exports.createConfigItemAsync = createConfigItemAsync;
  exports.createConfigItemSync = createConfigItemSync;
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
      return _full.default;
    }
  });
  exports.loadOptions = loadOptions;
  exports.loadOptionsAsync = loadOptionsAsync;
  exports.loadOptionsSync = loadOptionsSync;
  exports.loadPartialConfig = loadPartialConfig;
  exports.loadPartialConfigAsync = loadPartialConfigAsync;
  exports.loadPartialConfigSync = loadPartialConfigSync;
  var _full = require_full();
  var _partial = require_partial();
  var _item = require_item();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var loadPartialConfigRunner = _gensync()(_partial.loadPartialConfig);
  var loadOptionsRunner = _gensync()(loadOptionsImpl);
  var createConfigItemRunner = _gensync()(_item.createConfigItem);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/plugin-pass.js
var require_plugin_pass = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class PluginPass {
    constructor(file, key, options) {
      this._map = new Map;
      this.key = undefined;
      this.file = undefined;
      this.opts = undefined;
      this.cwd = undefined;
      this.filename = undefined;
      this.key = key;
      this.file = file;
      this.opts = options || {};
      this.cwd = file.opts.cwd;
      this.filename = file.opts.filename;
    }
    set(key, val) {
      this._map.set(key, val);
    }
    get(key) {
      return this._map.get(key);
    }
    availableHelper(name, versionRange) {
      return this.file.availableHelper(name, versionRange);
    }
    addHelper(name) {
      return this.file.addHelper(name);
    }
    buildCodeFrameError(node2, msg, _Error) {
      return this.file.buildCodeFrameError(node2, msg, _Error);
    }
  }
  exports.default = PluginPass;
  {
    PluginPass.prototype.getModuleName = function getModuleName() {
      return this.file.getModuleName();
    };
    PluginPass.prototype.addImport = function addImport() {
      this.file.addImport();
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var require_block_hoist_plugin = __commonJS((exports) => {
  var _traverse = function() {
    const data = require_lib13();
    _traverse = function() {
      return data;
    };
    return data;
  };
  var loadBlockHoistPlugin = function() {
    if (!LOADED_PLUGIN) {
      LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, {
        visitor: _traverse().default.explode(blockHoistPlugin.visitor)
      }), {});
    }
    return LOADED_PLUGIN;
  };
  var priority = function(bodyNode) {
    const priority2 = bodyNode == null ? undefined : bodyNode._blockHoist;
    if (priority2 == null)
      return 1;
    if (priority2 === true)
      return 2;
    return priority2;
  };
  var stableSort = function(body) {
    const buckets = Object.create(null);
    for (let i = 0;i < body.length; i++) {
      const n = body[i];
      const p = priority(n);
      const bucket = buckets[p] || (buckets[p] = []);
      bucket.push(n);
    }
    const keys = Object.keys(buckets).map((k) => +k).sort((a, b) => b - a);
    let index = 0;
    for (const key of keys) {
      const bucket = buckets[key];
      for (const n of bucket) {
        body[index++] = n;
      }
    }
    return body;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = loadBlockHoistPlugin;
  var _plugin = require_plugin();
  var LOADED_PLUGIN;
  var blockHoistPlugin = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: node2
        }) {
          const {
            body
          } = node2;
          let max = Math.pow(2, 30) - 1;
          let hasChange = false;
          for (let i = 0;i < body.length; i++) {
            const n = body[i];
            const p = priority(n);
            if (p > max) {
              hasChange = true;
              break;
            }
            max = p;
          }
          if (!hasChange)
            return;
          node2.body = stableSort(body.slice());
        }
      }
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/normalize-opts.js
var require_normalize_opts = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var normalizeOptions = function(config2) {
    const {
      filename,
      cwd,
      filenameRelative = typeof filename === "string" ? _path().relative(cwd, filename) : "unknown",
      sourceType = "module",
      inputSourceMap,
      sourceMaps = !!inputSourceMap,
      sourceRoot = config2.options.moduleRoot,
      sourceFileName = _path().basename(filenameRelative),
      comments = true,
      compact = "auto"
    } = config2.options;
    const opts = config2.options;
    const options = Object.assign({}, opts, {
      parserOpts: Object.assign({
        sourceType: _path().extname(filenameRelative) === ".mjs" ? "module" : sourceType,
        sourceFileName: filename,
        plugins: []
      }, opts.parserOpts),
      generatorOpts: Object.assign({
        filename,
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        retainLines: opts.retainLines,
        comments,
        shouldPrintComment: opts.shouldPrintComment,
        compact,
        minified: opts.minified,
        sourceMaps,
        sourceRoot,
        sourceFileName
      }, opts.generatorOpts)
    });
    for (const plugins of config2.passes) {
      for (const plugin of plugins) {
        if (plugin.manipulateOptions) {
          plugin.manipulateOptions(options, options.parserOpts);
        }
      }
    }
    return options;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeOptions;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS((exports) => {
  var decodeBase64WithBufferFrom = function(base64) {
    return Buffer.from(base64, "base64").toString();
  };
  var decodeBase64WithNewBuffer = function(base64) {
    if (typeof value === "number") {
      throw new TypeError("The value to decode must not be of type number.");
    }
    return new Buffer(base64, "base64").toString();
  };
  var decodeBase64WithAtob = function(base64) {
    return decodeURIComponent(escape(atob(base64)));
  };
  var stripComment = function(sm) {
    return sm.split(",").pop();
  };
  var readFromFileMap = function(sm, read) {
    var r = exports.mapFileCommentRegex.exec(sm);
    var filename = r[1] || r[2];
    try {
      var sm = read(filename);
      if (sm != null && typeof sm.catch === "function") {
        return sm.catch(throwError);
      } else {
        return sm;
      }
    } catch (e) {
      throwError(e);
    }
    function throwError(e) {
      throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e.stack);
    }
  };
  var Converter = function(sm, opts) {
    opts = opts || {};
    if (opts.hasComment) {
      sm = stripComment(sm);
    }
    if (opts.encoding === "base64") {
      sm = decodeBase64(sm);
    } else if (opts.encoding === "uri") {
      sm = decodeURIComponent(sm);
    }
    if (opts.isJSON || opts.encoding) {
      sm = JSON.parse(sm);
    }
    this.sourcemap = sm;
  };
  var encodeBase64WithBufferFrom = function() {
    var json = this.toJSON();
    return Buffer.from(json, "utf8").toString("base64");
  };
  var encodeBase64WithNewBuffer = function() {
    var json = this.toJSON();
    if (typeof json === "number") {
      throw new TypeError("The json to encode must not be of type number.");
    }
    return new Buffer(json, "utf8").toString("base64");
  };
  var encodeBase64WithBtoa = function() {
    var json = this.toJSON();
    return btoa(unescape(encodeURIComponent(json)));
  };
  var makeConverter = function(sm) {
    return new Converter(sm, { isJSON: true });
  };
  Object.defineProperty(exports, "commentRegex", {
    get: function getCommentRegex() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }
  });
  Object.defineProperty(exports, "mapFileCommentRegex", {
    get: function getMapFileCommentRegex() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }
  });
  var decodeBase64;
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      decodeBase64 = decodeBase64WithBufferFrom;
    } else {
      decodeBase64 = decodeBase64WithNewBuffer;
    }
  } else {
    decodeBase64 = decodeBase64WithAtob;
  }
  Converter.prototype.toJSON = function(space) {
    return JSON.stringify(this.sourcemap, null, space);
  };
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
    } else {
      Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
    }
  } else {
    Converter.prototype.toBase64 = encodeBase64WithBtoa;
  }
  Converter.prototype.toURI = function() {
    var json = this.toJSON();
    return encodeURIComponent(json);
  };
  Converter.prototype.toComment = function(options) {
    var encoding, content, data;
    if (options != null && options.encoding === "uri") {
      encoding = "";
      content = this.toURI();
    } else {
      encoding = ";base64";
      content = this.toBase64();
    }
    data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
    return options != null && options.multiline ? "/*# " + data + " */" : "//# " + data;
  };
  Converter.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Converter.prototype.addProperty = function(key, value2) {
    if (this.sourcemap.hasOwnProperty(key))
      throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(key, value2);
  };
  Converter.prototype.setProperty = function(key, value2) {
    this.sourcemap[key] = value2;
    return this;
  };
  Converter.prototype.getProperty = function(key) {
    return this.sourcemap[key];
  };
  exports.fromObject = function(obj) {
    return new Converter(obj);
  };
  exports.fromJSON = function(json) {
    return new Converter(json, { isJSON: true });
  };
  exports.fromURI = function(uri) {
    return new Converter(uri, { encoding: "uri" });
  };
  exports.fromBase64 = function(base64) {
    return new Converter(base64, { encoding: "base64" });
  };
  exports.fromComment = function(comment) {
    var m, encoding;
    comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
    m = exports.commentRegex.exec(comment);
    encoding = m && m[4] || "uri";
    return new Converter(comment, { encoding, hasComment: true });
  };
  exports.fromMapFileComment = function(comment, read) {
    if (typeof read === "string") {
      throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
    }
    var sm = readFromFileMap(comment, read);
    if (sm != null && typeof sm.then === "function") {
      return sm.then(makeConverter);
    } else {
      return makeConverter(sm);
    }
  };
  exports.fromSource = function(content) {
    var m = content.match(exports.commentRegex);
    return m ? exports.fromComment(m.pop()) : null;
  };
  exports.fromMapFileSource = function(content, read) {
    if (typeof read === "string") {
      throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
    }
    var m = content.match(exports.mapFileCommentRegex);
    return m ? exports.fromMapFileComment(m.pop(), read) : null;
  };
  exports.removeComments = function(src) {
    return src.replace(exports.commentRegex, "");
  };
  exports.removeMapFileComments = function(src) {
    return src.replace(exports.mapFileCommentRegex, "");
  };
  exports.generateMapFileComment = function(file, options) {
    var data = "sourceMappingURL=" + file;
    return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var require_missing_plugin_helper = __commonJS((exports) => {
  var generateMissingPluginMessage = function(missingPluginName, loc, codeFrame) {
    let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled ` + `(${loc.line}:${loc.column + 1}):\n\n` + codeFrame;
    const pluginInfo = pluginNameMap[missingPluginName];
    if (pluginInfo) {
      const {
        syntax: syntaxPlugin,
        transform: transformPlugin
      } = pluginInfo;
      if (syntaxPlugin) {
        const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
        if (transformPlugin) {
          const transformPluginInfo = getNameURLCombination(transformPlugin);
          const sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          helpMessage += `\n\nAdd ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;
        } else {
          helpMessage += `\n\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config ` + `to enable parsing.`;
        }
      }
    }
    return helpMessage;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = generateMissingPluginMessage;
  var pluginNameMap = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    importAttributes: {
      syntax: {
        name: "@babel/plugin-syntax-import-attributes",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    }
  };
  {
    Object.assign(pluginNameMap, {
      asyncGenerators: {
        syntax: {
          name: "@babel/plugin-syntax-async-generators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
        },
        transform: {
          name: "@babel/plugin-transform-async-generator-functions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
        }
      },
      classProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
        },
        transform: {
          name: "@babel/plugin-transform-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
        }
      },
      classPrivateProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
        },
        transform: {
          name: "@babel/plugin-transform-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
        }
      },
      classPrivateMethods: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
        },
        transform: {
          name: "@babel/plugin-transform-private-methods",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
        }
      },
      classStaticBlock: {
        syntax: {
          name: "@babel/plugin-syntax-class-static-block",
          url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
        },
        transform: {
          name: "@babel/plugin-transform-class-static-block",
          url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
        }
      },
      dynamicImport: {
        syntax: {
          name: "@babel/plugin-syntax-dynamic-import",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
        }
      },
      exportNamespaceFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-namespace-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
        },
        transform: {
          name: "@babel/plugin-transform-export-namespace-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
        }
      },
      importAssertions: {
        syntax: {
          name: "@babel/plugin-syntax-import-assertions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
        }
      },
      importMeta: {
        syntax: {
          name: "@babel/plugin-syntax-import-meta",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
        }
      },
      logicalAssignment: {
        syntax: {
          name: "@babel/plugin-syntax-logical-assignment-operators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
        },
        transform: {
          name: "@babel/plugin-transform-logical-assignment-operators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
        }
      },
      moduleStringNames: {
        syntax: {
          name: "@babel/plugin-syntax-module-string-names",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
        }
      },
      numericSeparator: {
        syntax: {
          name: "@babel/plugin-syntax-numeric-separator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
        },
        transform: {
          name: "@babel/plugin-transform-numeric-separator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
        }
      },
      nullishCoalescingOperator: {
        syntax: {
          name: "@babel/plugin-syntax-nullish-coalescing-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
        },
        transform: {
          name: "@babel/plugin-transform-nullish-coalescing-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
        }
      },
      objectRestSpread: {
        syntax: {
          name: "@babel/plugin-syntax-object-rest-spread",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
        },
        transform: {
          name: "@babel/plugin-transform-object-rest-spread",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
        }
      },
      optionalCatchBinding: {
        syntax: {
          name: "@babel/plugin-syntax-optional-catch-binding",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
        },
        transform: {
          name: "@babel/plugin-transform-optional-catch-binding",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
        }
      },
      optionalChaining: {
        syntax: {
          name: "@babel/plugin-syntax-optional-chaining",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
        },
        transform: {
          name: "@babel/plugin-transform-optional-chaining",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
        }
      },
      privateIn: {
        syntax: {
          name: "@babel/plugin-syntax-private-property-in-object",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
        },
        transform: {
          name: "@babel/plugin-transform-private-property-in-object",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
        }
      },
      regexpUnicodeSets: {
        syntax: {
          name: "@babel/plugin-syntax-unicode-sets-regex",
          url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
        },
        transform: {
          name: "@babel/plugin-transform-unicode-sets-regex",
          url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
        }
      }
    });
  }
  var getNameURLCombination = ({
    name,
    url
  }) => `${name} (${url})`;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/parser/index.js
var require_parser3 = __commonJS((exports) => {
  var _parser = function() {
    const data = require_lib4();
    _parser = function() {
      return data;
    };
    return data;
  };
  var _codeFrame = function() {
    const data = require_lib9();
    _codeFrame = function() {
      return data;
    };
    return data;
  };
  function* parser3(pluginPasses, {
    parserOpts,
    highlightCode = true,
    filename = "unknown"
  }, code) {
    try {
      const results = [];
      for (const plugins of pluginPasses) {
        for (const plugin of plugins) {
          const {
            parserOverride
          } = plugin;
          if (parserOverride) {
            const ast = parserOverride(code, parserOpts, _parser().parse);
            if (ast !== undefined)
              results.push(ast);
          }
        }
      }
      if (results.length === 0) {
        return (0, _parser().parse)(code, parserOpts);
      } else if (results.length === 1) {
        yield* [];
        if (typeof results[0].then === "function") {
          throw new Error(`You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        return results[0];
      }
      throw new Error("More than one plugin attempted to override parsing.");
    } catch (err) {
      if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
        err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.";
      }
      const {
        loc,
        missingPlugin
      } = err;
      if (loc) {
        const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        }, {
          highlightCode
        });
        if (missingPlugin) {
          err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);
        } else {
          err.message = `${filename}: ${err.message}\n\n` + codeFrame;
        }
        err.code = "BABEL_PARSE_ERROR";
      }
      throw err;
    }
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parser3;
  var _missingPluginHelper = require_missing_plugin_helper();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/util/clone-deep.js
var require_clone_deep = __commonJS((exports) => {
  var deepClone = function(value2, cache) {
    if (value2 !== null) {
      if (cache.has(value2))
        return cache.get(value2);
      let cloned;
      if (Array.isArray(value2)) {
        cloned = new Array(value2.length);
        cache.set(value2, cloned);
        for (let i = 0;i < value2.length; i++) {
          cloned[i] = typeof value2[i] !== "object" ? value2[i] : deepClone(value2[i], cache);
        }
      } else {
        cloned = {};
        cache.set(value2, cloned);
        const keys = Object.keys(value2);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          cloned[key] = typeof value2[key] !== "object" ? value2[key] : deepClone(value2[key], cache);
        }
      }
      return cloned;
    }
    return value2;
  };
  var _default = function(value2) {
    if (typeof value2 !== "object")
      return value2;
    return deepClone(value2, new Map);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/normalize-file.js
var require_normalize_file = __commonJS((exports) => {
  var _fs = function() {
    const data = __require("fs");
    _fs = function() {
      return data;
    };
    return data;
  };
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _debug = function() {
    const data = require_src();
    _debug = function() {
      return data;
    };
    return data;
  };
  var _t = function() {
    const data = require_lib3();
    _t = function() {
      return data;
    };
    return data;
  };
  var _convertSourceMap = function() {
    const data = require_convert_source_map();
    _convertSourceMap = function() {
      return data;
    };
    return data;
  };
  function* normalizeFile(pluginPasses, options, code, ast) {
    code = `${code || ""}`;
    if (ast) {
      if (ast.type === "Program") {
        ast = file(ast, [], []);
      } else if (ast.type !== "File") {
        throw new Error("AST root must be a Program or File node");
      }
      if (options.cloneInputAst) {
        ast = (0, _cloneDeep.default)(ast);
      }
    } else {
      ast = yield* (0, _index.default)(pluginPasses, options, code);
    }
    let inputMap = null;
    if (options.inputSourceMap !== false) {
      if (typeof options.inputSourceMap === "object") {
        inputMap = _convertSourceMap().fromObject(options.inputSourceMap);
      }
      if (!inputMap) {
        const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);
        if (lastComment) {
          try {
            inputMap = _convertSourceMap().fromComment("//" + lastComment);
          } catch (err) {
            {
              debug("discarding unknown inline input sourcemap");
            }
          }
        }
      }
      if (!inputMap) {
        const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);
        if (typeof options.filename === "string" && lastComment) {
          try {
            const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);
            const inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]), "utf8");
            inputMap = _convertSourceMap().fromJSON(inputMapContent);
          } catch (err) {
            debug("discarding unknown file input sourcemap", err);
          }
        } else if (lastComment) {
          debug("discarding un-loadable file input sourcemap");
        }
      }
    }
    return new _file.default(options, {
      code,
      ast,
      inputMap
    });
  }
  var extractCommentsFromList = function(regex, comments, lastComment) {
    if (comments) {
      comments = comments.filter(({
        value: value2
      }) => {
        if (regex.test(value2)) {
          lastComment = value2;
          return false;
        }
        return true;
      });
    }
    return [comments, lastComment];
  };
  var extractComments = function(regex, ast) {
    let lastComment = null;
    traverseFast(ast, (node2) => {
      [node2.leadingComments, lastComment] = extractCommentsFromList(regex, node2.leadingComments, lastComment);
      [node2.innerComments, lastComment] = extractCommentsFromList(regex, node2.innerComments, lastComment);
      [node2.trailingComments, lastComment] = extractCommentsFromList(regex, node2.trailingComments, lastComment);
    });
    return lastComment;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeFile;
  var _file = require_file();
  var _index = require_parser3();
  var _cloneDeep = require_clone_deep();
  var {
    file,
    traverseFast
  } = _t();
  var debug = _debug()("babel:transform:file");
  var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
  var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@ampproject/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_trace_mapping_umd(), require_gen_mapping_umd()) : typeof define === "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.remapping = factory(global2.traceMapping, global2.genMapping));
  })(exports, function(traceMapping, genMapping) {
    const SOURCELESS_MAPPING = SegmentObject("", -1, -1, "", null);
    const EMPTY_SOURCES = [];
    function SegmentObject(source, line, column, name, content) {
      return { source, line, column, name, content };
    }
    function Source(map, sources, source, content) {
      return {
        map,
        sources,
        source,
        content
      };
    }
    function MapSource(map, sources) {
      return Source(map, sources, "", null);
    }
    function OriginalSource(source, content) {
      return Source(null, EMPTY_SOURCES, source, content);
    }
    function traceMappings(tree) {
      const gen = new genMapping.GenMapping({ file: tree.map.file });
      const { sources: rootSources, map } = tree;
      const rootNames = map.names;
      const rootMappings = traceMapping.decodedMappings(map);
      for (let i = 0;i < rootMappings.length; i++) {
        const segments = rootMappings[i];
        for (let j = 0;j < segments.length; j++) {
          const segment = segments[j];
          const genCol = segment[0];
          let traced = SOURCELESS_MAPPING;
          if (segment.length !== 1) {
            const source2 = rootSources[segment[1]];
            traced = originalPositionFor(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
            if (traced == null)
              continue;
          }
          const { column, line, name, content, source } = traced;
          genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name);
          if (source && content != null)
            genMapping.setSourceContent(gen, source, content);
        }
      }
      return gen;
    }
    function originalPositionFor(source, line, column, name) {
      if (!source.map) {
        return SegmentObject(source.source, line, column, name, source.content);
      }
      const segment = traceMapping.traceSegment(source.map, line, column);
      if (segment == null)
        return null;
      if (segment.length === 1)
        return SOURCELESS_MAPPING;
      return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
    }
    function asArray(value2) {
      if (Array.isArray(value2))
        return value2;
      return [value2];
    }
    function buildSourceMapTree(input, loader2) {
      const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ""));
      const map = maps.pop();
      for (let i = 0;i < maps.length; i++) {
        if (maps[i].sources.length > 1) {
          throw new Error(`Transformation map ${i} must have exactly one source file.\n` + "Did you specify these with the most recent transformation maps first?");
        }
      }
      let tree = build2(map, loader2, "", 0);
      for (let i = maps.length - 1;i >= 0; i--) {
        tree = MapSource(maps[i], [tree]);
      }
      return tree;
    }
    function build2(map, loader2, importer, importerDepth) {
      const { resolvedSources, sourcesContent } = map;
      const depth = importerDepth + 1;
      const children = resolvedSources.map((sourceFile, i) => {
        const ctx = {
          importer,
          depth,
          source: sourceFile || "",
          content: undefined
        };
        const sourceMap = loader2(ctx.source, ctx);
        const { source, content } = ctx;
        if (sourceMap)
          return build2(new traceMapping.TraceMap(sourceMap, source), loader2, source, depth);
        const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;
        return OriginalSource(source, sourceContent);
      });
      return MapSource(map, children);
    }

    class SourceMap {
      constructor(map, options) {
        const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
        this.version = out.version;
        this.file = out.file;
        this.mappings = out.mappings;
        this.names = out.names;
        this.sourceRoot = out.sourceRoot;
        this.sources = out.sources;
        if (!options.excludeContent) {
          this.sourcesContent = out.sourcesContent;
        }
      }
      toString() {
        return JSON.stringify(this);
      }
    }
    function remapping(input, loader2, options) {
      const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
      const tree = buildSourceMapTree(input, loader2);
      return new SourceMap(traceMappings(tree), opts);
    }
    return remapping;
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/file/merge-map.js
var require_merge_map = __commonJS((exports) => {
  var _remapping = function() {
    const data = require_remapping_umd();
    _remapping = function() {
      return data;
    };
    return data;
  };
  var mergeSourceMap = function(inputMap, map, sourceFileName) {
    const source = sourceFileName.replace(/\\/g, "/");
    let found = false;
    const result = _remapping()(rootless(map), (s, ctx) => {
      if (s === source && !found) {
        found = true;
        ctx.source = "";
        return rootless(inputMap);
      }
      return null;
    });
    if (typeof inputMap.sourceRoot === "string") {
      result.sourceRoot = inputMap.sourceRoot;
    }
    return Object.assign({}, result);
  };
  var rootless = function(map) {
    return Object.assign({}, map, {
      sourceRoot: null
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = mergeSourceMap;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/file/generate.js
var require_generate = __commonJS((exports) => {
  var _convertSourceMap = function() {
    const data = require_convert_source_map();
    _convertSourceMap = function() {
      return data;
    };
    return data;
  };
  var _generator = function() {
    const data = require_lib7();
    _generator = function() {
      return data;
    };
    return data;
  };
  var generateCode = function(pluginPasses, file) {
    const {
      opts,
      ast,
      code,
      inputMap
    } = file;
    const {
      generatorOpts
    } = opts;
    generatorOpts.inputSourceMap = inputMap == null ? undefined : inputMap.toObject();
    const results = [];
    for (const plugins of pluginPasses) {
      for (const plugin of plugins) {
        const {
          generatorOverride
        } = plugin;
        if (generatorOverride) {
          const result2 = generatorOverride(ast, generatorOpts, code, _generator().default);
          if (result2 !== undefined)
            results.push(result2);
        }
      }
    }
    let result;
    if (results.length === 0) {
      result = (0, _generator().default)(ast, generatorOpts, code);
    } else if (results.length === 1) {
      result = results[0];
      if (typeof result.then === "function") {
        throw new Error(`You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
      }
    } else {
      throw new Error("More than one plugin attempted to override codegen.");
    }
    let {
      code: outputCode,
      decodedMap: outputMap = result.map
    } = result;
    if (result.__mergedMap) {
      outputMap = Object.assign({}, result.map);
    } else {
      if (outputMap) {
        if (inputMap) {
          outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName);
        } else {
          outputMap = result.map;
        }
      }
    }
    if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
      outputCode += "\n" + _convertSourceMap().fromObject(outputMap).toComment();
    }
    if (opts.sourceMaps === "inline") {
      outputMap = null;
    }
    return {
      outputCode,
      outputMap
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = generateCode;
  var _mergeMap = require_merge_map();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transformation/index.js
var require_transformation = __commonJS((exports) => {
  var _traverse = function() {
    const data = require_lib13();
    _traverse = function() {
      return data;
    };
    return data;
  };
  function* run(config2, code, ast) {
    const file = yield* (0, _normalizeFile.default)(config2.passes, (0, _normalizeOpts.default)(config2), code, ast);
    const opts = file.opts;
    try {
      yield* transformFile(file, config2.passes);
    } catch (e) {
      var _opts$filename;
      e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : "unknown file"}: ${e.message}`;
      if (!e.code) {
        e.code = "BABEL_TRANSFORM_ERROR";
      }
      throw e;
    }
    let outputCode, outputMap;
    try {
      if (opts.code !== false) {
        ({
          outputCode,
          outputMap
        } = (0, _generate.default)(config2.passes, file));
      }
    } catch (e) {
      var _opts$filename2;
      e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown file"}: ${e.message}`;
      if (!e.code) {
        e.code = "BABEL_GENERATE_ERROR";
      }
      throw e;
    }
    return {
      metadata: file.metadata,
      options: opts,
      ast: opts.ast === true ? file.ast : null,
      code: outputCode === undefined ? null : outputCode,
      map: outputMap === undefined ? null : outputMap,
      sourceType: file.ast.program.sourceType,
      externalDependencies: (0, _deepArray.flattenToSet)(config2.externalDependencies)
    };
  }
  function* transformFile(file, pluginPasses) {
    for (const pluginPairs of pluginPasses) {
      const passPairs = [];
      const passes = [];
      const visitors = [];
      for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {
        const pass = new _pluginPass.default(file, plugin.key, plugin.options);
        passPairs.push([plugin, pass]);
        passes.push(pass);
        visitors.push(plugin.visitor);
      }
      for (const [plugin, pass] of passPairs) {
        const fn = plugin.pre;
        if (fn) {
          const result = fn.call(pass, file);
          yield* [];
          if (isThenable(result)) {
            throw new Error(`You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
          }
        }
      }
      const visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
      {
        (0, _traverse().default)(file.ast, visitor, file.scope);
      }
      for (const [plugin, pass] of passPairs) {
        const fn = plugin.post;
        if (fn) {
          const result = fn.call(pass, file);
          yield* [];
          if (isThenable(result)) {
            throw new Error(`You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
          }
        }
      }
    }
  }
  var isThenable = function(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.run = run;
  var _pluginPass = require_plugin_pass();
  var _blockHoistPlugin = require_block_hoist_plugin();
  var _normalizeOpts = require_normalize_opts();
  var _normalizeFile = require_normalize_file();
  var _generate = require_generate();
  var _deepArray = require_deep_array();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transform-file.js
var require_transform_file = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var transformFile = function(...args) {
    transformFileRunner.errback(...args);
  };
  var transformFileSync = function(...args) {
    return transformFileRunner.sync(...args);
  };
  var transformFileAsync = function(...args) {
    return transformFileRunner.async(...args);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.transformFile = transformFile;
  exports.transformFileAsync = transformFileAsync;
  exports.transformFileSync = transformFileSync;
  var _index = require_config();
  var _index2 = require_transformation();
  var fs3 = require_fs();
  var transformFileRunner = _gensync()(function* (filename, opts) {
    const options = Object.assign({}, opts, {
      filename
    });
    const config2 = yield* (0, _index.default)(options);
    if (config2 === null)
      return null;
    const code = yield* fs3.readFile(filename, "utf8");
    return yield* (0, _index2.run)(config2, code);
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/import.cjs
var require_import = __commonJS((exports, module) => {
  module.exports = function import_(filepath) {
    return import(filepath);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/module-types.js
var require_module_types = __commonJS((exports) => {
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _url = function() {
    const data = __require("url");
    _url = function() {
      return data;
    };
    return data;
  };
  var _semver = function() {
    const data = require_semver();
    _semver = function() {
      return data;
    };
    return data;
  };
  var _debug = function() {
    const data = require_src();
    _debug = function() {
      return data;
    };
    return data;
  };
  var asyncGeneratorStep = function(gen, resolve6, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value2 = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve6(value2);
    } else {
      Promise.resolve(value2).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve6, reject) {
        var gen = fn.apply(self2, args);
        function _next(value2) {
          asyncGeneratorStep(gen, resolve6, reject, _next, _throw, "next", value2);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve6, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  };
  function* loadCodeDefault(filepath, asyncError) {
    switch (_path().extname(filepath)) {
      case ".cjs": {
        return loadCjsDefault(filepath, arguments[2]);
      }
      case ".mjs":
        break;
      case ".cts":
        return loadCtsDefault(filepath);
      default:
        try {
          {
            return loadCjsDefault(filepath, arguments[2]);
          }
        } catch (e) {
          if (e.code !== "ERR_REQUIRE_ESM")
            throw e;
        }
    }
    if (yield* (0, _async.isAsync)()) {
      return yield* (0, _async.waitFor)(loadMjsDefault(filepath));
    }
    throw new _configError.default(asyncError, filepath);
  }
  var loadCtsDefault = function(filepath) {
    const ext = ".cts";
    const hasTsSupport = !!(require.extensions[".ts"] || require.extensions[".cts"] || require.extensions[".mts"]);
    let handler;
    if (!hasTsSupport) {
      const opts = {
        babelrc: false,
        configFile: false,
        sourceType: "unambiguous",
        sourceMaps: "inline",
        sourceFileName: _path().basename(filepath),
        presets: [[getTSPreset(filepath), Object.assign({
          onlyRemoveTypeImports: true,
          optimizeConstEnums: true
        }, {
          allowDeclareFields: true
        })]]
      };
      handler = function(m, filename) {
        if (handler && filename.endsWith(ext)) {
          try {
            return m._compile((0, _transformFile.transformFileSync)(filename, Object.assign({}, opts, {
              filename
            })).code, filename);
          } catch (error) {
            if (!hasTsSupport) {
              const packageJson = require_package2();
              if (_semver().lt(packageJson.version, "7.21.4")) {
                console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
              }
            }
            throw error;
          }
        }
        return require.extensions[".js"](m, filename);
      };
      require.extensions[ext] = handler;
    }
    try {
      return loadCjsDefault(filepath);
    } finally {
      if (!hasTsSupport) {
        if (require.extensions[ext] === handler)
          delete require.extensions[ext];
        handler = undefined;
      }
    }
  };
  var loadCjsDefault = function(filepath) {
    if (LOADING_CJS_FILES.has(filepath)) {
      debug("Auto-ignoring usage of config %o.", filepath);
      return {};
    }
    let module2;
    try {
      LOADING_CJS_FILES.add(filepath);
      module2 = (0, _rewriteStackTrace.endHiddenCallStack)(require)(filepath);
    } finally {
      LOADING_CJS_FILES.delete(filepath);
    }
    {
      var _module;
      return (_module = module2) != null && _module.__esModule ? module2.default || (arguments[1] ? module2 : undefined) : module2;
    }
  };
  var loadMjsDefault = function(_x) {
    return _loadMjsDefault.apply(this, arguments);
  };
  var _loadMjsDefault = function() {
    _loadMjsDefault = _asyncToGenerator(function* (filepath) {
      if (!import_) {
        throw new _configError.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n", filepath);
      }
      const module2 = yield (0, _rewriteStackTrace.endHiddenCallStack)(import_)((0, _url().pathToFileURL)(filepath));
      return module2.default;
    });
    return _loadMjsDefault.apply(this, arguments);
  };
  var getTSPreset = function(filepath) {
    try {
      return require_lib31();
    } catch (error) {
      if (error.code !== "MODULE_NOT_FOUND")
        throw error;
      let message = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
      {
        if (process.versions.pnp) {
          message += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
\t"@babel/core@*":
\t\tpeerDependencies:
\t\t\t"@babel/preset-typescript": "*"
`;
        }
      }
      throw new _configError.default(message, filepath);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = loadCodeDefault;
  exports.supportsESM = undefined;
  var _async = require_async();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var _configError = require_config_error();
  var _transformFile = require_transform_file();
  var debug = _debug()("babel:config:loading:files:module-types");
  var import_;
  try {
    import_ = require_import();
  } catch (_unused) {
  }
  var supportsESM = exports.supportsESM = _semver().satisfies(process.versions.node, "^12.17 || >=13.2");
  var LOADING_CJS_FILES = new Set;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/configuration.js
var require_configuration = __commonJS((exports) => {
  var _debug = function() {
    const data = require_src();
    _debug = function() {
      return data;
    };
    return data;
  };
  var _fs = function() {
    const data = __require("fs");
    _fs = function() {
      return data;
    };
    return data;
  };
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _json = function() {
    const data = require_lib18();
    _json = function() {
      return data;
    };
    return data;
  };
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  function* readConfigCode(filepath, data) {
    if (!_fs().existsSync(filepath))
      return null;
    let options = yield* (0, _moduleTypes.default)(filepath, "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously.");
    let cacheNeedsConfiguration = false;
    if (typeof options === "function") {
      ({
        options,
        cacheNeedsConfiguration
      } = yield* runConfig(options, data));
    }
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new _configError.default(`Configuration should be an exported JavaScript object.`, filepath);
    }
    if (typeof options.then === "function") {
      options.catch == null || options.catch(() => {
      });
      throw new _configError.default(`You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.`, filepath);
    }
    if (cacheNeedsConfiguration)
      throwConfigError(filepath);
    return buildConfigFileObject(options, filepath);
  }
  var buildConfigFileObject = function(options, filepath) {
    let configFilesByFilepath = cfboaf.get(options);
    if (!configFilesByFilepath) {
      cfboaf.set(options, configFilesByFilepath = new Map);
    }
    let configFile = configFilesByFilepath.get(filepath);
    if (!configFile) {
      configFile = {
        filepath,
        dirname: _path().dirname(filepath),
        options
      };
      configFilesByFilepath.set(filepath, configFile);
    }
    return configFile;
  };
  var findConfigUpwards = function(rootDir) {
    let dirname4 = rootDir;
    for (;; ) {
      for (const filename of ROOT_CONFIG_FILENAMES) {
        if (_fs().existsSync(_path().join(dirname4, filename))) {
          return dirname4;
        }
      }
      const nextDir = _path().dirname(dirname4);
      if (dirname4 === nextDir)
        break;
      dirname4 = nextDir;
    }
    return null;
  };
  function* findRelativeConfig(packageData, envName, caller) {
    let config2 = null;
    let ignore = null;
    const dirname4 = _path().dirname(packageData.filepath);
    for (const loc of packageData.directories) {
      if (!config2) {
        var _packageData$pkg;
        config2 = yield* loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? undefined : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null);
      }
      if (!ignore) {
        const ignoreLoc = _path().join(loc, BABELIGNORE_FILENAME);
        ignore = yield* readIgnoreConfig(ignoreLoc);
        if (ignore) {
          debug("Found ignore %o from %o.", ignore.filepath, dirname4);
        }
      }
    }
    return {
      config: config2,
      ignore
    };
  }
  var findRootConfig = function(dirname4, envName, caller) {
    return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname4, envName, caller);
  };
  function* loadOneConfig(names, dirname4, envName, caller, previousConfig = null) {
    const configs = yield* _gensync().all(names.map((filename) => readConfig(_path().join(dirname4, filename), envName, caller)));
    const config2 = configs.reduce((previousConfig2, config3) => {
      if (config3 && previousConfig2) {
        throw new _configError.default(`Multiple configuration files found. Please remove one:\n` + ` - ${_path().basename(previousConfig2.filepath)}\n` + ` - ${config3.filepath}\n` + `from ${dirname4}`);
      }
      return config3 || previousConfig2;
    }, previousConfig);
    if (config2) {
      debug("Found configuration %o from %o.", config2.filepath, dirname4);
    }
    return config2;
  }
  function* loadConfig(name, dirname4, envName, caller) {
    const filepath = (((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? require.resolve : (r, {
      paths: [b]
    }, M = __require("module")) => {
      let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
      if (f)
        return f;
      f = new Error(`Cannot resolve module '${r}'`);
      f.code = "MODULE_NOT_FOUND";
      throw f;
    })(name, {
      paths: [dirname4]
    });
    const conf = yield* readConfig(filepath, envName, caller);
    if (!conf) {
      throw new _configError.default(`Config file contains no configuration data`, filepath);
    }
    debug("Loaded config %o from %o.", name, dirname4);
    return conf;
  }
  var readConfig = function(filepath, envName, caller) {
    const ext = _path().extname(filepath);
    switch (ext) {
      case ".js":
      case ".cjs":
      case ".mjs":
      case ".cts":
        return readConfigCode(filepath, {
          envName,
          caller
        });
      default:
        return readConfigJSON5(filepath);
    }
  };
  function* resolveShowConfigPath(dirname4) {
    const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;
    if (targetPath != null) {
      const absolutePath = _path().resolve(dirname4, targetPath);
      const stats = yield* fs3.stat(absolutePath);
      if (!stats.isFile()) {
        throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
      }
      return absolutePath;
    }
    return null;
  }
  var throwConfigError = function(filepath) {
    throw new _configError.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, filepath);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ROOT_CONFIG_FILENAMES = undefined;
  exports.findConfigUpwards = findConfigUpwards;
  exports.findRelativeConfig = findRelativeConfig;
  exports.findRootConfig = findRootConfig;
  exports.loadConfig = loadConfig;
  exports.resolveShowConfigPath = resolveShowConfigPath;
  var _caching = require_caching();
  var _configApi = require_config_api();
  var _utils = require_utils2();
  var _moduleTypes = require_module_types();
  var _patternToRegex = require_pattern_to_regex();
  var _configError = require_config_error();
  var fs3 = require_fs();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var debug = _debug()("babel:config:loading:files:configuration");
  var ROOT_CONFIG_FILENAMES = exports.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"];
  var RELATIVE_CONFIG_FILENAMES = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"];
  var BABELIGNORE_FILENAME = ".babelignore";
  var runConfig = (0, _caching.makeWeakCache)(function* runConfig(options, cache) {
    yield* [];
    return {
      options: (0, _rewriteStackTrace.endHiddenCallStack)(options)((0, _configApi.makeConfigAPI)(cache)),
      cacheNeedsConfiguration: !cache.configured()
    };
  });
  var cfboaf = new WeakMap;
  var packageToBabelConfig = (0, _caching.makeWeakCacheSync)((file) => {
    const babel = file.options["babel"];
    if (typeof babel === "undefined")
      return null;
    if (typeof babel !== "object" || Array.isArray(babel) || babel === null) {
      throw new _configError.default(`.babel property must be an object`, file.filepath);
    }
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: babel
    };
  });
  var readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
    let options;
    try {
      options = _json().parse(content);
    } catch (err) {
      throw new _configError.default(`Error while parsing config - ${err.message}`, filepath);
    }
    if (!options)
      throw new _configError.default(`No config detected`, filepath);
    if (typeof options !== "object") {
      throw new _configError.default(`Config returned typeof ${typeof options}`, filepath);
    }
    if (Array.isArray(options)) {
      throw new _configError.default(`Expected config object but found array`, filepath);
    }
    delete options["$schema"];
    return {
      filepath,
      dirname: _path().dirname(filepath),
      options
    };
  });
  var readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
    const ignoreDir = _path().dirname(filepath);
    const ignorePatterns = content.split("\n").map((line) => line.replace(/#(.*?)$/, "").trim()).filter((line) => !!line);
    for (const pattern of ignorePatterns) {
      if (pattern[0] === "!") {
        throw new _configError.default(`Negation of file paths is not supported.`, filepath);
      }
    }
    return {
      filepath,
      dirname: _path().dirname(filepath),
      ignore: ignorePatterns.map((pattern) => (0, _patternToRegex.default)(pattern, ignoreDir))
    };
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var require_import_meta_resolve = __commonJS((exports) => {
  var _assert = function() {
    const data = __require("assert");
    _assert = function() {
      return data;
    };
    return data;
  };
  var _fs = function() {
    const data = _interopRequireWildcard(__require("fs"), true);
    _fs = function() {
      return data;
    };
    return data;
  };
  var _process = function() {
    const data = __require("process");
    _process = function() {
      return data;
    };
    return data;
  };
  var _url = function() {
    const data = __require("url");
    _url = function() {
      return data;
    };
    return data;
  };
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _module = function() {
    const data = __require("module");
    _module = function() {
      return data;
    };
    return data;
  };
  var _v = function() {
    const data = __require("v8");
    _v = function() {
      return data;
    };
    return data;
  };
  var _util = function() {
    const data = __require("util");
    _util = function() {
      return data;
    };
    return data;
  };
  var _getRequireWildcardCache = function(e) {
    if (typeof WeakMap != "function")
      return null;
    var r = new WeakMap, t = new WeakMap;
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t : r;
    })(e);
  };
  var _interopRequireWildcard = function(e, r) {
    if (!r && e && e.__esModule)
      return e;
    if (e === null || typeof e != "object" && typeof e != "function")
      return { default: e };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e))
      return t.get(e);
    var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e)
      if (u !== "default" && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    return n.default = e, t && t.set(e, n), n;
  };
  var formatList = function(array, type = "and") {
    return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
  };
  var createError = function(sym, value2, def) {
    messages.set(sym, value2);
    return makeNodeErrorWithCode(def, sym);
  };
  var makeNodeErrorWithCode = function(Base, key) {
    return NodeError;
    function NodeError(...args) {
      const limit = Error.stackTraceLimit;
      if (isErrorStackTraceLimitWritable())
        Error.stackTraceLimit = 0;
      const error = new Base;
      if (isErrorStackTraceLimitWritable())
        Error.stackTraceLimit = limit;
      const message = getMessage(key, args, error);
      Object.defineProperties(error, {
        message: {
          value: message,
          enumerable: false,
          writable: true,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${key}]: ${this.message}`;
          },
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      captureLargerStackTrace(error);
      error.code = key;
      return error;
    }
  };
  var isErrorStackTraceLimitWritable = function() {
    try {
      if (_v().startupSnapshot.isBuildingSnapshot()) {
        return false;
      }
    } catch (_unused) {
    }
    const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
    if (desc === undefined) {
      return Object.isExtensible(Error);
    }
    return own$1.call(desc, "writable") && desc.writable !== undefined ? desc.writable : desc.set !== undefined;
  };
  var hideStackFrames = function(fn) {
    const hidden = nodeInternalPrefix + fn.name;
    Object.defineProperty(fn, "name", {
      value: hidden
    });
    return fn;
  };
  var getMessage = function(key, args, self2) {
    const message = messages.get(key);
    _assert()(message !== undefined, "expected `message` to be found");
    if (typeof message === "function") {
      _assert()(message.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${message.length}).`);
      return Reflect.apply(message, self2, args);
    }
    const regex = /%[dfijoOs]/g;
    let expectedLength = 0;
    while (regex.exec(message) !== null)
      expectedLength++;
    _assert()(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);
    if (args.length === 0)
      return message;
    args.unshift(message);
    return Reflect.apply(_util().format, null, args);
  };
  var determineSpecificType = function(value2) {
    if (value2 === null || value2 === undefined) {
      return String(value2);
    }
    if (typeof value2 === "function" && value2.name) {
      return `function ${value2.name}`;
    }
    if (typeof value2 === "object") {
      if (value2.constructor && value2.constructor.name) {
        return `an instance of ${value2.constructor.name}`;
      }
      return `${(0, _util().inspect)(value2, {
        depth: -1
      })}`;
    }
    let inspected = (0, _util().inspect)(value2, {
      colors: false
    });
    if (inspected.length > 28) {
      inspected = `${inspected.slice(0, 25)}...`;
    }
    return `type ${typeof value2} (${inspected})`;
  };
  var read = function(jsonPath, {
    base,
    specifier
  }) {
    const existing = cache.get(jsonPath);
    if (existing) {
      return existing;
    }
    let string;
    try {
      string = _fs().default.readFileSync(_path().toNamespacedPath(jsonPath), "utf8");
    } catch (error) {
      const exception = error;
      if (exception.code !== "ENOENT") {
        throw exception;
      }
    }
    const result = {
      exists: false,
      pjsonPath: jsonPath,
      main: undefined,
      name: undefined,
      type: "none",
      exports: undefined,
      imports: undefined
    };
    if (string !== undefined) {
      let parsed;
      try {
        parsed = JSON.parse(string);
      } catch (error_) {
        const cause = error_;
        const error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `"${specifier}" from ` : "") + (0, _url().fileURLToPath)(base || specifier), cause.message);
        error.cause = cause;
        throw error;
      }
      result.exists = true;
      if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") {
        result.name = parsed.name;
      }
      if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") {
        result.main = parsed.main;
      }
      if (hasOwnProperty$1.call(parsed, "exports")) {
        result.exports = parsed.exports;
      }
      if (hasOwnProperty$1.call(parsed, "imports")) {
        result.imports = parsed.imports;
      }
      if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
        result.type = parsed.type;
      }
    }
    cache.set(jsonPath, result);
    return result;
  };
  var getPackageScopeConfig = function(resolved) {
    let packageJSONUrl = new (_url()).URL("package.json", resolved);
    while (true) {
      const packageJSONPath2 = packageJSONUrl.pathname;
      if (packageJSONPath2.endsWith("node_modules/package.json")) {
        break;
      }
      const packageConfig = packageJsonReader.read((0, _url().fileURLToPath)(packageJSONUrl), {
        specifier: resolved
      });
      if (packageConfig.exists) {
        return packageConfig;
      }
      const lastPackageJSONUrl = packageJSONUrl;
      packageJSONUrl = new (_url()).URL("../package.json", packageJSONUrl);
      if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
        break;
      }
    }
    const packageJSONPath = (0, _url().fileURLToPath)(packageJSONUrl);
    return {
      pjsonPath: packageJSONPath,
      exists: false,
      main: undefined,
      name: undefined,
      type: "none",
      exports: undefined,
      imports: undefined
    };
  };
  var getPackageType = function(url) {
    const packageConfig = getPackageScopeConfig(url);
    return packageConfig.type;
  };
  var mimeToFormat = function(mime) {
    if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
      return "module";
    if (mime === "application/json")
      return "json";
    return null;
  };
  var getDataProtocolModuleFormat = function(parsed) {
    const {
      1: mime
    } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
    return mimeToFormat(mime);
  };
  var extname3 = function(url) {
    const pathname = url.pathname;
    let index = pathname.length;
    while (index--) {
      const code = pathname.codePointAt(index);
      if (code === 47) {
        return "";
      }
      if (code === 46) {
        return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
      }
    }
    return "";
  };
  var getFileProtocolModuleFormat = function(url, _context, ignoreErrors) {
    const ext = extname3(url);
    if (ext === ".js") {
      const packageType = getPackageType(url);
      if (packageType !== "none") {
        return packageType;
      }
      return "commonjs";
    }
    if (ext === "") {
      const packageType = getPackageType(url);
      if (packageType === "none" || packageType === "commonjs") {
        return "commonjs";
      }
      return "module";
    }
    const format3 = extensionFormatMap[ext];
    if (format3)
      return format3;
    if (ignoreErrors) {
      return;
    }
    const filepath = (0, _url().fileURLToPath)(url);
    throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
  };
  var getHttpProtocolModuleFormat = function() {
  };
  var defaultGetFormatWithoutErrors = function(url, context) {
    const protocol = url.protocol;
    if (!hasOwnProperty.call(protocolHandlers, protocol)) {
      return null;
    }
    return protocolHandlers[protocol](url, context, true) || null;
  };
  var getDefaultConditions = function() {
    return DEFAULT_CONDITIONS;
  };
  var getDefaultConditionsSet = function() {
    return DEFAULT_CONDITIONS_SET;
  };
  var getConditionsSet = function(conditions) {
    if (conditions !== undefined && conditions !== getDefaultConditions()) {
      if (!Array.isArray(conditions)) {
        throw new ERR_INVALID_ARG_VALUE("conditions", conditions, "expected an array");
      }
      return new Set(conditions);
    }
    return getDefaultConditionsSet();
  };
  var emitInvalidSegmentDeprecation = function(target, request, match, packageJsonUrl, internal, base, isTarget) {
    if (_process().noDeprecation) {
      return;
    }
    const pjsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
    const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
    _process().emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module ` + `request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
  };
  var emitLegacyIndexDeprecation = function(url, packageJsonUrl, base, main) {
    if (_process().noDeprecation) {
      return;
    }
    const format3 = defaultGetFormatWithoutErrors(url, {
      parentURL: base.href
    });
    if (format3 !== "module")
      return;
    const urlPath = (0, _url().fileURLToPath)(url.href);
    const pkgPath = (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl));
    const basePath = (0, _url().fileURLToPath)(base);
    if (!main) {
      _process().emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${urlPath.slice(pkgPath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
    } else if (_path().resolve(pkgPath, main) !== urlPath) {
      _process().emitWarning(`Package ${pkgPath} has a "main" field set to "${main}", ` + `excluding the full filename and extension to the resolved file at "${urlPath.slice(pkgPath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is ` + "deprecated for ES modules.", "DeprecationWarning", "DEP0151");
    }
  };
  var tryStatSync = function(path3) {
    try {
      return (0, _fs().statSync)(path3);
    } catch (_unused2) {
      return new (_fs()).Stats;
    }
  };
  var fileExists = function(url) {
    const stats = (0, _fs().statSync)(url, {
      throwIfNoEntry: false
    });
    const isFile = stats ? stats.isFile() : undefined;
    return isFile === null || isFile === undefined ? false : isFile;
  };
  var legacyMainResolve = function(packageJsonUrl, packageConfig, base) {
    let guess;
    if (packageConfig.main !== undefined) {
      guess = new (_url()).URL(packageConfig.main, packageJsonUrl);
      if (fileExists(guess))
        return guess;
      const tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
      let i2 = -1;
      while (++i2 < tries2.length) {
        guess = new (_url()).URL(tries2[i2], packageJsonUrl);
        if (fileExists(guess))
          break;
        guess = undefined;
      }
      if (guess) {
        emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
        return guess;
      }
    }
    const tries = ["./index.js", "./index.json", "./index.node"];
    let i = -1;
    while (++i < tries.length) {
      guess = new (_url()).URL(tries[i], packageJsonUrl);
      if (fileExists(guess))
        break;
      guess = undefined;
    }
    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
    throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
  };
  var finalizeResolution = function(resolved, base, preserveSymlinks) {
    if (encodedSepRegEx.exec(resolved.pathname) !== null) {
      throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base));
    }
    let filePath;
    try {
      filePath = (0, _url().fileURLToPath)(resolved);
    } catch (error) {
      const cause = error;
      Object.defineProperty(cause, "input", {
        value: String(resolved)
      });
      Object.defineProperty(cause, "module", {
        value: String(base)
      });
      throw cause;
    }
    const stats = tryStatSync(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
    if (stats.isDirectory()) {
      const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, _url().fileURLToPath)(base));
      error.url = String(resolved);
      throw error;
    }
    if (!stats.isFile()) {
      const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && (0, _url().fileURLToPath)(base), true);
      error.url = String(resolved);
      throw error;
    }
    if (!preserveSymlinks) {
      const real = (0, _fs().realpathSync)(filePath);
      const {
        search,
        hash
      } = resolved;
      resolved = (0, _url().pathToFileURL)(real + (filePath.endsWith(_path().sep) ? "/" : ""));
      resolved.search = search;
      resolved.hash = hash;
    }
    return resolved;
  };
  var importNotDefined = function(specifier, packageJsonUrl, base) {
    return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
  };
  var exportsNotFound = function(subpath, packageJsonUrl, base) {
    return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
  };
  var throwInvalidSubpath = function(request, match, packageJsonUrl, internal, base) {
    const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;
    throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && (0, _url().fileURLToPath)(base));
  };
  var invalidPackageTarget = function(subpath, target, packageJsonUrl, internal, base) {
    target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
    return new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));
  };
  var resolvePackageTargetString = function(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
    if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    if (!target.startsWith("./")) {
      if (internal && !target.startsWith("../") && !target.startsWith("/")) {
        let isURL2 = false;
        try {
          new (_url()).URL(target);
          isURL2 = true;
        } catch (_unused3) {
        }
        if (!isURL2) {
          const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target + subpath;
          return packageResolve(exportTarget, packageJsonUrl, conditions);
        }
      }
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
    if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
      if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
        if (!isPathMap) {
          const request = pattern ? match.replace("*", () => subpath) : match + subpath;
          const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
          emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, true);
        }
      } else {
        throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      }
    }
    const resolved = new (_url()).URL(target, packageJsonUrl);
    const resolvedPath = resolved.pathname;
    const packagePath = new (_url()).URL(".", packageJsonUrl).pathname;
    if (!resolvedPath.startsWith(packagePath))
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    if (subpath === "")
      return resolved;
    if (invalidSegmentRegEx.exec(subpath) !== null) {
      const request = pattern ? match.replace("*", () => subpath) : match + subpath;
      if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
        if (!isPathMap) {
          const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
          emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, false);
        }
      } else {
        throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
      }
    }
    if (pattern) {
      return new (_url()).URL(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath));
    }
    return new (_url()).URL(subpath, resolved);
  };
  var isArrayIndex = function(key) {
    const keyNumber = Number(key);
    if (`${keyNumber}` !== key)
      return false;
    return keyNumber >= 0 && keyNumber < 4294967295;
  };
  var resolvePackageTarget = function(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
    if (typeof target === "string") {
      return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
    }
    if (Array.isArray(target)) {
      const targetList = target;
      if (targetList.length === 0)
        return null;
      let lastException;
      let i = -1;
      while (++i < targetList.length) {
        const targetItem = targetList[i];
        let resolveResult;
        try {
          resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
        } catch (error) {
          const exception = error;
          lastException = exception;
          if (exception.code === "ERR_INVALID_PACKAGE_TARGET")
            continue;
          throw error;
        }
        if (resolveResult === undefined)
          continue;
        if (resolveResult === null) {
          lastException = null;
          continue;
        }
        return resolveResult;
      }
      if (lastException === undefined || lastException === null) {
        return null;
      }
      throw lastException;
    }
    if (typeof target === "object" && target !== null) {
      const keys = Object.getOwnPropertyNames(target);
      let i = -1;
      while (++i < keys.length) {
        const key = keys[i];
        if (isArrayIndex(key)) {
          throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
        }
      }
      i = -1;
      while (++i < keys.length) {
        const key = keys[i];
        if (key === "default" || conditions && conditions.has(key)) {
          const conditionalTarget = target[key];
          const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
          if (resolveResult === undefined)
            continue;
          return resolveResult;
        }
      }
      return null;
    }
    if (target === null) {
      return null;
    }
    throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
  };
  var isConditionalExportsMainSugar = function(exports2, packageJsonUrl, base) {
    if (typeof exports2 === "string" || Array.isArray(exports2))
      return true;
    if (typeof exports2 !== "object" || exports2 === null)
      return false;
    const keys = Object.getOwnPropertyNames(exports2);
    let isConditionalSugar = false;
    let i = 0;
    let j = -1;
    while (++j < keys.length) {
      const key = keys[j];
      const curIsConditionalSugar = key === "" || key[0] !== ".";
      if (i++ === 0) {
        isConditionalSugar = curIsConditionalSugar;
      } else if (isConditionalSugar !== curIsConditionalSugar) {
        throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain some keys starting with \'.\' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.');
      }
    }
    return isConditionalSugar;
  };
  var emitTrailingSlashPatternDeprecation = function(match, pjsonUrl, base) {
    if (_process().noDeprecation) {
      return;
    }
    const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
    if (emittedPackageWarnings.has(pjsonPath + "|" + match))
      return;
    emittedPackageWarnings.add(pjsonPath + "|" + match);
    _process().emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the ` + `"exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
  };
  var packageExportsResolve = function(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
    let exports2 = packageConfig.exports;
    if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base)) {
      exports2 = {
        ".": exports2
      };
    }
    if (own.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
      const target = exports2[packageSubpath];
      const resolveResult = resolvePackageTarget(packageJsonUrl, target, "", packageSubpath, base, false, false, false, conditions);
      if (resolveResult === null || resolveResult === undefined) {
        throw exportsNotFound(packageSubpath, packageJsonUrl, base);
      }
      return resolveResult;
    }
    let bestMatch = "";
    let bestMatchSubpath = "";
    const keys = Object.getOwnPropertyNames(exports2);
    let i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      const patternIndex = key.indexOf("*");
      if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
        if (packageSubpath.endsWith("/")) {
          emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
        }
        const patternTrailer = key.slice(patternIndex + 1);
        if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
          bestMatch = key;
          bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
        }
      }
    }
    if (bestMatch) {
      const target = exports2[bestMatch];
      const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
      if (resolveResult === null || resolveResult === undefined) {
        throw exportsNotFound(packageSubpath, packageJsonUrl, base);
      }
      return resolveResult;
    }
    throw exportsNotFound(packageSubpath, packageJsonUrl, base);
  };
  var patternKeyCompare = function(a, b) {
    const aPatternIndex = a.indexOf("*");
    const bPatternIndex = b.indexOf("*");
    const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
    const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
    if (baseLengthA > baseLengthB)
      return -1;
    if (baseLengthB > baseLengthA)
      return 1;
    if (aPatternIndex === -1)
      return 1;
    if (bPatternIndex === -1)
      return -1;
    if (a.length > b.length)
      return -1;
    if (b.length > a.length)
      return 1;
    return 0;
  };
  var packageImportsResolve = function(name, base, conditions) {
    if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
      const reason = "is not a valid internal imports specifier name";
      throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));
    }
    let packageJsonUrl;
    const packageConfig = getPackageScopeConfig(base);
    if (packageConfig.exists) {
      packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
      const imports = packageConfig.imports;
      if (imports) {
        if (own.call(imports, name) && !name.includes("*")) {
          const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
          if (resolveResult !== null && resolveResult !== undefined) {
            return resolveResult;
          }
        } else {
          let bestMatch = "";
          let bestMatchSubpath = "";
          const keys = Object.getOwnPropertyNames(imports);
          let i = -1;
          while (++i < keys.length) {
            const key = keys[i];
            const patternIndex = key.indexOf("*");
            if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
              const patternTrailer = key.slice(patternIndex + 1);
              if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                bestMatch = key;
                bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
              }
            }
          }
          if (bestMatch) {
            const target = imports[bestMatch];
            const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
            if (resolveResult !== null && resolveResult !== undefined) {
              return resolveResult;
            }
          }
        }
      }
    }
    throw importNotDefined(name, packageJsonUrl, base);
  };
  var parsePackageName = function(specifier, base) {
    let separatorIndex = specifier.indexOf("/");
    let validPackageName = true;
    let isScoped = false;
    if (specifier[0] === "@") {
      isScoped = true;
      if (separatorIndex === -1 || specifier.length === 0) {
        validPackageName = false;
      } else {
        separatorIndex = specifier.indexOf("/", separatorIndex + 1);
      }
    }
    const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
    if (invalidPackageNameRegEx.exec(packageName) !== null) {
      validPackageName = false;
    }
    if (!validPackageName) {
      throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", (0, _url().fileURLToPath)(base));
    }
    const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
    return {
      packageName,
      packageSubpath,
      isScoped
    };
  };
  var packageResolve = function(specifier, base, conditions) {
    if (_module().builtinModules.includes(specifier)) {
      return new (_url()).URL("node:" + specifier);
    }
    const {
      packageName,
      packageSubpath,
      isScoped
    } = parsePackageName(specifier, base);
    const packageConfig = getPackageScopeConfig(base);
    if (packageConfig.exists) {
      const packageJsonUrl2 = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
      if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
        return packageExportsResolve(packageJsonUrl2, packageSubpath, packageConfig, base, conditions);
      }
    }
    let packageJsonUrl = new (_url()).URL("./node_modules/" + packageName + "/package.json", base);
    let packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
    let lastPath;
    do {
      const stat = tryStatSync(packageJsonPath.slice(0, -13));
      if (!stat.isDirectory()) {
        lastPath = packageJsonPath;
        packageJsonUrl = new (_url()).URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl);
        packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
        continue;
      }
      const packageConfig2 = packageJsonReader.read(packageJsonPath, {
        base,
        specifier
      });
      if (packageConfig2.exports !== undefined && packageConfig2.exports !== null) {
        return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig2, base, conditions);
      }
      if (packageSubpath === ".") {
        return legacyMainResolve(packageJsonUrl, packageConfig2, base);
      }
      return new (_url()).URL(packageSubpath, packageJsonUrl);
    } while (packageJsonPath.length !== lastPath.length);
    throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base), false);
  };
  var isRelativeSpecifier = function(specifier) {
    if (specifier[0] === ".") {
      if (specifier.length === 1 || specifier[1] === "/")
        return true;
      if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
        return true;
      }
    }
    return false;
  };
  var shouldBeTreatedAsRelativeOrAbsolutePath = function(specifier) {
    if (specifier === "")
      return false;
    if (specifier[0] === "/")
      return true;
    return isRelativeSpecifier(specifier);
  };
  var moduleResolve = function(specifier, base, conditions, preserveSymlinks) {
    const protocol = base.protocol;
    const isRemote = protocol === "http:" || protocol === "https:";
    let resolved;
    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
      resolved = new (_url()).URL(specifier, base);
    } else if (!isRemote && specifier[0] === "#") {
      resolved = packageImportsResolve(specifier, base, conditions);
    } else {
      try {
        resolved = new (_url()).URL(specifier);
      } catch (_unused4) {
        if (!isRemote) {
          resolved = packageResolve(specifier, base, conditions);
        }
      }
    }
    _assert()(resolved !== undefined, "expected to be defined");
    if (resolved.protocol !== "file:") {
      return resolved;
    }
    return finalizeResolution(resolved, base, preserveSymlinks);
  };
  var checkIfDisallowedImport = function(specifier, parsed, parsedParentURL) {
    if (parsedParentURL) {
      const parentProtocol = parsedParentURL.protocol;
      if (parentProtocol === "http:" || parentProtocol === "https:") {
        if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
          const parsedProtocol = parsed == null ? undefined : parsed.protocol;
          if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:") {
            throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
          }
          return {
            url: (parsed == null ? undefined : parsed.href) || ""
          };
        }
        if (_module().builtinModules.includes(specifier)) {
          throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
        }
        throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "only relative and absolute specifiers are supported.");
      }
    }
  };
  var isURL = function(self2) {
    return Boolean(self2 && typeof self2 === "object" && "href" in self2 && typeof self2.href === "string" && "protocol" in self2 && typeof self2.protocol === "string" && self2.href && self2.protocol);
  };
  var throwIfInvalidParentURL = function(parentURL) {
    if (parentURL === undefined) {
      return;
    }
    if (typeof parentURL !== "string" && !isURL(parentURL)) {
      throw new codes.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], parentURL);
    }
  };
  var defaultResolve = function(specifier, context = {}) {
    const {
      parentURL
    } = context;
    _assert()(parentURL !== undefined, "expected `parentURL` to be defined");
    throwIfInvalidParentURL(parentURL);
    let parsedParentURL;
    if (parentURL) {
      try {
        parsedParentURL = new (_url()).URL(parentURL);
      } catch (_unused5) {
      }
    }
    let parsed;
    try {
      parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new (_url()).URL(specifier, parsedParentURL) : new (_url()).URL(specifier);
      const protocol = parsed.protocol;
      if (protocol === "data:") {
        return {
          url: parsed.href,
          format: null
        };
      }
    } catch (_unused6) {
    }
    const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
    if (maybeReturn)
      return maybeReturn;
    if (parsed && parsed.protocol === "node:")
      return {
        url: specifier
      };
    const conditions = getConditionsSet(context.conditions);
    const url = moduleResolve(specifier, new (_url()).URL(parentURL), conditions, false);
    return {
      url: url.href,
      format: defaultGetFormatWithoutErrors(url, {
        parentURL
      })
    };
  };
  var resolve6 = function(specifier, parent) {
    if (!parent) {
      throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
    }
    try {
      return defaultResolve(specifier, {
        parentURL: parent
      }).url;
    } catch (error) {
      const exception = error;
      if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url === "string") {
        return exception.url;
      }
      throw error;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.moduleResolve = moduleResolve;
  exports.resolve = resolve6;
  var own$1 = {}.hasOwnProperty;
  var classRegExp = /^([A-Z][a-z\d]*)+$/;
  var kTypes = new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]);
  var codes = {};
  var messages = new Map;
  var nodeInternalPrefix = "__node_internal_";
  var userStackTraceLimit;
  codes.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
    _assert()(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value2 of expected) {
      _assert()(typeof value2 === "string", "All expected entries have to be of type string");
      if (kTypes.has(value2)) {
        types.push(value2.toLowerCase());
      } else if (classRegExp.exec(value2) === null) {
        _assert()(value2 !== "object", 'The value "object" should be written as "Object"');
        other.push(value2);
      } else {
        instances.push(value2);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(types, "or")}`;
      if (instances.length > 0 || other.length > 0)
        message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0)
        message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0].toLowerCase() !== other[0])
          message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  }, TypeError);
  codes.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base = undefined) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  }, TypeError);
  codes.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (path3, base, message) => {
    return `Invalid package config ${path3}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  }, Error);
  codes.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (pkgPath, key, target, isImport = false, base = undefined) => {
    const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      _assert()(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined ` + `in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
  }, Error);
  codes.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (path3, base, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path3}' imported from ${base}`;
  }, Error);
  codes.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
  codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
  }, TypeError);
  codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (pkgPath, subpath, base = undefined) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  }, Error);
  codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
  codes.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (ext, path3) => {
    return `Unknown file extension "${ext}" for ${path3}`;
  }, TypeError);
  codes.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (name, value2, reason = "is invalid") => {
    let inspected = (0, _util().inspect)(value2);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  }, TypeError);
  var captureLargerStackTrace = hideStackFrames(function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error);
    if (stackTraceLimitIsWritable)
      Error.stackTraceLimit = userStackTraceLimit;
    return error;
  });
  var hasOwnProperty$1 = {}.hasOwnProperty;
  var {
    ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1
  } = codes;
  var cache = new Map;
  var reader = {
    read
  };
  var packageJsonReader = reader;
  var {
    ERR_UNKNOWN_FILE_EXTENSION
  } = codes;
  var hasOwnProperty = {}.hasOwnProperty;
  var extensionFormatMap = {
    __proto__: null,
    ".cjs": "commonjs",
    ".js": "module",
    ".json": "json",
    ".mjs": "module"
  };
  var protocolHandlers = {
    __proto__: null,
    "data:": getDataProtocolModuleFormat,
    "file:": getFileProtocolModuleFormat,
    "http:": getHttpProtocolModuleFormat,
    "https:": getHttpProtocolModuleFormat,
    "node:"() {
      return "builtin";
    }
  };
  var {
    ERR_INVALID_ARG_VALUE
  } = codes;
  var DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
  var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
  var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
  var {
    ERR_NETWORK_IMPORT_DISALLOWED,
    ERR_INVALID_MODULE_SPECIFIER,
    ERR_INVALID_PACKAGE_CONFIG,
    ERR_INVALID_PACKAGE_TARGET,
    ERR_MODULE_NOT_FOUND,
    ERR_PACKAGE_IMPORT_NOT_DEFINED,
    ERR_PACKAGE_PATH_NOT_EXPORTED,
    ERR_UNSUPPORTED_DIR_IMPORT
  } = codes;
  var own = {}.hasOwnProperty;
  var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
  var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
  var invalidPackageNameRegEx = /^\.|%|\\/;
  var patternRegEx = /\*/g;
  var encodedSepRegEx = /%2f|%5c/i;
  var emittedPackageWarnings = new Set;
  var doubleSlashRegEx = /[/\\]{2}/;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/plugins.js
var require_plugins3 = __commonJS((exports) => {
  var _debug = function() {
    const data = require_src();
    _debug = function() {
      return data;
    };
    return data;
  };
  var _path = function() {
    const data = __require("path");
    _path = function() {
      return data;
    };
    return data;
  };
  var _url = function() {
    const data = __require("url");
    _url = function() {
      return data;
    };
    return data;
  };
  var _fs = function() {
    const data = __require("fs");
    _fs = function() {
      return data;
    };
    return data;
  };
  function* loadPlugin(name, dirname4) {
    const filepath = resolvePlugin(name, dirname4, yield* (0, _async.isAsync)());
    const value2 = yield* requireModule("plugin", filepath);
    debug("Loaded plugin %o from %o.", name, dirname4);
    return {
      filepath,
      value: value2
    };
  }
  function* loadPreset(name, dirname4) {
    const filepath = resolvePreset(name, dirname4, yield* (0, _async.isAsync)());
    const value2 = yield* requireModule("preset", filepath);
    debug("Loaded preset %o from %o.", name, dirname4);
    return {
      filepath,
      value: value2
    };
  }
  var standardizeName = function(type, name) {
    if (_path().isAbsolute(name))
      return name;
    const isPreset = type === "preset";
    return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `\$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `\$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `\$1/babel-${type}`).replace(EXACT_RE, "");
  };
  function* resolveAlternativesHelper(type, name) {
    const standardizedName = standardizeName(type, name);
    const {
      error,
      value: value2
    } = yield standardizedName;
    if (!error)
      return value2;
    if (error.code !== "MODULE_NOT_FOUND")
      throw error;
    if (standardizedName !== name && !(yield name).error) {
      error.message += `\n- If you want to resolve "${name}", use "module:${name}"`;
    }
    if (!(yield standardizeName(type, "@babel/" + name)).error) {
      error.message += `\n- Did you mean "@babel/${name}"?`;
    }
    const oppositeType = type === "preset" ? "plugin" : "preset";
    if (!(yield standardizeName(oppositeType, name)).error) {
      error.message += `\n- Did you accidentally pass a ${oppositeType} as a ${type}?`;
    }
    if (type === "plugin") {
      const transformName = standardizedName.replace("-proposal-", "-transform-");
      if (transformName !== standardizedName && !(yield transformName).error) {
        error.message += `\n- Did you mean "${transformName}"?`;
      }
    }
    error.message += `\n
Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`;
    throw error;
  }
  var tryRequireResolve = function(id, dirname4) {
    try {
      if (dirname4) {
        return {
          error: null,
          value: (((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? require.resolve : (r, {
            paths: [b]
          }, M = __require("module")) => {
            let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
            if (f)
              return f;
            f = new Error(`Cannot resolve module '${r}'`);
            f.code = "MODULE_NOT_FOUND";
            throw f;
          })(id, {
            paths: [dirname4]
          })
        };
      } else {
        return {
          error: null,
          value: require.resolve(id)
        };
      }
    } catch (error) {
      return {
        error,
        value: null
      };
    }
  };
  var tryImportMetaResolve = function(id, options) {
    try {
      return {
        error: null,
        value: (0, _importMetaResolve.resolve)(id, options)
      };
    } catch (error) {
      return {
        error,
        value: null
      };
    }
  };
  var resolveStandardizedNameForRequire = function(type, name, dirname4) {
    const it = resolveAlternativesHelper(type, name);
    let res = it.next();
    while (!res.done) {
      res = it.next(tryRequireResolve(res.value, dirname4));
    }
    return res.value;
  };
  var resolveStandardizedNameForImport = function(type, name, dirname4) {
    const parentUrl = (0, _url().pathToFileURL)(_path().join(dirname4, "./babel-virtual-resolve-base.js")).href;
    const it = resolveAlternativesHelper(type, name);
    let res = it.next();
    while (!res.done) {
      res = it.next(tryImportMetaResolve(res.value, parentUrl));
    }
    return (0, _url().fileURLToPath)(res.value);
  };
  var resolveStandardizedName = function(type, name, dirname4, resolveESM) {
    if (!_moduleTypes.supportsESM || !resolveESM) {
      return resolveStandardizedNameForRequire(type, name, dirname4);
    }
    try {
      const resolved = resolveStandardizedNameForImport(type, name, dirname4);
      if (!(0, _fs().existsSync)(resolved)) {
        throw Object.assign(new Error(`Could not resolve "${name}" in file ${dirname4}.`), {
          type: "MODULE_NOT_FOUND"
        });
      }
      return resolved;
    } catch (e) {
      try {
        return resolveStandardizedNameForRequire(type, name, dirname4);
      } catch (e2) {
        if (e.type === "MODULE_NOT_FOUND")
          throw e;
        if (e2.type === "MODULE_NOT_FOUND")
          throw e2;
        throw e;
      }
    }
  };
  function* requireModule(type, name) {
    {
      if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name)) {
        throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored ` + 'and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.');
      }
    }
    try {
      {
        LOADING_MODULES.add(name);
      }
      {
        return yield* (0, _moduleTypes.default)(name, `You appear to be using a native ECMAScript module ${type}, ` + "which is only supported when running Babel asynchronously.", true);
      }
    } catch (err) {
      err.message = `[BABEL]: ${err.message} (While processing: ${name})`;
      throw err;
    } finally {
      {
        LOADING_MODULES.delete(name);
      }
    }
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.loadPlugin = loadPlugin;
  exports.loadPreset = loadPreset;
  exports.resolvePreset = exports.resolvePlugin = undefined;
  var _async = require_async();
  var _moduleTypes = require_module_types();
  var _importMetaResolve = require_import_meta_resolve();
  var debug = _debug()("babel:config:loading:files:plugins");
  var EXACT_RE = /^module:/;
  var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
  var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
  var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
  var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
  var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
  var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
  var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;
  var resolvePlugin = exports.resolvePlugin = resolveStandardizedName.bind(null, "plugin");
  var resolvePreset = exports.resolvePreset = resolveStandardizedName.bind(null, "preset");
  {
    LOADING_MODULES = new Set;
  }
  var LOADING_MODULES;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/config/files/index.js
var require_files = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ROOT_CONFIG_FILENAMES", {
    enumerable: true,
    get: function() {
      return _configuration.ROOT_CONFIG_FILENAMES;
    }
  });
  Object.defineProperty(exports, "findConfigUpwards", {
    enumerable: true,
    get: function() {
      return _configuration.findConfigUpwards;
    }
  });
  Object.defineProperty(exports, "findPackageData", {
    enumerable: true,
    get: function() {
      return _package.findPackageData;
    }
  });
  Object.defineProperty(exports, "findRelativeConfig", {
    enumerable: true,
    get: function() {
      return _configuration.findRelativeConfig;
    }
  });
  Object.defineProperty(exports, "findRootConfig", {
    enumerable: true,
    get: function() {
      return _configuration.findRootConfig;
    }
  });
  Object.defineProperty(exports, "loadConfig", {
    enumerable: true,
    get: function() {
      return _configuration.loadConfig;
    }
  });
  Object.defineProperty(exports, "loadPlugin", {
    enumerable: true,
    get: function() {
      return _plugins.loadPlugin;
    }
  });
  Object.defineProperty(exports, "loadPreset", {
    enumerable: true,
    get: function() {
      return _plugins.loadPreset;
    }
  });
  Object.defineProperty(exports, "resolvePlugin", {
    enumerable: true,
    get: function() {
      return _plugins.resolvePlugin;
    }
  });
  Object.defineProperty(exports, "resolvePreset", {
    enumerable: true,
    get: function() {
      return _plugins.resolvePreset;
    }
  });
  Object.defineProperty(exports, "resolveShowConfigPath", {
    enumerable: true,
    get: function() {
      return _configuration.resolveShowConfigPath;
    }
  });
  var _package = require_package();
  var _configuration = require_configuration();
  var _plugins = require_plugins3();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transform.js
var require_transform = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var transformSync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(...args);
  };
  var transformAsync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.async)(...args);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.transform = undefined;
  exports.transformAsync = transformAsync;
  exports.transformSync = transformSync;
  var _index = require_config();
  var _index2 = require_transformation();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var transformRunner = _gensync()(function* transform(code, opts) {
    const config2 = yield* (0, _index.default)(opts);
    if (config2 === null)
      return null;
    return yield* (0, _index2.run)(config2, code);
  });
  var transform = exports.transform = function transform(code, optsOrCallback, maybeCallback) {
    let opts;
    let callback;
    if (typeof optsOrCallback === "function") {
      callback = optsOrCallback;
      opts = undefined;
    } else {
      opts = optsOrCallback;
      callback = maybeCallback;
    }
    if (callback === undefined) {
      {
        return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(code, opts);
      }
    }
    (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.errback)(code, opts, callback);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/transform-ast.js
var require_transform_ast = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var transformFromAstSync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(...args);
  };
  var transformFromAstAsync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.async)(...args);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.transformFromAst = undefined;
  exports.transformFromAstAsync = transformFromAstAsync;
  exports.transformFromAstSync = transformFromAstSync;
  var _index = require_config();
  var _index2 = require_transformation();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var transformFromAstRunner = _gensync()(function* (ast, code, opts) {
    const config2 = yield* (0, _index.default)(opts);
    if (config2 === null)
      return null;
    if (!ast)
      throw new Error("No AST given");
    return yield* (0, _index2.run)(config2, code, ast);
  });
  var transformFromAst = exports.transformFromAst = function transformFromAst(ast, code, optsOrCallback, maybeCallback) {
    let opts;
    let callback;
    if (typeof optsOrCallback === "function") {
      callback = optsOrCallback;
      opts = undefined;
    } else {
      opts = optsOrCallback;
      callback = maybeCallback;
    }
    if (callback === undefined) {
      {
        return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(ast, code, opts);
      }
    }
    (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.errback)(ast, code, opts, callback);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/parse.js
var require_parse5 = __commonJS((exports) => {
  var _gensync = function() {
    const data = require_gensync();
    _gensync = function() {
      return data;
    };
    return data;
  };
  var parseSync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(...args);
  };
  var parseAsync = function(...args) {
    return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.async)(...args);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parse = undefined;
  exports.parseAsync = parseAsync;
  exports.parseSync = parseSync;
  var _index = require_config();
  var _index2 = require_parser3();
  var _normalizeOpts = require_normalize_opts();
  var _rewriteStackTrace = require_rewrite_stack_trace();
  var parseRunner = _gensync()(function* parse(code, opts) {
    const config2 = yield* (0, _index.default)(opts);
    if (config2 === null) {
      return null;
    }
    return yield* (0, _index2.default)(config2.passes, (0, _normalizeOpts.default)(config2), code);
  });
  var parse2 = exports.parse = function parse(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }
    if (callback === undefined) {
      {
        return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(code, opts);
      }
    }
    (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.errback)(code, opts, callback);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@babel/core/lib/index.js
var require_lib33 = __commonJS((exports) => {
  var _types = function() {
    const data = require_lib3();
    _types = function() {
      return data;
    };
    return data;
  };
  var _parser = function() {
    const data = require_lib4();
    _parser = function() {
      return data;
    };
    return data;
  };
  var _traverse = function() {
    const data = require_lib13();
    _traverse = function() {
      return data;
    };
    return data;
  };
  var _template = function() {
    const data = require_lib11();
    _template = function() {
      return data;
    };
    return data;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_EXTENSIONS = undefined;
  Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
      return _file.default;
    }
  });
  Object.defineProperty(exports, "buildExternalHelpers", {
    enumerable: true,
    get: function() {
      return _buildExternalHelpers.default;
    }
  });
  Object.defineProperty(exports, "createConfigItem", {
    enumerable: true,
    get: function() {
      return _index2.createConfigItem;
    }
  });
  Object.defineProperty(exports, "createConfigItemAsync", {
    enumerable: true,
    get: function() {
      return _index2.createConfigItemAsync;
    }
  });
  Object.defineProperty(exports, "createConfigItemSync", {
    enumerable: true,
    get: function() {
      return _index2.createConfigItemSync;
    }
  });
  Object.defineProperty(exports, "getEnv", {
    enumerable: true,
    get: function() {
      return _environment.getEnv;
    }
  });
  Object.defineProperty(exports, "loadOptions", {
    enumerable: true,
    get: function() {
      return _index2.loadOptions;
    }
  });
  Object.defineProperty(exports, "loadOptionsAsync", {
    enumerable: true,
    get: function() {
      return _index2.loadOptionsAsync;
    }
  });
  Object.defineProperty(exports, "loadOptionsSync", {
    enumerable: true,
    get: function() {
      return _index2.loadOptionsSync;
    }
  });
  Object.defineProperty(exports, "loadPartialConfig", {
    enumerable: true,
    get: function() {
      return _index2.loadPartialConfig;
    }
  });
  Object.defineProperty(exports, "loadPartialConfigAsync", {
    enumerable: true,
    get: function() {
      return _index2.loadPartialConfigAsync;
    }
  });
  Object.defineProperty(exports, "loadPartialConfigSync", {
    enumerable: true,
    get: function() {
      return _index2.loadPartialConfigSync;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.parse;
    }
  });
  Object.defineProperty(exports, "parseAsync", {
    enumerable: true,
    get: function() {
      return _parse.parseAsync;
    }
  });
  Object.defineProperty(exports, "parseSync", {
    enumerable: true,
    get: function() {
      return _parse.parseSync;
    }
  });
  Object.defineProperty(exports, "resolvePlugin", {
    enumerable: true,
    get: function() {
      return _index.resolvePlugin;
    }
  });
  Object.defineProperty(exports, "resolvePreset", {
    enumerable: true,
    get: function() {
      return _index.resolvePreset;
    }
  });
  Object.defineProperty((0, exports), "template", {
    enumerable: true,
    get: function() {
      return _template().default;
    }
  });
  Object.defineProperty((0, exports), "tokTypes", {
    enumerable: true,
    get: function() {
      return _parser().tokTypes;
    }
  });
  Object.defineProperty(exports, "transform", {
    enumerable: true,
    get: function() {
      return _transform.transform;
    }
  });
  Object.defineProperty(exports, "transformAsync", {
    enumerable: true,
    get: function() {
      return _transform.transformAsync;
    }
  });
  Object.defineProperty(exports, "transformFile", {
    enumerable: true,
    get: function() {
      return _transformFile.transformFile;
    }
  });
  Object.defineProperty(exports, "transformFileAsync", {
    enumerable: true,
    get: function() {
      return _transformFile.transformFileAsync;
    }
  });
  Object.defineProperty(exports, "transformFileSync", {
    enumerable: true,
    get: function() {
      return _transformFile.transformFileSync;
    }
  });
  Object.defineProperty(exports, "transformFromAst", {
    enumerable: true,
    get: function() {
      return _transformAst.transformFromAst;
    }
  });
  Object.defineProperty(exports, "transformFromAstAsync", {
    enumerable: true,
    get: function() {
      return _transformAst.transformFromAstAsync;
    }
  });
  Object.defineProperty(exports, "transformFromAstSync", {
    enumerable: true,
    get: function() {
      return _transformAst.transformFromAstSync;
    }
  });
  Object.defineProperty(exports, "transformSync", {
    enumerable: true,
    get: function() {
      return _transform.transformSync;
    }
  });
  Object.defineProperty((0, exports), "traverse", {
    enumerable: true,
    get: function() {
      return _traverse().default;
    }
  });
  exports.version = exports.types = undefined;
  var _file = require_file();
  var _buildExternalHelpers = require_build_external_helpers();
  var _index = require_files();
  var _environment = require_environment();
  Object.defineProperty((0, exports), "types", {
    enumerable: true,
    get: function() {
      return _types();
    }
  });
  var _index2 = require_config();
  var _transform = require_transform();
  var _transformFile = require_transform_file();
  var _transformAst = require_transform_ast();
  var _parse = require_parse5();
  var thisFile = require_lib33();
  var version2 = exports.version = "7.23.7";
  var DEFAULT_EXTENSIONS = exports.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  {
    exports.OptionManager = class OptionManager {
      init(opts) {
        return (0, _index2.loadOptionsSync)(opts);
      }
    };
    exports.Plugin = function Plugin(alias) {
      throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);
    };
  }
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cli-table3/src/debug.js
var require_debug2 = __commonJS((exports, module) => {
  var messages = [];
  var level = 0;
  var debug = (msg, min) => {
    if (level >= min) {
      messages.push(msg);
    }
  };
  debug.WARN = 1;
  debug.INFO = 2;
  debug.DEBUG = 3;
  debug.reset = () => {
    messages = [];
  };
  debug.setDebugLevel = (v) => {
    level = v;
  };
  debug.warn = (msg) => debug(msg, debug.WARN);
  debug.info = (msg) => debug(msg, debug.INFO);
  debug.debug = (msg) => debug(msg, debug.DEBUG);
  debug.debugMessages = () => messages;
  module.exports = debug;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi2 = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex2 = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi2(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex2(), "  ");
    let width = 0;
    for (let i = 0;i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cli-table3/src/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var codeRegex = function(capture) {
    return capture ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
  };
  var strlen = function(str) {
    let code = codeRegex();
    let stripped = ("" + str).replace(code, "");
    let split = stripped.split("\n");
    return split.reduce(function(memo, s) {
      return stringWidth(s) > memo ? stringWidth(s) : memo;
    }, 0);
  };
  var repeat = function(str, times) {
    return Array(times + 1).join(str);
  };
  var pad = function(str, len, pad2, dir) {
    let length = strlen(str);
    if (len + 1 >= length) {
      let padlen = len - length;
      switch (dir) {
        case "right": {
          str = repeat(pad2, padlen) + str;
          break;
        }
        case "center": {
          let right2 = Math.ceil(padlen / 2);
          let left2 = padlen - right2;
          str = repeat(pad2, left2) + str + repeat(pad2, right2);
          break;
        }
        default: {
          str = str + repeat(pad2, padlen);
          break;
        }
      }
    }
    return str;
  };
  var addToCodeCache = function(name, on, off) {
    on = "\x1B[" + on + "m";
    off = "\x1B[" + off + "m";
    codeCache[on] = { set: name, to: true };
    codeCache[off] = { set: name, to: false };
    codeCache[name] = { on, off };
  };
  var updateState = function(state, controlChars) {
    let controlCode = controlChars[1] ? parseInt(controlChars[1].split(";")[0]) : 0;
    if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) {
      state.lastForegroundAdded = controlChars[0];
      return;
    }
    if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) {
      state.lastBackgroundAdded = controlChars[0];
      return;
    }
    if (controlCode === 0) {
      for (let i in state) {
        if (Object.prototype.hasOwnProperty.call(state, i)) {
          delete state[i];
        }
      }
      return;
    }
    let info = codeCache[controlChars[0]];
    if (info) {
      state[info.set] = info.to;
    }
  };
  var readState = function(line) {
    let code = codeRegex(true);
    let controlChars = code.exec(line);
    let state = {};
    while (controlChars !== null) {
      updateState(state, controlChars);
      controlChars = code.exec(line);
    }
    return state;
  };
  var unwindState = function(state, ret) {
    let lastBackgroundAdded = state.lastBackgroundAdded;
    let lastForegroundAdded = state.lastForegroundAdded;
    delete state.lastBackgroundAdded;
    delete state.lastForegroundAdded;
    Object.keys(state).forEach(function(key) {
      if (state[key]) {
        ret += codeCache[key].off;
      }
    });
    if (lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") {
      ret += "\x1B[49m";
    }
    if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") {
      ret += "\x1B[39m";
    }
    return ret;
  };
  var rewindState = function(state, ret) {
    let lastBackgroundAdded = state.lastBackgroundAdded;
    let lastForegroundAdded = state.lastForegroundAdded;
    delete state.lastBackgroundAdded;
    delete state.lastForegroundAdded;
    Object.keys(state).forEach(function(key) {
      if (state[key]) {
        ret = codeCache[key].on + ret;
      }
    });
    if (lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") {
      ret = lastBackgroundAdded + ret;
    }
    if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") {
      ret = lastForegroundAdded + ret;
    }
    return ret;
  };
  var truncateWidth = function(str, desiredLength) {
    if (str.length === strlen(str)) {
      return str.substr(0, desiredLength);
    }
    while (strlen(str) > desiredLength) {
      str = str.slice(0, -1);
    }
    return str;
  };
  var truncateWidthWithAnsi = function(str, desiredLength) {
    let code = codeRegex(true);
    let split = str.split(codeRegex());
    let splitIndex = 0;
    let retLen = 0;
    let ret = "";
    let myArray;
    let state = {};
    while (retLen < desiredLength) {
      myArray = code.exec(str);
      let toAdd = split[splitIndex];
      splitIndex++;
      if (retLen + strlen(toAdd) > desiredLength) {
        toAdd = truncateWidth(toAdd, desiredLength - retLen);
      }
      ret += toAdd;
      retLen += strlen(toAdd);
      if (retLen < desiredLength) {
        if (!myArray) {
          break;
        }
        ret += myArray[0];
        updateState(state, myArray);
      }
    }
    return unwindState(state, ret);
  };
  var truncate = function(str, desiredLength, truncateChar) {
    truncateChar = truncateChar || "\u2026";
    let lengthOfStr = strlen(str);
    if (lengthOfStr <= desiredLength) {
      return str;
    }
    desiredLength -= strlen(truncateChar);
    let ret = truncateWidthWithAnsi(str, desiredLength);
    return ret + truncateChar;
  };
  var defaultOptions = function() {
    return {
      chars: {
        top: "\u2500",
        "top-mid": "\u252C",
        "top-left": "\u250C",
        "top-right": "\u2510",
        bottom: "\u2500",
        "bottom-mid": "\u2534",
        "bottom-left": "\u2514",
        "bottom-right": "\u2518",
        left: "\u2502",
        "left-mid": "\u251C",
        mid: "\u2500",
        "mid-mid": "\u253C",
        right: "\u2502",
        "right-mid": "\u2524",
        middle: "\u2502"
      },
      truncate: "\u2026",
      colWidths: [],
      rowHeights: [],
      colAligns: [],
      rowAligns: [],
      style: {
        "padding-left": 1,
        "padding-right": 1,
        head: ["red"],
        border: ["grey"],
        compact: false
      },
      head: []
    };
  };
  var mergeOptions = function(options2, defaults) {
    options2 = options2 || {};
    defaults = defaults || defaultOptions();
    let ret = Object.assign({}, defaults, options2);
    ret.chars = Object.assign({}, defaults.chars, options2.chars);
    ret.style = Object.assign({}, defaults.style, options2.style);
    return ret;
  };
  var wordWrap = function(maxLength, input) {
    let lines = [];
    let split = input.split(/(\s+)/g);
    let line = [];
    let lineLength = 0;
    let whitespace;
    for (let i = 0;i < split.length; i += 2) {
      let word = split[i];
      let newLength = lineLength + strlen(word);
      if (lineLength > 0 && whitespace) {
        newLength += whitespace.length;
      }
      if (newLength > maxLength) {
        if (lineLength !== 0) {
          lines.push(line.join(""));
        }
        line = [word];
        lineLength = strlen(word);
      } else {
        line.push(whitespace || "", word);
        lineLength = newLength;
      }
      whitespace = split[i + 1];
    }
    if (lineLength) {
      lines.push(line.join(""));
    }
    return lines;
  };
  var textWrap = function(maxLength, input) {
    let lines = [];
    let line = "";
    function pushLine(str, ws) {
      if (line.length && ws)
        line += ws;
      line += str;
      while (line.length > maxLength) {
        lines.push(line.slice(0, maxLength));
        line = line.slice(maxLength);
      }
    }
    let split = input.split(/(\s+)/g);
    for (let i = 0;i < split.length; i += 2) {
      pushLine(split[i], i && split[i - 1]);
    }
    if (line.length)
      lines.push(line);
    return lines;
  };
  var multiLineWordWrap = function(maxLength, input, wrapOnWordBoundary = true) {
    let output = [];
    input = input.split("\n");
    const handler = wrapOnWordBoundary ? wordWrap : textWrap;
    for (let i = 0;i < input.length; i++) {
      output.push.apply(output, handler(maxLength, input[i]));
    }
    return output;
  };
  var colorizeLines = function(input) {
    let state = {};
    let output = [];
    for (let i = 0;i < input.length; i++) {
      let line = rewindState(state, input[i]);
      state = readState(line);
      let temp = Object.assign({}, state);
      output.push(unwindState(temp, line));
    }
    return output;
  };
  var hyperlink = function(url, text) {
    const OSC = "\x1B]";
    const BEL = "\x07";
    const SEP = ";";
    return [OSC, "8", SEP, SEP, url || text, BEL, text, OSC, "8", SEP, SEP, BEL].join("");
  };
  var stringWidth = require_string_width();
  var codeCache = {};
  addToCodeCache("bold", 1, 22);
  addToCodeCache("italics", 3, 23);
  addToCodeCache("underline", 4, 24);
  addToCodeCache("inverse", 7, 27);
  addToCodeCache("strikethrough", 9, 29);
  module.exports = {
    strlen,
    repeat,
    pad,
    truncate,
    mergeOptions,
    wordWrap: multiLineWordWrap,
    colorizeLines,
    hyperlink
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles3 = {};
  module["exports"] = styles3;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles3[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag4 = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv;
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var translateLevel2 = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor2 = function(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os2.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env3) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env3;
      }) || env3.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env3) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env3) {
      var version2 = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env3.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env3.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env3) {
      return 1;
    }
    if (env3.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    var level = supportsColor2(stream);
    return translateLevel2(level);
  };
  var os2 = __require("os");
  var hasFlag2 = require_has_flag4();
  var env3 = process.env;
  var forceColor = undefined;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false")) {
    forceColor = false;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env3) {
    forceColor = env3.FORCE_COLOR.length === 0 || parseInt(env3.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options2) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options2) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i) {
        bool = i === character;
      });
      return bool;
    }
    function heComes(text2, options3) {
      var result = "";
      var counts;
      var l;
      options3 = options3 || {};
      options3["up"] = typeof options3["up"] !== "undefined" ? options3["up"] : true;
      options3["mid"] = typeof options3["mid"] !== "undefined" ? options3["mid"] : true;
      options3["down"] = typeof options3["down"] !== "undefined" ? options3["down"] : true;
      options3["size"] = typeof options3["size"] !== "undefined" ? options3["size"] : "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (isChar(l)) {
          continue;
        }
        result = result + text2[l];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options3.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index = arr[d];
          for (var i = 0;i <= counts[index]; i++) {
            if (options3[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options2);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      if (letter === " ")
        return letter;
      switch (i % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i++ % rainbowColors.length]](letter);
      }
    };
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var build2 = function(_styles) {
    var builder = function builder() {
      return applyStyle2.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto2;
    return builder;
  };
  var applyStyle2 = function() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util2.inspect(arg);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    while (i--) {
      var code = ansiStyles2[nestedStyles[i]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  };
  var init = function() {
    var ret = {};
    Object.keys(styles3).forEach(function(name) {
      ret[name] = {
        get: function() {
          return build2([name]);
        }
      };
    });
    return ret;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util2 = __require("util");
  var ansiStyles2 = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles2[style];
    if (!styleMap && style in colors) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles3 = function() {
    var ret = {};
    ansiStyles2.grey = ansiStyles2.gray;
    Object.keys(ansiStyles2).forEach(function(key) {
      ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles2[key].close), "g");
      ret[key] = {
        get: function() {
          return build2(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto2 = defineProps(function colors() {
  }, styles3);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller\'s) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + \'/../themes/generic-logging.js\'); The new syntax looks like colors.setTheme(require(__dirname + \'/../themes/generic-logging.js\'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i in theme[style2]) {
              out = colors[theme[style2][i]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var sequencer = function sequencer(map2, str) {
    var exploded = str.split("");
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america()(colors);
  colors.maps.zebra = require_zebra()(colors);
  colors.maps.rainbow = require_rainbow()(colors);
  colors.maps.random = require_random()(colors);
  for (map in colors.maps) {
    (function(map2) {
      colors[map2] = function(str) {
        return sequencer(colors.maps[map2], str);
      };
    })(map);
  }
  var map;
  defineProps(colors, init());
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@colors/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cli-table3/src/cell.js
var require_cell = __commonJS((exports, module) => {
  var firstDefined = function(...args) {
    return args.filter((v) => v !== undefined && v !== null).shift();
  };
  var setOption = function(objA, objB, nameB, targetObj) {
    let nameA = nameB.split("-");
    if (nameA.length > 1) {
      nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);
      nameA = nameA.join("");
      targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB]);
    } else {
      targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);
    }
  };
  var findDimension = function(dimensionTable, startingIndex, span) {
    let ret = dimensionTable[startingIndex];
    for (let i = 1;i < span; i++) {
      ret += 1 + dimensionTable[startingIndex + i];
    }
    return ret;
  };
  var sumPlusOne = function(a, b) {
    return a + b + 1;
  };
  var { info, debug } = require_debug2();
  var utils = require_utils4();

  class Cell {
    constructor(options2) {
      this.setOptions(options2);
      this.x = null;
      this.y = null;
    }
    setOptions(options2) {
      if (["boolean", "number", "string"].indexOf(typeof options2) !== -1) {
        options2 = { content: "" + options2 };
      }
      options2 = options2 || {};
      this.options = options2;
      let content = options2.content;
      if (["boolean", "number", "string"].indexOf(typeof content) !== -1) {
        this.content = String(content);
      } else if (!content) {
        this.content = this.options.href || "";
      } else {
        throw new Error("Content needs to be a primitive, got: " + typeof content);
      }
      this.colSpan = options2.colSpan || 1;
      this.rowSpan = options2.rowSpan || 1;
      if (this.options.href) {
        Object.defineProperty(this, "href", {
          get() {
            return this.options.href;
          }
        });
      }
    }
    mergeTableOptions(tableOptions, cells) {
      this.cells = cells;
      let optionsChars = this.options.chars || {};
      let tableChars = tableOptions.chars;
      let chars = this.chars = {};
      CHAR_NAMES.forEach(function(name) {
        setOption(optionsChars, tableChars, name, chars);
      });
      this.truncate = this.options.truncate || tableOptions.truncate;
      let style = this.options.style = this.options.style || {};
      let tableStyle = tableOptions.style;
      setOption(style, tableStyle, "padding-left", this);
      setOption(style, tableStyle, "padding-right", this);
      this.head = style.head || tableStyle.head;
      this.border = style.border || tableStyle.border;
      this.fixedWidth = tableOptions.colWidths[this.x];
      this.lines = this.computeLines(tableOptions);
      this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;
      this.desiredHeight = this.lines.length;
    }
    computeLines(tableOptions) {
      const tableWordWrap = tableOptions.wordWrap || tableOptions.textWrap;
      const { wordWrap = tableWordWrap } = this.options;
      if (this.fixedWidth && wordWrap) {
        this.fixedWidth -= this.paddingLeft + this.paddingRight;
        if (this.colSpan) {
          let i = 1;
          while (i < this.colSpan) {
            this.fixedWidth += tableOptions.colWidths[this.x + i];
            i++;
          }
        }
        const { wrapOnWordBoundary: tableWrapOnWordBoundary = true } = tableOptions;
        const { wrapOnWordBoundary = tableWrapOnWordBoundary } = this.options;
        return this.wrapLines(utils.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));
      }
      return this.wrapLines(this.content.split("\n"));
    }
    wrapLines(computedLines) {
      const lines = utils.colorizeLines(computedLines);
      if (this.href) {
        return lines.map((line) => utils.hyperlink(this.href, line));
      }
      return lines;
    }
    init(tableOptions) {
      let x = this.x;
      let y = this.y;
      this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);
      this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);
      this.width = this.widths.reduce(sumPlusOne, -1);
      this.height = this.heights.reduce(sumPlusOne, -1);
      this.hAlign = this.options.hAlign || tableOptions.colAligns[x];
      this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];
      this.drawRight = x + this.colSpan == tableOptions.colWidths.length;
    }
    draw(lineNum, spanningCell) {
      if (lineNum == "top")
        return this.drawTop(this.drawRight);
      if (lineNum == "bottom")
        return this.drawBottom(this.drawRight);
      let content = utils.truncate(this.content, 10, this.truncate);
      if (!lineNum) {
        info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);
      } else {
      }
      let padLen = Math.max(this.height - this.lines.length, 0);
      let padTop;
      switch (this.vAlign) {
        case "center":
          padTop = Math.ceil(padLen / 2);
          break;
        case "bottom":
          padTop = padLen;
          break;
        default:
          padTop = 0;
      }
      if (lineNum < padTop || lineNum >= padTop + this.lines.length) {
        return this.drawEmpty(this.drawRight, spanningCell);
      }
      let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
      return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
    }
    drawTop(drawRight) {
      let content = [];
      if (this.cells) {
        this.widths.forEach(function(width, index) {
          content.push(this._topLeftChar(index));
          content.push(utils.repeat(this.chars[this.y == 0 ? "top" : "mid"], width));
        }, this);
      } else {
        content.push(this._topLeftChar(0));
        content.push(utils.repeat(this.chars[this.y == 0 ? "top" : "mid"], this.width));
      }
      if (drawRight) {
        content.push(this.chars[this.y == 0 ? "topRight" : "rightMid"]);
      }
      return this.wrapWithStyleColors("border", content.join(""));
    }
    _topLeftChar(offset) {
      let x = this.x + offset;
      let leftChar;
      if (this.y == 0) {
        leftChar = x == 0 ? "topLeft" : offset == 0 ? "topMid" : "top";
      } else {
        if (x == 0) {
          leftChar = "leftMid";
        } else {
          leftChar = offset == 0 ? "midMid" : "bottomMid";
          if (this.cells) {
            let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;
            if (spanAbove) {
              leftChar = offset == 0 ? "topMid" : "mid";
            }
            if (offset == 0) {
              let i = 1;
              while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {
                i++;
              }
              if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {
                leftChar = "leftMid";
              }
            }
          }
        }
      }
      return this.chars[leftChar];
    }
    wrapWithStyleColors(styleProperty, content) {
      if (this[styleProperty] && this[styleProperty].length) {
        try {
          let colors = require_safe();
          for (let i = this[styleProperty].length - 1;i >= 0; i--) {
            colors = colors[this[styleProperty][i]];
          }
          return colors(content);
        } catch (e) {
          return content;
        }
      } else {
        return content;
      }
    }
    drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
      let left2 = this.chars[this.x == 0 ? "left" : "middle"];
      if (this.x && spanningCell && this.cells) {
        let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
        while (cellLeft instanceof ColSpanCell) {
          cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
        }
        if (!(cellLeft instanceof RowSpanCell)) {
          left2 = this.chars["rightMid"];
        }
      }
      let leftPadding = utils.repeat(" ", this.paddingLeft);
      let right2 = drawRight ? this.chars["right"] : "";
      let rightPadding = utils.repeat(" ", this.paddingRight);
      let line = this.lines[lineNum];
      let len = this.width - (this.paddingLeft + this.paddingRight);
      if (forceTruncationSymbol)
        line += this.truncate || "\u2026";
      let content = utils.truncate(line, len, this.truncate);
      content = utils.pad(content, len, " ", this.hAlign);
      content = leftPadding + content + rightPadding;
      return this.stylizeLine(left2, content, right2);
    }
    stylizeLine(left2, content, right2) {
      left2 = this.wrapWithStyleColors("border", left2);
      right2 = this.wrapWithStyleColors("border", right2);
      if (this.y === 0) {
        content = this.wrapWithStyleColors("head", content);
      }
      return left2 + content + right2;
    }
    drawBottom(drawRight) {
      let left2 = this.chars[this.x == 0 ? "bottomLeft" : "bottomMid"];
      let content = utils.repeat(this.chars.bottom, this.width);
      let right2 = drawRight ? this.chars["bottomRight"] : "";
      return this.wrapWithStyleColors("border", left2 + content + right2);
    }
    drawEmpty(drawRight, spanningCell) {
      let left2 = this.chars[this.x == 0 ? "left" : "middle"];
      if (this.x && spanningCell && this.cells) {
        let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
        while (cellLeft instanceof ColSpanCell) {
          cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
        }
        if (!(cellLeft instanceof RowSpanCell)) {
          left2 = this.chars["rightMid"];
        }
      }
      let right2 = drawRight ? this.chars["right"] : "";
      let content = utils.repeat(" ", this.width);
      return this.stylizeLine(left2, content, right2);
    }
  }

  class ColSpanCell {
    constructor() {
    }
    draw(lineNum) {
      if (typeof lineNum === "number") {
        debug(`${this.y}-${this.x}: 1x1 ColSpanCell`);
      }
      return "";
    }
    init() {
    }
    mergeTableOptions() {
    }
  }

  class RowSpanCell {
    constructor(originalCell) {
      this.originalCell = originalCell;
    }
    init(tableOptions) {
      let y = this.y;
      let originalY = this.originalCell.y;
      this.cellOffset = y - originalY;
      this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);
    }
    draw(lineNum) {
      if (lineNum == "top") {
        return this.originalCell.draw(this.offset, this.cellOffset);
      }
      if (lineNum == "bottom") {
        return this.originalCell.draw("bottom");
      }
      debug(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`);
      return this.originalCell.draw(this.offset + 1 + lineNum);
    }
    mergeTableOptions() {
    }
  }
  var CHAR_NAMES = [
    "top",
    "top-mid",
    "top-left",
    "top-right",
    "bottom",
    "bottom-mid",
    "bottom-left",
    "bottom-right",
    "left",
    "left-mid",
    "mid",
    "mid-mid",
    "right",
    "right-mid",
    "middle"
  ];
  module.exports = Cell;
  module.exports.ColSpanCell = ColSpanCell;
  module.exports.RowSpanCell = RowSpanCell;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cli-table3/src/layout-manager.js
var require_layout_manager = __commonJS((exports, module) => {
  var makeComputeWidths = function(colSpan, desiredWidth, x, forcedMin) {
    return function(vals, table) {
      let result = [];
      let spanners = [];
      let auto = {};
      table.forEach(function(row) {
        row.forEach(function(cell) {
          if ((cell[colSpan] || 1) > 1) {
            spanners.push(cell);
          } else {
            result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);
          }
        });
      });
      vals.forEach(function(val, index) {
        if (typeof val === "number") {
          result[index] = val;
        }
      });
      for (let k = spanners.length - 1;k >= 0; k--) {
        let cell = spanners[k];
        let span = cell[colSpan];
        let col = cell[x];
        let existingWidth = result[col];
        let editableCols = typeof vals[col] === "number" ? 0 : 1;
        if (typeof existingWidth === "number") {
          for (let i = 1;i < span; i++) {
            existingWidth += 1 + result[col + i];
            if (typeof vals[col + i] !== "number") {
              editableCols++;
            }
          }
        } else {
          existingWidth = desiredWidth === "desiredWidth" ? cell.desiredWidth - 1 : 1;
          if (!auto[col] || auto[col] < existingWidth) {
            auto[col] = existingWidth;
          }
        }
        if (cell[desiredWidth] > existingWidth) {
          let i = 0;
          while (editableCols > 0 && cell[desiredWidth] > existingWidth) {
            if (typeof vals[col + i] !== "number") {
              let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
              existingWidth += dif;
              result[col + i] += dif;
              editableCols--;
            }
            i++;
          }
        }
      }
      Object.assign(vals, result, auto);
      for (let j = 0;j < vals.length; j++) {
        vals[j] = Math.max(forcedMin, vals[j] || 0);
      }
    };
  };
  var { warn, debug } = require_debug2();
  var Cell = require_cell();
  var { ColSpanCell, RowSpanCell } = Cell;
  (function() {
    function next(alloc, col) {
      if (alloc[col] > 0) {
        return next(alloc, col + 1);
      }
      return col;
    }
    function layoutTable(table) {
      let alloc = {};
      table.forEach(function(row, rowIndex) {
        let col = 0;
        row.forEach(function(cell) {
          cell.y = rowIndex;
          cell.x = rowIndex ? next(alloc, col) : col;
          const rowSpan = cell.rowSpan || 1;
          const colSpan = cell.colSpan || 1;
          if (rowSpan > 1) {
            for (let cs = 0;cs < colSpan; cs++) {
              alloc[cell.x + cs] = rowSpan;
            }
          }
          col = cell.x + colSpan;
        });
        Object.keys(alloc).forEach((idx) => {
          alloc[idx]--;
          if (alloc[idx] < 1)
            delete alloc[idx];
        });
      });
    }
    function maxWidth(table) {
      let mw = 0;
      table.forEach(function(row) {
        row.forEach(function(cell) {
          mw = Math.max(mw, cell.x + (cell.colSpan || 1));
        });
      });
      return mw;
    }
    function maxHeight(table) {
      return table.length;
    }
    function cellsConflict(cell1, cell2) {
      let yMin1 = cell1.y;
      let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);
      let yMin2 = cell2.y;
      let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);
      let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);
      let xMin1 = cell1.x;
      let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);
      let xMin2 = cell2.x;
      let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);
      let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);
      return yConflict && xConflict;
    }
    function conflictExists(rows, x, y) {
      let i_max = Math.min(rows.length - 1, y);
      let cell = { x, y };
      for (let i = 0;i <= i_max; i++) {
        let row = rows[i];
        for (let j = 0;j < row.length; j++) {
          if (cellsConflict(cell, row[j])) {
            return true;
          }
        }
      }
      return false;
    }
    function allBlank(rows, y, xMin, xMax) {
      for (let x = xMin;x < xMax; x++) {
        if (conflictExists(rows, x, y)) {
          return false;
        }
      }
      return true;
    }
    function addRowSpanCells(table) {
      table.forEach(function(row, rowIndex) {
        row.forEach(function(cell) {
          for (let i = 1;i < cell.rowSpan; i++) {
            let rowSpanCell = new RowSpanCell(cell);
            rowSpanCell.x = cell.x;
            rowSpanCell.y = cell.y + i;
            rowSpanCell.colSpan = cell.colSpan;
            insertCell(rowSpanCell, table[rowIndex + i]);
          }
        });
      });
    }
    function addColSpanCells(cellRows) {
      for (let rowIndex = cellRows.length - 1;rowIndex >= 0; rowIndex--) {
        let cellColumns = cellRows[rowIndex];
        for (let columnIndex = 0;columnIndex < cellColumns.length; columnIndex++) {
          let cell = cellColumns[columnIndex];
          for (let k = 1;k < cell.colSpan; k++) {
            let colSpanCell = new ColSpanCell;
            colSpanCell.x = cell.x + k;
            colSpanCell.y = cell.y;
            cellColumns.splice(columnIndex + 1, 0, colSpanCell);
          }
        }
      }
    }
    function insertCell(cell, row) {
      let x = 0;
      while (x < row.length && row[x].x < cell.x) {
        x++;
      }
      row.splice(x, 0, cell);
    }
    function fillInTable(table) {
      let h_max = maxHeight(table);
      let w_max = maxWidth(table);
      debug(`Max rows: ${h_max}; Max cols: ${w_max}`);
      for (let y = 0;y < h_max; y++) {
        for (let x = 0;x < w_max; x++) {
          if (!conflictExists(table, x, y)) {
            let opts = { x, y, colSpan: 1, rowSpan: 1 };
            x++;
            while (x < w_max && !conflictExists(table, x, y)) {
              opts.colSpan++;
              x++;
            }
            let y2 = y + 1;
            while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {
              opts.rowSpan++;
              y2++;
            }
            let cell = new Cell(opts);
            cell.x = opts.x;
            cell.y = opts.y;
            warn(`Missing cell at ${cell.y}-${cell.x}.`);
            insertCell(cell, table[y]);
          }
        }
      }
    }
    function generateCells(rows) {
      return rows.map(function(row) {
        if (!Array.isArray(row)) {
          let key = Object.keys(row)[0];
          row = row[key];
          if (Array.isArray(row)) {
            row = row.slice();
            row.unshift(key);
          } else {
            row = [key, row];
          }
        }
        return row.map(function(cell) {
          return new Cell(cell);
        });
      });
    }
    function makeTableLayout(rows) {
      let cellRows = generateCells(rows);
      layoutTable(cellRows);
      fillInTable(cellRows);
      addRowSpanCells(cellRows);
      addColSpanCells(cellRows);
      return cellRows;
    }
    module.exports = {
      makeTableLayout,
      layoutTable,
      addRowSpanCells,
      maxWidth,
      fillInTable,
      computeWidths: makeComputeWidths("colSpan", "desiredWidth", "x", 1),
      computeHeights: makeComputeWidths("rowSpan", "desiredHeight", "y", 1)
    };
  })();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cli-table3/src/table.js
var require_table = __commonJS((exports, module) => {
  var doDraw = function(row, lineNum, result) {
    let line = [];
    row.forEach(function(cell) {
      line.push(cell.draw(lineNum));
    });
    let str = line.join("");
    if (str.length)
      result.push(str);
  };
  var debug = require_debug2();
  var utils = require_utils4();
  var tableLayout = require_layout_manager();

  class Table extends Array {
    constructor(opts) {
      super();
      const options2 = utils.mergeOptions(opts);
      Object.defineProperty(this, "options", {
        value: options2,
        enumerable: options2.debug
      });
      if (options2.debug) {
        switch (typeof options2.debug) {
          case "boolean":
            debug.setDebugLevel(debug.WARN);
            break;
          case "number":
            debug.setDebugLevel(options2.debug);
            break;
          case "string":
            debug.setDebugLevel(parseInt(options2.debug, 10));
            break;
          default:
            debug.setDebugLevel(debug.WARN);
            debug.warn(`Debug option is expected to be boolean, number, or string. Received a ${typeof options2.debug}`);
        }
        Object.defineProperty(this, "messages", {
          get() {
            return debug.debugMessages();
          }
        });
      }
    }
    toString() {
      let array = this;
      let headersPresent = this.options.head && this.options.head.length;
      if (headersPresent) {
        array = [this.options.head];
        if (this.length) {
          array.push.apply(array, this);
        }
      } else {
        this.options.style.head = [];
      }
      let cells = tableLayout.makeTableLayout(array);
      cells.forEach(function(row) {
        row.forEach(function(cell) {
          cell.mergeTableOptions(this.options, cells);
        }, this);
      }, this);
      tableLayout.computeWidths(this.options.colWidths, cells);
      tableLayout.computeHeights(this.options.rowHeights, cells);
      cells.forEach(function(row) {
        row.forEach(function(cell) {
          cell.init(this.options);
        }, this);
      }, this);
      let result = [];
      for (let rowIndex = 0;rowIndex < cells.length; rowIndex++) {
        let row = cells[rowIndex];
        let heightOfRow = this.options.rowHeights[rowIndex];
        if (rowIndex === 0 || !this.options.style.compact || rowIndex == 1 && headersPresent) {
          doDraw(row, "top", result);
        }
        for (let lineNum = 0;lineNum < heightOfRow; lineNum++) {
          doDraw(row, lineNum, result);
        }
        if (rowIndex + 1 == cells.length) {
          doDraw(row, "bottom", result);
        }
      }
      return result.join("\n");
    }
    get width() {
      let str = this.toString().split("\n");
      return str[0].length;
    }
  }
  Table.reset = () => debug.reset();
  module.exports = Table;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["esprima"] = factory();
    else
      root["esprima"] = factory();
  })(exports, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module2 = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.loaded = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var comment_handler_1 = __webpack_require__(1);
        var jsx_parser_1 = __webpack_require__(3);
        var parser_1 = __webpack_require__(8);
        var tokenizer_1 = __webpack_require__(15);
        function parse3(code, options2, delegate) {
          var commentHandler = null;
          var proxyDelegate = function(node2, metadata) {
            if (delegate) {
              delegate(node2, metadata);
            }
            if (commentHandler) {
              commentHandler.visit(node2, metadata);
            }
          };
          var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
          var collectComment = false;
          if (options2) {
            collectComment = typeof options2.comment === "boolean" && options2.comment;
            var attachComment = typeof options2.attachComment === "boolean" && options2.attachComment;
            if (collectComment || attachComment) {
              commentHandler = new comment_handler_1.CommentHandler;
              commentHandler.attach = attachComment;
              options2.comment = true;
              parserDelegate = proxyDelegate;
            }
          }
          var isModule2 = false;
          if (options2 && typeof options2.sourceType === "string") {
            isModule2 = options2.sourceType === "module";
          }
          var parser4;
          if (options2 && typeof options2.jsx === "boolean" && options2.jsx) {
            parser4 = new jsx_parser_1.JSXParser(code, options2, parserDelegate);
          } else {
            parser4 = new parser_1.Parser(code, options2, parserDelegate);
          }
          var program = isModule2 ? parser4.parseModule() : parser4.parseScript();
          var ast = program;
          if (collectComment && commentHandler) {
            ast.comments = commentHandler.comments;
          }
          if (parser4.config.tokens) {
            ast.tokens = parser4.tokens;
          }
          if (parser4.config.tolerant) {
            ast.errors = parser4.errorHandler.errors;
          }
          return ast;
        }
        exports2.parse = parse3;
        function parseModule(code, options2, delegate) {
          var parsingOptions = options2 || {};
          parsingOptions.sourceType = "module";
          return parse3(code, parsingOptions, delegate);
        }
        exports2.parseModule = parseModule;
        function parseScript(code, options2, delegate) {
          var parsingOptions = options2 || {};
          parsingOptions.sourceType = "script";
          return parse3(code, parsingOptions, delegate);
        }
        exports2.parseScript = parseScript;
        function tokenize(code, options2, delegate) {
          var tokenizer = new tokenizer_1.Tokenizer(code, options2);
          var tokens;
          tokens = [];
          try {
            while (true) {
              var token = tokenizer.getNextToken();
              if (!token) {
                break;
              }
              if (delegate) {
                token = delegate(token);
              }
              tokens.push(token);
            }
          } catch (e) {
            tokenizer.errorHandler.tolerate(e);
          }
          if (tokenizer.errorHandler.tolerant) {
            tokens.errors = tokenizer.errors();
          }
          return tokens;
        }
        exports2.tokenize = tokenize;
        var syntax_1 = __webpack_require__(2);
        exports2.Syntax = syntax_1.Syntax;
        exports2.version = "4.0.1";
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var CommentHandler = function() {
          function CommentHandler2() {
            this.attach = false;
            this.comments = [];
            this.stack = [];
            this.leading = [];
            this.trailing = [];
          }
          CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
            if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
              var innerComments = [];
              for (var i = this.leading.length - 1;i >= 0; --i) {
                var entry = this.leading[i];
                if (metadata.end.offset >= entry.start) {
                  innerComments.unshift(entry.comment);
                  this.leading.splice(i, 1);
                  this.trailing.splice(i, 1);
                }
              }
              if (innerComments.length) {
                node2.innerComments = innerComments;
              }
            }
          };
          CommentHandler2.prototype.findTrailingComments = function(metadata) {
            var trailingComments = [];
            if (this.trailing.length > 0) {
              for (var i = this.trailing.length - 1;i >= 0; --i) {
                var entry_1 = this.trailing[i];
                if (entry_1.start >= metadata.end.offset) {
                  trailingComments.unshift(entry_1.comment);
                }
              }
              this.trailing.length = 0;
              return trailingComments;
            }
            var entry = this.stack[this.stack.length - 1];
            if (entry && entry.node.trailingComments) {
              var firstComment = entry.node.trailingComments[0];
              if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                trailingComments = entry.node.trailingComments;
                delete entry.node.trailingComments;
              }
            }
            return trailingComments;
          };
          CommentHandler2.prototype.findLeadingComments = function(metadata) {
            var leadingComments = [];
            var target;
            while (this.stack.length > 0) {
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.start >= metadata.start.offset) {
                target = entry.node;
                this.stack.pop();
              } else {
                break;
              }
            }
            if (target) {
              var count = target.leadingComments ? target.leadingComments.length : 0;
              for (var i = count - 1;i >= 0; --i) {
                var comment = target.leadingComments[i];
                if (comment.range[1] <= metadata.start.offset) {
                  leadingComments.unshift(comment);
                  target.leadingComments.splice(i, 1);
                }
              }
              if (target.leadingComments && target.leadingComments.length === 0) {
                delete target.leadingComments;
              }
              return leadingComments;
            }
            for (var i = this.leading.length - 1;i >= 0; --i) {
              var entry = this.leading[i];
              if (entry.start <= metadata.start.offset) {
                leadingComments.unshift(entry.comment);
                this.leading.splice(i, 1);
              }
            }
            return leadingComments;
          };
          CommentHandler2.prototype.visitNode = function(node2, metadata) {
            if (node2.type === syntax_1.Syntax.Program && node2.body.length > 0) {
              return;
            }
            this.insertInnerComments(node2, metadata);
            var trailingComments = this.findTrailingComments(metadata);
            var leadingComments = this.findLeadingComments(metadata);
            if (leadingComments.length > 0) {
              node2.leadingComments = leadingComments;
            }
            if (trailingComments.length > 0) {
              node2.trailingComments = trailingComments;
            }
            this.stack.push({
              node: node2,
              start: metadata.start.offset
            });
          };
          CommentHandler2.prototype.visitComment = function(node2, metadata) {
            var type = node2.type[0] === "L" ? "Line" : "Block";
            var comment = {
              type,
              value: node2.value
            };
            if (node2.range) {
              comment.range = node2.range;
            }
            if (node2.loc) {
              comment.loc = node2.loc;
            }
            this.comments.push(comment);
            if (this.attach) {
              var entry = {
                comment: {
                  type,
                  value: node2.value,
                  range: [metadata.start.offset, metadata.end.offset]
                },
                start: metadata.start.offset
              };
              if (node2.loc) {
                entry.comment.loc = node2.loc;
              }
              node2.type = type;
              this.leading.push(entry);
              this.trailing.push(entry);
            }
          };
          CommentHandler2.prototype.visit = function(node2, metadata) {
            if (node2.type === "LineComment") {
              this.visitComment(node2, metadata);
            } else if (node2.type === "BlockComment") {
              this.visitComment(node2, metadata);
            } else if (this.attach) {
              this.visitNode(node2, metadata);
            }
          };
          return CommentHandler2;
        }();
        exports2.CommentHandler = CommentHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Syntax = {
          AssignmentExpression: "AssignmentExpression",
          AssignmentPattern: "AssignmentPattern",
          ArrayExpression: "ArrayExpression",
          ArrayPattern: "ArrayPattern",
          ArrowFunctionExpression: "ArrowFunctionExpression",
          AwaitExpression: "AwaitExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ClassBody: "ClassBody",
          ClassDeclaration: "ClassDeclaration",
          ClassExpression: "ClassExpression",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExportAllDeclaration: "ExportAllDeclaration",
          ExportDefaultDeclaration: "ExportDefaultDeclaration",
          ExportNamedDeclaration: "ExportNamedDeclaration",
          ExportSpecifier: "ExportSpecifier",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForOfStatement: "ForOfStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          ImportDeclaration: "ImportDeclaration",
          ImportDefaultSpecifier: "ImportDefaultSpecifier",
          ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
          ImportSpecifier: "ImportSpecifier",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          MetaProperty: "MetaProperty",
          MethodDefinition: "MethodDefinition",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          ObjectPattern: "ObjectPattern",
          Program: "Program",
          Property: "Property",
          RestElement: "RestElement",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SpreadElement: "SpreadElement",
          Super: "Super",
          SwitchCase: "SwitchCase",
          SwitchStatement: "SwitchStatement",
          TaggedTemplateExpression: "TaggedTemplateExpression",
          TemplateElement: "TemplateElement",
          TemplateLiteral: "TemplateLiteral",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement",
          YieldExpression: "YieldExpression"
        };
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
            d.__proto__ = b;
          } || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
          };
          return function(d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var character_1 = __webpack_require__(4);
        var JSXNode = __webpack_require__(5);
        var jsx_syntax_1 = __webpack_require__(6);
        var Node = __webpack_require__(7);
        var parser_1 = __webpack_require__(8);
        var token_1 = __webpack_require__(13);
        var xhtml_entities_1 = __webpack_require__(14);
        token_1.TokenName[100] = "JSXIdentifier";
        token_1.TokenName[101] = "JSXText";
        function getQualifiedElementName(elementName) {
          var qualifiedName;
          switch (elementName.type) {
            case jsx_syntax_1.JSXSyntax.JSXIdentifier:
              var id = elementName;
              qualifiedName = id.name;
              break;
            case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
              var ns = elementName;
              qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
              break;
            case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
              var expr = elementName;
              qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
              break;
            default:
              break;
          }
          return qualifiedName;
        }
        var JSXParser = function(_super) {
          __extends(JSXParser2, _super);
          function JSXParser2(code, options2, delegate) {
            return _super.call(this, code, options2, delegate) || this;
          }
          JSXParser2.prototype.parsePrimaryExpression = function() {
            return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
          };
          JSXParser2.prototype.startJSX = function() {
            this.scanner.index = this.startMarker.index;
            this.scanner.lineNumber = this.startMarker.line;
            this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
          };
          JSXParser2.prototype.finishJSX = function() {
            this.nextToken();
          };
          JSXParser2.prototype.reenterJSX = function() {
            this.startJSX();
            this.expectJSX("}");
            if (this.config.tokens) {
              this.tokens.pop();
            }
          };
          JSXParser2.prototype.createJSXNode = function() {
            this.collectComments();
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.createJSXChildNode = function() {
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.scanXHTMLEntity = function(quote) {
            var result = "&";
            var valid = true;
            var terminated = false;
            var numeric = false;
            var hex = false;
            while (!this.scanner.eof() && valid && !terminated) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === quote) {
                break;
              }
              terminated = ch === ";";
              result += ch;
              ++this.scanner.index;
              if (!terminated) {
                switch (result.length) {
                  case 2:
                    numeric = ch === "#";
                    break;
                  case 3:
                    if (numeric) {
                      hex = ch === "x";
                      valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                      numeric = numeric && !hex;
                    }
                    break;
                  default:
                    valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                    valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                    break;
                }
              }
            }
            if (valid && terminated && result.length > 2) {
              var str = result.substr(1, result.length - 2);
              if (numeric && str.length > 1) {
                result = String.fromCharCode(parseInt(str.substr(1), 10));
              } else if (hex && str.length > 2) {
                result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
              } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                result = xhtml_entities_1.XHTMLEntities[str];
              }
            }
            return result;
          };
          JSXParser2.prototype.lexJSX = function() {
            var cp = this.scanner.source.charCodeAt(this.scanner.index);
            if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
              var value2 = this.scanner.source[this.scanner.index++];
              return {
                type: 7,
                value: value2,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index - 1,
                end: this.scanner.index
              };
            }
            if (cp === 34 || cp === 39) {
              var start = this.scanner.index;
              var quote = this.scanner.source[this.scanner.index++];
              var str = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index++];
                if (ch === quote) {
                  break;
                } else if (ch === "&") {
                  str += this.scanXHTMLEntity(quote);
                } else {
                  str += ch;
                }
              }
              return {
                type: 8,
                value: str,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 46) {
              var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
              var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
              var value2 = n1 === 46 && n2 === 46 ? "..." : ".";
              var start = this.scanner.index;
              this.scanner.index += value2.length;
              return {
                type: 7,
                value: value2,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 96) {
              return {
                type: 10,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index,
                end: this.scanner.index
              };
            }
            if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
              var start = this.scanner.index;
              ++this.scanner.index;
              while (!this.scanner.eof()) {
                var ch = this.scanner.source.charCodeAt(this.scanner.index);
                if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                  ++this.scanner.index;
                } else if (ch === 45) {
                  ++this.scanner.index;
                } else {
                  break;
                }
              }
              var id = this.scanner.source.slice(start, this.scanner.index);
              return {
                type: 100,
                value: id,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            return this.scanner.lex();
          };
          JSXParser2.prototype.nextJSXToken = function() {
            this.collectComments();
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = this.lexJSX();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            if (this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.nextJSXText = function() {
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var start = this.scanner.index;
            var text = "";
            while (!this.scanner.eof()) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === "{" || ch === "<") {
                break;
              }
              ++this.scanner.index;
              text += ch;
              if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.scanner.lineNumber;
                if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                  ++this.scanner.index;
                }
                this.scanner.lineStart = this.scanner.index;
              }
            }
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = {
              type: 101,
              value: text,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start,
              end: this.scanner.index
            };
            if (text.length > 0 && this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.peekJSXToken = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.lexJSX();
            this.scanner.restoreState(state);
            return next;
          };
          JSXParser2.prototype.expectJSX = function(value2) {
            var token = this.nextJSXToken();
            if (token.type !== 7 || token.value !== value2) {
              this.throwUnexpectedToken(token);
            }
          };
          JSXParser2.prototype.matchJSX = function(value2) {
            var next = this.peekJSXToken();
            return next.type === 7 && next.value === value2;
          };
          JSXParser2.prototype.parseJSXIdentifier = function() {
            var node2 = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 100) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node2, new JSXNode.JSXIdentifier(token.value));
          };
          JSXParser2.prototype.parseJSXElementName = function() {
            var node2 = this.createJSXNode();
            var elementName = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = elementName;
              this.expectJSX(":");
              var name_1 = this.parseJSXIdentifier();
              elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_1));
            } else if (this.matchJSX(".")) {
              while (this.matchJSX(".")) {
                var object = elementName;
                this.expectJSX(".");
                var property2 = this.parseJSXIdentifier();
                elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object, property2));
              }
            }
            return elementName;
          };
          JSXParser2.prototype.parseJSXAttributeName = function() {
            var node2 = this.createJSXNode();
            var attributeName;
            var identifier = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = identifier;
              this.expectJSX(":");
              var name_2 = this.parseJSXIdentifier();
              attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_2));
            } else {
              attributeName = identifier;
            }
            return attributeName;
          };
          JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
            var node2 = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 8) {
              this.throwUnexpectedToken(token);
            }
            var raw = this.getTokenRaw(token);
            return this.finalize(node2, new Node.Literal(token.value, raw));
          };
          JSXParser2.prototype.parseJSXExpressionAttribute = function() {
            var node2 = this.createJSXNode();
            this.expectJSX("{");
            this.finishJSX();
            if (this.match("}")) {
              this.tolerateError("JSX attributes must only be assigned a non-empty expression");
            }
            var expression = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXAttributeValue = function() {
            return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
          };
          JSXParser2.prototype.parseJSXNameValueAttribute = function() {
            var node2 = this.createJSXNode();
            var name = this.parseJSXAttributeName();
            var value2 = null;
            if (this.matchJSX("=")) {
              this.expectJSX("=");
              value2 = this.parseJSXAttributeValue();
            }
            return this.finalize(node2, new JSXNode.JSXAttribute(name, value2));
          };
          JSXParser2.prototype.parseJSXSpreadAttribute = function() {
            var node2 = this.createJSXNode();
            this.expectJSX("{");
            this.expectJSX("...");
            this.finishJSX();
            var argument = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
          };
          JSXParser2.prototype.parseJSXAttributes = function() {
            var attributes = [];
            while (!this.matchJSX("/") && !this.matchJSX(">")) {
              var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
              attributes.push(attribute);
            }
            return attributes;
          };
          JSXParser2.prototype.parseJSXOpeningElement = function() {
            var node2 = this.createJSXNode();
            this.expectJSX("<");
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node2, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXBoundaryElement = function() {
            var node2 = this.createJSXNode();
            this.expectJSX("<");
            if (this.matchJSX("/")) {
              this.expectJSX("/");
              var name_3 = this.parseJSXElementName();
              this.expectJSX(">");
              return this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
            }
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node2, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXEmptyExpression = function() {
            var node2 = this.createJSXChildNode();
            this.collectComments();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            return this.finalize(node2, new JSXNode.JSXEmptyExpression);
          };
          JSXParser2.prototype.parseJSXExpressionContainer = function() {
            var node2 = this.createJSXNode();
            this.expectJSX("{");
            var expression;
            if (this.matchJSX("}")) {
              expression = this.parseJSXEmptyExpression();
              this.expectJSX("}");
            } else {
              this.finishJSX();
              expression = this.parseAssignmentExpression();
              this.reenterJSX();
            }
            return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXChildren = function() {
            var children = [];
            while (!this.scanner.eof()) {
              var node2 = this.createJSXChildNode();
              var token = this.nextJSXText();
              if (token.start < token.end) {
                var raw = this.getTokenRaw(token);
                var child = this.finalize(node2, new JSXNode.JSXText(token.value, raw));
                children.push(child);
              }
              if (this.scanner.source[this.scanner.index] === "{") {
                var container = this.parseJSXExpressionContainer();
                children.push(container);
              } else {
                break;
              }
            }
            return children;
          };
          JSXParser2.prototype.parseComplexJSXElement = function(el) {
            var stack = [];
            while (!this.scanner.eof()) {
              el.children = el.children.concat(this.parseJSXChildren());
              var node2 = this.createJSXChildNode();
              var element = this.parseJSXBoundaryElement();
              if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                var opening = element;
                if (opening.selfClosing) {
                  var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                  el.children.push(child);
                } else {
                  stack.push(el);
                  el = { node: node2, opening, closing: null, children: [] };
                }
              }
              if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                el.closing = element;
                var open_1 = getQualifiedElementName(el.opening.name);
                var close_1 = getQualifiedElementName(el.closing.name);
                if (open_1 !== close_1) {
                  this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                }
                if (stack.length > 0) {
                  var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                  el = stack[stack.length - 1];
                  el.children.push(child);
                  stack.pop();
                } else {
                  break;
                }
              }
            }
            return el;
          };
          JSXParser2.prototype.parseJSXElement = function() {
            var node2 = this.createJSXNode();
            var opening = this.parseJSXOpeningElement();
            var children = [];
            var closing = null;
            if (!opening.selfClosing) {
              var el = this.parseComplexJSXElement({ node: node2, opening, closing, children });
              children = el.children;
              closing = el.closing;
            }
            return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
          };
          JSXParser2.prototype.parseJSXRoot = function() {
            if (this.config.tokens) {
              this.tokens.pop();
            }
            this.startJSX();
            var element = this.parseJSXElement();
            this.finishJSX();
            return element;
          };
          JSXParser2.prototype.isStartOfExpression = function() {
            return _super.prototype.isStartOfExpression.call(this) || this.match("<");
          };
          return JSXParser2;
        }(parser_1.Parser);
        exports2.JSXParser = JSXParser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var Regex = {
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
          NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
        exports2.Character = {
          fromCodePoint: function(cp) {
            return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
          },
          isWhiteSpace: function(cp) {
            return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
          },
          isLineTerminator: function(cp) {
            return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
          },
          isIdentifierStart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
          },
          isIdentifierPart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
          },
          isDecimalDigit: function(cp) {
            return cp >= 48 && cp <= 57;
          },
          isHexDigit: function(cp) {
            return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
          },
          isOctalDigit: function(cp) {
            return cp >= 48 && cp <= 55;
          }
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var jsx_syntax_1 = __webpack_require__(6);
        var JSXClosingElement = function() {
          function JSXClosingElement2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
            this.name = name;
          }
          return JSXClosingElement2;
        }();
        exports2.JSXClosingElement = JSXClosingElement;
        var JSXElement = function() {
          function JSXElement2(openingElement, children, closingElement) {
            this.type = jsx_syntax_1.JSXSyntax.JSXElement;
            this.openingElement = openingElement;
            this.children = children;
            this.closingElement = closingElement;
          }
          return JSXElement2;
        }();
        exports2.JSXElement = JSXElement;
        var JSXEmptyExpression = function() {
          function JSXEmptyExpression2() {
            this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
          }
          return JSXEmptyExpression2;
        }();
        exports2.JSXEmptyExpression = JSXEmptyExpression;
        var JSXExpressionContainer = function() {
          function JSXExpressionContainer2(expression) {
            this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
            this.expression = expression;
          }
          return JSXExpressionContainer2;
        }();
        exports2.JSXExpressionContainer = JSXExpressionContainer;
        var JSXIdentifier = function() {
          function JSXIdentifier2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
            this.name = name;
          }
          return JSXIdentifier2;
        }();
        exports2.JSXIdentifier = JSXIdentifier;
        var JSXMemberExpression = function() {
          function JSXMemberExpression2(object, property2) {
            this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
            this.object = object;
            this.property = property2;
          }
          return JSXMemberExpression2;
        }();
        exports2.JSXMemberExpression = JSXMemberExpression;
        var JSXAttribute = function() {
          function JSXAttribute2(name, value2) {
            this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
            this.name = name;
            this.value = value2;
          }
          return JSXAttribute2;
        }();
        exports2.JSXAttribute = JSXAttribute;
        var JSXNamespacedName = function() {
          function JSXNamespacedName2(namespace, name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
            this.namespace = namespace;
            this.name = name;
          }
          return JSXNamespacedName2;
        }();
        exports2.JSXNamespacedName = JSXNamespacedName;
        var JSXOpeningElement = function() {
          function JSXOpeningElement2(name, selfClosing, attributes) {
            this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
            this.name = name;
            this.selfClosing = selfClosing;
            this.attributes = attributes;
          }
          return JSXOpeningElement2;
        }();
        exports2.JSXOpeningElement = JSXOpeningElement;
        var JSXSpreadAttribute = function() {
          function JSXSpreadAttribute2(argument) {
            this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
            this.argument = argument;
          }
          return JSXSpreadAttribute2;
        }();
        exports2.JSXSpreadAttribute = JSXSpreadAttribute;
        var JSXText = function() {
          function JSXText2(value2, raw) {
            this.type = jsx_syntax_1.JSXSyntax.JSXText;
            this.value = value2;
            this.raw = raw;
          }
          return JSXText2;
        }();
        exports2.JSXText = JSXText;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.JSXSyntax = {
          JSXAttribute: "JSXAttribute",
          JSXClosingElement: "JSXClosingElement",
          JSXElement: "JSXElement",
          JSXEmptyExpression: "JSXEmptyExpression",
          JSXExpressionContainer: "JSXExpressionContainer",
          JSXIdentifier: "JSXIdentifier",
          JSXMemberExpression: "JSXMemberExpression",
          JSXNamespacedName: "JSXNamespacedName",
          JSXOpeningElement: "JSXOpeningElement",
          JSXSpreadAttribute: "JSXSpreadAttribute",
          JSXText: "JSXText"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var ArrayExpression = function() {
          function ArrayExpression2(elements) {
            this.type = syntax_1.Syntax.ArrayExpression;
            this.elements = elements;
          }
          return ArrayExpression2;
        }();
        exports2.ArrayExpression = ArrayExpression;
        var ArrayPattern = function() {
          function ArrayPattern2(elements) {
            this.type = syntax_1.Syntax.ArrayPattern;
            this.elements = elements;
          }
          return ArrayPattern2;
        }();
        exports2.ArrayPattern = ArrayPattern;
        var ArrowFunctionExpression = function() {
          function ArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = false;
          }
          return ArrowFunctionExpression2;
        }();
        exports2.ArrowFunctionExpression = ArrowFunctionExpression;
        var AssignmentExpression = function() {
          function AssignmentExpression2(operator, left2, right2) {
            this.type = syntax_1.Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left2;
            this.right = right2;
          }
          return AssignmentExpression2;
        }();
        exports2.AssignmentExpression = AssignmentExpression;
        var AssignmentPattern = function() {
          function AssignmentPattern2(left2, right2) {
            this.type = syntax_1.Syntax.AssignmentPattern;
            this.left = left2;
            this.right = right2;
          }
          return AssignmentPattern2;
        }();
        exports2.AssignmentPattern = AssignmentPattern;
        var AsyncArrowFunctionExpression = function() {
          function AsyncArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = true;
          }
          return AsyncArrowFunctionExpression2;
        }();
        exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
        var AsyncFunctionDeclaration = function() {
          function AsyncFunctionDeclaration2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionDeclaration2;
        }();
        exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
        var AsyncFunctionExpression = function() {
          function AsyncFunctionExpression2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionExpression2;
        }();
        exports2.AsyncFunctionExpression = AsyncFunctionExpression;
        var AwaitExpression = function() {
          function AwaitExpression2(argument) {
            this.type = syntax_1.Syntax.AwaitExpression;
            this.argument = argument;
          }
          return AwaitExpression2;
        }();
        exports2.AwaitExpression = AwaitExpression;
        var BinaryExpression = function() {
          function BinaryExpression2(operator, left2, right2) {
            var logical = operator === "||" || operator === "&&";
            this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left2;
            this.right = right2;
          }
          return BinaryExpression2;
        }();
        exports2.BinaryExpression = BinaryExpression;
        var BlockStatement = function() {
          function BlockStatement2(body) {
            this.type = syntax_1.Syntax.BlockStatement;
            this.body = body;
          }
          return BlockStatement2;
        }();
        exports2.BlockStatement = BlockStatement;
        var BreakStatement = function() {
          function BreakStatement2(label) {
            this.type = syntax_1.Syntax.BreakStatement;
            this.label = label;
          }
          return BreakStatement2;
        }();
        exports2.BreakStatement = BreakStatement;
        var CallExpression = function() {
          function CallExpression2(callee, args) {
            this.type = syntax_1.Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return CallExpression2;
        }();
        exports2.CallExpression = CallExpression;
        var CatchClause = function() {
          function CatchClause2(param, body) {
            this.type = syntax_1.Syntax.CatchClause;
            this.param = param;
            this.body = body;
          }
          return CatchClause2;
        }();
        exports2.CatchClause = CatchClause;
        var ClassBody = function() {
          function ClassBody2(body) {
            this.type = syntax_1.Syntax.ClassBody;
            this.body = body;
          }
          return ClassBody2;
        }();
        exports2.ClassBody = ClassBody;
        var ClassDeclaration = function() {
          function ClassDeclaration2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassDeclaration2;
        }();
        exports2.ClassDeclaration = ClassDeclaration;
        var ClassExpression = function() {
          function ClassExpression2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassExpression2;
        }();
        exports2.ClassExpression = ClassExpression;
        var ComputedMemberExpression = function() {
          function ComputedMemberExpression2(object, property2) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = true;
            this.object = object;
            this.property = property2;
          }
          return ComputedMemberExpression2;
        }();
        exports2.ComputedMemberExpression = ComputedMemberExpression;
        var ConditionalExpression = function() {
          function ConditionalExpression2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return ConditionalExpression2;
        }();
        exports2.ConditionalExpression = ConditionalExpression;
        var ContinueStatement = function() {
          function ContinueStatement2(label) {
            this.type = syntax_1.Syntax.ContinueStatement;
            this.label = label;
          }
          return ContinueStatement2;
        }();
        exports2.ContinueStatement = ContinueStatement;
        var DebuggerStatement = function() {
          function DebuggerStatement2() {
            this.type = syntax_1.Syntax.DebuggerStatement;
          }
          return DebuggerStatement2;
        }();
        exports2.DebuggerStatement = DebuggerStatement;
        var Directive = function() {
          function Directive2(expression, directive) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
            this.directive = directive;
          }
          return Directive2;
        }();
        exports2.Directive = Directive;
        var DoWhileStatement = function() {
          function DoWhileStatement2(body, test) {
            this.type = syntax_1.Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
          }
          return DoWhileStatement2;
        }();
        exports2.DoWhileStatement = DoWhileStatement;
        var EmptyStatement = function() {
          function EmptyStatement2() {
            this.type = syntax_1.Syntax.EmptyStatement;
          }
          return EmptyStatement2;
        }();
        exports2.EmptyStatement = EmptyStatement;
        var ExportAllDeclaration = function() {
          function ExportAllDeclaration2(source) {
            this.type = syntax_1.Syntax.ExportAllDeclaration;
            this.source = source;
          }
          return ExportAllDeclaration2;
        }();
        exports2.ExportAllDeclaration = ExportAllDeclaration;
        var ExportDefaultDeclaration = function() {
          function ExportDefaultDeclaration2(declaration) {
            this.type = syntax_1.Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
          }
          return ExportDefaultDeclaration2;
        }();
        exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
        var ExportNamedDeclaration = function() {
          function ExportNamedDeclaration2(declaration, specifiers, source) {
            this.type = syntax_1.Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ExportNamedDeclaration2;
        }();
        exports2.ExportNamedDeclaration = ExportNamedDeclaration;
        var ExportSpecifier = function() {
          function ExportSpecifier2(local, exported) {
            this.type = syntax_1.Syntax.ExportSpecifier;
            this.exported = exported;
            this.local = local;
          }
          return ExportSpecifier2;
        }();
        exports2.ExportSpecifier = ExportSpecifier;
        var ExpressionStatement = function() {
          function ExpressionStatement2(expression) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
          }
          return ExpressionStatement2;
        }();
        exports2.ExpressionStatement = ExpressionStatement;
        var ForInStatement = function() {
          function ForInStatement2(left2, right2, body) {
            this.type = syntax_1.Syntax.ForInStatement;
            this.left = left2;
            this.right = right2;
            this.body = body;
            this.each = false;
          }
          return ForInStatement2;
        }();
        exports2.ForInStatement = ForInStatement;
        var ForOfStatement = function() {
          function ForOfStatement2(left2, right2, body) {
            this.type = syntax_1.Syntax.ForOfStatement;
            this.left = left2;
            this.right = right2;
            this.body = body;
          }
          return ForOfStatement2;
        }();
        exports2.ForOfStatement = ForOfStatement;
        var ForStatement = function() {
          function ForStatement2(init, test, update, body) {
            this.type = syntax_1.Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
          }
          return ForStatement2;
        }();
        exports2.ForStatement = ForStatement;
        var FunctionDeclaration = function() {
          function FunctionDeclaration2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionDeclaration2;
        }();
        exports2.FunctionDeclaration = FunctionDeclaration;
        var FunctionExpression = function() {
          function FunctionExpression2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionExpression2;
        }();
        exports2.FunctionExpression = FunctionExpression;
        var Identifier = function() {
          function Identifier2(name) {
            this.type = syntax_1.Syntax.Identifier;
            this.name = name;
          }
          return Identifier2;
        }();
        exports2.Identifier = Identifier;
        var IfStatement = function() {
          function IfStatement2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return IfStatement2;
        }();
        exports2.IfStatement = IfStatement;
        var ImportDeclaration = function() {
          function ImportDeclaration2(specifiers, source) {
            this.type = syntax_1.Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ImportDeclaration2;
        }();
        exports2.ImportDeclaration = ImportDeclaration;
        var ImportDefaultSpecifier = function() {
          function ImportDefaultSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportDefaultSpecifier;
            this.local = local;
          }
          return ImportDefaultSpecifier2;
        }();
        exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
        var ImportNamespaceSpecifier = function() {
          function ImportNamespaceSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
            this.local = local;
          }
          return ImportNamespaceSpecifier2;
        }();
        exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
        var ImportSpecifier = function() {
          function ImportSpecifier2(local, imported) {
            this.type = syntax_1.Syntax.ImportSpecifier;
            this.local = local;
            this.imported = imported;
          }
          return ImportSpecifier2;
        }();
        exports2.ImportSpecifier = ImportSpecifier;
        var LabeledStatement = function() {
          function LabeledStatement2(label, body) {
            this.type = syntax_1.Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
          }
          return LabeledStatement2;
        }();
        exports2.LabeledStatement = LabeledStatement;
        var Literal = function() {
          function Literal2(value2, raw) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value2;
            this.raw = raw;
          }
          return Literal2;
        }();
        exports2.Literal = Literal;
        var MetaProperty = function() {
          function MetaProperty2(meta, property2) {
            this.type = syntax_1.Syntax.MetaProperty;
            this.meta = meta;
            this.property = property2;
          }
          return MetaProperty2;
        }();
        exports2.MetaProperty = MetaProperty;
        var MethodDefinition = function() {
          function MethodDefinition2(key, computed, value2, kind, isStatic) {
            this.type = syntax_1.Syntax.MethodDefinition;
            this.key = key;
            this.computed = computed;
            this.value = value2;
            this.kind = kind;
            this.static = isStatic;
          }
          return MethodDefinition2;
        }();
        exports2.MethodDefinition = MethodDefinition;
        var Module = function() {
          function Module2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "module";
          }
          return Module2;
        }();
        exports2.Module = Module;
        var NewExpression = function() {
          function NewExpression2(callee, args) {
            this.type = syntax_1.Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return NewExpression2;
        }();
        exports2.NewExpression = NewExpression;
        var ObjectExpression = function() {
          function ObjectExpression2(properties) {
            this.type = syntax_1.Syntax.ObjectExpression;
            this.properties = properties;
          }
          return ObjectExpression2;
        }();
        exports2.ObjectExpression = ObjectExpression;
        var ObjectPattern = function() {
          function ObjectPattern2(properties) {
            this.type = syntax_1.Syntax.ObjectPattern;
            this.properties = properties;
          }
          return ObjectPattern2;
        }();
        exports2.ObjectPattern = ObjectPattern;
        var Property = function() {
          function Property2(kind, key, computed, value2, method, shorthand) {
            this.type = syntax_1.Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value2;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
          }
          return Property2;
        }();
        exports2.Property = Property;
        var RegexLiteral = function() {
          function RegexLiteral2(value2, raw, pattern, flags) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value2;
            this.raw = raw;
            this.regex = { pattern, flags };
          }
          return RegexLiteral2;
        }();
        exports2.RegexLiteral = RegexLiteral;
        var RestElement = function() {
          function RestElement2(argument) {
            this.type = syntax_1.Syntax.RestElement;
            this.argument = argument;
          }
          return RestElement2;
        }();
        exports2.RestElement = RestElement;
        var ReturnStatement = function() {
          function ReturnStatement2(argument) {
            this.type = syntax_1.Syntax.ReturnStatement;
            this.argument = argument;
          }
          return ReturnStatement2;
        }();
        exports2.ReturnStatement = ReturnStatement;
        var Script = function() {
          function Script2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "script";
          }
          return Script2;
        }();
        exports2.Script = Script;
        var SequenceExpression = function() {
          function SequenceExpression2(expressions) {
            this.type = syntax_1.Syntax.SequenceExpression;
            this.expressions = expressions;
          }
          return SequenceExpression2;
        }();
        exports2.SequenceExpression = SequenceExpression;
        var SpreadElement = function() {
          function SpreadElement2(argument) {
            this.type = syntax_1.Syntax.SpreadElement;
            this.argument = argument;
          }
          return SpreadElement2;
        }();
        exports2.SpreadElement = SpreadElement;
        var StaticMemberExpression = function() {
          function StaticMemberExpression2(object, property2) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = false;
            this.object = object;
            this.property = property2;
          }
          return StaticMemberExpression2;
        }();
        exports2.StaticMemberExpression = StaticMemberExpression;
        var Super = function() {
          function Super2() {
            this.type = syntax_1.Syntax.Super;
          }
          return Super2;
        }();
        exports2.Super = Super;
        var SwitchCase = function() {
          function SwitchCase2(test, consequent) {
            this.type = syntax_1.Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
          }
          return SwitchCase2;
        }();
        exports2.SwitchCase = SwitchCase;
        var SwitchStatement = function() {
          function SwitchStatement2(discriminant, cases) {
            this.type = syntax_1.Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
          }
          return SwitchStatement2;
        }();
        exports2.SwitchStatement = SwitchStatement;
        var TaggedTemplateExpression = function() {
          function TaggedTemplateExpression2(tag2, quasi) {
            this.type = syntax_1.Syntax.TaggedTemplateExpression;
            this.tag = tag2;
            this.quasi = quasi;
          }
          return TaggedTemplateExpression2;
        }();
        exports2.TaggedTemplateExpression = TaggedTemplateExpression;
        var TemplateElement = function() {
          function TemplateElement2(value2, tail) {
            this.type = syntax_1.Syntax.TemplateElement;
            this.value = value2;
            this.tail = tail;
          }
          return TemplateElement2;
        }();
        exports2.TemplateElement = TemplateElement;
        var TemplateLiteral = function() {
          function TemplateLiteral2(quasis, expressions) {
            this.type = syntax_1.Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
          }
          return TemplateLiteral2;
        }();
        exports2.TemplateLiteral = TemplateLiteral;
        var ThisExpression = function() {
          function ThisExpression2() {
            this.type = syntax_1.Syntax.ThisExpression;
          }
          return ThisExpression2;
        }();
        exports2.ThisExpression = ThisExpression;
        var ThrowStatement = function() {
          function ThrowStatement2(argument) {
            this.type = syntax_1.Syntax.ThrowStatement;
            this.argument = argument;
          }
          return ThrowStatement2;
        }();
        exports2.ThrowStatement = ThrowStatement;
        var TryStatement = function() {
          function TryStatement2(block2, handler, finalizer) {
            this.type = syntax_1.Syntax.TryStatement;
            this.block = block2;
            this.handler = handler;
            this.finalizer = finalizer;
          }
          return TryStatement2;
        }();
        exports2.TryStatement = TryStatement;
        var UnaryExpression = function() {
          function UnaryExpression2(operator, argument) {
            this.type = syntax_1.Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
          }
          return UnaryExpression2;
        }();
        exports2.UnaryExpression = UnaryExpression;
        var UpdateExpression = function() {
          function UpdateExpression2(operator, argument, prefix) {
            this.type = syntax_1.Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = prefix;
          }
          return UpdateExpression2;
        }();
        exports2.UpdateExpression = UpdateExpression;
        var VariableDeclaration = function() {
          function VariableDeclaration2(declarations, kind) {
            this.type = syntax_1.Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
          }
          return VariableDeclaration2;
        }();
        exports2.VariableDeclaration = VariableDeclaration;
        var VariableDeclarator = function() {
          function VariableDeclarator2(id, init) {
            this.type = syntax_1.Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
          }
          return VariableDeclarator2;
        }();
        exports2.VariableDeclarator = VariableDeclarator;
        var WhileStatement = function() {
          function WhileStatement2(test, body) {
            this.type = syntax_1.Syntax.WhileStatement;
            this.test = test;
            this.body = body;
          }
          return WhileStatement2;
        }();
        exports2.WhileStatement = WhileStatement;
        var WithStatement = function() {
          function WithStatement2(object, body) {
            this.type = syntax_1.Syntax.WithStatement;
            this.object = object;
            this.body = body;
          }
          return WithStatement2;
        }();
        exports2.WithStatement = WithStatement;
        var YieldExpression = function() {
          function YieldExpression2(argument, delegate) {
            this.type = syntax_1.Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
          }
          return YieldExpression2;
        }();
        exports2.YieldExpression = YieldExpression;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var error_handler_1 = __webpack_require__(10);
        var messages_1 = __webpack_require__(11);
        var Node = __webpack_require__(7);
        var scanner_1 = __webpack_require__(12);
        var syntax_1 = __webpack_require__(2);
        var token_1 = __webpack_require__(13);
        var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
        var Parser2 = function() {
          function Parser3(code, options2, delegate) {
            if (options2 === undefined) {
              options2 = {};
            }
            this.config = {
              range: typeof options2.range === "boolean" && options2.range,
              loc: typeof options2.loc === "boolean" && options2.loc,
              source: null,
              tokens: typeof options2.tokens === "boolean" && options2.tokens,
              comment: typeof options2.comment === "boolean" && options2.comment,
              tolerant: typeof options2.tolerant === "boolean" && options2.tolerant
            };
            if (this.config.loc && options2.source && options2.source !== null) {
              this.config.source = String(options2.source);
            }
            this.delegate = delegate;
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = this.config.tolerant;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = this.config.comment;
            this.operatorPrecedence = {
              ")": 0,
              ";": 0,
              ",": 0,
              "=": 0,
              "]": 0,
              "||": 1,
              "&&": 2,
              "|": 3,
              "^": 4,
              "&": 5,
              "==": 6,
              "!=": 6,
              "===": 6,
              "!==": 6,
              "<": 7,
              ">": 7,
              "<=": 7,
              ">=": 7,
              "<<": 8,
              ">>": 8,
              ">>>": 8,
              "+": 9,
              "-": 9,
              "*": 11,
              "/": 11,
              "%": 11
            };
            this.lookahead = {
              type: 2,
              value: "",
              lineNumber: this.scanner.lineNumber,
              lineStart: 0,
              start: 0,
              end: 0
            };
            this.hasLineTerminator = false;
            this.context = {
              isModule: false,
              await: false,
              allowIn: true,
              allowStrictDirective: true,
              allowYield: true,
              firstCoverInitializedNameError: null,
              isAssignmentTarget: false,
              isBindingElement: false,
              inFunctionBody: false,
              inIteration: false,
              inSwitch: false,
              labelSet: {},
              strict: false
            };
            this.tokens = [];
            this.startMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.lastMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.nextToken();
            this.lastMarker = {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          }
          Parser3.prototype.throwError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
              assert_1.assert(idx < args.length, "Message reference must be in range");
              return args[idx];
            });
            var index = this.lastMarker.index;
            var line = this.lastMarker.line;
            var column = this.lastMarker.column + 1;
            throw this.errorHandler.createError(index, line, column, msg);
          };
          Parser3.prototype.tolerateError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
              assert_1.assert(idx < args.length, "Message reference must be in range");
              return args[idx];
            });
            var index = this.lastMarker.index;
            var line = this.scanner.lineNumber;
            var column = this.lastMarker.column + 1;
            this.errorHandler.tolerateError(index, line, column, msg);
          };
          Parser3.prototype.unexpectedTokenError = function(token, message) {
            var msg = message || messages_1.Messages.UnexpectedToken;
            var value2;
            if (token) {
              if (!message) {
                msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                if (token.type === 4) {
                  if (this.scanner.isFutureReservedWord(token.value)) {
                    msg = messages_1.Messages.UnexpectedReserved;
                  } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                    msg = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              value2 = token.value;
            } else {
              value2 = "ILLEGAL";
            }
            msg = msg.replace("%0", value2);
            if (token && typeof token.lineNumber === "number") {
              var index = token.start;
              var line = token.lineNumber;
              var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
              var column = token.start - lastMarkerLineStart + 1;
              return this.errorHandler.createError(index, line, column, msg);
            } else {
              var index = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              return this.errorHandler.createError(index, line, column, msg);
            }
          };
          Parser3.prototype.throwUnexpectedToken = function(token, message) {
            throw this.unexpectedTokenError(token, message);
          };
          Parser3.prototype.tolerateUnexpectedToken = function(token, message) {
            this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
          };
          Parser3.prototype.collectComments = function() {
            if (!this.config.comment) {
              this.scanner.scanComments();
            } else {
              var comments = this.scanner.scanComments();
              if (comments.length > 0 && this.delegate) {
                for (var i = 0;i < comments.length; ++i) {
                  var e = comments[i];
                  var node2 = undefined;
                  node2 = {
                    type: e.multiLine ? "BlockComment" : "LineComment",
                    value: this.scanner.source.slice(e.slice[0], e.slice[1])
                  };
                  if (this.config.range) {
                    node2.range = e.range;
                  }
                  if (this.config.loc) {
                    node2.loc = e.loc;
                  }
                  var metadata = {
                    start: {
                      line: e.loc.start.line,
                      column: e.loc.start.column,
                      offset: e.range[0]
                    },
                    end: {
                      line: e.loc.end.line,
                      column: e.loc.end.column,
                      offset: e.range[1]
                    }
                  };
                  this.delegate(node2, metadata);
                }
              }
            }
          };
          Parser3.prototype.getTokenRaw = function(token) {
            return this.scanner.source.slice(token.start, token.end);
          };
          Parser3.prototype.convertToken = function(token) {
            var t = {
              type: token_1.TokenName[token.type],
              value: this.getTokenRaw(token)
            };
            if (this.config.range) {
              t.range = [token.start, token.end];
            }
            if (this.config.loc) {
              t.loc = {
                start: {
                  line: this.startMarker.line,
                  column: this.startMarker.column
                },
                end: {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                }
              };
            }
            if (token.type === 9) {
              var pattern = token.pattern;
              var flags = token.flags;
              t.regex = { pattern, flags };
            }
            return t;
          };
          Parser3.prototype.nextToken = function() {
            var token = this.lookahead;
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            this.collectComments();
            if (this.scanner.index !== this.startMarker.index) {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            }
            var next = this.scanner.lex();
            this.hasLineTerminator = token.lineNumber !== next.lineNumber;
            if (next && this.context.strict && next.type === 3) {
              if (this.scanner.isStrictModeReservedWord(next.value)) {
                next.type = 4;
              }
            }
            this.lookahead = next;
            if (this.config.tokens && next.type !== 2) {
              this.tokens.push(this.convertToken(next));
            }
            return token;
          };
          Parser3.prototype.nextRegexToken = function() {
            this.collectComments();
            var token = this.scanner.scanRegExp();
            if (this.config.tokens) {
              this.tokens.pop();
              this.tokens.push(this.convertToken(token));
            }
            this.lookahead = token;
            this.nextToken();
            return token;
          };
          Parser3.prototype.createNode = function() {
            return {
              index: this.startMarker.index,
              line: this.startMarker.line,
              column: this.startMarker.column
            };
          };
          Parser3.prototype.startNode = function(token, lastLineStart) {
            if (lastLineStart === undefined) {
              lastLineStart = 0;
            }
            var column = token.start - token.lineStart;
            var line = token.lineNumber;
            if (column < 0) {
              column += lastLineStart;
              line--;
            }
            return {
              index: token.start,
              line,
              column
            };
          };
          Parser3.prototype.finalize = function(marker, node2) {
            if (this.config.range) {
              node2.range = [marker.index, this.lastMarker.index];
            }
            if (this.config.loc) {
              node2.loc = {
                start: {
                  line: marker.line,
                  column: marker.column
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column
                }
              };
              if (this.config.source) {
                node2.loc.source = this.config.source;
              }
            }
            if (this.delegate) {
              var metadata = {
                start: {
                  line: marker.line,
                  column: marker.column,
                  offset: marker.index
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column,
                  offset: this.lastMarker.index
                }
              };
              this.delegate(node2, metadata);
            }
            return node2;
          };
          Parser3.prototype.expect = function(value2) {
            var token = this.nextToken();
            if (token.type !== 7 || token.value !== value2) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser3.prototype.expectCommaSeparator = function() {
            if (this.config.tolerant) {
              var token = this.lookahead;
              if (token.type === 7 && token.value === ",") {
                this.nextToken();
              } else if (token.type === 7 && token.value === ";") {
                this.nextToken();
                this.tolerateUnexpectedToken(token);
              } else {
                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
              }
            } else {
              this.expect(",");
            }
          };
          Parser3.prototype.expectKeyword = function(keyword) {
            var token = this.nextToken();
            if (token.type !== 4 || token.value !== keyword) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser3.prototype.match = function(value2) {
            return this.lookahead.type === 7 && this.lookahead.value === value2;
          };
          Parser3.prototype.matchKeyword = function(keyword) {
            return this.lookahead.type === 4 && this.lookahead.value === keyword;
          };
          Parser3.prototype.matchContextualKeyword = function(keyword) {
            return this.lookahead.type === 3 && this.lookahead.value === keyword;
          };
          Parser3.prototype.matchAssign = function() {
            if (this.lookahead.type !== 7) {
              return false;
            }
            var op = this.lookahead.value;
            return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
          };
          Parser3.prototype.isolateCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            if (this.context.firstCoverInitializedNameError !== null) {
              this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
            }
            this.context.isBindingElement = previousIsBindingElement;
            this.context.isAssignmentTarget = previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
            return result;
          };
          Parser3.prototype.inheritCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
            this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
            return result;
          };
          Parser3.prototype.consumeSemicolon = function() {
            if (this.match(";")) {
              this.nextToken();
            } else if (!this.hasLineTerminator) {
              if (this.lookahead.type !== 2 && !this.match("}")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.lastMarker.index = this.startMarker.index;
              this.lastMarker.line = this.startMarker.line;
              this.lastMarker.column = this.startMarker.column;
            }
          };
          Parser3.prototype.parsePrimaryExpression = function() {
            var node2 = this.createNode();
            var expr;
            var token, raw;
            switch (this.lookahead.type) {
              case 3:
                if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                  this.tolerateUnexpectedToken(this.lookahead);
                }
                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node.Identifier(this.nextToken().value));
                break;
              case 6:
              case 8:
                if (this.context.strict && this.lookahead.octal) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node2, new Node.Literal(token.value, raw));
                break;
              case 1:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node2, new Node.Literal(token.value === "true", raw));
                break;
              case 5:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node2, new Node.Literal(null, raw));
                break;
              case 10:
                expr = this.parseTemplateLiteral();
                break;
              case 7:
                switch (this.lookahead.value) {
                  case "(":
                    this.context.isBindingElement = false;
                    expr = this.inheritCoverGrammar(this.parseGroupExpression);
                    break;
                  case "[":
                    expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                    break;
                  case "{":
                    expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                    break;
                  case "/":
                  case "/=":
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.scanner.index = this.startMarker.index;
                    token = this.nextRegexToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node2, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                break;
              case 4:
                if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseIdentifierName();
                } else if (!this.context.strict && this.matchKeyword("let")) {
                  expr = this.finalize(node2, new Node.Identifier(this.nextToken().value));
                } else {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  if (this.matchKeyword("function")) {
                    expr = this.parseFunctionExpression();
                  } else if (this.matchKeyword("this")) {
                    this.nextToken();
                    expr = this.finalize(node2, new Node.ThisExpression);
                  } else if (this.matchKeyword("class")) {
                    expr = this.parseClassExpression();
                  } else {
                    expr = this.throwUnexpectedToken(this.nextToken());
                  }
                }
                break;
              default:
                expr = this.throwUnexpectedToken(this.nextToken());
            }
            return expr;
          };
          Parser3.prototype.parseSpreadElement = function() {
            var node2 = this.createNode();
            this.expect("...");
            var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
            return this.finalize(node2, new Node.SpreadElement(arg));
          };
          Parser3.prototype.parseArrayInitializer = function() {
            var node2 = this.createNode();
            var elements = [];
            this.expect("[");
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else if (this.match("...")) {
                var element = this.parseSpreadElement();
                if (!this.match("]")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  this.expect(",");
                }
                elements.push(element);
              } else {
                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node2, new Node.ArrayExpression(elements));
          };
          Parser3.prototype.parsePropertyMethod = function(params) {
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = params.simple;
            var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
            if (this.context.strict && params.firstRestricted) {
              this.tolerateUnexpectedToken(params.firstRestricted, params.message);
            }
            if (this.context.strict && params.stricted) {
              this.tolerateUnexpectedToken(params.stricted, params.message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            return body;
          };
          Parser3.prototype.parsePropertyMethodFunction = function() {
            var isGenerator = false;
            var node2 = this.createNode();
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node2, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser3.prototype.parsePropertyMethodAsyncFunction = function() {
            var node2 = this.createNode();
            var previousAllowYield = this.context.allowYield;
            var previousAwait = this.context.await;
            this.context.allowYield = false;
            this.context.await = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            this.context.await = previousAwait;
            return this.finalize(node2, new Node.AsyncFunctionExpression(null, params.params, method));
          };
          Parser3.prototype.parseObjectPropertyKey = function() {
            var node2 = this.createNode();
            var token = this.nextToken();
            var key;
            switch (token.type) {
              case 8:
              case 6:
                if (this.context.strict && token.octal) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                }
                var raw = this.getTokenRaw(token);
                key = this.finalize(node2, new Node.Literal(token.value, raw));
                break;
              case 3:
              case 1:
              case 5:
              case 4:
                key = this.finalize(node2, new Node.Identifier(token.value));
                break;
              case 7:
                if (token.value === "[") {
                  key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.expect("]");
                } else {
                  key = this.throwUnexpectedToken(token);
                }
                break;
              default:
                key = this.throwUnexpectedToken(token);
            }
            return key;
          };
          Parser3.prototype.isPropertyKey = function(key, value2) {
            return key.type === syntax_1.Syntax.Identifier && key.name === value2 || key.type === syntax_1.Syntax.Literal && key.value === value2;
          };
          Parser3.prototype.parseObjectProperty = function(hasProto) {
            var node2 = this.createNode();
            var token = this.lookahead;
            var kind;
            var key = null;
            var value2 = null;
            var computed = false;
            var method = false;
            var shorthand = false;
            var isAsync2 = false;
            if (token.type === 3) {
              var id = token.value;
              this.nextToken();
              computed = this.match("[");
              isAsync2 = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
              key = isAsync2 ? this.parseObjectPropertyKey() : this.finalize(node2, new Node.Identifier(id));
            } else if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3 && !isAsync2 && token.value === "get" && lookaheadPropertyKey) {
              kind = "get";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.context.allowYield = false;
              value2 = this.parseGetterMethod();
            } else if (token.type === 3 && !isAsync2 && token.value === "set" && lookaheadPropertyKey) {
              kind = "set";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value2 = this.parseSetterMethod();
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value2 = this.parseGeneratorMethod();
              method = true;
            } else {
              if (!key) {
                this.throwUnexpectedToken(this.lookahead);
              }
              kind = "init";
              if (this.match(":") && !isAsync2) {
                if (!computed && this.isPropertyKey(key, "__proto__")) {
                  if (hasProto.value) {
                    this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                  }
                  hasProto.value = true;
                }
                this.nextToken();
                value2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
              } else if (this.match("(")) {
                value2 = isAsync2 ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              } else if (token.type === 3) {
                var id = this.finalize(node2, new Node.Identifier(token.value));
                if (this.match("=")) {
                  this.context.firstCoverInitializedNameError = this.lookahead;
                  this.nextToken();
                  shorthand = true;
                  var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  value2 = this.finalize(node2, new Node.AssignmentPattern(id, init));
                } else {
                  shorthand = true;
                  value2 = id;
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node2, new Node.Property(kind, key, computed, value2, method, shorthand));
          };
          Parser3.prototype.parseObjectInitializer = function() {
            var node2 = this.createNode();
            this.expect("{");
            var properties = [];
            var hasProto = { value: false };
            while (!this.match("}")) {
              properties.push(this.parseObjectProperty(hasProto));
              if (!this.match("}")) {
                this.expectCommaSeparator();
              }
            }
            this.expect("}");
            return this.finalize(node2, new Node.ObjectExpression(properties));
          };
          Parser3.prototype.parseTemplateHead = function() {
            assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
            var node2 = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node2, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser3.prototype.parseTemplateElement = function() {
            if (this.lookahead.type !== 10) {
              this.throwUnexpectedToken();
            }
            var node2 = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node2, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser3.prototype.parseTemplateLiteral = function() {
            var node2 = this.createNode();
            var expressions = [];
            var quasis = [];
            var quasi = this.parseTemplateHead();
            quasis.push(quasi);
            while (!quasi.tail) {
              expressions.push(this.parseExpression());
              quasi = this.parseTemplateElement();
              quasis.push(quasi);
            }
            return this.finalize(node2, new Node.TemplateLiteral(quasis, expressions));
          };
          Parser3.prototype.reinterpretExpressionAsPattern = function(expr) {
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
              case syntax_1.Syntax.MemberExpression:
              case syntax_1.Syntax.RestElement:
              case syntax_1.Syntax.AssignmentPattern:
                break;
              case syntax_1.Syntax.SpreadElement:
                expr.type = syntax_1.Syntax.RestElement;
                this.reinterpretExpressionAsPattern(expr.argument);
                break;
              case syntax_1.Syntax.ArrayExpression:
                expr.type = syntax_1.Syntax.ArrayPattern;
                for (var i = 0;i < expr.elements.length; i++) {
                  if (expr.elements[i] !== null) {
                    this.reinterpretExpressionAsPattern(expr.elements[i]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectExpression:
                expr.type = syntax_1.Syntax.ObjectPattern;
                for (var i = 0;i < expr.properties.length; i++) {
                  this.reinterpretExpressionAsPattern(expr.properties[i].value);
                }
                break;
              case syntax_1.Syntax.AssignmentExpression:
                expr.type = syntax_1.Syntax.AssignmentPattern;
                delete expr.operator;
                this.reinterpretExpressionAsPattern(expr.left);
                break;
              default:
                break;
            }
          };
          Parser3.prototype.parseGroupExpression = function() {
            var expr;
            this.expect("(");
            if (this.match(")")) {
              this.nextToken();
              if (!this.match("=>")) {
                this.expect("=>");
              }
              expr = {
                type: ArrowParameterPlaceHolder,
                params: [],
                async: false
              };
            } else {
              var startToken = this.lookahead;
              var params = [];
              if (this.match("...")) {
                expr = this.parseRestElement(params);
                this.expect(")");
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [expr],
                  async: false
                };
              } else {
                var arrow = false;
                this.context.isBindingElement = true;
                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  this.context.isAssignmentTarget = false;
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    if (this.match(")")) {
                      this.nextToken();
                      for (var i = 0;i < expressions.length; i++) {
                        this.reinterpretExpressionAsPattern(expressions[i]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else if (this.match("...")) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      expressions.push(this.parseRestElement(params));
                      this.expect(")");
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      this.context.isBindingElement = false;
                      for (var i = 0;i < expressions.length; i++) {
                        this.reinterpretExpressionAsPattern(expressions[i]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else {
                      expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    }
                    if (arrow) {
                      break;
                    }
                  }
                  if (!arrow) {
                    expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                  }
                }
                if (!arrow) {
                  this.expect(")");
                  if (this.match("=>")) {
                    if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [expr],
                        async: false
                      };
                    }
                    if (!arrow) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      if (expr.type === syntax_1.Syntax.SequenceExpression) {
                        for (var i = 0;i < expr.expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expr.expressions[i]);
                        }
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: parameters,
                        async: false
                      };
                    }
                  }
                  this.context.isBindingElement = false;
                }
              }
            }
            return expr;
          };
          Parser3.prototype.parseArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser3.prototype.isIdentifierName = function(token) {
            return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
          };
          Parser3.prototype.parseIdentifierName = function() {
            var node2 = this.createNode();
            var token = this.nextToken();
            if (!this.isIdentifierName(token)) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node2, new Node.Identifier(token.value));
          };
          Parser3.prototype.parseNewExpression = function() {
            var node2 = this.createNode();
            var id = this.parseIdentifierName();
            assert_1.assert(id.name === "new", "New expression must start with `new`");
            var expr;
            if (this.match(".")) {
              this.nextToken();
              if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                var property2 = this.parseIdentifierName();
                expr = new Node.MetaProperty(id, property2);
              } else {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
              var args = this.match("(") ? this.parseArguments() : [];
              expr = new Node.NewExpression(callee, args);
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return this.finalize(node2, expr);
          };
          Parser3.prototype.parseAsyncArgument = function() {
            var arg = this.parseAssignmentExpression();
            this.context.firstCoverInitializedNameError = null;
            return arg;
          };
          Parser3.prototype.parseAsyncArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser3.prototype.parseLeftHandSideExpressionAllowCall = function() {
            var startToken = this.lookahead;
            var maybeAsync = this.matchContextualKeyword("async");
            var previousAllowIn = this.context.allowIn;
            this.context.allowIn = true;
            var expr;
            if (this.matchKeyword("super") && this.context.inFunctionBody) {
              expr = this.createNode();
              this.nextToken();
              expr = this.finalize(expr, new Node.Super);
              if (!this.match("(") && !this.match(".") && !this.match("[")) {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            }
            while (true) {
              if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property2 = this.parseIdentifierName();
                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property2));
              } else if (this.match("(")) {
                var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = false;
                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                if (asyncArrow && this.match("=>")) {
                  for (var i = 0;i < args.length; ++i) {
                    this.reinterpretExpressionAsPattern(args[i]);
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: args,
                    async: true
                  };
                }
              } else if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property2 = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property2));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            this.context.allowIn = previousAllowIn;
            return expr;
          };
          Parser3.prototype.parseSuper = function() {
            var node2 = this.createNode();
            this.expectKeyword("super");
            if (!this.match("[") && !this.match(".")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            return this.finalize(node2, new Node.Super);
          };
          Parser3.prototype.parseLeftHandSideExpression = function() {
            assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
            var node2 = this.startNode(this.lookahead);
            var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            while (true) {
              if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property2 = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(node2, new Node.ComputedMemberExpression(expr, property2));
              } else if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property2 = this.parseIdentifierName();
                expr = this.finalize(node2, new Node.StaticMemberExpression(expr, property2));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(node2, new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            return expr;
          };
          Parser3.prototype.parseUpdateExpression = function() {
            var expr;
            var startToken = this.lookahead;
            if (this.match("++") || this.match("--")) {
              var node2 = this.startNode(startToken);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
              }
              if (!this.context.isAssignmentTarget) {
                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
              }
              var prefix = true;
              expr = this.finalize(node2, new Node.UpdateExpression(token.value, expr, prefix));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else {
              expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              if (!this.hasLineTerminator && this.lookahead.type === 7) {
                if (this.match("++") || this.match("--")) {
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var operator = this.nextToken().value;
                  var prefix = false;
                  expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                }
              }
            }
            return expr;
          };
          Parser3.prototype.parseAwaitExpression = function() {
            var node2 = this.createNode();
            this.nextToken();
            var argument = this.parseUnaryExpression();
            return this.finalize(node2, new Node.AwaitExpression(argument));
          };
          Parser3.prototype.parseUnaryExpression = function() {
            var expr;
            if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
              var node2 = this.startNode(this.lookahead);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              expr = this.finalize(node2, new Node.UnaryExpression(token.value, expr));
              if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                this.tolerateError(messages_1.Messages.StrictDelete);
              }
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else if (this.context.await && this.matchContextualKeyword("await")) {
              expr = this.parseAwaitExpression();
            } else {
              expr = this.parseUpdateExpression();
            }
            return expr;
          };
          Parser3.prototype.parseExponentiationExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var left2 = expr;
              var right2 = this.isolateCoverGrammar(this.parseExponentiationExpression);
              expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left2, right2));
            }
            return expr;
          };
          Parser3.prototype.binaryPrecedence = function(token) {
            var op = token.value;
            var precedence;
            if (token.type === 7) {
              precedence = this.operatorPrecedence[op] || 0;
            } else if (token.type === 4) {
              precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
            } else {
              precedence = 0;
            }
            return precedence;
          };
          Parser3.prototype.parseBinaryExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
            var token = this.lookahead;
            var prec = this.binaryPrecedence(token);
            if (prec > 0) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var markers = [startToken, this.lookahead];
              var left2 = expr;
              var right2 = this.isolateCoverGrammar(this.parseExponentiationExpression);
              var stack = [left2, token.value, right2];
              var precedences = [prec];
              while (true) {
                prec = this.binaryPrecedence(this.lookahead);
                if (prec <= 0) {
                  break;
                }
                while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                  right2 = stack.pop();
                  var operator = stack.pop();
                  precedences.pop();
                  left2 = stack.pop();
                  markers.pop();
                  var node2 = this.startNode(markers[markers.length - 1]);
                  stack.push(this.finalize(node2, new Node.BinaryExpression(operator, left2, right2)));
                }
                stack.push(this.nextToken().value);
                precedences.push(prec);
                markers.push(this.lookahead);
                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
              }
              var i = stack.length - 1;
              expr = stack[i];
              var lastMarker = markers.pop();
              while (i > 1) {
                var marker = markers.pop();
                var lastLineStart = lastMarker && lastMarker.lineStart;
                var node2 = this.startNode(marker, lastLineStart);
                var operator = stack[i - 1];
                expr = this.finalize(node2, new Node.BinaryExpression(operator, stack[i - 2], expr));
                i -= 2;
                lastMarker = marker;
              }
            }
            return expr;
          };
          Parser3.prototype.parseConditionalExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
            if (this.match("?")) {
              this.nextToken();
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowIn = previousAllowIn;
              this.expect(":");
              var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
              expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return expr;
          };
          Parser3.prototype.checkPatternParam = function(options2, param) {
            switch (param.type) {
              case syntax_1.Syntax.Identifier:
                this.validateParam(options2, param, param.name);
                break;
              case syntax_1.Syntax.RestElement:
                this.checkPatternParam(options2, param.argument);
                break;
              case syntax_1.Syntax.AssignmentPattern:
                this.checkPatternParam(options2, param.left);
                break;
              case syntax_1.Syntax.ArrayPattern:
                for (var i = 0;i < param.elements.length; i++) {
                  if (param.elements[i] !== null) {
                    this.checkPatternParam(options2, param.elements[i]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectPattern:
                for (var i = 0;i < param.properties.length; i++) {
                  this.checkPatternParam(options2, param.properties[i].value);
                }
                break;
              default:
                break;
            }
            options2.simple = options2.simple && param instanceof Node.Identifier;
          };
          Parser3.prototype.reinterpretAsCoverFormalsList = function(expr) {
            var params = [expr];
            var options2;
            var asyncArrow = false;
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
                break;
              case ArrowParameterPlaceHolder:
                params = expr.params;
                asyncArrow = expr.async;
                break;
              default:
                return null;
            }
            options2 = {
              simple: true,
              paramSet: {}
            };
            for (var i = 0;i < params.length; ++i) {
              var param = params[i];
              if (param.type === syntax_1.Syntax.AssignmentPattern) {
                if (param.right.type === syntax_1.Syntax.YieldExpression) {
                  if (param.right.argument) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  param.right.type = syntax_1.Syntax.Identifier;
                  param.right.name = "yield";
                  delete param.right.argument;
                  delete param.right.delegate;
                }
              } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.checkPatternParam(options2, param);
              params[i] = param;
            }
            if (this.context.strict || !this.context.allowYield) {
              for (var i = 0;i < params.length; ++i) {
                var param = params[i];
                if (param.type === syntax_1.Syntax.YieldExpression) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              }
            }
            if (options2.message === messages_1.Messages.StrictParamDupe) {
              var token = this.context.strict ? options2.stricted : options2.firstRestricted;
              this.throwUnexpectedToken(token, options2.message);
            }
            return {
              simple: options2.simple,
              params,
              stricted: options2.stricted,
              firstRestricted: options2.firstRestricted,
              message: options2.message
            };
          };
          Parser3.prototype.parseAssignmentExpression = function() {
            var expr;
            if (!this.context.allowYield && this.matchKeyword("yield")) {
              expr = this.parseYieldExpression();
            } else {
              var startToken = this.lookahead;
              var token = startToken;
              expr = this.parseConditionalExpression();
              if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                  var arg = this.parsePrimaryExpression();
                  this.reinterpretExpressionAsPattern(arg);
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [arg],
                    async: true
                  };
                }
              }
              if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var isAsync2 = expr.async;
                var list2 = this.reinterpretAsCoverFormalsList(expr);
                if (list2) {
                  if (this.hasLineTerminator) {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  this.context.firstCoverInitializedNameError = null;
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = list2.simple;
                  var previousAllowYield = this.context.allowYield;
                  var previousAwait = this.context.await;
                  this.context.allowYield = true;
                  this.context.await = isAsync2;
                  var node2 = this.startNode(startToken);
                  this.expect("=>");
                  var body = undefined;
                  if (this.match("{")) {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    body = this.parseFunctionSourceElements();
                    this.context.allowIn = previousAllowIn;
                  } else {
                    body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  }
                  var expression = body.type !== syntax_1.Syntax.BlockStatement;
                  if (this.context.strict && list2.firstRestricted) {
                    this.throwUnexpectedToken(list2.firstRestricted, list2.message);
                  }
                  if (this.context.strict && list2.stricted) {
                    this.tolerateUnexpectedToken(list2.stricted, list2.message);
                  }
                  expr = isAsync2 ? this.finalize(node2, new Node.AsyncArrowFunctionExpression(list2.params, body, expression)) : this.finalize(node2, new Node.ArrowFunctionExpression(list2.params, body, expression));
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  this.context.allowYield = previousAllowYield;
                  this.context.await = previousAwait;
                }
              } else {
                if (this.matchAssign()) {
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                    var id = expr;
                    if (this.scanner.isRestrictedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                    }
                    if (this.scanner.isStrictModeReservedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                    }
                  }
                  if (!this.match("=")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  } else {
                    this.reinterpretExpressionAsPattern(expr);
                  }
                  token = this.nextToken();
                  var operator = token.value;
                  var right2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right2));
                  this.context.firstCoverInitializedNameError = null;
                }
              }
            }
            return expr;
          };
          Parser3.prototype.parseExpression = function() {
            var startToken = this.lookahead;
            var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
            if (this.match(",")) {
              var expressions = [];
              expressions.push(expr);
              while (this.lookahead.type !== 2) {
                if (!this.match(",")) {
                  break;
                }
                this.nextToken();
                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
              }
              expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
            }
            return expr;
          };
          Parser3.prototype.parseStatementListItem = function() {
            var statement;
            this.context.isAssignmentTarget = true;
            this.context.isBindingElement = true;
            if (this.lookahead.type === 4) {
              switch (this.lookahead.value) {
                case "export":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                  }
                  statement = this.parseExportDeclaration();
                  break;
                case "import":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                  }
                  statement = this.parseImportDeclaration();
                  break;
                case "const":
                  statement = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "function":
                  statement = this.parseFunctionDeclaration();
                  break;
                case "class":
                  statement = this.parseClassDeclaration();
                  break;
                case "let":
                  statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                  break;
                default:
                  statement = this.parseStatement();
                  break;
              }
            } else {
              statement = this.parseStatement();
            }
            return statement;
          };
          Parser3.prototype.parseBlock = function() {
            var node2 = this.createNode();
            this.expect("{");
            var block2 = [];
            while (true) {
              if (this.match("}")) {
                break;
              }
              block2.push(this.parseStatementListItem());
            }
            this.expect("}");
            return this.finalize(node2, new Node.BlockStatement(block2));
          };
          Parser3.prototype.parseLexicalBinding = function(kind, options2) {
            var node2 = this.createNode();
            var params = [];
            var id = this.parsePattern(params, kind);
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (kind === "const") {
              if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else {
                  this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                }
              }
            } else if (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
              this.expect("=");
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            }
            return this.finalize(node2, new Node.VariableDeclarator(id, init));
          };
          Parser3.prototype.parseBindingList = function(kind, options2) {
            var list2 = [this.parseLexicalBinding(kind, options2)];
            while (this.match(",")) {
              this.nextToken();
              list2.push(this.parseLexicalBinding(kind, options2));
            }
            return list2;
          };
          Parser3.prototype.isLexicalDeclaration = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.scanner.lex();
            this.scanner.restoreState(state);
            return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
          };
          Parser3.prototype.parseLexicalDeclaration = function(options2) {
            var node2 = this.createNode();
            var kind = this.nextToken().value;
            assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
            var declarations = this.parseBindingList(kind, options2);
            this.consumeSemicolon();
            return this.finalize(node2, new Node.VariableDeclaration(declarations, kind));
          };
          Parser3.prototype.parseBindingRestElement = function(params, kind) {
            var node2 = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params, kind);
            return this.finalize(node2, new Node.RestElement(arg));
          };
          Parser3.prototype.parseArrayPattern = function(params, kind) {
            var node2 = this.createNode();
            this.expect("[");
            var elements = [];
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else {
                if (this.match("...")) {
                  elements.push(this.parseBindingRestElement(params, kind));
                  break;
                } else {
                  elements.push(this.parsePatternWithDefault(params, kind));
                }
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node2, new Node.ArrayPattern(elements));
          };
          Parser3.prototype.parsePropertyPattern = function(params, kind) {
            var node2 = this.createNode();
            var computed = false;
            var shorthand = false;
            var method = false;
            var key;
            var value2;
            if (this.lookahead.type === 3) {
              var keyToken = this.lookahead;
              key = this.parseVariableIdentifier();
              var init = this.finalize(node2, new Node.Identifier(keyToken.value));
              if (this.match("=")) {
                params.push(keyToken);
                shorthand = true;
                this.nextToken();
                var expr = this.parseAssignmentExpression();
                value2 = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
              } else if (!this.match(":")) {
                params.push(keyToken);
                shorthand = true;
                value2 = init;
              } else {
                this.expect(":");
                value2 = this.parsePatternWithDefault(params, kind);
              }
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.expect(":");
              value2 = this.parsePatternWithDefault(params, kind);
            }
            return this.finalize(node2, new Node.Property("init", key, computed, value2, method, shorthand));
          };
          Parser3.prototype.parseObjectPattern = function(params, kind) {
            var node2 = this.createNode();
            var properties = [];
            this.expect("{");
            while (!this.match("}")) {
              properties.push(this.parsePropertyPattern(params, kind));
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return this.finalize(node2, new Node.ObjectPattern(properties));
          };
          Parser3.prototype.parsePattern = function(params, kind) {
            var pattern;
            if (this.match("[")) {
              pattern = this.parseArrayPattern(params, kind);
            } else if (this.match("{")) {
              pattern = this.parseObjectPattern(params, kind);
            } else {
              if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
              }
              params.push(this.lookahead);
              pattern = this.parseVariableIdentifier(kind);
            }
            return pattern;
          };
          Parser3.prototype.parsePatternWithDefault = function(params, kind) {
            var startToken = this.lookahead;
            var pattern = this.parsePattern(params, kind);
            if (this.match("=")) {
              this.nextToken();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var right2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowYield = previousAllowYield;
              pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right2));
            }
            return pattern;
          };
          Parser3.prototype.parseVariableIdentifier = function(kind) {
            var node2 = this.createNode();
            var token = this.nextToken();
            if (token.type === 4 && token.value === "yield") {
              if (this.context.strict) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else if (!this.context.allowYield) {
                this.throwUnexpectedToken(token);
              }
            } else if (token.type !== 3) {
              if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else {
                if (this.context.strict || token.value !== "let" || kind !== "var") {
                  this.throwUnexpectedToken(token);
                }
              }
            } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
              this.tolerateUnexpectedToken(token);
            }
            return this.finalize(node2, new Node.Identifier(token.value));
          };
          Parser3.prototype.parseVariableDeclaration = function(options2) {
            var node2 = this.createNode();
            var params = [];
            var id = this.parsePattern(params, "var");
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (this.match("=")) {
              this.nextToken();
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            } else if (id.type !== syntax_1.Syntax.Identifier && !options2.inFor) {
              this.expect("=");
            }
            return this.finalize(node2, new Node.VariableDeclarator(id, init));
          };
          Parser3.prototype.parseVariableDeclarationList = function(options2) {
            var opt = { inFor: options2.inFor };
            var list2 = [];
            list2.push(this.parseVariableDeclaration(opt));
            while (this.match(",")) {
              this.nextToken();
              list2.push(this.parseVariableDeclaration(opt));
            }
            return list2;
          };
          Parser3.prototype.parseVariableStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("var");
            var declarations = this.parseVariableDeclarationList({ inFor: false });
            this.consumeSemicolon();
            return this.finalize(node2, new Node.VariableDeclaration(declarations, "var"));
          };
          Parser3.prototype.parseEmptyStatement = function() {
            var node2 = this.createNode();
            this.expect(";");
            return this.finalize(node2, new Node.EmptyStatement);
          };
          Parser3.prototype.parseExpressionStatement = function() {
            var node2 = this.createNode();
            var expr = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node2, new Node.ExpressionStatement(expr));
          };
          Parser3.prototype.parseIfClause = function() {
            if (this.context.strict && this.matchKeyword("function")) {
              this.tolerateError(messages_1.Messages.StrictFunction);
            }
            return this.parseStatement();
          };
          Parser3.prototype.parseIfStatement = function() {
            var node2 = this.createNode();
            var consequent;
            var alternate = null;
            this.expectKeyword("if");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              consequent = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              consequent = this.parseIfClause();
              if (this.matchKeyword("else")) {
                this.nextToken();
                alternate = this.parseIfClause();
              }
            }
            return this.finalize(node2, new Node.IfStatement(test, consequent, alternate));
          };
          Parser3.prototype.parseDoWhileStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("do");
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            var body = this.parseStatement();
            this.context.inIteration = previousInIteration;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
            } else {
              this.expect(")");
              if (this.match(";")) {
                this.nextToken();
              }
            }
            return this.finalize(node2, new Node.DoWhileStatement(body, test));
          };
          Parser3.prototype.parseWhileStatement = function() {
            var node2 = this.createNode();
            var body;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.parseStatement();
              this.context.inIteration = previousInIteration;
            }
            return this.finalize(node2, new Node.WhileStatement(test, body));
          };
          Parser3.prototype.parseForStatement = function() {
            var init = null;
            var test = null;
            var update = null;
            var forIn = true;
            var left2, right2;
            var node2 = this.createNode();
            this.expectKeyword("for");
            this.expect("(");
            if (this.match(";")) {
              this.nextToken();
            } else {
              if (this.matchKeyword("var")) {
                init = this.createNode();
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                var declarations = this.parseVariableDeclarationList({ inFor: true });
                this.context.allowIn = previousAllowIn;
                if (declarations.length === 1 && this.matchKeyword("in")) {
                  var decl = declarations[0];
                  if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                    this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                  }
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left2 = init;
                  right2 = this.parseExpression();
                  init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left2 = init;
                  right2 = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.expect(";");
                }
              } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                init = this.createNode();
                var kind = this.nextToken().value;
                if (!this.context.strict && this.lookahead.value === "in") {
                  init = this.finalize(init, new Node.Identifier(kind));
                  this.nextToken();
                  left2 = init;
                  right2 = this.parseExpression();
                  init = null;
                } else {
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseBindingList(kind, { inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    this.nextToken();
                    left2 = init;
                    right2 = this.parseExpression();
                    init = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    this.nextToken();
                    left2 = init;
                    right2 = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    this.consumeSemicolon();
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                  }
                }
              } else {
                var initStartToken = this.lookahead;
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                if (this.matchKeyword("in")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left2 = init;
                  right2 = this.parseExpression();
                  init = null;
                } else if (this.matchContextualKeyword("of")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left2 = init;
                  right2 = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  if (this.match(",")) {
                    var initSeq = [init];
                    while (this.match(",")) {
                      this.nextToken();
                      initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                    }
                    init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                  }
                  this.expect(";");
                }
              }
            }
            if (typeof left2 === "undefined") {
              if (!this.match(";")) {
                test = this.parseExpression();
              }
              this.expect(";");
              if (!this.match(")")) {
                update = this.parseExpression();
              }
            }
            var body;
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.isolateCoverGrammar(this.parseStatement);
              this.context.inIteration = previousInIteration;
            }
            return typeof left2 === "undefined" ? this.finalize(node2, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node2, new Node.ForInStatement(left2, right2, body)) : this.finalize(node2, new Node.ForOfStatement(left2, right2, body));
          };
          Parser3.prototype.parseContinueStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("continue");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              label = id;
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration) {
              this.throwError(messages_1.Messages.IllegalContinue);
            }
            return this.finalize(node2, new Node.ContinueStatement(label));
          };
          Parser3.prototype.parseBreakStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("break");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
              label = id;
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration && !this.context.inSwitch) {
              this.throwError(messages_1.Messages.IllegalBreak);
            }
            return this.finalize(node2, new Node.BreakStatement(label));
          };
          Parser3.prototype.parseReturnStatement = function() {
            if (!this.context.inFunctionBody) {
              this.tolerateError(messages_1.Messages.IllegalReturn);
            }
            var node2 = this.createNode();
            this.expectKeyword("return");
            var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
            var argument = hasArgument ? this.parseExpression() : null;
            this.consumeSemicolon();
            return this.finalize(node2, new Node.ReturnStatement(argument));
          };
          Parser3.prototype.parseWithStatement = function() {
            if (this.context.strict) {
              this.tolerateError(messages_1.Messages.StrictModeWith);
            }
            var node2 = this.createNode();
            var body;
            this.expectKeyword("with");
            this.expect("(");
            var object = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              body = this.parseStatement();
            }
            return this.finalize(node2, new Node.WithStatement(object, body));
          };
          Parser3.prototype.parseSwitchCase = function() {
            var node2 = this.createNode();
            var test;
            if (this.matchKeyword("default")) {
              this.nextToken();
              test = null;
            } else {
              this.expectKeyword("case");
              test = this.parseExpression();
            }
            this.expect(":");
            var consequent = [];
            while (true) {
              if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                break;
              }
              consequent.push(this.parseStatementListItem());
            }
            return this.finalize(node2, new Node.SwitchCase(test, consequent));
          };
          Parser3.prototype.parseSwitchStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("switch");
            this.expect("(");
            var discriminant = this.parseExpression();
            this.expect(")");
            var previousInSwitch = this.context.inSwitch;
            this.context.inSwitch = true;
            var cases = [];
            var defaultFound = false;
            this.expect("{");
            while (true) {
              if (this.match("}")) {
                break;
              }
              var clause = this.parseSwitchCase();
              if (clause.test === null) {
                if (defaultFound) {
                  this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
              }
              cases.push(clause);
            }
            this.expect("}");
            this.context.inSwitch = previousInSwitch;
            return this.finalize(node2, new Node.SwitchStatement(discriminant, cases));
          };
          Parser3.prototype.parseLabelledStatement = function() {
            var node2 = this.createNode();
            var expr = this.parseExpression();
            var statement;
            if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
              this.nextToken();
              var id = expr;
              var key = "$" + id.name;
              if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
              }
              this.context.labelSet[key] = true;
              var body = undefined;
              if (this.matchKeyword("class")) {
                this.tolerateUnexpectedToken(this.lookahead);
                body = this.parseClassDeclaration();
              } else if (this.matchKeyword("function")) {
                var token = this.lookahead;
                var declaration = this.parseFunctionDeclaration();
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                } else if (declaration.generator) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                }
                body = declaration;
              } else {
                body = this.parseStatement();
              }
              delete this.context.labelSet[key];
              statement = new Node.LabeledStatement(id, body);
            } else {
              this.consumeSemicolon();
              statement = new Node.ExpressionStatement(expr);
            }
            return this.finalize(node2, statement);
          };
          Parser3.prototype.parseThrowStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("throw");
            if (this.hasLineTerminator) {
              this.throwError(messages_1.Messages.NewlineAfterThrow);
            }
            var argument = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node2, new Node.ThrowStatement(argument));
          };
          Parser3.prototype.parseCatchClause = function() {
            var node2 = this.createNode();
            this.expectKeyword("catch");
            this.expect("(");
            if (this.match(")")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            var params = [];
            var param = this.parsePattern(params);
            var paramMap = {};
            for (var i = 0;i < params.length; i++) {
              var key = "$" + params[i].value;
              if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
              }
              paramMap[key] = true;
            }
            if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(param.name)) {
                this.tolerateError(messages_1.Messages.StrictCatchVariable);
              }
            }
            this.expect(")");
            var body = this.parseBlock();
            return this.finalize(node2, new Node.CatchClause(param, body));
          };
          Parser3.prototype.parseFinallyClause = function() {
            this.expectKeyword("finally");
            return this.parseBlock();
          };
          Parser3.prototype.parseTryStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("try");
            var block2 = this.parseBlock();
            var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
            var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
            if (!handler && !finalizer) {
              this.throwError(messages_1.Messages.NoCatchOrFinally);
            }
            return this.finalize(node2, new Node.TryStatement(block2, handler, finalizer));
          };
          Parser3.prototype.parseDebuggerStatement = function() {
            var node2 = this.createNode();
            this.expectKeyword("debugger");
            this.consumeSemicolon();
            return this.finalize(node2, new Node.DebuggerStatement);
          };
          Parser3.prototype.parseStatement = function() {
            var statement;
            switch (this.lookahead.type) {
              case 1:
              case 5:
              case 6:
              case 8:
              case 10:
              case 9:
                statement = this.parseExpressionStatement();
                break;
              case 7:
                var value2 = this.lookahead.value;
                if (value2 === "{") {
                  statement = this.parseBlock();
                } else if (value2 === "(") {
                  statement = this.parseExpressionStatement();
                } else if (value2 === ";") {
                  statement = this.parseEmptyStatement();
                } else {
                  statement = this.parseExpressionStatement();
                }
                break;
              case 3:
                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                break;
              case 4:
                switch (this.lookahead.value) {
                  case "break":
                    statement = this.parseBreakStatement();
                    break;
                  case "continue":
                    statement = this.parseContinueStatement();
                    break;
                  case "debugger":
                    statement = this.parseDebuggerStatement();
                    break;
                  case "do":
                    statement = this.parseDoWhileStatement();
                    break;
                  case "for":
                    statement = this.parseForStatement();
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "if":
                    statement = this.parseIfStatement();
                    break;
                  case "return":
                    statement = this.parseReturnStatement();
                    break;
                  case "switch":
                    statement = this.parseSwitchStatement();
                    break;
                  case "throw":
                    statement = this.parseThrowStatement();
                    break;
                  case "try":
                    statement = this.parseTryStatement();
                    break;
                  case "var":
                    statement = this.parseVariableStatement();
                    break;
                  case "while":
                    statement = this.parseWhileStatement();
                    break;
                  case "with":
                    statement = this.parseWithStatement();
                    break;
                  default:
                    statement = this.parseExpressionStatement();
                    break;
                }
                break;
              default:
                statement = this.throwUnexpectedToken(this.lookahead);
            }
            return statement;
          };
          Parser3.prototype.parseFunctionSourceElements = function() {
            var node2 = this.createNode();
            this.expect("{");
            var body = this.parseDirectivePrologues();
            var previousLabelSet = this.context.labelSet;
            var previousInIteration = this.context.inIteration;
            var previousInSwitch = this.context.inSwitch;
            var previousInFunctionBody = this.context.inFunctionBody;
            this.context.labelSet = {};
            this.context.inIteration = false;
            this.context.inSwitch = false;
            this.context.inFunctionBody = true;
            while (this.lookahead.type !== 2) {
              if (this.match("}")) {
                break;
              }
              body.push(this.parseStatementListItem());
            }
            this.expect("}");
            this.context.labelSet = previousLabelSet;
            this.context.inIteration = previousInIteration;
            this.context.inSwitch = previousInSwitch;
            this.context.inFunctionBody = previousInFunctionBody;
            return this.finalize(node2, new Node.BlockStatement(body));
          };
          Parser3.prototype.validateParam = function(options2, param, name) {
            var key = "$" + name;
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(name)) {
                options2.stricted = param;
                options2.message = messages_1.Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                options2.stricted = param;
                options2.message = messages_1.Messages.StrictParamDupe;
              }
            } else if (!options2.firstRestricted) {
              if (this.scanner.isRestrictedWord(name)) {
                options2.firstRestricted = param;
                options2.message = messages_1.Messages.StrictParamName;
              } else if (this.scanner.isStrictModeReservedWord(name)) {
                options2.firstRestricted = param;
                options2.message = messages_1.Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                options2.stricted = param;
                options2.message = messages_1.Messages.StrictParamDupe;
              }
            }
            if (typeof Object.defineProperty === "function") {
              Object.defineProperty(options2.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
            } else {
              options2.paramSet[key] = true;
            }
          };
          Parser3.prototype.parseRestElement = function(params) {
            var node2 = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params);
            if (this.match("=")) {
              this.throwError(messages_1.Messages.DefaultRestParameter);
            }
            if (!this.match(")")) {
              this.throwError(messages_1.Messages.ParameterAfterRestParameter);
            }
            return this.finalize(node2, new Node.RestElement(arg));
          };
          Parser3.prototype.parseFormalParameter = function(options2) {
            var params = [];
            var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
            for (var i = 0;i < params.length; i++) {
              this.validateParam(options2, params[i], params[i].value);
            }
            options2.simple = options2.simple && param instanceof Node.Identifier;
            options2.params.push(param);
          };
          Parser3.prototype.parseFormalParameters = function(firstRestricted) {
            var options2;
            options2 = {
              simple: true,
              params: [],
              firstRestricted
            };
            this.expect("(");
            if (!this.match(")")) {
              options2.paramSet = {};
              while (this.lookahead.type !== 2) {
                this.parseFormalParameter(options2);
                if (this.match(")")) {
                  break;
                }
                this.expect(",");
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return {
              simple: options2.simple,
              params: options2.params,
              stricted: options2.stricted,
              firstRestricted: options2.firstRestricted,
              message: options2.message
            };
          };
          Parser3.prototype.matchAsyncFunction = function() {
            var match = this.matchContextualKeyword("async");
            if (match) {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
            }
            return match;
          };
          Parser3.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
            var node2 = this.createNode();
            var isAsync2 = this.matchContextualKeyword("async");
            if (isAsync2) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync2 ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted = null;
            if (!identifierIsOptional || !this.match("(")) {
              var token = this.lookahead;
              id = this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync2;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync2 ? this.finalize(node2, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node2, new Node.FunctionDeclaration(id, params, body, isGenerator));
          };
          Parser3.prototype.parseFunctionExpression = function() {
            var node2 = this.createNode();
            var isAsync2 = this.matchContextualKeyword("async");
            if (isAsync2) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync2 ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted;
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync2;
            this.context.allowYield = !isGenerator;
            if (!this.match("(")) {
              var token = this.lookahead;
              id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync2 ? this.finalize(node2, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node2, new Node.FunctionExpression(id, params, body, isGenerator));
          };
          Parser3.prototype.parseDirective = function() {
            var token = this.lookahead;
            var node2 = this.createNode();
            var expr = this.parseExpression();
            var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
            this.consumeSemicolon();
            return this.finalize(node2, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
          };
          Parser3.prototype.parseDirectivePrologues = function() {
            var firstRestricted = null;
            var body = [];
            while (true) {
              var token = this.lookahead;
              if (token.type !== 8) {
                break;
              }
              var statement = this.parseDirective();
              body.push(statement);
              var directive = statement.directive;
              if (typeof directive !== "string") {
                break;
              }
              if (directive === "use strict") {
                this.context.strict = true;
                if (firstRestricted) {
                  this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                }
                if (!this.context.allowStrictDirective) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                }
              } else {
                if (!firstRestricted && token.octal) {
                  firstRestricted = token;
                }
              }
            }
            return body;
          };
          Parser3.prototype.qualifiedPropertyName = function(token) {
            switch (token.type) {
              case 3:
              case 8:
              case 1:
              case 5:
              case 6:
              case 4:
                return true;
              case 7:
                return token.value === "[";
              default:
                break;
            }
            return false;
          };
          Parser3.prototype.parseGetterMethod = function() {
            var node2 = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length > 0) {
              this.tolerateError(messages_1.Messages.BadGetterArity);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node2, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser3.prototype.parseSetterMethod = function() {
            var node2 = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length !== 1) {
              this.tolerateError(messages_1.Messages.BadSetterArity);
            } else if (formalParameters.params[0] instanceof Node.RestElement) {
              this.tolerateError(messages_1.Messages.BadSetterRestParameter);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node2, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser3.prototype.parseGeneratorMethod = function() {
            var node2 = this.createNode();
            var isGenerator = true;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            this.context.allowYield = false;
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node2, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser3.prototype.isStartOfExpression = function() {
            var start = true;
            var value2 = this.lookahead.value;
            switch (this.lookahead.type) {
              case 7:
                start = value2 === "[" || value2 === "(" || value2 === "{" || value2 === "+" || value2 === "-" || value2 === "!" || value2 === "~" || value2 === "++" || value2 === "--" || value2 === "/" || value2 === "/=";
                break;
              case 4:
                start = value2 === "class" || value2 === "delete" || value2 === "function" || value2 === "let" || value2 === "new" || value2 === "super" || value2 === "this" || value2 === "typeof" || value2 === "void" || value2 === "yield";
                break;
              default:
                break;
            }
            return start;
          };
          Parser3.prototype.parseYieldExpression = function() {
            var node2 = this.createNode();
            this.expectKeyword("yield");
            var argument = null;
            var delegate = false;
            if (!this.hasLineTerminator) {
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = false;
              delegate = this.match("*");
              if (delegate) {
                this.nextToken();
                argument = this.parseAssignmentExpression();
              } else if (this.isStartOfExpression()) {
                argument = this.parseAssignmentExpression();
              }
              this.context.allowYield = previousAllowYield;
            }
            return this.finalize(node2, new Node.YieldExpression(argument, delegate));
          };
          Parser3.prototype.parseClassElement = function(hasConstructor) {
            var token = this.lookahead;
            var node2 = this.createNode();
            var kind = "";
            var key = null;
            var value2 = null;
            var computed = false;
            var method = false;
            var isStatic = false;
            var isAsync2 = false;
            if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              var id = key;
              if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                token = this.lookahead;
                isStatic = true;
                computed = this.match("[");
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  key = this.parseObjectPropertyKey();
                }
              }
              if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                var punctuator = this.lookahead.value;
                if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                  isAsync2 = true;
                  token = this.lookahead;
                  key = this.parseObjectPropertyKey();
                  if (token.type === 3 && token.value === "constructor") {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                  }
                }
              }
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3) {
              if (token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value2 = this.parseGetterMethod();
              } else if (token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseSetterMethod();
              }
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value2 = this.parseGeneratorMethod();
              method = true;
            }
            if (!kind && key && this.match("(")) {
              kind = "init";
              value2 = isAsync2 ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
              method = true;
            }
            if (!kind) {
              this.throwUnexpectedToken(this.lookahead);
            }
            if (kind === "init") {
              kind = "method";
            }
            if (!computed) {
              if (isStatic && this.isPropertyKey(key, "prototype")) {
                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
              }
              if (!isStatic && this.isPropertyKey(key, "constructor")) {
                if (kind !== "method" || !method || value2 && value2.generator) {
                  this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                }
                if (hasConstructor.value) {
                  this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                } else {
                  hasConstructor.value = true;
                }
                kind = "constructor";
              }
            }
            return this.finalize(node2, new Node.MethodDefinition(key, computed, value2, kind, isStatic));
          };
          Parser3.prototype.parseClassElementList = function() {
            var body = [];
            var hasConstructor = { value: false };
            this.expect("{");
            while (!this.match("}")) {
              if (this.match(";")) {
                this.nextToken();
              } else {
                body.push(this.parseClassElement(hasConstructor));
              }
            }
            this.expect("}");
            return body;
          };
          Parser3.prototype.parseClassBody = function() {
            var node2 = this.createNode();
            var elementList = this.parseClassElementList();
            return this.finalize(node2, new Node.ClassBody(elementList));
          };
          Parser3.prototype.parseClassDeclaration = function(identifierIsOptional) {
            var node2 = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node2, new Node.ClassDeclaration(id, superClass, classBody));
          };
          Parser3.prototype.parseClassExpression = function() {
            var node2 = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node2, new Node.ClassExpression(id, superClass, classBody));
          };
          Parser3.prototype.parseModule = function() {
            this.context.strict = true;
            this.context.isModule = true;
            this.scanner.isModule = true;
            var node2 = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node2, new Node.Module(body));
          };
          Parser3.prototype.parseScript = function() {
            var node2 = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node2, new Node.Script(body));
          };
          Parser3.prototype.parseModuleSpecifier = function() {
            var node2 = this.createNode();
            if (this.lookahead.type !== 8) {
              this.throwError(messages_1.Messages.InvalidModuleSpecifier);
            }
            var token = this.nextToken();
            var raw = this.getTokenRaw(token);
            return this.finalize(node2, new Node.Literal(token.value, raw));
          };
          Parser3.prototype.parseImportSpecifier = function() {
            var node2 = this.createNode();
            var imported;
            var local;
            if (this.lookahead.type === 3) {
              imported = this.parseVariableIdentifier();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              }
            } else {
              imported = this.parseIdentifierName();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node2, new Node.ImportSpecifier(local, imported));
          };
          Parser3.prototype.parseNamedImports = function() {
            this.expect("{");
            var specifiers = [];
            while (!this.match("}")) {
              specifiers.push(this.parseImportSpecifier());
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return specifiers;
          };
          Parser3.prototype.parseImportDefaultSpecifier = function() {
            var node2 = this.createNode();
            var local = this.parseIdentifierName();
            return this.finalize(node2, new Node.ImportDefaultSpecifier(local));
          };
          Parser3.prototype.parseImportNamespaceSpecifier = function() {
            var node2 = this.createNode();
            this.expect("*");
            if (!this.matchContextualKeyword("as")) {
              this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
            }
            this.nextToken();
            var local = this.parseIdentifierName();
            return this.finalize(node2, new Node.ImportNamespaceSpecifier(local));
          };
          Parser3.prototype.parseImportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalImportDeclaration);
            }
            var node2 = this.createNode();
            this.expectKeyword("import");
            var src;
            var specifiers = [];
            if (this.lookahead.type === 8) {
              src = this.parseModuleSpecifier();
            } else {
              if (this.match("{")) {
                specifiers = specifiers.concat(this.parseNamedImports());
              } else if (this.match("*")) {
                specifiers.push(this.parseImportNamespaceSpecifier());
              } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                specifiers.push(this.parseImportDefaultSpecifier());
                if (this.match(",")) {
                  this.nextToken();
                  if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              src = this.parseModuleSpecifier();
            }
            this.consumeSemicolon();
            return this.finalize(node2, new Node.ImportDeclaration(specifiers, src));
          };
          Parser3.prototype.parseExportSpecifier = function() {
            var node2 = this.createNode();
            var local = this.parseIdentifierName();
            var exported = local;
            if (this.matchContextualKeyword("as")) {
              this.nextToken();
              exported = this.parseIdentifierName();
            }
            return this.finalize(node2, new Node.ExportSpecifier(local, exported));
          };
          Parser3.prototype.parseExportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalExportDeclaration);
            }
            var node2 = this.createNode();
            this.expectKeyword("export");
            var exportDeclaration;
            if (this.matchKeyword("default")) {
              this.nextToken();
              if (this.matchKeyword("function")) {
                var declaration = this.parseFunctionDeclaration(true);
                exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchKeyword("class")) {
                var declaration = this.parseClassDeclaration(true);
                exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchContextualKeyword("async")) {
                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
              } else {
                if (this.matchContextualKeyword("from")) {
                  this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                }
                var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
              }
            } else if (this.match("*")) {
              this.nextToken();
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              var src = this.parseModuleSpecifier();
              this.consumeSemicolon();
              exportDeclaration = this.finalize(node2, new Node.ExportAllDeclaration(src));
            } else if (this.lookahead.type === 4) {
              var declaration = undefined;
              switch (this.lookahead.value) {
                case "let":
                case "const":
                  declaration = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "var":
                case "class":
                case "function":
                  declaration = this.parseStatementListItem();
                  break;
                default:
                  this.throwUnexpectedToken(this.lookahead);
              }
              exportDeclaration = this.finalize(node2, new Node.ExportNamedDeclaration(declaration, [], null));
            } else if (this.matchAsyncFunction()) {
              var declaration = this.parseFunctionDeclaration();
              exportDeclaration = this.finalize(node2, new Node.ExportNamedDeclaration(declaration, [], null));
            } else {
              var specifiers = [];
              var source = null;
              var isExportFromIdentifier = false;
              this.expect("{");
              while (!this.match("}")) {
                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                specifiers.push(this.parseExportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              if (this.matchContextualKeyword("from")) {
                this.nextToken();
                source = this.parseModuleSpecifier();
                this.consumeSemicolon();
              } else if (isExportFromIdentifier) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              } else {
                this.consumeSemicolon();
              }
              exportDeclaration = this.finalize(node2, new Node.ExportNamedDeclaration(null, specifiers, source));
            }
            return exportDeclaration;
          };
          return Parser3;
        }();
        exports2.Parser = Parser2;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function assert(condition, message) {
          if (!condition) {
            throw new Error("ASSERT: " + message);
          }
        }
        exports2.assert = assert;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var ErrorHandler = function() {
          function ErrorHandler2() {
            this.errors = [];
            this.tolerant = false;
          }
          ErrorHandler2.prototype.recordError = function(error) {
            this.errors.push(error);
          };
          ErrorHandler2.prototype.tolerate = function(error) {
            if (this.tolerant) {
              this.recordError(error);
            } else {
              throw error;
            }
          };
          ErrorHandler2.prototype.constructError = function(msg, column) {
            var error = new Error(msg);
            try {
              throw error;
            } catch (base5) {
              if (Object.create && Object.defineProperty) {
                error = Object.create(base5);
                Object.defineProperty(error, "column", { value: column });
              }
            }
            return error;
          };
          ErrorHandler2.prototype.createError = function(index, line, col, description) {
            var msg = "Line " + line + ": " + description;
            var error = this.constructError(msg, col);
            error.index = index;
            error.lineNumber = line;
            error.description = description;
            return error;
          };
          ErrorHandler2.prototype.throwError = function(index, line, col, description) {
            throw this.createError(index, line, col, description);
          };
          ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
            var error = this.createError(index, line, col, description);
            if (this.tolerant) {
              this.recordError(error);
            } else {
              throw error;
            }
          };
          return ErrorHandler2;
        }();
        exports2.ErrorHandler = ErrorHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Messages = {
          BadGetterArity: "Getter must not have any formal parameters",
          BadSetterArity: "Setter must have exactly one formal parameter",
          BadSetterRestParameter: "Setter function argument must not be a rest parameter",
          ConstructorIsAsync: "Class constructor may not be an async method",
          ConstructorSpecialMethod: "Class constructor may not be an accessor",
          DeclarationMissingInitializer: "Missing initializer in %0 declaration",
          DefaultRestParameter: "Unexpected token =",
          DuplicateBinding: "Duplicate binding %0",
          DuplicateConstructor: "A class may only have one constructor",
          DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
          ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
          GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
          IllegalBreak: "Illegal break statement",
          IllegalContinue: "Illegal continue statement",
          IllegalExportDeclaration: "Unexpected token",
          IllegalImportDeclaration: "Unexpected token",
          IllegalLanguageModeDirective: "Illegal \'use strict\' directive in function with non-simple parameter list",
          IllegalReturn: "Illegal return statement",
          InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
          InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
          InvalidModuleSpecifier: "Unexpected token",
          InvalidRegExp: "Invalid regular expression",
          LetInLexicalBinding: "let is disallowed as a lexically bound name",
          MissingFromClause: "Unexpected token",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NewlineAfterThrow: "Illegal newline after throw",
          NoAsAfterImportNamespace: "Unexpected token",
          NoCatchOrFinally: "Missing catch or finally after try",
          ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
          Redeclaration: "%0 \'%1\' has already been declared",
          StaticPrototype: "Classes may not have static property named prototype",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
          UnexpectedEOS: "Unexpected end of input",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedNumber: "Unexpected number",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedString: "Unexpected string",
          UnexpectedTemplate: "Unexpected quasi %0",
          UnexpectedToken: "Unexpected token %0",
          UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
          UnknownLabel: "Undefined label \'%0\'",
          UnterminatedRegExp: "Invalid regular expression: missing /"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var character_1 = __webpack_require__(4);
        var messages_1 = __webpack_require__(11);
        function hexValue(ch) {
          return "0123456789abcdef".indexOf(ch.toLowerCase());
        }
        function octalValue(ch) {
          return "01234567".indexOf(ch);
        }
        var Scanner = function() {
          function Scanner2(code, handler) {
            this.source = code;
            this.errorHandler = handler;
            this.trackComment = false;
            this.isModule = false;
            this.length = code.length;
            this.index = 0;
            this.lineNumber = code.length > 0 ? 1 : 0;
            this.lineStart = 0;
            this.curlyStack = [];
          }
          Scanner2.prototype.saveState = function() {
            return {
              index: this.index,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart
            };
          };
          Scanner2.prototype.restoreState = function(state) {
            this.index = state.index;
            this.lineNumber = state.lineNumber;
            this.lineStart = state.lineStart;
          };
          Scanner2.prototype.eof = function() {
            return this.index >= this.length;
          };
          Scanner2.prototype.throwUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.tolerateUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.skipSingleLineComment = function(offset) {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - offset;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - offset
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              ++this.index;
              if (character_1.Character.isLineTerminator(ch)) {
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 1
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index - 1],
                    range: [start, this.index - 1],
                    loc
                  };
                  comments.push(entry);
                }
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                return comments;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: false,
                slice: [start + offset, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            return comments;
          };
          Scanner2.prototype.skipMultiLineComment = function() {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - 2;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 2
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isLineTerminator(ch)) {
                if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                ++this.index;
                this.lineStart = this.index;
              } else if (ch === 42) {
                if (this.source.charCodeAt(this.index + 1) === 47) {
                  this.index += 2;
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart
                    };
                    var entry = {
                      multiLine: true,
                      slice: [start + 2, this.index - 2],
                      range: [start, this.index],
                      loc
                    };
                    comments.push(entry);
                  }
                  return comments;
                }
                ++this.index;
              } else {
                ++this.index;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: true,
                slice: [start + 2, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            this.tolerateUnexpectedToken();
            return comments;
          };
          Scanner2.prototype.scanComments = function() {
            var comments;
            if (this.trackComment) {
              comments = [];
            }
            var start = this.index === 0;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isWhiteSpace(ch)) {
                ++this.index;
              } else if (character_1.Character.isLineTerminator(ch)) {
                ++this.index;
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                start = true;
              } else if (ch === 47) {
                ch = this.source.charCodeAt(this.index + 1);
                if (ch === 47) {
                  this.index += 2;
                  var comment = this.skipSingleLineComment(2);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                  start = true;
                } else if (ch === 42) {
                  this.index += 2;
                  var comment = this.skipMultiLineComment();
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (start && ch === 45) {
                if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                  this.index += 3;
                  var comment = this.skipSingleLineComment(3);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (ch === 60 && !this.isModule) {
                if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                  this.index += 4;
                  var comment = this.skipSingleLineComment(4);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return comments;
          };
          Scanner2.prototype.isFutureReservedWord = function(id) {
            switch (id) {
              case "enum":
              case "export":
              case "import":
              case "super":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isStrictModeReservedWord = function(id) {
            switch (id) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isRestrictedWord = function(id) {
            return id === "eval" || id === "arguments";
          };
          Scanner2.prototype.isKeyword = function(id) {
            switch (id.length) {
              case 2:
                return id === "if" || id === "in" || id === "do";
              case 3:
                return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
              case 4:
                return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
              case 5:
                return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
              case 6:
                return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
              case 7:
                return id === "default" || id === "finally" || id === "extends";
              case 8:
                return id === "function" || id === "continue" || id === "debugger";
              case 10:
                return id === "instanceof";
              default:
                return false;
            }
          };
          Scanner2.prototype.codePointAt = function(i) {
            var cp = this.source.charCodeAt(i);
            if (cp >= 55296 && cp <= 56319) {
              var second = this.source.charCodeAt(i + 1);
              if (second >= 56320 && second <= 57343) {
                var first = cp;
                cp = (first - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return cp;
          };
          Scanner2.prototype.scanHexEscape = function(prefix) {
            var len = prefix === "u" ? 4 : 2;
            var code = 0;
            for (var i = 0;i < len; ++i) {
              if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                code = code * 16 + hexValue(this.source[this.index++]);
              } else {
                return null;
              }
            }
            return String.fromCharCode(code);
          };
          Scanner2.prototype.scanUnicodeCodePointEscape = function() {
            var ch = this.source[this.index];
            var code = 0;
            if (ch === "}") {
              this.throwUnexpectedToken();
            }
            while (!this.eof()) {
              ch = this.source[this.index++];
              if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                break;
              }
              code = code * 16 + hexValue(ch);
            }
            if (code > 1114111 || ch !== "}") {
              this.throwUnexpectedToken();
            }
            return character_1.Character.fromCodePoint(code);
          };
          Scanner2.prototype.getIdentifier = function() {
            var start = this.index++;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (ch === 92) {
                this.index = start;
                return this.getComplexIdentifier();
              } else if (ch >= 55296 && ch < 57343) {
                this.index = start;
                return this.getComplexIdentifier();
              }
              if (character_1.Character.isIdentifierPart(ch)) {
                ++this.index;
              } else {
                break;
              }
            }
            return this.source.slice(start, this.index);
          };
          Scanner2.prototype.getComplexIdentifier = function() {
            var cp = this.codePointAt(this.index);
            var id = character_1.Character.fromCodePoint(cp);
            this.index += id.length;
            var ch;
            if (cp === 92) {
              if (this.source.charCodeAt(this.index) !== 117) {
                this.throwUnexpectedToken();
              }
              ++this.index;
              if (this.source[this.index] === "{") {
                ++this.index;
                ch = this.scanUnicodeCodePointEscape();
              } else {
                ch = this.scanHexEscape("u");
                if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken();
                }
              }
              id = ch;
            }
            while (!this.eof()) {
              cp = this.codePointAt(this.index);
              if (!character_1.Character.isIdentifierPart(cp)) {
                break;
              }
              ch = character_1.Character.fromCodePoint(cp);
              id += ch;
              this.index += ch.length;
              if (cp === 92) {
                id = id.substr(0, id.length - 1);
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id += ch;
              }
            }
            return id;
          };
          Scanner2.prototype.octalToDecimal = function(ch) {
            var octal = ch !== "0";
            var code = octalValue(ch);
            if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              octal = true;
              code = code * 8 + octalValue(this.source[this.index++]);
              if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                code = code * 8 + octalValue(this.source[this.index++]);
              }
            }
            return {
              code,
              octal
            };
          };
          Scanner2.prototype.scanIdentifier = function() {
            var type;
            var start = this.index;
            var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
            if (id.length === 1) {
              type = 3;
            } else if (this.isKeyword(id)) {
              type = 4;
            } else if (id === "null") {
              type = 5;
            } else if (id === "true" || id === "false") {
              type = 1;
            } else {
              type = 3;
            }
            if (type !== 3 && start + id.length !== this.index) {
              var restore = this.index;
              this.index = start;
              this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
              this.index = restore;
            }
            return {
              type,
              value: id,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanPunctuator = function() {
            var start = this.index;
            var str = this.source[this.index];
            switch (str) {
              case "(":
              case "{":
                if (str === "{") {
                  this.curlyStack.push("{");
                }
                ++this.index;
                break;
              case ".":
                ++this.index;
                if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                  this.index += 2;
                  str = "...";
                }
                break;
              case "}":
                ++this.index;
                this.curlyStack.pop();
                break;
              case ")":
              case ";":
              case ",":
              case "[":
              case "]":
              case ":":
              case "?":
              case "~":
                ++this.index;
                break;
              default:
                str = this.source.substr(this.index, 4);
                if (str === ">>>=") {
                  this.index += 4;
                } else {
                  str = str.substr(0, 3);
                  if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                    this.index += 3;
                  } else {
                    str = str.substr(0, 2);
                    if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                      this.index += 2;
                    } else {
                      str = this.source[this.index];
                      if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                        ++this.index;
                      }
                    }
                  }
                }
            }
            if (this.index === start) {
              this.throwUnexpectedToken();
            }
            return {
              type: 7,
              value: str,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanHexLiteral = function(start) {
            var num = "";
            while (!this.eof()) {
              if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt("0x" + num, 16),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanBinaryLiteral = function(start) {
            var num = "";
            var ch;
            while (!this.eof()) {
              ch = this.source[this.index];
              if (ch !== "0" && ch !== "1") {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (!this.eof()) {
              ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                this.throwUnexpectedToken();
              }
            }
            return {
              type: 6,
              value: parseInt(num, 2),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
            var num = "";
            var octal = false;
            if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
              octal = true;
              num = "0" + this.source[this.index++];
            } else {
              ++this.index;
            }
            while (!this.eof()) {
              if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (!octal && num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt(num, 8),
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.isImplicitOctalLiteral = function() {
            for (var i = this.index + 1;i < this.length; ++i) {
              var ch = this.source[i];
              if (ch === "8" || ch === "9") {
                return false;
              }
              if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                return true;
              }
            }
            return true;
          };
          Scanner2.prototype.scanNumericLiteral = function() {
            var start = this.index;
            var ch = this.source[start];
            assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
            var num = "";
            if (ch !== ".") {
              num = this.source[this.index++];
              ch = this.source[this.index];
              if (num === "0") {
                if (ch === "x" || ch === "X") {
                  ++this.index;
                  return this.scanHexLiteral(start);
                }
                if (ch === "b" || ch === "B") {
                  ++this.index;
                  return this.scanBinaryLiteral(start);
                }
                if (ch === "o" || ch === "O") {
                  return this.scanOctalLiteral(ch, start);
                }
                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  if (this.isImplicitOctalLiteral()) {
                    return this.scanOctalLiteral(ch, start);
                  }
                }
              }
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === ".") {
              num += this.source[this.index++];
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === "e" || ch === "E") {
              num += this.source[this.index++];
              ch = this.source[this.index];
              if (ch === "+" || ch === "-") {
                num += this.source[this.index++];
              }
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
              } else {
                this.throwUnexpectedToken();
              }
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseFloat(num),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanStringLiteral = function() {
            var start = this.index;
            var quote = this.source[start];
            assert_1.assert(quote === "\'" || quote === '"', "String literal must starts with a quote");
            ++this.index;
            var octal = false;
            var str = "";
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === quote) {
                quote = "";
                break;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        str += this.scanUnicodeCodePointEscape();
                      } else {
                        var unescaped_1 = this.scanHexEscape(ch);
                        if (unescaped_1 === null) {
                          this.throwUnexpectedToken();
                        }
                        str += unescaped_1;
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      str += unescaped;
                      break;
                    case "n":
                      str += "\n";
                      break;
                    case "r":
                      str += "\r";
                      break;
                    case "t":
                      str += "\t";
                      break;
                    case "b":
                      str += "\b";
                      break;
                    case "f":
                      str += "\f";
                      break;
                    case "v":
                      str += "\v";
                      break;
                    case "8":
                    case "9":
                      str += ch;
                      this.tolerateUnexpectedToken();
                      break;
                    default:
                      if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        var octToDec = this.octalToDecimal(ch);
                        octal = octToDec.octal || octal;
                        str += String.fromCharCode(octToDec.code);
                      } else {
                        str += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                break;
              } else {
                str += ch;
              }
            }
            if (quote !== "") {
              this.index = start;
              this.throwUnexpectedToken();
            }
            return {
              type: 8,
              value: str,
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanTemplate = function() {
            var cooked = "";
            var terminated = false;
            var start = this.index;
            var head = this.source[start] === "`";
            var tail = false;
            var rawOffset = 2;
            ++this.index;
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === "`") {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
              } else if (ch === "$") {
                if (this.source[this.index] === "{") {
                  this.curlyStack.push("${");
                  ++this.index;
                  terminated = true;
                  break;
                }
                cooked += ch;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "n":
                      cooked += "\n";
                      break;
                    case "r":
                      cooked += "\r";
                      break;
                    case "t":
                      cooked += "\t";
                      break;
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        cooked += this.scanUnicodeCodePointEscape();
                      } else {
                        var restore = this.index;
                        var unescaped_2 = this.scanHexEscape(ch);
                        if (unescaped_2 !== null) {
                          cooked += unescaped_2;
                        } else {
                          this.index = restore;
                          cooked += ch;
                        }
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      cooked += unescaped;
                      break;
                    case "b":
                      cooked += "\b";
                      break;
                    case "f":
                      cooked += "\f";
                      break;
                    case "v":
                      cooked += "\v";
                      break;
                    default:
                      if (ch === "0") {
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        }
                        cooked += "\0";
                      } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                      } else {
                        cooked += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.lineNumber;
                if (ch === "\r" && this.source[this.index] === "\n") {
                  ++this.index;
                }
                this.lineStart = this.index;
                cooked += "\n";
              } else {
                cooked += ch;
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken();
            }
            if (!head) {
              this.curlyStack.pop();
            }
            return {
              type: 10,
              value: this.source.slice(start + 1, this.index - rawOffset),
              cooked,
              head,
              tail,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.testRegExp = function(pattern, flags) {
            var astralSubstitute = "\uFFFF";
            var tmp = pattern;
            var self2 = this;
            if (flags.indexOf("u") >= 0) {
              tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                var codePoint = parseInt($1 || $2, 16);
                if (codePoint > 1114111) {
                  self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                if (codePoint <= 65535) {
                  return String.fromCharCode(codePoint);
                }
                return astralSubstitute;
              }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
            }
            try {
              RegExp(tmp);
            } catch (e) {
              this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
            }
            try {
              return new RegExp(pattern, flags);
            } catch (exception) {
              return null;
            }
          };
          Scanner2.prototype.scanRegExpBody = function() {
            var ch = this.source[this.index];
            assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
            var str = this.source[this.index++];
            var classMarker = false;
            var terminated = false;
            while (!this.eof()) {
              ch = this.source[this.index++];
              str += ch;
              if (ch === "\\") {
                ch = this.source[this.index++];
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                str += ch;
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              } else if (classMarker) {
                if (ch === "]") {
                  classMarker = false;
                }
              } else {
                if (ch === "/") {
                  terminated = true;
                  break;
                } else if (ch === "[") {
                  classMarker = true;
                }
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
            }
            return str.substr(1, str.length - 2);
          };
          Scanner2.prototype.scanRegExpFlags = function() {
            var str = "";
            var flags = "";
            while (!this.eof()) {
              var ch = this.source[this.index];
              if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                break;
              }
              ++this.index;
              if (ch === "\\" && !this.eof()) {
                ch = this.source[this.index];
                if (ch === "u") {
                  ++this.index;
                  var restore = this.index;
                  var char = this.scanHexEscape("u");
                  if (char !== null) {
                    flags += char;
                    for (str += "\\u";restore < this.index; ++restore) {
                      str += this.source[restore];
                    }
                  } else {
                    this.index = restore;
                    flags += "u";
                    str += "\\u";
                  }
                  this.tolerateUnexpectedToken();
                } else {
                  str += "\\";
                  this.tolerateUnexpectedToken();
                }
              } else {
                flags += ch;
                str += ch;
              }
            }
            return flags;
          };
          Scanner2.prototype.scanRegExp = function() {
            var start = this.index;
            var pattern = this.scanRegExpBody();
            var flags = this.scanRegExpFlags();
            var value2 = this.testRegExp(pattern, flags);
            return {
              type: 9,
              value: "",
              pattern,
              flags,
              regex: value2,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.lex = function() {
            if (this.eof()) {
              return {
                type: 2,
                value: "",
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: this.index,
                end: this.index
              };
            }
            var cp = this.source.charCodeAt(this.index);
            if (character_1.Character.isIdentifierStart(cp)) {
              return this.scanIdentifier();
            }
            if (cp === 40 || cp === 41 || cp === 59) {
              return this.scanPunctuator();
            }
            if (cp === 39 || cp === 34) {
              return this.scanStringLiteral();
            }
            if (cp === 46) {
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                return this.scanNumericLiteral();
              }
              return this.scanPunctuator();
            }
            if (character_1.Character.isDecimalDigit(cp)) {
              return this.scanNumericLiteral();
            }
            if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
              return this.scanTemplate();
            }
            if (cp >= 55296 && cp < 57343) {
              if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                return this.scanIdentifier();
              }
            }
            return this.scanPunctuator();
          };
          return Scanner2;
        }();
        exports2.Scanner = Scanner;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TokenName = {};
        exports2.TokenName[1] = "Boolean";
        exports2.TokenName[2] = "<end>";
        exports2.TokenName[3] = "Identifier";
        exports2.TokenName[4] = "Keyword";
        exports2.TokenName[5] = "Null";
        exports2.TokenName[6] = "Numeric";
        exports2.TokenName[7] = "Punctuator";
        exports2.TokenName[8] = "String";
        exports2.TokenName[9] = "RegularExpression";
        exports2.TokenName[10] = "Template";
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.XHTMLEntities = {
          quot: '"',
          amp: "&",
          apos: "'",
          gt: ">",
          nbsp: "\xA0",
          iexcl: "\xA1",
          cent: "\xA2",
          pound: "\xA3",
          curren: "\xA4",
          yen: "\xA5",
          brvbar: "\xA6",
          sect: "\xA7",
          uml: "\xA8",
          copy: "\xA9",
          ordf: "\xAA",
          laquo: "\xAB",
          not: "\xAC",
          shy: "\xAD",
          reg: "\xAE",
          macr: "\xAF",
          deg: "\xB0",
          plusmn: "\xB1",
          sup2: "\xB2",
          sup3: "\xB3",
          acute: "\xB4",
          micro: "\xB5",
          para: "\xB6",
          middot: "\xB7",
          cedil: "\xB8",
          sup1: "\xB9",
          ordm: "\xBA",
          raquo: "\xBB",
          frac14: "\xBC",
          frac12: "\xBD",
          frac34: "\xBE",
          iquest: "\xBF",
          Agrave: "\xC0",
          Aacute: "\xC1",
          Acirc: "\xC2",
          Atilde: "\xC3",
          Auml: "\xC4",
          Aring: "\xC5",
          AElig: "\xC6",
          Ccedil: "\xC7",
          Egrave: "\xC8",
          Eacute: "\xC9",
          Ecirc: "\xCA",
          Euml: "\xCB",
          Igrave: "\xCC",
          Iacute: "\xCD",
          Icirc: "\xCE",
          Iuml: "\xCF",
          ETH: "\xD0",
          Ntilde: "\xD1",
          Ograve: "\xD2",
          Oacute: "\xD3",
          Ocirc: "\xD4",
          Otilde: "\xD5",
          Ouml: "\xD6",
          times: "\xD7",
          Oslash: "\xD8",
          Ugrave: "\xD9",
          Uacute: "\xDA",
          Ucirc: "\xDB",
          Uuml: "\xDC",
          Yacute: "\xDD",
          THORN: "\xDE",
          szlig: "\xDF",
          agrave: "\xE0",
          aacute: "\xE1",
          acirc: "\xE2",
          atilde: "\xE3",
          auml: "\xE4",
          aring: "\xE5",
          aelig: "\xE6",
          ccedil: "\xE7",
          egrave: "\xE8",
          eacute: "\xE9",
          ecirc: "\xEA",
          euml: "\xEB",
          igrave: "\xEC",
          iacute: "\xED",
          icirc: "\xEE",
          iuml: "\xEF",
          eth: "\xF0",
          ntilde: "\xF1",
          ograve: "\xF2",
          oacute: "\xF3",
          ocirc: "\xF4",
          otilde: "\xF5",
          ouml: "\xF6",
          divide: "\xF7",
          oslash: "\xF8",
          ugrave: "\xF9",
          uacute: "\xFA",
          ucirc: "\xFB",
          uuml: "\xFC",
          yacute: "\xFD",
          thorn: "\xFE",
          yuml: "\xFF",
          OElig: "\u0152",
          oelig: "\u0153",
          Scaron: "\u0160",
          scaron: "\u0161",
          Yuml: "\u0178",
          fnof: "\u0192",
          circ: "\u02C6",
          tilde: "\u02DC",
          Alpha: "\u0391",
          Beta: "\u0392",
          Gamma: "\u0393",
          Delta: "\u0394",
          Epsilon: "\u0395",
          Zeta: "\u0396",
          Eta: "\u0397",
          Theta: "\u0398",
          Iota: "\u0399",
          Kappa: "\u039A",
          Lambda: "\u039B",
          Mu: "\u039C",
          Nu: "\u039D",
          Xi: "\u039E",
          Omicron: "\u039F",
          Pi: "\u03A0",
          Rho: "\u03A1",
          Sigma: "\u03A3",
          Tau: "\u03A4",
          Upsilon: "\u03A5",
          Phi: "\u03A6",
          Chi: "\u03A7",
          Psi: "\u03A8",
          Omega: "\u03A9",
          alpha: "\u03B1",
          beta: "\u03B2",
          gamma: "\u03B3",
          delta: "\u03B4",
          epsilon: "\u03B5",
          zeta: "\u03B6",
          eta: "\u03B7",
          theta: "\u03B8",
          iota: "\u03B9",
          kappa: "\u03BA",
          lambda: "\u03BB",
          mu: "\u03BC",
          nu: "\u03BD",
          xi: "\u03BE",
          omicron: "\u03BF",
          pi: "\u03C0",
          rho: "\u03C1",
          sigmaf: "\u03C2",
          sigma: "\u03C3",
          tau: "\u03C4",
          upsilon: "\u03C5",
          phi: "\u03C6",
          chi: "\u03C7",
          psi: "\u03C8",
          omega: "\u03C9",
          thetasym: "\u03D1",
          upsih: "\u03D2",
          piv: "\u03D6",
          ensp: "\u2002",
          emsp: "\u2003",
          thinsp: "\u2009",
          zwnj: "\u200C",
          zwj: "\u200D",
          lrm: "\u200E",
          rlm: "\u200F",
          ndash: "\u2013",
          mdash: "\u2014",
          lsquo: "\u2018",
          rsquo: "\u2019",
          sbquo: "\u201A",
          ldquo: "\u201C",
          rdquo: "\u201D",
          bdquo: "\u201E",
          dagger: "\u2020",
          Dagger: "\u2021",
          bull: "\u2022",
          hellip: "\u2026",
          permil: "\u2030",
          prime: "\u2032",
          Prime: "\u2033",
          lsaquo: "\u2039",
          rsaquo: "\u203A",
          oline: "\u203E",
          frasl: "\u2044",
          euro: "\u20AC",
          image: "\u2111",
          weierp: "\u2118",
          real: "\u211C",
          trade: "\u2122",
          alefsym: "\u2135",
          larr: "\u2190",
          uarr: "\u2191",
          rarr: "\u2192",
          darr: "\u2193",
          harr: "\u2194",
          crarr: "\u21B5",
          lArr: "\u21D0",
          uArr: "\u21D1",
          rArr: "\u21D2",
          dArr: "\u21D3",
          hArr: "\u21D4",
          forall: "\u2200",
          part: "\u2202",
          exist: "\u2203",
          empty: "\u2205",
          nabla: "\u2207",
          isin: "\u2208",
          notin: "\u2209",
          ni: "\u220B",
          prod: "\u220F",
          sum: "\u2211",
          minus: "\u2212",
          lowast: "\u2217",
          radic: "\u221A",
          prop: "\u221D",
          infin: "\u221E",
          ang: "\u2220",
          and: "\u2227",
          or: "\u2228",
          cap: "\u2229",
          cup: "\u222A",
          int: "\u222B",
          there4: "\u2234",
          sim: "\u223C",
          cong: "\u2245",
          asymp: "\u2248",
          ne: "\u2260",
          equiv: "\u2261",
          le: "\u2264",
          ge: "\u2265",
          sub: "\u2282",
          sup: "\u2283",
          nsub: "\u2284",
          sube: "\u2286",
          supe: "\u2287",
          oplus: "\u2295",
          otimes: "\u2297",
          perp: "\u22A5",
          sdot: "\u22C5",
          lceil: "\u2308",
          rceil: "\u2309",
          lfloor: "\u230A",
          rfloor: "\u230B",
          loz: "\u25CA",
          spades: "\u2660",
          clubs: "\u2663",
          hearts: "\u2665",
          diams: "\u2666",
          lang: "\u27E8",
          rang: "\u27E9"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var error_handler_1 = __webpack_require__(10);
        var scanner_1 = __webpack_require__(12);
        var token_1 = __webpack_require__(13);
        var Reader = function() {
          function Reader2() {
            this.values = [];
            this.curly = this.paren = -1;
          }
          Reader2.prototype.beforeFunctionExpression = function(t) {
            return [
              "(",
              "{",
              "[",
              "in",
              "typeof",
              "instanceof",
              "new",
              "return",
              "case",
              "delete",
              "throw",
              "void",
              "=",
              "+=",
              "-=",
              "*=",
              "**=",
              "/=",
              "%=",
              "<<=",
              ">>=",
              ">>>=",
              "&=",
              "|=",
              "^=",
              ",",
              "+",
              "-",
              "*",
              "**",
              "/",
              "%",
              "++",
              "--",
              "<<",
              ">>",
              ">>>",
              "&",
              "|",
              "^",
              "!",
              "~",
              "&&",
              "||",
              "?",
              ":",
              "===",
              "==",
              ">=",
              "<=",
              "<",
              ">",
              "!=",
              "!=="
            ].indexOf(t) >= 0;
          };
          Reader2.prototype.isRegexStart = function() {
            var previous = this.values[this.values.length - 1];
            var regex = previous !== null;
            switch (previous) {
              case "this":
              case "]":
                regex = false;
                break;
              case ")":
                var keyword = this.values[this.paren - 1];
                regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                break;
              case "}":
                regex = false;
                if (this.values[this.curly - 3] === "function") {
                  var check = this.values[this.curly - 4];
                  regex = check ? !this.beforeFunctionExpression(check) : false;
                } else if (this.values[this.curly - 4] === "function") {
                  var check = this.values[this.curly - 5];
                  regex = check ? !this.beforeFunctionExpression(check) : true;
                }
                break;
              default:
                break;
            }
            return regex;
          };
          Reader2.prototype.push = function(token) {
            if (token.type === 7 || token.type === 4) {
              if (token.value === "{") {
                this.curly = this.values.length;
              } else if (token.value === "(") {
                this.paren = this.values.length;
              }
              this.values.push(token.value);
            } else {
              this.values.push(null);
            }
          };
          return Reader2;
        }();
        var Tokenizer = function() {
          function Tokenizer2(code, config2) {
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = config2 ? typeof config2.tolerant === "boolean" && config2.tolerant : false;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = config2 ? typeof config2.comment === "boolean" && config2.comment : false;
            this.trackRange = config2 ? typeof config2.range === "boolean" && config2.range : false;
            this.trackLoc = config2 ? typeof config2.loc === "boolean" && config2.loc : false;
            this.buffer = [];
            this.reader = new Reader;
          }
          Tokenizer2.prototype.errors = function() {
            return this.errorHandler.errors;
          };
          Tokenizer2.prototype.getNextToken = function() {
            if (this.buffer.length === 0) {
              var comments = this.scanner.scanComments();
              if (this.scanner.trackComment) {
                for (var i = 0;i < comments.length; ++i) {
                  var e = comments[i];
                  var value2 = this.scanner.source.slice(e.slice[0], e.slice[1]);
                  var comment = {
                    type: e.multiLine ? "BlockComment" : "LineComment",
                    value: value2
                  };
                  if (this.trackRange) {
                    comment.range = e.range;
                  }
                  if (this.trackLoc) {
                    comment.loc = e.loc;
                  }
                  this.buffer.push(comment);
                }
              }
              if (!this.scanner.eof()) {
                var loc = undefined;
                if (this.trackLoc) {
                  loc = {
                    start: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    },
                    end: {}
                  };
                }
                var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                this.reader.push(token);
                var entry = {
                  type: token_1.TokenName[token.type],
                  value: this.scanner.source.slice(token.start, token.end)
                };
                if (this.trackRange) {
                  entry.range = [token.start, token.end];
                }
                if (this.trackLoc) {
                  loc.end = {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  };
                  entry.loc = loc;
                }
                if (token.type === 9) {
                  var pattern = token.pattern;
                  var flags = token.flags;
                  entry.regex = { pattern, flags };
                }
                this.buffer.push(entry);
              }
            }
            return this.buffer.shift();
          };
          return Tokenizer2;
        }();
        exports2.Tokenizer = Tokenizer;
      }
    ]);
  });
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/redeyed/redeyed.js
var require_redeyed = __commonJS((exports, module) => {
  (function() {
    var esprima;
    var exportFn;
    var toString2 = Object.prototype.toString;
    if (typeof module === "object" && typeof exports === "object" && typeof require === "function") {
      esprima = require_esprima();
      exportFn = function(redeyed) {
        module.exports = redeyed;
      };
      bootstrap(esprima, exportFn);
    } else if (typeof define === "function" && define.amd) {
      define(["esprima"], function(esprima2) {
        return bootstrap(esprima2);
      });
    } else if (typeof window === "object") {
      window.redeyed = bootstrap(window.esprima);
    }
    function bootstrap(esprima2, exportFn2) {
      function isFunction2(obj) {
        return toString2.call(obj) === "[object Function]";
      }
      function isString(obj) {
        return toString2.call(obj) === "[object String]";
      }
      function isObject(obj) {
        return toString2.call(obj) === "[object Object]";
      }
      function surroundWith(before, after) {
        return function(s) {
          return before + s + after;
        };
      }
      function isNonCircular(key) {
        return key !== "_parent";
      }
      function objectizeString(value2) {
        var vals = value2.split(":");
        if (vals.length === 0 || vals.length > 2) {
          throw new Error("illegal string config: " + value2 + '\nShould be of format "before:after"');
        }
        if (vals.length === 1 || vals[1].length === 0) {
          return vals.indexOf(":") < 0 ? { _before: vals[0] } : { _after: vals[0] };
        } else {
          return { _before: vals[0], _after: vals[1] };
        }
      }
      function objectize(node2) {
        function resolve6(value2, key) {
          if (!value2._parent)
            return;
          if (value2._parent._default && value2._parent._default[key])
            return value2._parent._default[key];
          var root = value2._parent._parent;
          if (!root)
            return;
          return root._default ? root._default[key] : undefined;
        }
        function process3(key) {
          var value2 = node2[key];
          if (!value2)
            return;
          if (isFunction2(value2))
            return;
          if (isString(value2)) {
            node2[key] = value2 = objectizeString(value2);
          }
          value2._parent = node2;
          if (isObject(value2)) {
            if (!value2._before && !value2._after)
              return objectize(value2);
            value2._before = value2._before || resolve6(value2, "_before");
            value2._after = value2._after || resolve6(value2, "_after");
            return;
          }
          throw new Error("nodes need to be either {String}, {Object} or {Function}." + value2 + " is neither.");
        }
        if (node2._default)
          process3("_default");
        Object.keys(node2).filter(function(key) {
          return isNonCircular(key) && node2.hasOwnProperty(key) && key !== "_before" && key !== "_after" && key !== "_default";
        }).forEach(process3);
      }
      function functionize(node2) {
        Object.keys(node2).filter(function(key) {
          return isNonCircular(key) && node2.hasOwnProperty(key);
        }).forEach(function(key) {
          var value2 = node2[key];
          if (isFunction2(value2))
            return;
          if (isObject(value2)) {
            if (!value2._before && !value2._after)
              return functionize(value2);
            var before = value2._before || "";
            var after = value2._after || "";
            node2[key] = surroundWith(before, after);
            return node2[key];
          }
        });
      }
      function normalize2(root) {
        objectize(root);
        functionize(root);
      }
      function mergeTokensAndComments(tokens, comments) {
        var all = {};
        function addToAllByRangeStart(t) {
          all[t.range[0]] = t;
        }
        tokens.forEach(addToAllByRangeStart);
        comments.forEach(addToAllByRangeStart);
        return Object.keys(all).map(function(k) {
          return all[k];
        });
      }
      function redeyed(code, config2, opts) {
        opts = opts || {};
        var parser4 = opts.parser || esprima2;
        var jsx = !!opts.jsx;
        var buildAst = jsx || !!opts.buildAst;
        var hashbang = "";
        var ast;
        var tokens;
        var comments;
        var lastSplitEnd = 0;
        var splits = [];
        var transformedCode;
        var all;
        var info;
        if (code[0] === "#" && code[1] === "!") {
          hashbang = code.substr(0, code.indexOf("\n") + 1);
          code = Array.apply(0, Array(hashbang.length)).join(" ") + "\n" + code.substr(hashbang.length);
        }
        if (buildAst) {
          ast = parser4.parse(code, { tokens: true, comment: true, range: true, loc: true, tolerant: true, jsx: true });
          tokens = ast.tokens;
          comments = ast.comments;
        } else {
          tokens = [];
          comments = [];
          parser4.tokenize(code, { range: true, loc: true, comment: true }, function(token2) {
            if (token2.type === "LineComment") {
              token2.type = "Line";
              comments.push(token2);
            } else if (token2.type === "BlockComment") {
              token2.type = "Block";
              comments.push(token2);
            } else {
              if (token2.type === "Identifier" && token2.value === "static")
                token2.type = "Keyword";
              tokens.push(token2);
            }
          });
        }
        normalize2(config2);
        function tokenIndex(tokens2, tkn, start2) {
          var current;
          var rangeStart = tkn.range[0];
          for (current = start2;current < tokens2.length; current++) {
            if (tokens2[current].range[0] === rangeStart)
              return current;
          }
          throw new Error("Token %s not found at or after index: %d", tkn, start2);
        }
        function process3(surround2) {
          var result;
          var currentIndex;
          var nextIndex;
          var skip = 0;
          var splitEnd;
          result = surround2(code.slice(start, end), info);
          if (isObject(result)) {
            splits.push(result.replacement);
            currentIndex = info.tokenIndex;
            nextIndex = tokenIndex(info.tokens, result.skipPastToken, currentIndex);
            skip = nextIndex - currentIndex;
            splitEnd = skip > 0 ? tokens[nextIndex - 1].range[1] : end;
          } else {
            splits.push(result);
            splitEnd = end;
          }
          return { skip, splitEnd };
        }
        function addSplit(start2, end2, surround2, info2) {
          var result;
          var skip = 0;
          if (start2 >= end2)
            return;
          if (surround2) {
            result = process3(surround2);
            skip = result.skip;
            lastSplitEnd = result.splitEnd;
          } else {
            splits.push(code.slice(start2, end2));
            lastSplitEnd = end2;
          }
          return skip;
        }
        all = mergeTokensAndComments(tokens, comments);
        for (var tokenIdx = 0;tokenIdx < all.length; tokenIdx++) {
          var token = all[tokenIdx];
          var surroundForType = config2[token.type];
          var surround;
          var start;
          var end;
          if (surroundForType) {
            surround = surroundForType && surroundForType.hasOwnProperty(token.value) && surroundForType[token.value] && isFunction2(surroundForType[token.value]) ? surroundForType[token.value] : surroundForType._default;
            start = token.range[0];
            end = token.range[1];
            addSplit(lastSplitEnd, start);
            info = { tokenIndex: tokenIdx, tokens: all, ast, code };
            tokenIdx += addSplit(start, end, surround, info);
          }
        }
        if (lastSplitEnd < code.length) {
          addSplit(lastSplitEnd, code.length);
        }
        if (!opts.nojoin) {
          transformedCode = splits.join("");
          if (hashbang.length > 0) {
            transformedCode = hashbang + transformedCode.substr(hashbang.length);
          }
        }
        return {
          ast,
          tokens,
          comments,
          splits,
          code: transformedCode
        };
      }
      return exportFn2 ? exportFn2(redeyed) : redeyed;
    }
  })();
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/ansicolors/ansicolors.js
var require_ansicolors = __commonJS((exports, module) => {
  var colorNums = {
    white: 37,
    black: 30,
    blue: 34,
    cyan: 36,
    green: 32,
    magenta: 35,
    red: 31,
    yellow: 33,
    brightBlack: 90,
    brightRed: 91,
    brightGreen: 92,
    brightYellow: 93,
    brightBlue: 94,
    brightMagenta: 95,
    brightCyan: 96,
    brightWhite: 97
  };
  var backgroundColorNums = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBrightBlack: 100,
    bgBrightRed: 101,
    bgBrightGreen: 102,
    bgBrightYellow: 103,
    bgBrightBlue: 104,
    bgBrightMagenta: 105,
    bgBrightCyan: 106,
    bgBrightWhite: 107
  };
  var open = {};
  var close = {};
  var colors = {};
  Object.keys(colorNums).forEach(function(k) {
    var o = open[k] = "\x1B[" + colorNums[k] + "m";
    var c = close[k] = "\x1B[39m";
    colors[k] = function(s) {
      return o + s + c;
    };
  });
  Object.keys(backgroundColorNums).forEach(function(k) {
    var o = open[k] = "\x1B[" + backgroundColorNums[k] + "m";
    var c = close[k] = "\x1B[49m";
    colors[k] = function(s) {
      return o + s + c;
    };
  });
  module.exports = colors;
  colors.open = open;
  colors.close = close;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cardinal/themes/default.js
var require_default = __commonJS((exports, module) => {
  var colors = require_ansicolors();
  module.exports = {
    Boolean: {
      true: undefined,
      false: undefined,
      _default: colors.brightRed
    },
    Identifier: {
      undefined: colors.brightBlack,
      self: colors.brightRed,
      console: colors.blue,
      log: colors.blue,
      warn: colors.red,
      error: colors.brightRed,
      _default: colors.white
    },
    Null: {
      _default: colors.brightBlack
    },
    Numeric: {
      _default: colors.blue
    },
    String: {
      _default: function(s, info) {
        var nextToken = info.tokens[info.tokenIndex + 1];
        return nextToken && nextToken.type === "Punctuator" && nextToken.value === ":" ? colors.green(s) : colors.brightGreen(s);
      }
    },
    Keyword: {
      break: undefined,
      case: undefined,
      catch: colors.cyan,
      class: undefined,
      const: undefined,
      continue: undefined,
      debugger: undefined,
      default: undefined,
      delete: colors.red,
      do: undefined,
      else: undefined,
      enum: undefined,
      export: undefined,
      extends: undefined,
      finally: colors.cyan,
      for: undefined,
      function: undefined,
      if: undefined,
      implements: undefined,
      import: undefined,
      in: undefined,
      instanceof: undefined,
      let: undefined,
      new: colors.red,
      package: undefined,
      private: undefined,
      protected: undefined,
      public: undefined,
      return: colors.red,
      static: undefined,
      super: undefined,
      switch: undefined,
      this: colors.brightRed,
      throw: undefined,
      try: colors.cyan,
      typeof: undefined,
      var: colors.green,
      void: undefined,
      while: undefined,
      with: undefined,
      yield: undefined,
      _default: colors.brightBlue
    },
    Punctuator: {
      ";": colors.brightBlack,
      ".": colors.green,
      ",": colors.green,
      "{": colors.yellow,
      "}": colors.yellow,
      "(": colors.brightBlack,
      ")": colors.brightBlack,
      "[": colors.yellow,
      "]": colors.yellow,
      "<": undefined,
      ">": undefined,
      "+": undefined,
      "-": undefined,
      "*": undefined,
      "%": undefined,
      "&": undefined,
      "|": undefined,
      "^": undefined,
      "!": undefined,
      "~": undefined,
      "?": undefined,
      ":": undefined,
      "=": undefined,
      "<=": undefined,
      ">=": undefined,
      "==": undefined,
      "!=": undefined,
      "++": undefined,
      "--": undefined,
      "<<": undefined,
      ">>": undefined,
      "&&": undefined,
      "||": undefined,
      "+=": undefined,
      "-=": undefined,
      "*=": undefined,
      "%=": undefined,
      "&=": undefined,
      "|=": undefined,
      "^=": undefined,
      "/=": undefined,
      "=>": undefined,
      "**": undefined,
      "===": undefined,
      "!==": undefined,
      ">>>": undefined,
      "<<=": undefined,
      ">>=": undefined,
      "...": undefined,
      "**=": undefined,
      ">>>=": undefined,
      _default: colors.brightYellow
    },
    Line: {
      _default: colors.brightBlack
    },
    Block: {
      _default: colors.brightBlack
    },
    JSXAttribute: {
      _default: colors.magenta
    },
    JSXClosingElement: {
      _default: colors.magenta
    },
    JSXElement: {
      _default: colors.magenta
    },
    JSXEmptyExpression: {
      _default: colors.magenta
    },
    JSXExpressionContainer: {
      _default: colors.magenta
    },
    JSXIdentifier: {
      className: colors.blue,
      _default: colors.magenta
    },
    JSXMemberExpression: {
      _default: colors.magenta
    },
    JSXNamespacedName: {
      _default: colors.magenta
    },
    JSXOpeningElement: {
      _default: colors.magenta
    },
    JSXSpreadAttribute: {
      _default: colors.magenta
    },
    JSXText: {
      _default: colors.brightGreen
    },
    _default: undefined
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cardinal/lib/highlight.js
var require_highlight = __commonJS((exports, module) => {
  var trimEmptyLines = function(lines) {
    var line = lines.pop();
    while (!line || !line.length) {
      line = lines.pop();
    }
    if (line)
      lines.push(line);
  };
  var addLinenos = function(highlightedCode, firstline) {
    var highlightedLines = highlightedCode.split("\n");
    trimEmptyLines(highlightedLines);
    var linesLen = highlightedLines.length;
    var lines = [];
    var totalDigits;
    var lineno;
    function getDigits(n) {
      if (n < 10)
        return 1;
      if (n < 100)
        return 2;
      if (n < 1000)
        return 3;
      if (n < 1e4)
        return 4;
      return 5;
    }
    function pad(n, totalDigits2) {
      var padDigits = totalDigits2 - getDigits(n);
      switch (padDigits) {
        case 0:
          return "" + n;
        case 1:
          return " " + n;
        case 2:
          return "  " + n;
        case 3:
          return "   " + n;
        case 4:
          return "    " + n;
        case 5:
          return "     " + n;
      }
    }
    totalDigits = getDigits(linesLen + firstline - 1);
    for (var i = 0;i < linesLen; i++) {
      lineno = colorSurround(pad(i + firstline, totalDigits) + ": ").replace(surroundClose, "");
      lines.push(lineno + highlightedLines[i]);
    }
    return lines.join("\n");
  };
  var redeyed = require_redeyed();
  var theme = require_default();
  var colors = require_ansicolors();
  var colorSurround = colors.brightBlack;
  var surroundClose = "\x1B[39m";
  module.exports = function highlight(code, opts) {
    opts = opts || {};
    try {
      var result = redeyed(code, opts.theme || theme, { jsx: !!opts.jsx });
      var firstline = opts.firstline && !isNaN(opts.firstline) ? opts.firstline : 1;
      return opts.linenos ? addLinenos(result.code, firstline) : result.code;
    } catch (e) {
      e.message = "Unable to perform highlight. The code contained syntax errors: " + e.message;
      throw e;
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cardinal/lib/highlightFile.js
var require_highlightFile = __commonJS((exports, module) => {
  var isFunction2 = function(obj) {
    return toString.call(obj) === "[object Function]";
  };
  var fs5 = __require("fs");
  var highlight = require_highlight();
  module.exports = function highlightFile(fullPath, opts, cb) {
    if (isFunction2(opts)) {
      cb = opts;
      opts = {};
    }
    opts = opts || {};
    fs5.readFile(fullPath, "utf-8", function(err, code) {
      if (err)
        return cb(err);
      try {
        cb(null, highlight(code, opts));
      } catch (e) {
        cb(e);
      }
    });
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cardinal/lib/highlightFileSync.js
var require_highlightFileSync = __commonJS((exports, module) => {
  var fs5 = __require("fs");
  var highlight = require_highlight();
  module.exports = function highlightFileSync(fullPath, opts) {
    var code = fs5.readFileSync(fullPath, "utf-8");
    opts = opts || {};
    return highlight(code, opts);
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cardinal/cardinal.js
var require_cardinal = __commonJS((exports, module) => {
  module.exports = {
    highlight: require_highlight(),
    highlightFile: require_highlightFile(),
    highlightFileSync: require_highlightFileSync()
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@sindresorhus/is/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var isTypedArrayName = function(name) {
    return typedArrayTypeNames.includes(name);
  };
  var isObjectTypeName = function(name) {
    return objectTypeNames.includes(name);
  };
  var isPrimitiveTypeName = function(name) {
    return primitiveTypeNames.includes(name);
  };
  var isOfType = function(type) {
    return (value2) => typeof value2 === type;
  };
  var is = function(value2) {
    if (value2 === null) {
      return "null";
    }
    switch (typeof value2) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      default:
    }
    if (is.observable(value2)) {
      return "Observable";
    }
    if (is.array(value2)) {
      return "Array";
    }
    if (is.buffer(value2)) {
      return "Buffer";
    }
    const tagType = getObjectType(value2);
    if (tagType) {
      return tagType;
    }
    if (value2 instanceof String || value2 instanceof Boolean || value2 instanceof Number) {
      throw new TypeError("Please don\'t use object wrappers for primitive types");
    }
    return "Object";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var typedArrayTypeNames = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  var objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    ...typedArrayTypeNames
  ];
  var primitiveTypeNames = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  var { toString: toString2 } = Object.prototype;
  var getObjectType = (value2) => {
    const objectTypeName = toString2.call(value2).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value2)) {
      return "HTMLElement";
    }
    if (isObjectTypeName(objectTypeName)) {
      return objectTypeName;
    }
    return;
  };
  var isObjectOfType = (type) => (value2) => getObjectType(value2) === type;
  is.undefined = isOfType("undefined");
  is.string = isOfType("string");
  var isNumberType = isOfType("number");
  is.number = (value2) => isNumberType(value2) && !is.nan(value2);
  is.bigint = isOfType("bigint");
  is.function_ = isOfType("function");
  is.null_ = (value2) => value2 === null;
  is.class_ = (value2) => is.function_(value2) && value2.toString().startsWith("class ");
  is.boolean = (value2) => value2 === true || value2 === false;
  is.symbol = isOfType("symbol");
  is.numericString = (value2) => is.string(value2) && !is.emptyStringOrWhitespace(value2) && !Number.isNaN(Number(value2));
  is.array = (value2, assertion) => {
    if (!Array.isArray(value2)) {
      return false;
    }
    if (!is.function_(assertion)) {
      return true;
    }
    return value2.every(assertion);
  };
  is.buffer = (value2) => {
    var _a2, _b2, _c2, _d;
    return (_d = (_c2 = (_b2 = (_a2 = value2) === null || _a2 === undefined ? undefined : _a2.constructor) === null || _b2 === undefined ? undefined : _b2.isBuffer) === null || _c2 === undefined ? undefined : _c2.call(_b2, value2)) !== null && _d !== undefined ? _d : false;
  };
  is.blob = (value2) => isObjectOfType("Blob")(value2);
  is.nullOrUndefined = (value2) => is.null_(value2) || is.undefined(value2);
  is.object = (value2) => !is.null_(value2) && (typeof value2 === "object" || is.function_(value2));
  is.iterable = (value2) => {
    var _a2;
    return is.function_((_a2 = value2) === null || _a2 === undefined ? undefined : _a2[Symbol.iterator]);
  };
  is.asyncIterable = (value2) => {
    var _a2;
    return is.function_((_a2 = value2) === null || _a2 === undefined ? undefined : _a2[Symbol.asyncIterator]);
  };
  is.generator = (value2) => {
    var _a2, _b2;
    return is.iterable(value2) && is.function_((_a2 = value2) === null || _a2 === undefined ? undefined : _a2.next) && is.function_((_b2 = value2) === null || _b2 === undefined ? undefined : _b2.throw);
  };
  is.asyncGenerator = (value2) => is.asyncIterable(value2) && is.function_(value2.next) && is.function_(value2.throw);
  is.nativePromise = (value2) => isObjectOfType("Promise")(value2);
  var hasPromiseAPI = (value2) => {
    var _a2, _b2;
    return is.function_((_a2 = value2) === null || _a2 === undefined ? undefined : _a2.then) && is.function_((_b2 = value2) === null || _b2 === undefined ? undefined : _b2.catch);
  };
  is.promise = (value2) => is.nativePromise(value2) || hasPromiseAPI(value2);
  is.generatorFunction = isObjectOfType("GeneratorFunction");
  is.asyncGeneratorFunction = (value2) => getObjectType(value2) === "AsyncGeneratorFunction";
  is.asyncFunction = (value2) => getObjectType(value2) === "AsyncFunction";
  is.boundFunction = (value2) => is.function_(value2) && !value2.hasOwnProperty("prototype");
  is.regExp = isObjectOfType("RegExp");
  is.date = isObjectOfType("Date");
  is.error = isObjectOfType("Error");
  is.map = (value2) => isObjectOfType("Map")(value2);
  is.set = (value2) => isObjectOfType("Set")(value2);
  is.weakMap = (value2) => isObjectOfType("WeakMap")(value2);
  is.weakSet = (value2) => isObjectOfType("WeakSet")(value2);
  is.int8Array = isObjectOfType("Int8Array");
  is.uint8Array = isObjectOfType("Uint8Array");
  is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
  is.int16Array = isObjectOfType("Int16Array");
  is.uint16Array = isObjectOfType("Uint16Array");
  is.int32Array = isObjectOfType("Int32Array");
  is.uint32Array = isObjectOfType("Uint32Array");
  is.float32Array = isObjectOfType("Float32Array");
  is.float64Array = isObjectOfType("Float64Array");
  is.bigInt64Array = isObjectOfType("BigInt64Array");
  is.bigUint64Array = isObjectOfType("BigUint64Array");
  is.arrayBuffer = isObjectOfType("ArrayBuffer");
  is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
  is.dataView = isObjectOfType("DataView");
  is.enumCase = (value2, targetEnum) => Object.values(targetEnum).includes(value2);
  is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
  is.urlInstance = (value2) => isObjectOfType("URL")(value2);
  is.urlString = (value2) => {
    if (!is.string(value2)) {
      return false;
    }
    try {
      new URL(value2);
      return true;
    } catch (_a2) {
      return false;
    }
  };
  is.truthy = (value2) => Boolean(value2);
  is.falsy = (value2) => !value2;
  is.nan = (value2) => Number.isNaN(value2);
  is.primitive = (value2) => is.null_(value2) || isPrimitiveTypeName(typeof value2);
  is.integer = (value2) => Number.isInteger(value2);
  is.safeInteger = (value2) => Number.isSafeInteger(value2);
  is.plainObject = (value2) => {
    if (toString2.call(value2) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value2);
    return prototype === null || prototype === Object.getPrototypeOf({});
  };
  is.typedArray = (value2) => isTypedArrayName(getObjectType(value2));
  var isValidLength = (value2) => is.safeInteger(value2) && value2 >= 0;
  is.arrayLike = (value2) => !is.nullOrUndefined(value2) && !is.function_(value2) && isValidLength(value2.length);
  is.inRange = (value2, range) => {
    if (is.number(range)) {
      return value2 >= Math.min(0, range) && value2 <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
      return value2 >= Math.min(...range) && value2 <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
  };
  var NODE_TYPE_ELEMENT = 1;
  var DOM_PROPERTIES_TO_CHECK = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  is.domElement = (value2) => {
    return is.object(value2) && value2.nodeType === NODE_TYPE_ELEMENT && is.string(value2.nodeName) && !is.plainObject(value2) && DOM_PROPERTIES_TO_CHECK.every((property2) => (property2 in value2));
  };
  is.observable = (value2) => {
    var _a2, _b2, _c2, _d;
    if (!value2) {
      return false;
    }
    if (value2 === ((_b2 = (_a2 = value2)[Symbol.observable]) === null || _b2 === undefined ? undefined : _b2.call(_a2))) {
      return true;
    }
    if (value2 === ((_d = (_c2 = value2)["@@observable"]) === null || _d === undefined ? undefined : _d.call(_c2))) {
      return true;
    }
    return false;
  };
  is.nodeStream = (value2) => is.object(value2) && is.function_(value2.pipe) && !is.observable(value2);
  is.infinite = (value2) => value2 === Infinity || value2 === (-Infinity);
  var isAbsoluteMod2 = (remainder) => (value2) => is.integer(value2) && Math.abs(value2 % 2) === remainder;
  is.evenInteger = isAbsoluteMod2(0);
  is.oddInteger = isAbsoluteMod2(1);
  is.emptyArray = (value2) => is.array(value2) && value2.length === 0;
  is.nonEmptyArray = (value2) => is.array(value2) && value2.length > 0;
  is.emptyString = (value2) => is.string(value2) && value2.length === 0;
  var isWhiteSpaceString = (value2) => is.string(value2) && !/\S/.test(value2);
  is.emptyStringOrWhitespace = (value2) => is.emptyString(value2) || isWhiteSpaceString(value2);
  is.nonEmptyString = (value2) => is.string(value2) && value2.length > 0;
  is.nonEmptyStringAndNotWhitespace = (value2) => is.string(value2) && !is.emptyStringOrWhitespace(value2);
  is.emptyObject = (value2) => is.object(value2) && !is.map(value2) && !is.set(value2) && Object.keys(value2).length === 0;
  is.nonEmptyObject = (value2) => is.object(value2) && !is.map(value2) && !is.set(value2) && Object.keys(value2).length > 0;
  is.emptySet = (value2) => is.set(value2) && value2.size === 0;
  is.nonEmptySet = (value2) => is.set(value2) && value2.size > 0;
  is.emptyMap = (value2) => is.map(value2) && value2.size === 0;
  is.nonEmptyMap = (value2) => is.map(value2) && value2.size > 0;
  is.propertyKey = (value2) => is.any([is.string, is.number, is.symbol], value2);
  is.formData = (value2) => isObjectOfType("FormData")(value2);
  is.urlSearchParams = (value2) => isObjectOfType("URLSearchParams")(value2);
  var predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
      throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
      throw new TypeError("Invalid number of values");
    }
    return method.call(values, predicate);
  };
  is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
  };
  is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
  var assertType = (condition, description, value2, options2 = {}) => {
    if (!condition) {
      const { multipleValues } = options2;
      const valuesMessage = multipleValues ? `received values of types ${[
        ...new Set(value2.map((singleValue) => `\`${is(singleValue)}\``))
      ].join(", ")}` : `received value of type \`${is(value2)}\``;
      throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
  };
  exports.assert = {
    undefined: (value2) => assertType(is.undefined(value2), "undefined", value2),
    string: (value2) => assertType(is.string(value2), "string", value2),
    number: (value2) => assertType(is.number(value2), "number", value2),
    bigint: (value2) => assertType(is.bigint(value2), "bigint", value2),
    function_: (value2) => assertType(is.function_(value2), "Function", value2),
    null_: (value2) => assertType(is.null_(value2), "null", value2),
    class_: (value2) => assertType(is.class_(value2), "Class", value2),
    boolean: (value2) => assertType(is.boolean(value2), "boolean", value2),
    symbol: (value2) => assertType(is.symbol(value2), "symbol", value2),
    numericString: (value2) => assertType(is.numericString(value2), "string with a number", value2),
    array: (value2, assertion) => {
      const assert = assertType;
      assert(is.array(value2), "Array", value2);
      if (assertion) {
        value2.forEach(assertion);
      }
    },
    buffer: (value2) => assertType(is.buffer(value2), "Buffer", value2),
    blob: (value2) => assertType(is.blob(value2), "Blob", value2),
    nullOrUndefined: (value2) => assertType(is.nullOrUndefined(value2), "null or undefined", value2),
    object: (value2) => assertType(is.object(value2), "Object", value2),
    iterable: (value2) => assertType(is.iterable(value2), "Iterable", value2),
    asyncIterable: (value2) => assertType(is.asyncIterable(value2), "AsyncIterable", value2),
    generator: (value2) => assertType(is.generator(value2), "Generator", value2),
    asyncGenerator: (value2) => assertType(is.asyncGenerator(value2), "AsyncGenerator", value2),
    nativePromise: (value2) => assertType(is.nativePromise(value2), "native Promise", value2),
    promise: (value2) => assertType(is.promise(value2), "Promise", value2),
    generatorFunction: (value2) => assertType(is.generatorFunction(value2), "GeneratorFunction", value2),
    asyncGeneratorFunction: (value2) => assertType(is.asyncGeneratorFunction(value2), "AsyncGeneratorFunction", value2),
    asyncFunction: (value2) => assertType(is.asyncFunction(value2), "AsyncFunction", value2),
    boundFunction: (value2) => assertType(is.boundFunction(value2), "Function", value2),
    regExp: (value2) => assertType(is.regExp(value2), "RegExp", value2),
    date: (value2) => assertType(is.date(value2), "Date", value2),
    error: (value2) => assertType(is.error(value2), "Error", value2),
    map: (value2) => assertType(is.map(value2), "Map", value2),
    set: (value2) => assertType(is.set(value2), "Set", value2),
    weakMap: (value2) => assertType(is.weakMap(value2), "WeakMap", value2),
    weakSet: (value2) => assertType(is.weakSet(value2), "WeakSet", value2),
    int8Array: (value2) => assertType(is.int8Array(value2), "Int8Array", value2),
    uint8Array: (value2) => assertType(is.uint8Array(value2), "Uint8Array", value2),
    uint8ClampedArray: (value2) => assertType(is.uint8ClampedArray(value2), "Uint8ClampedArray", value2),
    int16Array: (value2) => assertType(is.int16Array(value2), "Int16Array", value2),
    uint16Array: (value2) => assertType(is.uint16Array(value2), "Uint16Array", value2),
    int32Array: (value2) => assertType(is.int32Array(value2), "Int32Array", value2),
    uint32Array: (value2) => assertType(is.uint32Array(value2), "Uint32Array", value2),
    float32Array: (value2) => assertType(is.float32Array(value2), "Float32Array", value2),
    float64Array: (value2) => assertType(is.float64Array(value2), "Float64Array", value2),
    bigInt64Array: (value2) => assertType(is.bigInt64Array(value2), "BigInt64Array", value2),
    bigUint64Array: (value2) => assertType(is.bigUint64Array(value2), "BigUint64Array", value2),
    arrayBuffer: (value2) => assertType(is.arrayBuffer(value2), "ArrayBuffer", value2),
    sharedArrayBuffer: (value2) => assertType(is.sharedArrayBuffer(value2), "SharedArrayBuffer", value2),
    dataView: (value2) => assertType(is.dataView(value2), "DataView", value2),
    enumCase: (value2, targetEnum) => assertType(is.enumCase(value2, targetEnum), "EnumCase", value2),
    urlInstance: (value2) => assertType(is.urlInstance(value2), "URL", value2),
    urlString: (value2) => assertType(is.urlString(value2), "string with a URL", value2),
    truthy: (value2) => assertType(is.truthy(value2), "truthy", value2),
    falsy: (value2) => assertType(is.falsy(value2), "falsy", value2),
    nan: (value2) => assertType(is.nan(value2), "NaN", value2),
    primitive: (value2) => assertType(is.primitive(value2), "primitive", value2),
    integer: (value2) => assertType(is.integer(value2), "integer", value2),
    safeInteger: (value2) => assertType(is.safeInteger(value2), "integer", value2),
    plainObject: (value2) => assertType(is.plainObject(value2), "plain object", value2),
    typedArray: (value2) => assertType(is.typedArray(value2), "TypedArray", value2),
    arrayLike: (value2) => assertType(is.arrayLike(value2), "array-like", value2),
    domElement: (value2) => assertType(is.domElement(value2), "HTMLElement", value2),
    observable: (value2) => assertType(is.observable(value2), "Observable", value2),
    nodeStream: (value2) => assertType(is.nodeStream(value2), "Node.js Stream", value2),
    infinite: (value2) => assertType(is.infinite(value2), "infinite number", value2),
    emptyArray: (value2) => assertType(is.emptyArray(value2), "empty array", value2),
    nonEmptyArray: (value2) => assertType(is.nonEmptyArray(value2), "non-empty array", value2),
    emptyString: (value2) => assertType(is.emptyString(value2), "empty string", value2),
    emptyStringOrWhitespace: (value2) => assertType(is.emptyStringOrWhitespace(value2), "empty string or whitespace", value2),
    nonEmptyString: (value2) => assertType(is.nonEmptyString(value2), "non-empty string", value2),
    nonEmptyStringAndNotWhitespace: (value2) => assertType(is.nonEmptyStringAndNotWhitespace(value2), "non-empty string and not whitespace", value2),
    emptyObject: (value2) => assertType(is.emptyObject(value2), "empty object", value2),
    nonEmptyObject: (value2) => assertType(is.nonEmptyObject(value2), "non-empty object", value2),
    emptySet: (value2) => assertType(is.emptySet(value2), "empty set", value2),
    nonEmptySet: (value2) => assertType(is.nonEmptySet(value2), "non-empty set", value2),
    emptyMap: (value2) => assertType(is.emptyMap(value2), "empty map", value2),
    nonEmptyMap: (value2) => assertType(is.nonEmptyMap(value2), "non-empty map", value2),
    propertyKey: (value2) => assertType(is.propertyKey(value2), "PropertyKey", value2),
    formData: (value2) => assertType(is.formData(value2), "FormData", value2),
    urlSearchParams: (value2) => assertType(is.urlSearchParams(value2), "URLSearchParams", value2),
    evenInteger: (value2) => assertType(is.evenInteger(value2), "even integer", value2),
    oddInteger: (value2) => assertType(is.oddInteger(value2), "odd integer", value2),
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
    inRange: (value2, range) => assertType(is.inRange(value2, range), "in range", value2),
    any: (predicate, ...values) => {
      return assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true });
    },
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
  };
  Object.defineProperties(is, {
    class: {
      value: is.class_
    },
    function: {
      value: is.function_
    },
    null: {
      value: is.null_
    }
  });
  Object.defineProperties(exports.assert, {
    class: {
      value: exports.assert.class_
    },
    function: {
      value: exports.assert.function_
    },
    null: {
      value: exports.assert.null_
    }
  });
  exports.default = is;
  module.exports = is;
  module.exports.default = is;
  module.exports.assert = exports.assert;
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/emojilib/emojis.json
var require_emojis = __commonJS((exports, module) => {
  module.exports = {
    grinning: {
      keywords: ["face", "smile", "happy", "joy", ":D", "grin"],
      char: "\uD83D\uDE00",
      fitzpatrick_scale: false,
      category: "people"
    },
    grimacing: {
      keywords: ["face", "grimace", "teeth"],
      char: "\uD83D\uDE2C",
      fitzpatrick_scale: false,
      category: "people"
    },
    grin: {
      keywords: ["face", "happy", "smile", "joy", "kawaii"],
      char: "\uD83D\uDE01",
      fitzpatrick_scale: false,
      category: "people"
    },
    joy: {
      keywords: ["face", "cry", "tears", "weep", "happy", "happytears", "haha"],
      char: "\uD83D\uDE02",
      fitzpatrick_scale: false,
      category: "people"
    },
    rofl: {
      keywords: ["face", "rolling", "floor", "laughing", "lol", "haha"],
      char: "\uD83E\uDD23",
      fitzpatrick_scale: false,
      category: "people"
    },
    partying: {
      keywords: ["face", "celebration", "woohoo"],
      char: "\uD83E\uDD73",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiley: {
      keywords: ["face", "happy", "joy", "haha", ":D", ":)", "smile", "funny"],
      char: "\uD83D\uDE03",
      fitzpatrick_scale: false,
      category: "people"
    },
    smile: {
      keywords: ["face", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)"],
      char: "\uD83D\uDE04",
      fitzpatrick_scale: false,
      category: "people"
    },
    sweat_smile: {
      keywords: ["face", "hot", "happy", "laugh", "sweat", "smile", "relief"],
      char: "\uD83D\uDE05",
      fitzpatrick_scale: false,
      category: "people"
    },
    laughing: {
      keywords: ["happy", "joy", "lol", "satisfied", "haha", "face", "glad", "XD", "laugh"],
      char: "\uD83D\uDE06",
      fitzpatrick_scale: false,
      category: "people"
    },
    innocent: {
      keywords: ["face", "angel", "heaven", "halo"],
      char: "\uD83D\uDE07",
      fitzpatrick_scale: false,
      category: "people"
    },
    wink: {
      keywords: ["face", "happy", "mischievous", "secret", ";)", "smile", "eye"],
      char: "\uD83D\uDE09",
      fitzpatrick_scale: false,
      category: "people"
    },
    blush: {
      keywords: ["face", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy"],
      char: "\uD83D\uDE0A",
      fitzpatrick_scale: false,
      category: "people"
    },
    slightly_smiling_face: {
      keywords: ["face", "smile"],
      char: "\uD83D\uDE42",
      fitzpatrick_scale: false,
      category: "people"
    },
    upside_down_face: {
      keywords: ["face", "flipped", "silly", "smile"],
      char: "\uD83D\uDE43",
      fitzpatrick_scale: false,
      category: "people"
    },
    relaxed: {
      keywords: ["face", "blush", "massage", "happiness"],
      char: "\u263A\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    yum: {
      keywords: ["happy", "joy", "tongue", "smile", "face", "silly", "yummy", "nom", "delicious", "savouring"],
      char: "\uD83D\uDE0B",
      fitzpatrick_scale: false,
      category: "people"
    },
    relieved: {
      keywords: ["face", "relaxed", "phew", "massage", "happiness"],
      char: "\uD83D\uDE0C",
      fitzpatrick_scale: false,
      category: "people"
    },
    heart_eyes: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "heart"],
      char: "\uD83D\uDE0D",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiling_face_with_three_hearts: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "hearts", "adore"],
      char: "\uD83E\uDD70",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_heart: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE18",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing: {
      keywords: ["love", "like", "face", "3", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE17",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_smiling_eyes: {
      keywords: ["face", "affection", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE19",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_closed_eyes: {
      keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"],
      char: "\uD83D\uDE1A",
      fitzpatrick_scale: false,
      category: "people"
    },
    stuck_out_tongue_winking_eye: {
      keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "wink", "tongue"],
      char: "\uD83D\uDE1C",
      fitzpatrick_scale: false,
      category: "people"
    },
    zany: {
      keywords: ["face", "goofy", "crazy"],
      char: "\uD83E\uDD2A",
      fitzpatrick_scale: false,
      category: "people"
    },
    raised_eyebrow: {
      keywords: ["face", "distrust", "scepticism", "disapproval", "disbelief", "surprise"],
      char: "\uD83E\uDD28",
      fitzpatrick_scale: false,
      category: "people"
    },
    monocle: {
      keywords: ["face", "stuffy", "wealthy"],
      char: "\uD83E\uDDD0",
      fitzpatrick_scale: false,
      category: "people"
    },
    stuck_out_tongue_closed_eyes: {
      keywords: ["face", "prank", "playful", "mischievous", "smile", "tongue"],
      char: "\uD83D\uDE1D",
      fitzpatrick_scale: false,
      category: "people"
    },
    stuck_out_tongue: {
      keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "tongue"],
      char: "\uD83D\uDE1B",
      fitzpatrick_scale: false,
      category: "people"
    },
    money_mouth_face: {
      keywords: ["face", "rich", "dollar", "money"],
      char: "\uD83E\uDD11",
      fitzpatrick_scale: false,
      category: "people"
    },
    nerd_face: {
      keywords: ["face", "nerdy", "geek", "dork"],
      char: "\uD83E\uDD13",
      fitzpatrick_scale: false,
      category: "people"
    },
    sunglasses: {
      keywords: ["face", "cool", "smile", "summer", "beach", "sunglass"],
      char: "\uD83D\uDE0E",
      fitzpatrick_scale: false,
      category: "people"
    },
    star_struck: {
      keywords: ["face", "smile", "starry", "eyes", "grinning"],
      char: "\uD83E\uDD29",
      fitzpatrick_scale: false,
      category: "people"
    },
    clown_face: {
      keywords: ["face"],
      char: "\uD83E\uDD21",
      fitzpatrick_scale: false,
      category: "people"
    },
    cowboy_hat_face: {
      keywords: ["face", "cowgirl", "hat"],
      char: "\uD83E\uDD20",
      fitzpatrick_scale: false,
      category: "people"
    },
    hugs: {
      keywords: ["face", "smile", "hug"],
      char: "\uD83E\uDD17",
      fitzpatrick_scale: false,
      category: "people"
    },
    smirk: {
      keywords: ["face", "smile", "mean", "prank", "smug", "sarcasm"],
      char: "\uD83D\uDE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    no_mouth: {
      keywords: ["face", "hellokitty"],
      char: "\uD83D\uDE36",
      fitzpatrick_scale: false,
      category: "people"
    },
    neutral_face: {
      keywords: ["indifference", "meh", ":|", "neutral"],
      char: "\uD83D\uDE10",
      fitzpatrick_scale: false,
      category: "people"
    },
    expressionless: {
      keywords: ["face", "indifferent", "-_-", "meh", "deadpan"],
      char: "\uD83D\uDE11",
      fitzpatrick_scale: false,
      category: "people"
    },
    unamused: {
      keywords: ["indifference", "bored", "straight face", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side_eye"],
      char: "\uD83D\uDE12",
      fitzpatrick_scale: false,
      category: "people"
    },
    roll_eyes: {
      keywords: ["face", "eyeroll", "frustrated"],
      char: "\uD83D\uDE44",
      fitzpatrick_scale: false,
      category: "people"
    },
    thinking: {
      keywords: ["face", "hmmm", "think", "consider"],
      char: "\uD83E\uDD14",
      fitzpatrick_scale: false,
      category: "people"
    },
    lying_face: {
      keywords: ["face", "lie", "pinocchio"],
      char: "\uD83E\uDD25",
      fitzpatrick_scale: false,
      category: "people"
    },
    hand_over_mouth: {
      keywords: ["face", "whoops", "shock", "surprise"],
      char: "\uD83E\uDD2D",
      fitzpatrick_scale: false,
      category: "people"
    },
    shushing: {
      keywords: ["face", "quiet", "shhh"],
      char: "\uD83E\uDD2B",
      fitzpatrick_scale: false,
      category: "people"
    },
    symbols_over_mouth: {
      keywords: ["face", "swearing", "cursing", "cussing", "profanity", "expletive"],
      char: "\uD83E\uDD2C",
      fitzpatrick_scale: false,
      category: "people"
    },
    exploding_head: {
      keywords: ["face", "shocked", "mind", "blown"],
      char: "\uD83E\uDD2F",
      fitzpatrick_scale: false,
      category: "people"
    },
    flushed: {
      keywords: ["face", "blush", "shy", "flattered"],
      char: "\uD83D\uDE33",
      fitzpatrick_scale: false,
      category: "people"
    },
    disappointed: {
      keywords: ["face", "sad", "upset", "depressed", ":("],
      char: "\uD83D\uDE1E",
      fitzpatrick_scale: false,
      category: "people"
    },
    worried: {
      keywords: ["face", "concern", "nervous", ":("],
      char: "\uD83D\uDE1F",
      fitzpatrick_scale: false,
      category: "people"
    },
    angry: {
      keywords: ["mad", "face", "annoyed", "frustrated"],
      char: "\uD83D\uDE20",
      fitzpatrick_scale: false,
      category: "people"
    },
    rage: {
      keywords: ["angry", "mad", "hate", "despise"],
      char: "\uD83D\uDE21",
      fitzpatrick_scale: false,
      category: "people"
    },
    pensive: {
      keywords: ["face", "sad", "depressed", "upset"],
      char: "\uD83D\uDE14",
      fitzpatrick_scale: false,
      category: "people"
    },
    confused: {
      keywords: ["face", "indifference", "huh", "weird", "hmmm", ":/"],
      char: "\uD83D\uDE15",
      fitzpatrick_scale: false,
      category: "people"
    },
    slightly_frowning_face: {
      keywords: ["face", "frowning", "disappointed", "sad", "upset"],
      char: "\uD83D\uDE41",
      fitzpatrick_scale: false,
      category: "people"
    },
    frowning_face: {
      keywords: ["face", "sad", "upset", "frown"],
      char: "\u2639",
      fitzpatrick_scale: false,
      category: "people"
    },
    persevere: {
      keywords: ["face", "sick", "no", "upset", "oops"],
      char: "\uD83D\uDE23",
      fitzpatrick_scale: false,
      category: "people"
    },
    confounded: {
      keywords: ["face", "confused", "sick", "unwell", "oops", ":S"],
      char: "\uD83D\uDE16",
      fitzpatrick_scale: false,
      category: "people"
    },
    tired_face: {
      keywords: ["sick", "whine", "upset", "frustrated"],
      char: "\uD83D\uDE2B",
      fitzpatrick_scale: false,
      category: "people"
    },
    weary: {
      keywords: ["face", "tired", "sleepy", "sad", "frustrated", "upset"],
      char: "\uD83D\uDE29",
      fitzpatrick_scale: false,
      category: "people"
    },
    pleading: {
      keywords: ["face", "begging", "mercy"],
      char: "\uD83E\uDD7A",
      fitzpatrick_scale: false,
      category: "people"
    },
    triumph: {
      keywords: ["face", "gas", "phew", "proud", "pride"],
      char: "\uD83D\uDE24",
      fitzpatrick_scale: false,
      category: "people"
    },
    open_mouth: {
      keywords: ["face", "surprise", "impressed", "wow", "whoa", ":O"],
      char: "\uD83D\uDE2E",
      fitzpatrick_scale: false,
      category: "people"
    },
    scream: {
      keywords: ["face", "munch", "scared", "omg"],
      char: "\uD83D\uDE31",
      fitzpatrick_scale: false,
      category: "people"
    },
    fearful: {
      keywords: ["face", "scared", "terrified", "nervous", "oops", "huh"],
      char: "\uD83D\uDE28",
      fitzpatrick_scale: false,
      category: "people"
    },
    cold_sweat: {
      keywords: ["face", "nervous", "sweat"],
      char: "\uD83D\uDE30",
      fitzpatrick_scale: false,
      category: "people"
    },
    hushed: {
      keywords: ["face", "woo", "shh"],
      char: "\uD83D\uDE2F",
      fitzpatrick_scale: false,
      category: "people"
    },
    frowning: {
      keywords: ["face", "aw", "what"],
      char: "\uD83D\uDE26",
      fitzpatrick_scale: false,
      category: "people"
    },
    anguished: {
      keywords: ["face", "stunned", "nervous"],
      char: "\uD83D\uDE27",
      fitzpatrick_scale: false,
      category: "people"
    },
    cry: {
      keywords: ["face", "tears", "sad", "depressed", "upset", ":'("],
      char: "\uD83D\uDE22",
      fitzpatrick_scale: false,
      category: "people"
    },
    disappointed_relieved: {
      keywords: ["face", "phew", "sweat", "nervous"],
      char: "\uD83D\uDE25",
      fitzpatrick_scale: false,
      category: "people"
    },
    drooling_face: {
      keywords: ["face"],
      char: "\uD83E\uDD24",
      fitzpatrick_scale: false,
      category: "people"
    },
    sleepy: {
      keywords: ["face", "tired", "rest", "nap"],
      char: "\uD83D\uDE2A",
      fitzpatrick_scale: false,
      category: "people"
    },
    sweat: {
      keywords: ["face", "hot", "sad", "tired", "exercise"],
      char: "\uD83D\uDE13",
      fitzpatrick_scale: false,
      category: "people"
    },
    hot: {
      keywords: ["face", "feverish", "heat", "red", "sweating"],
      char: "\uD83E\uDD75",
      fitzpatrick_scale: false,
      category: "people"
    },
    cold: {
      keywords: ["face", "blue", "freezing", "frozen", "frostbite", "icicles"],
      char: "\uD83E\uDD76",
      fitzpatrick_scale: false,
      category: "people"
    },
    sob: {
      keywords: ["face", "cry", "tears", "sad", "upset", "depressed"],
      char: "\uD83D\uDE2D",
      fitzpatrick_scale: false,
      category: "people"
    },
    dizzy_face: {
      keywords: ["spent", "unconscious", "xox", "dizzy"],
      char: "\uD83D\uDE35",
      fitzpatrick_scale: false,
      category: "people"
    },
    astonished: {
      keywords: ["face", "xox", "surprised", "poisoned"],
      char: "\uD83D\uDE32",
      fitzpatrick_scale: false,
      category: "people"
    },
    zipper_mouth_face: {
      keywords: ["face", "sealed", "zipper", "secret"],
      char: "\uD83E\uDD10",
      fitzpatrick_scale: false,
      category: "people"
    },
    nauseated_face: {
      keywords: ["face", "vomit", "gross", "green", "sick", "throw up", "ill"],
      char: "\uD83E\uDD22",
      fitzpatrick_scale: false,
      category: "people"
    },
    sneezing_face: {
      keywords: ["face", "gesundheit", "sneeze", "sick", "allergy"],
      char: "\uD83E\uDD27",
      fitzpatrick_scale: false,
      category: "people"
    },
    vomiting: {
      keywords: ["face", "sick"],
      char: "\uD83E\uDD2E",
      fitzpatrick_scale: false,
      category: "people"
    },
    mask: {
      keywords: ["face", "sick", "ill", "disease"],
      char: "\uD83D\uDE37",
      fitzpatrick_scale: false,
      category: "people"
    },
    face_with_thermometer: {
      keywords: ["sick", "temperature", "thermometer", "cold", "fever"],
      char: "\uD83E\uDD12",
      fitzpatrick_scale: false,
      category: "people"
    },
    face_with_head_bandage: {
      keywords: ["injured", "clumsy", "bandage", "hurt"],
      char: "\uD83E\uDD15",
      fitzpatrick_scale: false,
      category: "people"
    },
    woozy: {
      keywords: ["face", "dizzy", "intoxicated", "tipsy", "wavy"],
      char: "\uD83E\uDD74",
      fitzpatrick_scale: false,
      category: "people"
    },
    sleeping: {
      keywords: ["face", "tired", "sleepy", "night", "zzz"],
      char: "\uD83D\uDE34",
      fitzpatrick_scale: false,
      category: "people"
    },
    zzz: {
      keywords: ["sleepy", "tired", "dream"],
      char: "\uD83D\uDCA4",
      fitzpatrick_scale: false,
      category: "people"
    },
    poop: {
      keywords: ["hankey", "shitface", "fail", "turd", "shit"],
      char: "\uD83D\uDCA9",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiling_imp: {
      keywords: ["devil", "horns"],
      char: "\uD83D\uDE08",
      fitzpatrick_scale: false,
      category: "people"
    },
    imp: {
      keywords: ["devil", "angry", "horns"],
      char: "\uD83D\uDC7F",
      fitzpatrick_scale: false,
      category: "people"
    },
    japanese_ogre: {
      keywords: ["monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon", "japanese", "ogre"],
      char: "\uD83D\uDC79",
      fitzpatrick_scale: false,
      category: "people"
    },
    japanese_goblin: {
      keywords: ["red", "evil", "mask", "monster", "scary", "creepy", "japanese", "goblin"],
      char: "\uD83D\uDC7A",
      fitzpatrick_scale: false,
      category: "people"
    },
    skull: {
      keywords: ["dead", "skeleton", "creepy", "death"],
      char: "\uD83D\uDC80",
      fitzpatrick_scale: false,
      category: "people"
    },
    ghost: {
      keywords: ["halloween", "spooky", "scary"],
      char: "\uD83D\uDC7B",
      fitzpatrick_scale: false,
      category: "people"
    },
    alien: {
      keywords: ["UFO", "paul", "weird", "outer_space"],
      char: "\uD83D\uDC7D",
      fitzpatrick_scale: false,
      category: "people"
    },
    robot: {
      keywords: ["computer", "machine", "bot"],
      char: "\uD83E\uDD16",
      fitzpatrick_scale: false,
      category: "people"
    },
    smiley_cat: {
      keywords: ["animal", "cats", "happy", "smile"],
      char: "\uD83D\uDE3A",
      fitzpatrick_scale: false,
      category: "people"
    },
    smile_cat: {
      keywords: ["animal", "cats", "smile"],
      char: "\uD83D\uDE38",
      fitzpatrick_scale: false,
      category: "people"
    },
    joy_cat: {
      keywords: ["animal", "cats", "haha", "happy", "tears"],
      char: "\uD83D\uDE39",
      fitzpatrick_scale: false,
      category: "people"
    },
    heart_eyes_cat: {
      keywords: ["animal", "love", "like", "affection", "cats", "valentines", "heart"],
      char: "\uD83D\uDE3B",
      fitzpatrick_scale: false,
      category: "people"
    },
    smirk_cat: {
      keywords: ["animal", "cats", "smirk"],
      char: "\uD83D\uDE3C",
      fitzpatrick_scale: false,
      category: "people"
    },
    kissing_cat: {
      keywords: ["animal", "cats", "kiss"],
      char: "\uD83D\uDE3D",
      fitzpatrick_scale: false,
      category: "people"
    },
    scream_cat: {
      keywords: ["animal", "cats", "munch", "scared", "scream"],
      char: "\uD83D\uDE40",
      fitzpatrick_scale: false,
      category: "people"
    },
    crying_cat_face: {
      keywords: ["animal", "tears", "weep", "sad", "cats", "upset", "cry"],
      char: "\uD83D\uDE3F",
      fitzpatrick_scale: false,
      category: "people"
    },
    pouting_cat: {
      keywords: ["animal", "cats"],
      char: "\uD83D\uDE3E",
      fitzpatrick_scale: false,
      category: "people"
    },
    palms_up: {
      keywords: ["hands", "gesture", "cupped", "prayer"],
      char: "\uD83E\uDD32",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_hands: {
      keywords: ["gesture", "hooray", "yea", "celebration", "hands"],
      char: "\uD83D\uDE4C",
      fitzpatrick_scale: true,
      category: "people"
    },
    clap: {
      keywords: ["hands", "praise", "applause", "congrats", "yay"],
      char: "\uD83D\uDC4F",
      fitzpatrick_scale: true,
      category: "people"
    },
    wave: {
      keywords: ["hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm"],
      char: "\uD83D\uDC4B",
      fitzpatrick_scale: true,
      category: "people"
    },
    call_me_hand: {
      keywords: ["hands", "gesture"],
      char: "\uD83E\uDD19",
      fitzpatrick_scale: true,
      category: "people"
    },
    "+1": {
      keywords: ["thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like"],
      char: "\uD83D\uDC4D",
      fitzpatrick_scale: true,
      category: "people"
    },
    "-1": {
      keywords: ["thumbsdown", "no", "dislike", "hand"],
      char: "\uD83D\uDC4E",
      fitzpatrick_scale: true,
      category: "people"
    },
    facepunch: {
      keywords: ["angry", "violence", "fist", "hit", "attack", "hand"],
      char: "\uD83D\uDC4A",
      fitzpatrick_scale: true,
      category: "people"
    },
    fist: {
      keywords: ["fingers", "hand", "grasp"],
      char: "\u270A",
      fitzpatrick_scale: true,
      category: "people"
    },
    fist_left: {
      keywords: ["hand", "fistbump"],
      char: "\uD83E\uDD1B",
      fitzpatrick_scale: true,
      category: "people"
    },
    fist_right: {
      keywords: ["hand", "fistbump"],
      char: "\uD83E\uDD1C",
      fitzpatrick_scale: true,
      category: "people"
    },
    v: {
      keywords: ["fingers", "ohyeah", "hand", "peace", "victory", "two"],
      char: "\u270C",
      fitzpatrick_scale: true,
      category: "people"
    },
    ok_hand: {
      keywords: ["fingers", "limbs", "perfect", "ok", "okay"],
      char: "\uD83D\uDC4C",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_hand: {
      keywords: ["fingers", "stop", "highfive", "palm", "ban"],
      char: "\u270B",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_back_of_hand: {
      keywords: ["fingers", "raised", "backhand"],
      char: "\uD83E\uDD1A",
      fitzpatrick_scale: true,
      category: "people"
    },
    open_hands: {
      keywords: ["fingers", "butterfly", "hands", "open"],
      char: "\uD83D\uDC50",
      fitzpatrick_scale: true,
      category: "people"
    },
    muscle: {
      keywords: ["arm", "flex", "hand", "summer", "strong", "biceps"],
      char: "\uD83D\uDCAA",
      fitzpatrick_scale: true,
      category: "people"
    },
    pray: {
      keywords: ["please", "hope", "wish", "namaste", "highfive"],
      char: "\uD83D\uDE4F",
      fitzpatrick_scale: true,
      category: "people"
    },
    foot: {
      keywords: ["kick", "stomp"],
      char: "\uD83E\uDDB6",
      fitzpatrick_scale: true,
      category: "people"
    },
    leg: {
      keywords: ["kick", "limb"],
      char: "\uD83E\uDDB5",
      fitzpatrick_scale: true,
      category: "people"
    },
    handshake: {
      keywords: ["agreement", "shake"],
      char: "\uD83E\uDD1D",
      fitzpatrick_scale: false,
      category: "people"
    },
    point_up: {
      keywords: ["hand", "fingers", "direction", "up"],
      char: "\u261D",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_up_2: {
      keywords: ["fingers", "hand", "direction", "up"],
      char: "\uD83D\uDC46",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_down: {
      keywords: ["fingers", "hand", "direction", "down"],
      char: "\uD83D\uDC47",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_left: {
      keywords: ["direction", "fingers", "hand", "left"],
      char: "\uD83D\uDC48",
      fitzpatrick_scale: true,
      category: "people"
    },
    point_right: {
      keywords: ["fingers", "hand", "direction", "right"],
      char: "\uD83D\uDC49",
      fitzpatrick_scale: true,
      category: "people"
    },
    fu: {
      keywords: ["hand", "fingers", "rude", "middle", "flipping"],
      char: "\uD83D\uDD95",
      fitzpatrick_scale: true,
      category: "people"
    },
    raised_hand_with_fingers_splayed: {
      keywords: ["hand", "fingers", "palm"],
      char: "\uD83D\uDD90",
      fitzpatrick_scale: true,
      category: "people"
    },
    love_you: {
      keywords: ["hand", "fingers", "gesture"],
      char: "\uD83E\uDD1F",
      fitzpatrick_scale: true,
      category: "people"
    },
    metal: {
      keywords: ["hand", "fingers", "evil_eye", "sign_of_horns", "rock_on"],
      char: "\uD83E\uDD18",
      fitzpatrick_scale: true,
      category: "people"
    },
    crossed_fingers: {
      keywords: ["good", "lucky"],
      char: "\uD83E\uDD1E",
      fitzpatrick_scale: true,
      category: "people"
    },
    vulcan_salute: {
      keywords: ["hand", "fingers", "spock", "star trek"],
      char: "\uD83D\uDD96",
      fitzpatrick_scale: true,
      category: "people"
    },
    writing_hand: {
      keywords: ["lower_left_ballpoint_pen", "stationery", "write", "compose"],
      char: "\u270D",
      fitzpatrick_scale: true,
      category: "people"
    },
    selfie: {
      keywords: ["camera", "phone"],
      char: "\uD83E\uDD33",
      fitzpatrick_scale: true,
      category: "people"
    },
    nail_care: {
      keywords: ["beauty", "manicure", "finger", "fashion", "nail"],
      char: "\uD83D\uDC85",
      fitzpatrick_scale: true,
      category: "people"
    },
    lips: {
      keywords: ["mouth", "kiss"],
      char: "\uD83D\uDC44",
      fitzpatrick_scale: false,
      category: "people"
    },
    tooth: {
      keywords: ["teeth", "dentist"],
      char: "\uD83E\uDDB7",
      fitzpatrick_scale: false,
      category: "people"
    },
    tongue: {
      keywords: ["mouth", "playful"],
      char: "\uD83D\uDC45",
      fitzpatrick_scale: false,
      category: "people"
    },
    ear: {
      keywords: ["face", "hear", "sound", "listen"],
      char: "\uD83D\uDC42",
      fitzpatrick_scale: true,
      category: "people"
    },
    nose: {
      keywords: ["smell", "sniff"],
      char: "\uD83D\uDC43",
      fitzpatrick_scale: true,
      category: "people"
    },
    eye: {
      keywords: ["face", "look", "see", "watch", "stare"],
      char: "\uD83D\uDC41",
      fitzpatrick_scale: false,
      category: "people"
    },
    eyes: {
      keywords: ["look", "watch", "stalk", "peek", "see"],
      char: "\uD83D\uDC40",
      fitzpatrick_scale: false,
      category: "people"
    },
    brain: {
      keywords: ["smart", "intelligent"],
      char: "\uD83E\uDDE0",
      fitzpatrick_scale: false,
      category: "people"
    },
    bust_in_silhouette: {
      keywords: ["user", "person", "human"],
      char: "\uD83D\uDC64",
      fitzpatrick_scale: false,
      category: "people"
    },
    busts_in_silhouette: {
      keywords: ["user", "person", "human", "group", "team"],
      char: "\uD83D\uDC65",
      fitzpatrick_scale: false,
      category: "people"
    },
    speaking_head: {
      keywords: ["user", "person", "human", "sing", "say", "talk"],
      char: "\uD83D\uDDE3",
      fitzpatrick_scale: false,
      category: "people"
    },
    baby: {
      keywords: ["child", "boy", "girl", "toddler"],
      char: "\uD83D\uDC76",
      fitzpatrick_scale: true,
      category: "people"
    },
    child: {
      keywords: ["gender-neutral", "young"],
      char: "\uD83E\uDDD2",
      fitzpatrick_scale: true,
      category: "people"
    },
    boy: {
      keywords: ["man", "male", "guy", "teenager"],
      char: "\uD83D\uDC66",
      fitzpatrick_scale: true,
      category: "people"
    },
    girl: {
      keywords: ["female", "woman", "teenager"],
      char: "\uD83D\uDC67",
      fitzpatrick_scale: true,
      category: "people"
    },
    adult: {
      keywords: ["gender-neutral", "person"],
      char: "\uD83E\uDDD1",
      fitzpatrick_scale: true,
      category: "people"
    },
    man: {
      keywords: ["mustache", "father", "dad", "guy", "classy", "sir", "moustache"],
      char: "\uD83D\uDC68",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman: {
      keywords: ["female", "girls", "lady"],
      char: "\uD83D\uDC69",
      fitzpatrick_scale: true,
      category: "people"
    },
    blonde_woman: {
      keywords: ["woman", "female", "girl", "blonde", "person"],
      char: "\uD83D\uDC71\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    blonde_man: {
      keywords: ["man", "male", "boy", "blonde", "guy", "person"],
      char: "\uD83D\uDC71",
      fitzpatrick_scale: true,
      category: "people"
    },
    bearded_person: {
      keywords: ["person", "bewhiskered"],
      char: "\uD83E\uDDD4",
      fitzpatrick_scale: true,
      category: "people"
    },
    older_adult: {
      keywords: ["human", "elder", "senior", "gender-neutral"],
      char: "\uD83E\uDDD3",
      fitzpatrick_scale: true,
      category: "people"
    },
    older_man: {
      keywords: ["human", "male", "men", "old", "elder", "senior"],
      char: "\uD83D\uDC74",
      fitzpatrick_scale: true,
      category: "people"
    },
    older_woman: {
      keywords: ["human", "female", "women", "lady", "old", "elder", "senior"],
      char: "\uD83D\uDC75",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_with_gua_pi_mao: {
      keywords: ["male", "boy", "chinese"],
      char: "\uD83D\uDC72",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_with_headscarf: {
      keywords: ["female", "hijab", "mantilla", "tichel"],
      char: "\uD83E\uDDD5",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_with_turban: {
      keywords: ["female", "indian", "hinduism", "arabs", "woman"],
      char: "\uD83D\uDC73\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_with_turban: {
      keywords: ["male", "indian", "hinduism", "arabs"],
      char: "\uD83D\uDC73",
      fitzpatrick_scale: true,
      category: "people"
    },
    policewoman: {
      keywords: ["woman", "police", "law", "legal", "enforcement", "arrest", "911", "female"],
      char: "\uD83D\uDC6E\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    policeman: {
      keywords: ["man", "police", "law", "legal", "enforcement", "arrest", "911"],
      char: "\uD83D\uDC6E",
      fitzpatrick_scale: true,
      category: "people"
    },
    construction_worker_woman: {
      keywords: ["female", "human", "wip", "build", "construction", "worker", "labor", "woman"],
      char: "\uD83D\uDC77\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    construction_worker_man: {
      keywords: ["male", "human", "wip", "guy", "build", "construction", "worker", "labor"],
      char: "\uD83D\uDC77",
      fitzpatrick_scale: true,
      category: "people"
    },
    guardswoman: {
      keywords: ["uk", "gb", "british", "female", "royal", "woman"],
      char: "\uD83D\uDC82\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    guardsman: {
      keywords: ["uk", "gb", "british", "male", "guy", "royal"],
      char: "\uD83D\uDC82",
      fitzpatrick_scale: true,
      category: "people"
    },
    female_detective: {
      keywords: ["human", "spy", "detective", "female", "woman"],
      char: "\uD83D\uDD75\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    male_detective: {
      keywords: ["human", "spy", "detective"],
      char: "\uD83D\uDD75",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_health_worker: {
      keywords: ["doctor", "nurse", "therapist", "healthcare", "woman", "human"],
      char: "\uD83D\uDC69\u200D\u2695\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_health_worker: {
      keywords: ["doctor", "nurse", "therapist", "healthcare", "man", "human"],
      char: "\uD83D\uDC68\u200D\u2695\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_farmer: {
      keywords: ["rancher", "gardener", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDF3E",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_farmer: {
      keywords: ["rancher", "gardener", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDF3E",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_cook: {
      keywords: ["chef", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDF73",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_cook: {
      keywords: ["chef", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDF73",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_student: {
      keywords: ["graduate", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDF93",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_student: {
      keywords: ["graduate", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDF93",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_singer: {
      keywords: ["rockstar", "entertainer", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFA4",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_singer: {
      keywords: ["rockstar", "entertainer", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFA4",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_teacher: {
      keywords: ["instructor", "professor", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFEB",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_teacher: {
      keywords: ["instructor", "professor", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFEB",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_factory_worker: {
      keywords: ["assembly", "industrial", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFED",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_factory_worker: {
      keywords: ["assembly", "industrial", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFED",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_technologist: {
      keywords: ["coder", "developer", "engineer", "programmer", "software", "woman", "human", "laptop", "computer"],
      char: "\uD83D\uDC69\u200D\uD83D\uDCBB",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_technologist: {
      keywords: ["coder", "developer", "engineer", "programmer", "software", "man", "human", "laptop", "computer"],
      char: "\uD83D\uDC68\u200D\uD83D\uDCBB",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_office_worker: {
      keywords: ["business", "manager", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDCBC",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_office_worker: {
      keywords: ["business", "manager", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDCBC",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_mechanic: {
      keywords: ["plumber", "woman", "human", "wrench"],
      char: "\uD83D\uDC69\u200D\uD83D\uDD27",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_mechanic: {
      keywords: ["plumber", "man", "human", "wrench"],
      char: "\uD83D\uDC68\u200D\uD83D\uDD27",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_scientist: {
      keywords: ["biologist", "chemist", "engineer", "physicist", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDD2C",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_scientist: {
      keywords: ["biologist", "chemist", "engineer", "physicist", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDD2C",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_artist: {
      keywords: ["painter", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83C\uDFA8",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_artist: {
      keywords: ["painter", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83C\uDFA8",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_firefighter: {
      keywords: ["fireman", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDE92",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_firefighter: {
      keywords: ["fireman", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDE92",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_pilot: {
      keywords: ["aviator", "plane", "woman", "human"],
      char: "\uD83D\uDC69\u200D\u2708\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_pilot: {
      keywords: ["aviator", "plane", "man", "human"],
      char: "\uD83D\uDC68\u200D\u2708\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_astronaut: {
      keywords: ["space", "rocket", "woman", "human"],
      char: "\uD83D\uDC69\u200D\uD83D\uDE80",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_astronaut: {
      keywords: ["space", "rocket", "man", "human"],
      char: "\uD83D\uDC68\u200D\uD83D\uDE80",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_judge: {
      keywords: ["justice", "court", "woman", "human"],
      char: "\uD83D\uDC69\u200D\u2696\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_judge: {
      keywords: ["justice", "court", "man", "human"],
      char: "\uD83D\uDC68\u200D\u2696\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_superhero: {
      keywords: ["woman", "female", "good", "heroine", "superpowers"],
      char: "\uD83E\uDDB8\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_superhero: {
      keywords: ["man", "male", "good", "hero", "superpowers"],
      char: "\uD83E\uDDB8\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_supervillain: {
      keywords: ["woman", "female", "evil", "bad", "criminal", "heroine", "superpowers"],
      char: "\uD83E\uDDB9\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_supervillain: {
      keywords: ["man", "male", "evil", "bad", "criminal", "hero", "superpowers"],
      char: "\uD83E\uDDB9\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    mrs_claus: {
      keywords: ["woman", "female", "xmas", "mother christmas"],
      char: "\uD83E\uDD36",
      fitzpatrick_scale: true,
      category: "people"
    },
    santa: {
      keywords: ["festival", "man", "male", "xmas", "father christmas"],
      char: "\uD83C\uDF85",
      fitzpatrick_scale: true,
      category: "people"
    },
    sorceress: {
      keywords: ["woman", "female", "mage", "witch"],
      char: "\uD83E\uDDD9\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    wizard: {
      keywords: ["man", "male", "mage", "sorcerer"],
      char: "\uD83E\uDDD9\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_elf: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDD\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_elf: {
      keywords: ["man", "male"],
      char: "\uD83E\uDDDD\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_vampire: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDB\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_vampire: {
      keywords: ["man", "male", "dracula"],
      char: "\uD83E\uDDDB\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_zombie: {
      keywords: ["woman", "female", "undead", "walking dead"],
      char: "\uD83E\uDDDF\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    man_zombie: {
      keywords: ["man", "male", "dracula", "undead", "walking dead"],
      char: "\uD83E\uDDDF\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    woman_genie: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDE\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    man_genie: {
      keywords: ["man", "male"],
      char: "\uD83E\uDDDE\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    mermaid: {
      keywords: ["woman", "female", "merwoman", "ariel"],
      char: "\uD83E\uDDDC\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    merman: {
      keywords: ["man", "male", "triton"],
      char: "\uD83E\uDDDC\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_fairy: {
      keywords: ["woman", "female"],
      char: "\uD83E\uDDDA\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_fairy: {
      keywords: ["man", "male"],
      char: "\uD83E\uDDDA\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    angel: {
      keywords: ["heaven", "wings", "halo"],
      char: "\uD83D\uDC7C",
      fitzpatrick_scale: true,
      category: "people"
    },
    pregnant_woman: {
      keywords: ["baby"],
      char: "\uD83E\uDD30",
      fitzpatrick_scale: true,
      category: "people"
    },
    breastfeeding: {
      keywords: ["nursing", "baby"],
      char: "\uD83E\uDD31",
      fitzpatrick_scale: true,
      category: "people"
    },
    princess: {
      keywords: ["girl", "woman", "female", "blond", "crown", "royal", "queen"],
      char: "\uD83D\uDC78",
      fitzpatrick_scale: true,
      category: "people"
    },
    prince: {
      keywords: ["boy", "man", "male", "crown", "royal", "king"],
      char: "\uD83E\uDD34",
      fitzpatrick_scale: true,
      category: "people"
    },
    bride_with_veil: {
      keywords: ["couple", "marriage", "wedding", "woman", "bride"],
      char: "\uD83D\uDC70",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_in_tuxedo: {
      keywords: ["couple", "marriage", "wedding", "groom"],
      char: "\uD83E\uDD35",
      fitzpatrick_scale: true,
      category: "people"
    },
    running_woman: {
      keywords: ["woman", "walking", "exercise", "race", "running", "female"],
      char: "\uD83C\uDFC3\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    running_man: {
      keywords: ["man", "walking", "exercise", "race", "running"],
      char: "\uD83C\uDFC3",
      fitzpatrick_scale: true,
      category: "people"
    },
    walking_woman: {
      keywords: ["human", "feet", "steps", "woman", "female"],
      char: "\uD83D\uDEB6\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    walking_man: {
      keywords: ["human", "feet", "steps"],
      char: "\uD83D\uDEB6",
      fitzpatrick_scale: true,
      category: "people"
    },
    dancer: {
      keywords: ["female", "girl", "woman", "fun"],
      char: "\uD83D\uDC83",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_dancing: {
      keywords: ["male", "boy", "fun", "dancer"],
      char: "\uD83D\uDD7A",
      fitzpatrick_scale: true,
      category: "people"
    },
    dancing_women: {
      keywords: ["female", "bunny", "women", "girls"],
      char: "\uD83D\uDC6F",
      fitzpatrick_scale: false,
      category: "people"
    },
    dancing_men: {
      keywords: ["male", "bunny", "men", "boys"],
      char: "\uD83D\uDC6F\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "people"
    },
    couple: {
      keywords: ["pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage"],
      char: "\uD83D\uDC6B",
      fitzpatrick_scale: false,
      category: "people"
    },
    two_men_holding_hands: {
      keywords: ["pair", "couple", "love", "like", "bromance", "friendship", "people", "human"],
      char: "\uD83D\uDC6C",
      fitzpatrick_scale: false,
      category: "people"
    },
    two_women_holding_hands: {
      keywords: ["pair", "friendship", "couple", "love", "like", "female", "people", "human"],
      char: "\uD83D\uDC6D",
      fitzpatrick_scale: false,
      category: "people"
    },
    bowing_woman: {
      keywords: ["woman", "female", "girl"],
      char: "\uD83D\uDE47\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    bowing_man: {
      keywords: ["man", "male", "boy"],
      char: "\uD83D\uDE47",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_facepalming: {
      keywords: ["man", "male", "boy", "disbelief"],
      char: "\uD83E\uDD26\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_facepalming: {
      keywords: ["woman", "female", "girl", "disbelief"],
      char: "\uD83E\uDD26\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_shrugging: {
      keywords: ["woman", "female", "girl", "confused", "indifferent", "doubt"],
      char: "\uD83E\uDD37",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_shrugging: {
      keywords: ["man", "male", "boy", "confused", "indifferent", "doubt"],
      char: "\uD83E\uDD37\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    tipping_hand_woman: {
      keywords: ["female", "girl", "woman", "human", "information"],
      char: "\uD83D\uDC81",
      fitzpatrick_scale: true,
      category: "people"
    },
    tipping_hand_man: {
      keywords: ["male", "boy", "man", "human", "information"],
      char: "\uD83D\uDC81\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    no_good_woman: {
      keywords: ["female", "girl", "woman", "nope"],
      char: "\uD83D\uDE45",
      fitzpatrick_scale: true,
      category: "people"
    },
    no_good_man: {
      keywords: ["male", "boy", "man", "nope"],
      char: "\uD83D\uDE45\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    ok_woman: {
      keywords: ["women", "girl", "female", "pink", "human", "woman"],
      char: "\uD83D\uDE46",
      fitzpatrick_scale: true,
      category: "people"
    },
    ok_man: {
      keywords: ["men", "boy", "male", "blue", "human", "man"],
      char: "\uD83D\uDE46\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    raising_hand_woman: {
      keywords: ["female", "girl", "woman"],
      char: "\uD83D\uDE4B",
      fitzpatrick_scale: true,
      category: "people"
    },
    raising_hand_man: {
      keywords: ["male", "boy", "man"],
      char: "\uD83D\uDE4B\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    pouting_woman: {
      keywords: ["female", "girl", "woman"],
      char: "\uD83D\uDE4E",
      fitzpatrick_scale: true,
      category: "people"
    },
    pouting_man: {
      keywords: ["male", "boy", "man"],
      char: "\uD83D\uDE4E\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    frowning_woman: {
      keywords: ["female", "girl", "woman", "sad", "depressed", "discouraged", "unhappy"],
      char: "\uD83D\uDE4D",
      fitzpatrick_scale: true,
      category: "people"
    },
    frowning_man: {
      keywords: ["male", "boy", "man", "sad", "depressed", "discouraged", "unhappy"],
      char: "\uD83D\uDE4D\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    haircut_woman: {
      keywords: ["female", "girl", "woman"],
      char: "\uD83D\uDC87",
      fitzpatrick_scale: true,
      category: "people"
    },
    haircut_man: {
      keywords: ["male", "boy", "man"],
      char: "\uD83D\uDC87\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    massage_woman: {
      keywords: ["female", "girl", "woman", "head"],
      char: "\uD83D\uDC86",
      fitzpatrick_scale: true,
      category: "people"
    },
    massage_man: {
      keywords: ["male", "boy", "man", "head"],
      char: "\uD83D\uDC86\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    woman_in_steamy_room: {
      keywords: ["female", "woman", "spa", "steamroom", "sauna"],
      char: "\uD83E\uDDD6\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    man_in_steamy_room: {
      keywords: ["male", "man", "spa", "steamroom", "sauna"],
      char: "\uD83E\uDDD6\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "people"
    },
    couple_with_heart_woman_man: {
      keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"],
      char: "\uD83D\uDC91",
      fitzpatrick_scale: false,
      category: "people"
    },
    couple_with_heart_woman_woman: {
      keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"],
      char: "\uD83D\uDC69\u200D\u2764\uFE0F\u200D\uD83D\uDC69",
      fitzpatrick_scale: false,
      category: "people"
    },
    couple_with_heart_man_man: {
      keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"],
      char: "\uD83D\uDC68\u200D\u2764\uFE0F\u200D\uD83D\uDC68",
      fitzpatrick_scale: false,
      category: "people"
    },
    couplekiss_man_woman: {
      keywords: ["pair", "valentines", "love", "like", "dating", "marriage"],
      char: "\uD83D\uDC8F",
      fitzpatrick_scale: false,
      category: "people"
    },
    couplekiss_woman_woman: {
      keywords: ["pair", "valentines", "love", "like", "dating", "marriage"],
      char: "\uD83D\uDC69\u200D\u2764\uFE0F\u200D\uD83D\uDC8B\u200D\uD83D\uDC69",
      fitzpatrick_scale: false,
      category: "people"
    },
    couplekiss_man_man: {
      keywords: ["pair", "valentines", "love", "like", "dating", "marriage"],
      char: "\uD83D\uDC68\u200D\u2764\uFE0F\u200D\uD83D\uDC8B\u200D\uD83D\uDC68",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_boy: {
      keywords: ["home", "parents", "child", "mom", "dad", "father", "mother", "people", "human"],
      char: "\uD83D\uDC6A",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_girl: {
      keywords: ["home", "parents", "people", "human", "child"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_girl_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_boy_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_woman_girl_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_girl_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_boy_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_woman_girl_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_girl_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_boy_boy: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_man_girl_girl: {
      keywords: ["home", "parents", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_boy: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_girl: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_girl_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_boy_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_woman_girl_girl: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_boy: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_girl: {
      keywords: ["home", "parent", "people", "human", "child"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_girl_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_boy_boy: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66",
      fitzpatrick_scale: false,
      category: "people"
    },
    family_man_girl_girl: {
      keywords: ["home", "parent", "people", "human", "children"],
      char: "\uD83D\uDC68\u200D\uD83D\uDC67\u200D\uD83D\uDC67",
      fitzpatrick_scale: false,
      category: "people"
    },
    yarn: {
      keywords: ["ball", "crochet", "knit"],
      char: "\uD83E\uDDF6",
      fitzpatrick_scale: false,
      category: "people"
    },
    thread: {
      keywords: ["needle", "sewing", "spool", "string"],
      char: "\uD83E\uDDF5",
      fitzpatrick_scale: false,
      category: "people"
    },
    coat: {
      keywords: ["jacket"],
      char: "\uD83E\uDDE5",
      fitzpatrick_scale: false,
      category: "people"
    },
    labcoat: {
      keywords: ["doctor", "experiment", "scientist", "chemist"],
      char: "\uD83E\uDD7C",
      fitzpatrick_scale: false,
      category: "people"
    },
    womans_clothes: {
      keywords: ["fashion", "shopping_bags", "female"],
      char: "\uD83D\uDC5A",
      fitzpatrick_scale: false,
      category: "people"
    },
    tshirt: {
      keywords: ["fashion", "cloth", "casual", "shirt", "tee"],
      char: "\uD83D\uDC55",
      fitzpatrick_scale: false,
      category: "people"
    },
    jeans: {
      keywords: ["fashion", "shopping"],
      char: "\uD83D\uDC56",
      fitzpatrick_scale: false,
      category: "people"
    },
    necktie: {
      keywords: ["shirt", "suitup", "formal", "fashion", "cloth", "business"],
      char: "\uD83D\uDC54",
      fitzpatrick_scale: false,
      category: "people"
    },
    dress: {
      keywords: ["clothes", "fashion", "shopping"],
      char: "\uD83D\uDC57",
      fitzpatrick_scale: false,
      category: "people"
    },
    bikini: {
      keywords: ["swimming", "female", "woman", "girl", "fashion", "beach", "summer"],
      char: "\uD83D\uDC59",
      fitzpatrick_scale: false,
      category: "people"
    },
    kimono: {
      keywords: ["dress", "fashion", "women", "female", "japanese"],
      char: "\uD83D\uDC58",
      fitzpatrick_scale: false,
      category: "people"
    },
    lipstick: {
      keywords: ["female", "girl", "fashion", "woman"],
      char: "\uD83D\uDC84",
      fitzpatrick_scale: false,
      category: "people"
    },
    kiss: {
      keywords: ["face", "lips", "love", "like", "affection", "valentines"],
      char: "\uD83D\uDC8B",
      fitzpatrick_scale: false,
      category: "people"
    },
    footprints: {
      keywords: ["feet", "tracking", "walking", "beach"],
      char: "\uD83D\uDC63",
      fitzpatrick_scale: false,
      category: "people"
    },
    flat_shoe: {
      keywords: ["ballet", "slip-on", "slipper"],
      char: "\uD83E\uDD7F",
      fitzpatrick_scale: false,
      category: "people"
    },
    high_heel: {
      keywords: ["fashion", "shoes", "female", "pumps", "stiletto"],
      char: "\uD83D\uDC60",
      fitzpatrick_scale: false,
      category: "people"
    },
    sandal: {
      keywords: ["shoes", "fashion", "flip flops"],
      char: "\uD83D\uDC61",
      fitzpatrick_scale: false,
      category: "people"
    },
    boot: {
      keywords: ["shoes", "fashion"],
      char: "\uD83D\uDC62",
      fitzpatrick_scale: false,
      category: "people"
    },
    mans_shoe: {
      keywords: ["fashion", "male"],
      char: "\uD83D\uDC5E",
      fitzpatrick_scale: false,
      category: "people"
    },
    athletic_shoe: {
      keywords: ["shoes", "sports", "sneakers"],
      char: "\uD83D\uDC5F",
      fitzpatrick_scale: false,
      category: "people"
    },
    hiking_boot: {
      keywords: ["backpacking", "camping", "hiking"],
      char: "\uD83E\uDD7E",
      fitzpatrick_scale: false,
      category: "people"
    },
    socks: {
      keywords: ["stockings", "clothes"],
      char: "\uD83E\uDDE6",
      fitzpatrick_scale: false,
      category: "people"
    },
    gloves: {
      keywords: ["hands", "winter", "clothes"],
      char: "\uD83E\uDDE4",
      fitzpatrick_scale: false,
      category: "people"
    },
    scarf: {
      keywords: ["neck", "winter", "clothes"],
      char: "\uD83E\uDDE3",
      fitzpatrick_scale: false,
      category: "people"
    },
    womans_hat: {
      keywords: ["fashion", "accessories", "female", "lady", "spring"],
      char: "\uD83D\uDC52",
      fitzpatrick_scale: false,
      category: "people"
    },
    tophat: {
      keywords: ["magic", "gentleman", "classy", "circus"],
      char: "\uD83C\uDFA9",
      fitzpatrick_scale: false,
      category: "people"
    },
    billed_hat: {
      keywords: ["cap", "baseball"],
      char: "\uD83E\uDDE2",
      fitzpatrick_scale: false,
      category: "people"
    },
    rescue_worker_helmet: {
      keywords: ["construction", "build"],
      char: "\u26D1",
      fitzpatrick_scale: false,
      category: "people"
    },
    mortar_board: {
      keywords: ["school", "college", "degree", "university", "graduation", "cap", "hat", "legal", "learn", "education"],
      char: "\uD83C\uDF93",
      fitzpatrick_scale: false,
      category: "people"
    },
    crown: {
      keywords: ["king", "kod", "leader", "royalty", "lord"],
      char: "\uD83D\uDC51",
      fitzpatrick_scale: false,
      category: "people"
    },
    school_satchel: {
      keywords: ["student", "education", "bag", "backpack"],
      char: "\uD83C\uDF92",
      fitzpatrick_scale: false,
      category: "people"
    },
    luggage: {
      keywords: ["packing", "travel"],
      char: "\uD83E\uDDF3",
      fitzpatrick_scale: false,
      category: "people"
    },
    pouch: {
      keywords: ["bag", "accessories", "shopping"],
      char: "\uD83D\uDC5D",
      fitzpatrick_scale: false,
      category: "people"
    },
    purse: {
      keywords: ["fashion", "accessories", "money", "sales", "shopping"],
      char: "\uD83D\uDC5B",
      fitzpatrick_scale: false,
      category: "people"
    },
    handbag: {
      keywords: ["fashion", "accessory", "accessories", "shopping"],
      char: "\uD83D\uDC5C",
      fitzpatrick_scale: false,
      category: "people"
    },
    briefcase: {
      keywords: ["business", "documents", "work", "law", "legal", "job", "career"],
      char: "\uD83D\uDCBC",
      fitzpatrick_scale: false,
      category: "people"
    },
    eyeglasses: {
      keywords: ["fashion", "accessories", "eyesight", "nerdy", "dork", "geek"],
      char: "\uD83D\uDC53",
      fitzpatrick_scale: false,
      category: "people"
    },
    dark_sunglasses: {
      keywords: ["face", "cool", "accessories"],
      char: "\uD83D\uDD76",
      fitzpatrick_scale: false,
      category: "people"
    },
    goggles: {
      keywords: ["eyes", "protection", "safety"],
      char: "\uD83E\uDD7D",
      fitzpatrick_scale: false,
      category: "people"
    },
    ring: {
      keywords: ["wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement"],
      char: "\uD83D\uDC8D",
      fitzpatrick_scale: false,
      category: "people"
    },
    closed_umbrella: {
      keywords: ["weather", "rain", "drizzle"],
      char: "\uD83C\uDF02",
      fitzpatrick_scale: false,
      category: "people"
    },
    dog: {
      keywords: ["animal", "friend", "nature", "woof", "puppy", "pet", "faithful"],
      char: "\uD83D\uDC36",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cat: {
      keywords: ["animal", "meow", "nature", "pet", "kitten"],
      char: "\uD83D\uDC31",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mouse: {
      keywords: ["animal", "nature", "cheese_wedge", "rodent"],
      char: "\uD83D\uDC2D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hamster: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC39",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rabbit: {
      keywords: ["animal", "nature", "pet", "spring", "magic", "bunny"],
      char: "\uD83D\uDC30",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fox_face: {
      keywords: ["animal", "nature", "face"],
      char: "\uD83E\uDD8A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bear: {
      keywords: ["animal", "nature", "wild"],
      char: "\uD83D\uDC3B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    panda_face: {
      keywords: ["animal", "nature", "panda"],
      char: "\uD83D\uDC3C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    koala: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC28",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tiger: {
      keywords: ["animal", "cat", "danger", "wild", "nature", "roar"],
      char: "\uD83D\uDC2F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    lion: {
      keywords: ["animal", "nature"],
      char: "\uD83E\uDD81",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cow: {
      keywords: ["beef", "ox", "animal", "nature", "moo", "milk"],
      char: "\uD83D\uDC2E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    pig: {
      keywords: ["animal", "oink", "nature"],
      char: "\uD83D\uDC37",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    pig_nose: {
      keywords: ["animal", "oink"],
      char: "\uD83D\uDC3D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    frog: {
      keywords: ["animal", "nature", "croak", "toad"],
      char: "\uD83D\uDC38",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    squid: {
      keywords: ["animal", "nature", "ocean", "sea"],
      char: "\uD83E\uDD91",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    octopus: {
      keywords: ["animal", "creature", "ocean", "sea", "nature", "beach"],
      char: "\uD83D\uDC19",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shrimp: {
      keywords: ["animal", "ocean", "nature", "seafood"],
      char: "\uD83E\uDD90",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    monkey_face: {
      keywords: ["animal", "nature", "circus"],
      char: "\uD83D\uDC35",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    gorilla: {
      keywords: ["animal", "nature", "circus"],
      char: "\uD83E\uDD8D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    see_no_evil: {
      keywords: ["monkey", "animal", "nature", "haha"],
      char: "\uD83D\uDE48",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hear_no_evil: {
      keywords: ["animal", "monkey", "nature"],
      char: "\uD83D\uDE49",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    speak_no_evil: {
      keywords: ["monkey", "animal", "nature", "omg"],
      char: "\uD83D\uDE4A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    monkey: {
      keywords: ["animal", "nature", "banana", "circus"],
      char: "\uD83D\uDC12",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    chicken: {
      keywords: ["animal", "cluck", "nature", "bird"],
      char: "\uD83D\uDC14",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    penguin: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC27",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bird: {
      keywords: ["animal", "nature", "fly", "tweet", "spring"],
      char: "\uD83D\uDC26",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    baby_chick: {
      keywords: ["animal", "chicken", "bird"],
      char: "\uD83D\uDC24",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hatching_chick: {
      keywords: ["animal", "chicken", "egg", "born", "baby", "bird"],
      char: "\uD83D\uDC23",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hatched_chick: {
      keywords: ["animal", "chicken", "baby", "bird"],
      char: "\uD83D\uDC25",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    duck: {
      keywords: ["animal", "nature", "bird", "mallard"],
      char: "\uD83E\uDD86",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    eagle: {
      keywords: ["animal", "nature", "bird"],
      char: "\uD83E\uDD85",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    owl: {
      keywords: ["animal", "nature", "bird", "hoot"],
      char: "\uD83E\uDD89",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bat: {
      keywords: ["animal", "nature", "blind", "vampire"],
      char: "\uD83E\uDD87",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    wolf: {
      keywords: ["animal", "nature", "wild"],
      char: "\uD83D\uDC3A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    boar: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC17",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    horse: {
      keywords: ["animal", "brown", "nature"],
      char: "\uD83D\uDC34",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    unicorn: {
      keywords: ["animal", "nature", "mystical"],
      char: "\uD83E\uDD84",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    honeybee: {
      keywords: ["animal", "insect", "nature", "bug", "spring", "honey"],
      char: "\uD83D\uDC1D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bug: {
      keywords: ["animal", "insect", "nature", "worm"],
      char: "\uD83D\uDC1B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    butterfly: {
      keywords: ["animal", "insect", "nature", "caterpillar"],
      char: "\uD83E\uDD8B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snail: {
      keywords: ["slow", "animal", "shell"],
      char: "\uD83D\uDC0C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    beetle: {
      keywords: ["animal", "insect", "nature", "ladybug"],
      char: "\uD83D\uDC1E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ant: {
      keywords: ["animal", "insect", "nature", "bug"],
      char: "\uD83D\uDC1C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    grasshopper: {
      keywords: ["animal", "cricket", "chirp"],
      char: "\uD83E\uDD97",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    spider: {
      keywords: ["animal", "arachnid"],
      char: "\uD83D\uDD77",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    scorpion: {
      keywords: ["animal", "arachnid"],
      char: "\uD83E\uDD82",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    crab: {
      keywords: ["animal", "crustacean"],
      char: "\uD83E\uDD80",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snake: {
      keywords: ["animal", "evil", "nature", "hiss", "python"],
      char: "\uD83D\uDC0D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    lizard: {
      keywords: ["animal", "nature", "reptile"],
      char: "\uD83E\uDD8E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    "t-rex": {
      keywords: ["animal", "nature", "dinosaur", "tyrannosaurus", "extinct"],
      char: "\uD83E\uDD96",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sauropod: {
      keywords: ["animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct"],
      char: "\uD83E\uDD95",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    turtle: {
      keywords: ["animal", "slow", "nature", "tortoise"],
      char: "\uD83D\uDC22",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tropical_fish: {
      keywords: ["animal", "swim", "ocean", "beach", "nemo"],
      char: "\uD83D\uDC20",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fish: {
      keywords: ["animal", "food", "nature"],
      char: "\uD83D\uDC1F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    blowfish: {
      keywords: ["animal", "nature", "food", "sea", "ocean"],
      char: "\uD83D\uDC21",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dolphin: {
      keywords: ["animal", "nature", "fish", "sea", "ocean", "flipper", "fins", "beach"],
      char: "\uD83D\uDC2C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shark: {
      keywords: ["animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach"],
      char: "\uD83E\uDD88",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    whale: {
      keywords: ["animal", "nature", "sea", "ocean"],
      char: "\uD83D\uDC33",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    whale2: {
      keywords: ["animal", "nature", "sea", "ocean"],
      char: "\uD83D\uDC0B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    crocodile: {
      keywords: ["animal", "nature", "reptile", "lizard", "alligator"],
      char: "\uD83D\uDC0A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    leopard: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC06",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    zebra: {
      keywords: ["animal", "nature", "stripes", "safari"],
      char: "\uD83E\uDD93",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tiger2: {
      keywords: ["animal", "nature", "roar"],
      char: "\uD83D\uDC05",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    water_buffalo: {
      keywords: ["animal", "nature", "ox", "cow"],
      char: "\uD83D\uDC03",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ox: {
      keywords: ["animal", "cow", "beef"],
      char: "\uD83D\uDC02",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cow2: {
      keywords: ["beef", "ox", "animal", "nature", "moo", "milk"],
      char: "\uD83D\uDC04",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    deer: {
      keywords: ["animal", "nature", "horns", "venison"],
      char: "\uD83E\uDD8C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dromedary_camel: {
      keywords: ["animal", "hot", "desert", "hump"],
      char: "\uD83D\uDC2A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    camel: {
      keywords: ["animal", "nature", "hot", "desert", "hump"],
      char: "\uD83D\uDC2B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    giraffe: {
      keywords: ["animal", "nature", "spots", "safari"],
      char: "\uD83E\uDD92",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    elephant: {
      keywords: ["animal", "nature", "nose", "th", "circus"],
      char: "\uD83D\uDC18",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rhinoceros: {
      keywords: ["animal", "nature", "horn"],
      char: "\uD83E\uDD8F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    goat: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC10",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ram: {
      keywords: ["animal", "sheep", "nature"],
      char: "\uD83D\uDC0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sheep: {
      keywords: ["animal", "nature", "wool", "shipit"],
      char: "\uD83D\uDC11",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    racehorse: {
      keywords: ["animal", "gamble", "luck"],
      char: "\uD83D\uDC0E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    pig2: {
      keywords: ["animal", "nature"],
      char: "\uD83D\uDC16",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rat: {
      keywords: ["animal", "mouse", "rodent"],
      char: "\uD83D\uDC00",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mouse2: {
      keywords: ["animal", "nature", "rodent"],
      char: "\uD83D\uDC01",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rooster: {
      keywords: ["animal", "nature", "chicken"],
      char: "\uD83D\uDC13",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    turkey: {
      keywords: ["animal", "bird"],
      char: "\uD83E\uDD83",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dove: {
      keywords: ["animal", "bird"],
      char: "\uD83D\uDD4A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dog2: {
      keywords: ["animal", "nature", "friend", "doge", "pet", "faithful"],
      char: "\uD83D\uDC15",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    poodle: {
      keywords: ["dog", "animal", "101", "nature", "pet"],
      char: "\uD83D\uDC29",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cat2: {
      keywords: ["animal", "meow", "pet", "cats"],
      char: "\uD83D\uDC08",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rabbit2: {
      keywords: ["animal", "nature", "pet", "magic", "spring"],
      char: "\uD83D\uDC07",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    chipmunk: {
      keywords: ["animal", "nature", "rodent", "squirrel"],
      char: "\uD83D\uDC3F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hedgehog: {
      keywords: ["animal", "nature", "spiny"],
      char: "\uD83E\uDD94",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    raccoon: {
      keywords: ["animal", "nature"],
      char: "\uD83E\uDD9D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    llama: {
      keywords: ["animal", "nature", "alpaca"],
      char: "\uD83E\uDD99",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hippopotamus: {
      keywords: ["animal", "nature"],
      char: "\uD83E\uDD9B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    kangaroo: {
      keywords: ["animal", "nature", "australia", "joey", "hop", "marsupial"],
      char: "\uD83E\uDD98",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    badger: {
      keywords: ["animal", "nature", "honey"],
      char: "\uD83E\uDDA1",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    swan: {
      keywords: ["animal", "nature", "bird"],
      char: "\uD83E\uDDA2",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    peacock: {
      keywords: ["animal", "nature", "peahen", "bird"],
      char: "\uD83E\uDD9A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    parrot: {
      keywords: ["animal", "nature", "bird", "pirate", "talk"],
      char: "\uD83E\uDD9C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    lobster: {
      keywords: ["animal", "nature", "bisque", "claws", "seafood"],
      char: "\uD83E\uDD9E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mosquito: {
      keywords: ["animal", "nature", "insect", "malaria"],
      char: "\uD83E\uDD9F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    paw_prints: {
      keywords: ["animal", "tracking", "footprints", "dog", "cat", "pet", "feet"],
      char: "\uD83D\uDC3E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dragon: {
      keywords: ["animal", "myth", "nature", "chinese", "green"],
      char: "\uD83D\uDC09",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dragon_face: {
      keywords: ["animal", "myth", "nature", "chinese", "green"],
      char: "\uD83D\uDC32",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cactus: {
      keywords: ["vegetable", "plant", "nature"],
      char: "\uD83C\uDF35",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    christmas_tree: {
      keywords: ["festival", "vacation", "december", "xmas", "celebration"],
      char: "\uD83C\uDF84",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    evergreen_tree: {
      keywords: ["plant", "nature"],
      char: "\uD83C\uDF32",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    deciduous_tree: {
      keywords: ["plant", "nature"],
      char: "\uD83C\uDF33",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    palm_tree: {
      keywords: ["plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical"],
      char: "\uD83C\uDF34",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    seedling: {
      keywords: ["plant", "nature", "grass", "lawn", "spring"],
      char: "\uD83C\uDF31",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    herb: {
      keywords: ["vegetable", "plant", "medicine", "weed", "grass", "lawn"],
      char: "\uD83C\uDF3F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shamrock: {
      keywords: ["vegetable", "plant", "nature", "irish", "clover"],
      char: "\u2618",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    four_leaf_clover: {
      keywords: ["vegetable", "plant", "nature", "lucky", "irish"],
      char: "\uD83C\uDF40",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bamboo: {
      keywords: ["plant", "nature", "vegetable", "panda", "pine_decoration"],
      char: "\uD83C\uDF8D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tanabata_tree: {
      keywords: ["plant", "nature", "branch", "summer"],
      char: "\uD83C\uDF8B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    leaves: {
      keywords: ["nature", "plant", "tree", "vegetable", "grass", "lawn", "spring"],
      char: "\uD83C\uDF43",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fallen_leaf: {
      keywords: ["nature", "plant", "vegetable", "leaves"],
      char: "\uD83C\uDF42",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    maple_leaf: {
      keywords: ["nature", "plant", "vegetable", "ca", "fall"],
      char: "\uD83C\uDF41",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ear_of_rice: {
      keywords: ["nature", "plant"],
      char: "\uD83C\uDF3E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    hibiscus: {
      keywords: ["plant", "vegetable", "flowers", "beach"],
      char: "\uD83C\uDF3A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sunflower: {
      keywords: ["nature", "plant", "fall"],
      char: "\uD83C\uDF3B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    rose: {
      keywords: ["flowers", "valentines", "love", "spring"],
      char: "\uD83C\uDF39",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    wilted_flower: {
      keywords: ["plant", "nature", "flower"],
      char: "\uD83E\uDD40",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tulip: {
      keywords: ["flowers", "plant", "nature", "summer", "spring"],
      char: "\uD83C\uDF37",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    blossom: {
      keywords: ["nature", "flowers", "yellow"],
      char: "\uD83C\uDF3C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cherry_blossom: {
      keywords: ["nature", "plant", "spring", "flower"],
      char: "\uD83C\uDF38",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    bouquet: {
      keywords: ["flowers", "nature", "spring"],
      char: "\uD83D\uDC90",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    mushroom: {
      keywords: ["plant", "vegetable"],
      char: "\uD83C\uDF44",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    chestnut: {
      keywords: ["food", "squirrel"],
      char: "\uD83C\uDF30",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    jack_o_lantern: {
      keywords: ["halloween", "light", "pumpkin", "creepy", "fall"],
      char: "\uD83C\uDF83",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    shell: {
      keywords: ["nature", "sea", "beach"],
      char: "\uD83D\uDC1A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    spider_web: {
      keywords: ["animal", "insect", "arachnid", "silk"],
      char: "\uD83D\uDD78",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    earth_americas: {
      keywords: ["globe", "world", "USA", "international"],
      char: "\uD83C\uDF0E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    earth_africa: {
      keywords: ["globe", "world", "international"],
      char: "\uD83C\uDF0D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    earth_asia: {
      keywords: ["globe", "world", "east", "international"],
      char: "\uD83C\uDF0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    full_moon: {
      keywords: ["nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF15",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waning_gibbous_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing_gibbous_moon"],
      char: "\uD83C\uDF16",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    last_quarter_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF17",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waning_crescent_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF18",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    new_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF11",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waxing_crescent_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF12",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    first_quarter_moon: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF13",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    waxing_gibbous_moon: {
      keywords: ["nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep"],
      char: "\uD83C\uDF14",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    new_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    full_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1D",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    first_quarter_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    last_quarter_moon_with_face: {
      keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"],
      char: "\uD83C\uDF1C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_with_face: {
      keywords: ["nature", "morning", "sky"],
      char: "\uD83C\uDF1E",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    crescent_moon: {
      keywords: ["night", "sleep", "sky", "evening", "magic"],
      char: "\uD83C\uDF19",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    star: {
      keywords: ["night", "yellow"],
      char: "\u2B50",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    star2: {
      keywords: ["night", "sparkle", "awesome", "good", "magic"],
      char: "\uD83C\uDF1F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dizzy: {
      keywords: ["star", "sparkle", "shoot", "magic"],
      char: "\uD83D\uDCAB",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sparkles: {
      keywords: ["stars", "shine", "shiny", "cool", "awesome", "good", "magic"],
      char: "\u2728",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    comet: {
      keywords: ["space"],
      char: "\u2604",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sunny: {
      keywords: ["weather", "nature", "brightness", "summer", "beach", "spring"],
      char: "\u2600\uFE0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_behind_small_cloud: {
      keywords: ["weather"],
      char: "\uD83C\uDF24",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    partly_sunny: {
      keywords: ["weather", "nature", "cloudy", "morning", "fall", "spring"],
      char: "\u26C5",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_behind_large_cloud: {
      keywords: ["weather"],
      char: "\uD83C\uDF25",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sun_behind_rain_cloud: {
      keywords: ["weather"],
      char: "\uD83C\uDF26",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud: {
      keywords: ["weather", "sky"],
      char: "\u2601\uFE0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_rain: {
      keywords: ["weather"],
      char: "\uD83C\uDF27",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_lightning_and_rain: {
      keywords: ["weather", "lightning"],
      char: "\u26C8",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_lightning: {
      keywords: ["weather", "thunder"],
      char: "\uD83C\uDF29",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    zap: {
      keywords: ["thunder", "weather", "lightning bolt", "fast"],
      char: "\u26A1",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fire: {
      keywords: ["hot", "cook", "flame"],
      char: "\uD83D\uDD25",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    boom: {
      keywords: ["bomb", "explode", "explosion", "collision", "blown"],
      char: "\uD83D\uDCA5",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snowflake: {
      keywords: ["winter", "season", "cold", "weather", "christmas", "xmas"],
      char: "\u2744\uFE0F",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    cloud_with_snow: {
      keywords: ["weather"],
      char: "\uD83C\uDF28",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snowman: {
      keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen", "without_snow"],
      char: "\u26C4",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    snowman_with_snow: {
      keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"],
      char: "\u2603",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    wind_face: {
      keywords: ["gust", "air"],
      char: "\uD83C\uDF2C",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    dash: {
      keywords: ["wind", "air", "fast", "shoo", "fart", "smoke", "puff"],
      char: "\uD83D\uDCA8",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    tornado: {
      keywords: ["weather", "cyclone", "twister"],
      char: "\uD83C\uDF2A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    fog: {
      keywords: ["weather"],
      char: "\uD83C\uDF2B",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    open_umbrella: {
      keywords: ["weather", "spring"],
      char: "\u2602",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    umbrella: {
      keywords: ["rainy", "weather", "spring"],
      char: "\u2614",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    droplet: {
      keywords: ["water", "drip", "faucet", "spring"],
      char: "\uD83D\uDCA7",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    sweat_drops: {
      keywords: ["water", "drip", "oops"],
      char: "\uD83D\uDCA6",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    ocean: {
      keywords: ["sea", "water", "wave", "nature", "tsunami", "disaster"],
      char: "\uD83C\uDF0A",
      fitzpatrick_scale: false,
      category: "animals_and_nature"
    },
    green_apple: {
      keywords: ["fruit", "nature"],
      char: "\uD83C\uDF4F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    apple: {
      keywords: ["fruit", "mac", "school"],
      char: "\uD83C\uDF4E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pear: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF50",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tangerine: {
      keywords: ["food", "fruit", "nature", "orange"],
      char: "\uD83C\uDF4A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    lemon: {
      keywords: ["fruit", "nature"],
      char: "\uD83C\uDF4B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    banana: {
      keywords: ["fruit", "food", "monkey"],
      char: "\uD83C\uDF4C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    watermelon: {
      keywords: ["fruit", "food", "picnic", "summer"],
      char: "\uD83C\uDF49",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    grapes: {
      keywords: ["fruit", "food", "wine"],
      char: "\uD83C\uDF47",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    strawberry: {
      keywords: ["fruit", "food", "nature"],
      char: "\uD83C\uDF53",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    melon: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF48",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cherries: {
      keywords: ["food", "fruit"],
      char: "\uD83C\uDF52",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    peach: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF51",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pineapple: {
      keywords: ["fruit", "nature", "food"],
      char: "\uD83C\uDF4D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    coconut: {
      keywords: ["fruit", "nature", "food", "palm"],
      char: "\uD83E\uDD65",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    kiwi_fruit: {
      keywords: ["fruit", "food"],
      char: "\uD83E\uDD5D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    mango: {
      keywords: ["fruit", "food", "tropical"],
      char: "\uD83E\uDD6D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    avocado: {
      keywords: ["fruit", "food"],
      char: "\uD83E\uDD51",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    broccoli: {
      keywords: ["fruit", "food", "vegetable"],
      char: "\uD83E\uDD66",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tomato: {
      keywords: ["fruit", "vegetable", "nature", "food"],
      char: "\uD83C\uDF45",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    eggplant: {
      keywords: ["vegetable", "nature", "food", "aubergine"],
      char: "\uD83C\uDF46",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cucumber: {
      keywords: ["fruit", "food", "pickle"],
      char: "\uD83E\uDD52",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    carrot: {
      keywords: ["vegetable", "food", "orange"],
      char: "\uD83E\uDD55",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    hot_pepper: {
      keywords: ["food", "spicy", "chilli", "chili"],
      char: "\uD83C\uDF36",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    potato: {
      keywords: ["food", "tuber", "vegatable", "starch"],
      char: "\uD83E\uDD54",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    corn: {
      keywords: ["food", "vegetable", "plant"],
      char: "\uD83C\uDF3D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    leafy_greens: {
      keywords: ["food", "vegetable", "plant", "bok choy", "cabbage", "kale", "lettuce"],
      char: "\uD83E\uDD6C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sweet_potato: {
      keywords: ["food", "nature"],
      char: "\uD83C\uDF60",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    peanuts: {
      keywords: ["food", "nut"],
      char: "\uD83E\uDD5C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    honey_pot: {
      keywords: ["bees", "sweet", "kitchen"],
      char: "\uD83C\uDF6F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    croissant: {
      keywords: ["food", "bread", "french"],
      char: "\uD83E\uDD50",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bread: {
      keywords: ["food", "wheat", "breakfast", "toast"],
      char: "\uD83C\uDF5E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    baguette_bread: {
      keywords: ["food", "bread", "french"],
      char: "\uD83E\uDD56",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bagel: {
      keywords: ["food", "bread", "bakery", "schmear"],
      char: "\uD83E\uDD6F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pretzel: {
      keywords: ["food", "bread", "twisted"],
      char: "\uD83E\uDD68",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cheese: {
      keywords: ["food", "chadder"],
      char: "\uD83E\uDDC0",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    egg: {
      keywords: ["food", "chicken", "breakfast"],
      char: "\uD83E\uDD5A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bacon: {
      keywords: ["food", "breakfast", "pork", "pig", "meat"],
      char: "\uD83E\uDD53",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    steak: {
      keywords: ["food", "cow", "meat", "cut", "chop", "lambchop", "porkchop"],
      char: "\uD83E\uDD69",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pancakes: {
      keywords: ["food", "breakfast", "flapjacks", "hotcakes"],
      char: "\uD83E\uDD5E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    poultry_leg: {
      keywords: ["food", "meat", "drumstick", "bird", "chicken", "turkey"],
      char: "\uD83C\uDF57",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    meat_on_bone: {
      keywords: ["good", "food", "drumstick"],
      char: "\uD83C\uDF56",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bone: {
      keywords: ["skeleton"],
      char: "\uD83E\uDDB4",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fried_shrimp: {
      keywords: ["food", "animal", "appetizer", "summer"],
      char: "\uD83C\uDF64",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fried_egg: {
      keywords: ["food", "breakfast", "kitchen", "egg"],
      char: "\uD83C\uDF73",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    hamburger: {
      keywords: ["meat", "fast food", "beef", "cheeseburger", "mcdonalds", "burger king"],
      char: "\uD83C\uDF54",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fries: {
      keywords: ["chips", "snack", "fast food"],
      char: "\uD83C\uDF5F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    stuffed_flatbread: {
      keywords: ["food", "flatbread", "stuffed", "gyro"],
      char: "\uD83E\uDD59",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    hotdog: {
      keywords: ["food", "frankfurter"],
      char: "\uD83C\uDF2D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pizza: {
      keywords: ["food", "party"],
      char: "\uD83C\uDF55",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sandwich: {
      keywords: ["food", "lunch", "bread"],
      char: "\uD83E\uDD6A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    canned_food: {
      keywords: ["food", "soup"],
      char: "\uD83E\uDD6B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    spaghetti: {
      keywords: ["food", "italian", "noodle"],
      char: "\uD83C\uDF5D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    taco: {
      keywords: ["food", "mexican"],
      char: "\uD83C\uDF2E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    burrito: {
      keywords: ["food", "mexican"],
      char: "\uD83C\uDF2F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    green_salad: {
      keywords: ["food", "healthy", "lettuce"],
      char: "\uD83E\uDD57",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    shallow_pan_of_food: {
      keywords: ["food", "cooking", "casserole", "paella"],
      char: "\uD83E\uDD58",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    ramen: {
      keywords: ["food", "japanese", "noodle", "chopsticks"],
      char: "\uD83C\uDF5C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    stew: {
      keywords: ["food", "meat", "soup"],
      char: "\uD83C\uDF72",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fish_cake: {
      keywords: ["food", "japan", "sea", "beach", "narutomaki", "pink", "swirl", "kamaboko", "surimi", "ramen"],
      char: "\uD83C\uDF65",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fortune_cookie: {
      keywords: ["food", "prophecy"],
      char: "\uD83E\uDD60",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sushi: {
      keywords: ["food", "fish", "japanese", "rice"],
      char: "\uD83C\uDF63",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bento: {
      keywords: ["food", "japanese", "box"],
      char: "\uD83C\uDF71",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    curry: {
      keywords: ["food", "spicy", "hot", "indian"],
      char: "\uD83C\uDF5B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    rice_ball: {
      keywords: ["food", "japanese"],
      char: "\uD83C\uDF59",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    rice: {
      keywords: ["food", "china", "asian"],
      char: "\uD83C\uDF5A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    rice_cracker: {
      keywords: ["food", "japanese"],
      char: "\uD83C\uDF58",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    oden: {
      keywords: ["food", "japanese"],
      char: "\uD83C\uDF62",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    dango: {
      keywords: ["food", "dessert", "sweet", "japanese", "barbecue", "meat"],
      char: "\uD83C\uDF61",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    shaved_ice: {
      keywords: ["hot", "dessert", "summer"],
      char: "\uD83C\uDF67",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    ice_cream: {
      keywords: ["food", "hot", "dessert"],
      char: "\uD83C\uDF68",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    icecream: {
      keywords: ["food", "hot", "dessert", "summer"],
      char: "\uD83C\uDF66",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    pie: {
      keywords: ["food", "dessert", "pastry"],
      char: "\uD83E\uDD67",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cake: {
      keywords: ["food", "dessert"],
      char: "\uD83C\uDF70",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cupcake: {
      keywords: ["food", "dessert", "bakery", "sweet"],
      char: "\uD83E\uDDC1",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    moon_cake: {
      keywords: ["food", "autumn"],
      char: "\uD83E\uDD6E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    birthday: {
      keywords: ["food", "dessert", "cake"],
      char: "\uD83C\uDF82",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    custard: {
      keywords: ["dessert", "food"],
      char: "\uD83C\uDF6E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    candy: {
      keywords: ["snack", "dessert", "sweet", "lolly"],
      char: "\uD83C\uDF6C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    lollipop: {
      keywords: ["food", "snack", "candy", "sweet"],
      char: "\uD83C\uDF6D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    chocolate_bar: {
      keywords: ["food", "snack", "dessert", "sweet"],
      char: "\uD83C\uDF6B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    popcorn: {
      keywords: ["food", "movie theater", "films", "snack"],
      char: "\uD83C\uDF7F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    dumpling: {
      keywords: ["food", "empanada", "pierogi", "potsticker"],
      char: "\uD83E\uDD5F",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    doughnut: {
      keywords: ["food", "dessert", "snack", "sweet", "donut"],
      char: "\uD83C\uDF69",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cookie: {
      keywords: ["food", "snack", "oreo", "chocolate", "sweet", "dessert"],
      char: "\uD83C\uDF6A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    milk_glass: {
      keywords: ["beverage", "drink", "cow"],
      char: "\uD83E\uDD5B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    beer: {
      keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"],
      char: "\uD83C\uDF7A",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    beers: {
      keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"],
      char: "\uD83C\uDF7B",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    clinking_glasses: {
      keywords: ["beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast"],
      char: "\uD83E\uDD42",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    wine_glass: {
      keywords: ["drink", "beverage", "drunk", "alcohol", "booze"],
      char: "\uD83C\uDF77",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tumbler_glass: {
      keywords: ["drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "glass", "shot"],
      char: "\uD83E\uDD43",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cocktail: {
      keywords: ["drink", "drunk", "alcohol", "beverage", "booze", "mojito"],
      char: "\uD83C\uDF78",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tropical_drink: {
      keywords: ["beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito"],
      char: "\uD83C\uDF79",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    champagne: {
      keywords: ["drink", "wine", "bottle", "celebration"],
      char: "\uD83C\uDF7E",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    sake: {
      keywords: ["wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze"],
      char: "\uD83C\uDF76",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    tea: {
      keywords: ["drink", "bowl", "breakfast", "green", "british"],
      char: "\uD83C\uDF75",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    cup_with_straw: {
      keywords: ["drink", "soda"],
      char: "\uD83E\uDD64",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    coffee: {
      keywords: ["beverage", "caffeine", "latte", "espresso"],
      char: "\u2615",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    baby_bottle: {
      keywords: ["food", "container", "milk"],
      char: "\uD83C\uDF7C",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    salt: {
      keywords: ["condiment", "shaker"],
      char: "\uD83E\uDDC2",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    spoon: {
      keywords: ["cutlery", "kitchen", "tableware"],
      char: "\uD83E\uDD44",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    fork_and_knife: {
      keywords: ["cutlery", "kitchen"],
      char: "\uD83C\uDF74",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    plate_with_cutlery: {
      keywords: ["food", "eat", "meal", "lunch", "dinner", "restaurant"],
      char: "\uD83C\uDF7D",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    bowl_with_spoon: {
      keywords: ["food", "breakfast", "cereal", "oatmeal", "porridge"],
      char: "\uD83E\uDD63",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    takeout_box: {
      keywords: ["food", "leftovers"],
      char: "\uD83E\uDD61",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    chopsticks: {
      keywords: ["food"],
      char: "\uD83E\uDD62",
      fitzpatrick_scale: false,
      category: "food_and_drink"
    },
    soccer: {
      keywords: ["sports", "football"],
      char: "\u26BD",
      fitzpatrick_scale: false,
      category: "activity"
    },
    basketball: {
      keywords: ["sports", "balls", "NBA"],
      char: "\uD83C\uDFC0",
      fitzpatrick_scale: false,
      category: "activity"
    },
    football: {
      keywords: ["sports", "balls", "NFL"],
      char: "\uD83C\uDFC8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    baseball: {
      keywords: ["sports", "balls"],
      char: "\u26BE",
      fitzpatrick_scale: false,
      category: "activity"
    },
    softball: {
      keywords: ["sports", "balls"],
      char: "\uD83E\uDD4E",
      fitzpatrick_scale: false,
      category: "activity"
    },
    tennis: {
      keywords: ["sports", "balls", "green"],
      char: "\uD83C\uDFBE",
      fitzpatrick_scale: false,
      category: "activity"
    },
    volleyball: {
      keywords: ["sports", "balls"],
      char: "\uD83C\uDFD0",
      fitzpatrick_scale: false,
      category: "activity"
    },
    rugby_football: {
      keywords: ["sports", "team"],
      char: "\uD83C\uDFC9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    flying_disc: {
      keywords: ["sports", "frisbee", "ultimate"],
      char: "\uD83E\uDD4F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "8ball": {
      keywords: ["pool", "hobby", "game", "luck", "magic"],
      char: "\uD83C\uDFB1",
      fitzpatrick_scale: false,
      category: "activity"
    },
    golf: {
      keywords: ["sports", "business", "flag", "hole", "summer"],
      char: "\u26F3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    golfing_woman: {
      keywords: ["sports", "business", "woman", "female"],
      char: "\uD83C\uDFCC\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    golfing_man: {
      keywords: ["sports", "business"],
      char: "\uD83C\uDFCC",
      fitzpatrick_scale: true,
      category: "activity"
    },
    ping_pong: {
      keywords: ["sports", "pingpong"],
      char: "\uD83C\uDFD3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    badminton: {
      keywords: ["sports"],
      char: "\uD83C\uDFF8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    goal_net: {
      keywords: ["sports"],
      char: "\uD83E\uDD45",
      fitzpatrick_scale: false,
      category: "activity"
    },
    ice_hockey: {
      keywords: ["sports"],
      char: "\uD83C\uDFD2",
      fitzpatrick_scale: false,
      category: "activity"
    },
    field_hockey: {
      keywords: ["sports"],
      char: "\uD83C\uDFD1",
      fitzpatrick_scale: false,
      category: "activity"
    },
    lacrosse: {
      keywords: ["sports", "ball", "stick"],
      char: "\uD83E\uDD4D",
      fitzpatrick_scale: false,
      category: "activity"
    },
    cricket: {
      keywords: ["sports"],
      char: "\uD83C\uDFCF",
      fitzpatrick_scale: false,
      category: "activity"
    },
    ski: {
      keywords: ["sports", "winter", "cold", "snow"],
      char: "\uD83C\uDFBF",
      fitzpatrick_scale: false,
      category: "activity"
    },
    skier: {
      keywords: ["sports", "winter", "snow"],
      char: "\u26F7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    snowboarder: {
      keywords: ["sports", "winter"],
      char: "\uD83C\uDFC2",
      fitzpatrick_scale: true,
      category: "activity"
    },
    person_fencing: {
      keywords: ["sports", "fencing", "sword"],
      char: "\uD83E\uDD3A",
      fitzpatrick_scale: false,
      category: "activity"
    },
    women_wrestling: {
      keywords: ["sports", "wrestlers"],
      char: "\uD83E\uDD3C\u200D\u2640\uFE0F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    men_wrestling: {
      keywords: ["sports", "wrestlers"],
      char: "\uD83E\uDD3C\u200D\u2642\uFE0F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    woman_cartwheeling: {
      keywords: ["gymnastics"],
      char: "\uD83E\uDD38\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_cartwheeling: {
      keywords: ["gymnastics"],
      char: "\uD83E\uDD38\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    woman_playing_handball: {
      keywords: ["sports"],
      char: "\uD83E\uDD3E\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_playing_handball: {
      keywords: ["sports"],
      char: "\uD83E\uDD3E\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    ice_skate: {
      keywords: ["sports"],
      char: "\u26F8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    curling_stone: {
      keywords: ["sports"],
      char: "\uD83E\uDD4C",
      fitzpatrick_scale: false,
      category: "activity"
    },
    skateboard: {
      keywords: ["board"],
      char: "\uD83D\uDEF9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    sled: {
      keywords: ["sleigh", "luge", "toboggan"],
      char: "\uD83D\uDEF7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    bow_and_arrow: {
      keywords: ["sports"],
      char: "\uD83C\uDFF9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    fishing_pole_and_fish: {
      keywords: ["food", "hobby", "summer"],
      char: "\uD83C\uDFA3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    boxing_glove: {
      keywords: ["sports", "fighting"],
      char: "\uD83E\uDD4A",
      fitzpatrick_scale: false,
      category: "activity"
    },
    martial_arts_uniform: {
      keywords: ["judo", "karate", "taekwondo"],
      char: "\uD83E\uDD4B",
      fitzpatrick_scale: false,
      category: "activity"
    },
    rowing_woman: {
      keywords: ["sports", "hobby", "water", "ship", "woman", "female"],
      char: "\uD83D\uDEA3\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    rowing_man: {
      keywords: ["sports", "hobby", "water", "ship"],
      char: "\uD83D\uDEA3",
      fitzpatrick_scale: true,
      category: "activity"
    },
    climbing_woman: {
      keywords: ["sports", "hobby", "woman", "female", "rock"],
      char: "\uD83E\uDDD7\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    climbing_man: {
      keywords: ["sports", "hobby", "man", "male", "rock"],
      char: "\uD83E\uDDD7\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    swimming_woman: {
      keywords: ["sports", "exercise", "human", "athlete", "water", "summer", "woman", "female"],
      char: "\uD83C\uDFCA\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    swimming_man: {
      keywords: ["sports", "exercise", "human", "athlete", "water", "summer"],
      char: "\uD83C\uDFCA",
      fitzpatrick_scale: true,
      category: "activity"
    },
    woman_playing_water_polo: {
      keywords: ["sports", "pool"],
      char: "\uD83E\uDD3D\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_playing_water_polo: {
      keywords: ["sports", "pool"],
      char: "\uD83E\uDD3D\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    woman_in_lotus_position: {
      keywords: ["woman", "female", "meditation", "yoga", "serenity", "zen", "mindfulness"],
      char: "\uD83E\uDDD8\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_in_lotus_position: {
      keywords: ["man", "male", "meditation", "yoga", "serenity", "zen", "mindfulness"],
      char: "\uD83E\uDDD8\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    surfing_woman: {
      keywords: ["sports", "ocean", "sea", "summer", "beach", "woman", "female"],
      char: "\uD83C\uDFC4\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    surfing_man: {
      keywords: ["sports", "ocean", "sea", "summer", "beach"],
      char: "\uD83C\uDFC4",
      fitzpatrick_scale: true,
      category: "activity"
    },
    bath: {
      keywords: ["clean", "shower", "bathroom"],
      char: "\uD83D\uDEC0",
      fitzpatrick_scale: true,
      category: "activity"
    },
    basketball_woman: {
      keywords: ["sports", "human", "woman", "female"],
      char: "\u26F9\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    basketball_man: {
      keywords: ["sports", "human"],
      char: "\u26F9",
      fitzpatrick_scale: true,
      category: "activity"
    },
    weight_lifting_woman: {
      keywords: ["sports", "training", "exercise", "woman", "female"],
      char: "\uD83C\uDFCB\uFE0F\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    weight_lifting_man: {
      keywords: ["sports", "training", "exercise"],
      char: "\uD83C\uDFCB",
      fitzpatrick_scale: true,
      category: "activity"
    },
    biking_woman: {
      keywords: ["sports", "bike", "exercise", "hipster", "woman", "female"],
      char: "\uD83D\uDEB4\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    biking_man: {
      keywords: ["sports", "bike", "exercise", "hipster"],
      char: "\uD83D\uDEB4",
      fitzpatrick_scale: true,
      category: "activity"
    },
    mountain_biking_woman: {
      keywords: ["transportation", "sports", "human", "race", "bike", "woman", "female"],
      char: "\uD83D\uDEB5\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    mountain_biking_man: {
      keywords: ["transportation", "sports", "human", "race", "bike"],
      char: "\uD83D\uDEB5",
      fitzpatrick_scale: true,
      category: "activity"
    },
    horse_racing: {
      keywords: ["animal", "betting", "competition", "gambling", "luck"],
      char: "\uD83C\uDFC7",
      fitzpatrick_scale: true,
      category: "activity"
    },
    business_suit_levitating: {
      keywords: ["suit", "business", "levitate", "hover", "jump"],
      char: "\uD83D\uDD74",
      fitzpatrick_scale: true,
      category: "activity"
    },
    trophy: {
      keywords: ["win", "award", "contest", "place", "ftw", "ceremony"],
      char: "\uD83C\uDFC6",
      fitzpatrick_scale: false,
      category: "activity"
    },
    running_shirt_with_sash: {
      keywords: ["play", "pageant"],
      char: "\uD83C\uDFBD",
      fitzpatrick_scale: false,
      category: "activity"
    },
    medal_sports: {
      keywords: ["award", "winning"],
      char: "\uD83C\uDFC5",
      fitzpatrick_scale: false,
      category: "activity"
    },
    medal_military: {
      keywords: ["award", "winning", "army"],
      char: "\uD83C\uDF96",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "1st_place_medal": {
      keywords: ["award", "winning", "first"],
      char: "\uD83E\uDD47",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "2nd_place_medal": {
      keywords: ["award", "second"],
      char: "\uD83E\uDD48",
      fitzpatrick_scale: false,
      category: "activity"
    },
    "3rd_place_medal": {
      keywords: ["award", "third"],
      char: "\uD83E\uDD49",
      fitzpatrick_scale: false,
      category: "activity"
    },
    reminder_ribbon: {
      keywords: ["sports", "cause", "support", "awareness"],
      char: "\uD83C\uDF97",
      fitzpatrick_scale: false,
      category: "activity"
    },
    rosette: {
      keywords: ["flower", "decoration", "military"],
      char: "\uD83C\uDFF5",
      fitzpatrick_scale: false,
      category: "activity"
    },
    ticket: {
      keywords: ["event", "concert", "pass"],
      char: "\uD83C\uDFAB",
      fitzpatrick_scale: false,
      category: "activity"
    },
    tickets: {
      keywords: ["sports", "concert", "entrance"],
      char: "\uD83C\uDF9F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    performing_arts: {
      keywords: ["acting", "theater", "drama"],
      char: "\uD83C\uDFAD",
      fitzpatrick_scale: false,
      category: "activity"
    },
    art: {
      keywords: ["design", "paint", "draw", "colors"],
      char: "\uD83C\uDFA8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    circus_tent: {
      keywords: ["festival", "carnival", "party"],
      char: "\uD83C\uDFAA",
      fitzpatrick_scale: false,
      category: "activity"
    },
    woman_juggling: {
      keywords: ["juggle", "balance", "skill", "multitask"],
      char: "\uD83E\uDD39\u200D\u2640\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    man_juggling: {
      keywords: ["juggle", "balance", "skill", "multitask"],
      char: "\uD83E\uDD39\u200D\u2642\uFE0F",
      fitzpatrick_scale: true,
      category: "activity"
    },
    microphone: {
      keywords: ["sound", "music", "PA", "sing", "talkshow"],
      char: "\uD83C\uDFA4",
      fitzpatrick_scale: false,
      category: "activity"
    },
    headphones: {
      keywords: ["music", "score", "gadgets"],
      char: "\uD83C\uDFA7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    musical_score: {
      keywords: ["treble", "clef", "compose"],
      char: "\uD83C\uDFBC",
      fitzpatrick_scale: false,
      category: "activity"
    },
    musical_keyboard: {
      keywords: ["piano", "instrument", "compose"],
      char: "\uD83C\uDFB9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    drum: {
      keywords: ["music", "instrument", "drumsticks", "snare"],
      char: "\uD83E\uDD41",
      fitzpatrick_scale: false,
      category: "activity"
    },
    saxophone: {
      keywords: ["music", "instrument", "jazz", "blues"],
      char: "\uD83C\uDFB7",
      fitzpatrick_scale: false,
      category: "activity"
    },
    trumpet: {
      keywords: ["music", "brass"],
      char: "\uD83C\uDFBA",
      fitzpatrick_scale: false,
      category: "activity"
    },
    guitar: {
      keywords: ["music", "instrument"],
      char: "\uD83C\uDFB8",
      fitzpatrick_scale: false,
      category: "activity"
    },
    violin: {
      keywords: ["music", "instrument", "orchestra", "symphony"],
      char: "\uD83C\uDFBB",
      fitzpatrick_scale: false,
      category: "activity"
    },
    clapper: {
      keywords: ["movie", "film", "record"],
      char: "\uD83C\uDFAC",
      fitzpatrick_scale: false,
      category: "activity"
    },
    video_game: {
      keywords: ["play", "console", "PS4", "controller"],
      char: "\uD83C\uDFAE",
      fitzpatrick_scale: false,
      category: "activity"
    },
    space_invader: {
      keywords: ["game", "arcade", "play"],
      char: "\uD83D\uDC7E",
      fitzpatrick_scale: false,
      category: "activity"
    },
    dart: {
      keywords: ["game", "play", "bar", "target", "bullseye"],
      char: "\uD83C\uDFAF",
      fitzpatrick_scale: false,
      category: "activity"
    },
    game_die: {
      keywords: ["dice", "random", "tabletop", "play", "luck"],
      char: "\uD83C\uDFB2",
      fitzpatrick_scale: false,
      category: "activity"
    },
    chess_pawn: {
      keywords: ["expendable"],
      char: "\u265F",
      fitzpatrick_scale: false,
      category: "activity"
    },
    slot_machine: {
      keywords: ["bet", "gamble", "vegas", "fruit machine", "luck", "casino"],
      char: "\uD83C\uDFB0",
      fitzpatrick_scale: false,
      category: "activity"
    },
    jigsaw: {
      keywords: ["interlocking", "puzzle", "piece"],
      char: "\uD83E\uDDE9",
      fitzpatrick_scale: false,
      category: "activity"
    },
    bowling: {
      keywords: ["sports", "fun", "play"],
      char: "\uD83C\uDFB3",
      fitzpatrick_scale: false,
      category: "activity"
    },
    red_car: {
      keywords: ["red", "transportation", "vehicle"],
      char: "\uD83D\uDE97",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    taxi: {
      keywords: ["uber", "vehicle", "cars", "transportation"],
      char: "\uD83D\uDE95",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    blue_car: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE99",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bus: {
      keywords: ["car", "vehicle", "transportation"],
      char: "\uD83D\uDE8C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    trolleybus: {
      keywords: ["bart", "transportation", "vehicle"],
      char: "\uD83D\uDE8E",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    racing_car: {
      keywords: ["sports", "race", "fast", "formula", "f1"],
      char: "\uD83C\uDFCE",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    police_car: {
      keywords: ["vehicle", "cars", "transportation", "law", "legal", "enforcement"],
      char: "\uD83D\uDE93",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ambulance: {
      keywords: ["health", "911", "hospital"],
      char: "\uD83D\uDE91",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fire_engine: {
      keywords: ["transportation", "cars", "vehicle"],
      char: "\uD83D\uDE92",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    minibus: {
      keywords: ["vehicle", "car", "transportation"],
      char: "\uD83D\uDE90",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    truck: {
      keywords: ["cars", "transportation"],
      char: "\uD83D\uDE9A",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    articulated_lorry: {
      keywords: ["vehicle", "cars", "transportation", "express"],
      char: "\uD83D\uDE9B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tractor: {
      keywords: ["vehicle", "car", "farming", "agriculture"],
      char: "\uD83D\uDE9C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    kick_scooter: {
      keywords: ["vehicle", "kick", "razor"],
      char: "\uD83D\uDEF4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motorcycle: {
      keywords: ["race", "sports", "fast"],
      char: "\uD83C\uDFCD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bike: {
      keywords: ["sports", "bicycle", "exercise", "hipster"],
      char: "\uD83D\uDEB2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motor_scooter: {
      keywords: ["vehicle", "vespa", "sasha"],
      char: "\uD83D\uDEF5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rotating_light: {
      keywords: ["police", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal"],
      char: "\uD83D\uDEA8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_police_car: {
      keywords: ["vehicle", "law", "legal", "enforcement", "911"],
      char: "\uD83D\uDE94",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_bus: {
      keywords: ["vehicle", "transportation"],
      char: "\uD83D\uDE8D",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_automobile: {
      keywords: ["car", "vehicle", "transportation"],
      char: "\uD83D\uDE98",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    oncoming_taxi: {
      keywords: ["vehicle", "cars", "uber"],
      char: "\uD83D\uDE96",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    aerial_tramway: {
      keywords: ["transportation", "vehicle", "ski"],
      char: "\uD83D\uDEA1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain_cableway: {
      keywords: ["transportation", "vehicle", "ski"],
      char: "\uD83D\uDEA0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    suspension_railway: {
      keywords: ["vehicle", "transportation"],
      char: "\uD83D\uDE9F",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    railway_car: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE83",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    train: {
      keywords: ["transportation", "vehicle", "carriage", "public", "travel"],
      char: "\uD83D\uDE8B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    monorail: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE9D",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bullettrain_side: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE84",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bullettrain_front: {
      keywords: ["transportation", "vehicle", "speed", "fast", "public", "travel"],
      char: "\uD83D\uDE85",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    light_rail: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE88",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain_railway: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE9E",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    steam_locomotive: {
      keywords: ["transportation", "vehicle", "train"],
      char: "\uD83D\uDE82",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    train2: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE86",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    metro: {
      keywords: ["transportation", "blue-square", "mrt", "underground", "tube"],
      char: "\uD83D\uDE87",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tram: {
      keywords: ["transportation", "vehicle"],
      char: "\uD83D\uDE8A",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    station: {
      keywords: ["transportation", "vehicle", "public"],
      char: "\uD83D\uDE89",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    flying_saucer: {
      keywords: ["transportation", "vehicle", "ufo"],
      char: "\uD83D\uDEF8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    helicopter: {
      keywords: ["transportation", "vehicle", "fly"],
      char: "\uD83D\uDE81",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    small_airplane: {
      keywords: ["flight", "transportation", "fly", "vehicle"],
      char: "\uD83D\uDEE9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    airplane: {
      keywords: ["vehicle", "transportation", "flight", "fly"],
      char: "\u2708\uFE0F",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    flight_departure: {
      keywords: ["airport", "flight", "landing"],
      char: "\uD83D\uDEEB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    flight_arrival: {
      keywords: ["airport", "flight", "boarding"],
      char: "\uD83D\uDEEC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sailboat: {
      keywords: ["ship", "summer", "transportation", "water", "sailing"],
      char: "\u26F5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motor_boat: {
      keywords: ["ship"],
      char: "\uD83D\uDEE5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    speedboat: {
      keywords: ["ship", "transportation", "vehicle", "summer"],
      char: "\uD83D\uDEA4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ferry: {
      keywords: ["boat", "ship", "yacht"],
      char: "\u26F4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    passenger_ship: {
      keywords: ["yacht", "cruise", "ferry"],
      char: "\uD83D\uDEF3",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rocket: {
      keywords: ["launch", "ship", "staffmode", "NASA", "outer space", "outer_space", "fly"],
      char: "\uD83D\uDE80",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    artificial_satellite: {
      keywords: ["communication", "gps", "orbit", "spaceflight", "NASA", "ISS"],
      char: "\uD83D\uDEF0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    seat: {
      keywords: ["sit", "airplane", "transport", "bus", "flight", "fly"],
      char: "\uD83D\uDCBA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    canoe: {
      keywords: ["boat", "paddle", "water", "ship"],
      char: "\uD83D\uDEF6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    anchor: {
      keywords: ["ship", "ferry", "sea", "boat"],
      char: "\u2693",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    construction: {
      keywords: ["wip", "progress", "caution", "warning"],
      char: "\uD83D\uDEA7",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fuelpump: {
      keywords: ["gas station", "petroleum"],
      char: "\u26FD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    busstop: {
      keywords: ["transportation", "wait"],
      char: "\uD83D\uDE8F",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    vertical_traffic_light: {
      keywords: ["transportation", "driving"],
      char: "\uD83D\uDEA6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    traffic_light: {
      keywords: ["transportation", "signal"],
      char: "\uD83D\uDEA5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    checkered_flag: {
      keywords: ["contest", "finishline", "race", "gokart"],
      char: "\uD83C\uDFC1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ship: {
      keywords: ["transportation", "titanic", "deploy"],
      char: "\uD83D\uDEA2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    ferris_wheel: {
      keywords: ["photo", "carnival", "londoneye"],
      char: "\uD83C\uDFA1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    roller_coaster: {
      keywords: ["carnival", "playground", "photo", "fun"],
      char: "\uD83C\uDFA2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    carousel_horse: {
      keywords: ["photo", "carnival"],
      char: "\uD83C\uDFA0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    building_construction: {
      keywords: ["wip", "working", "progress"],
      char: "\uD83C\uDFD7",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    foggy: {
      keywords: ["photo", "mountain"],
      char: "\uD83C\uDF01",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tokyo_tower: {
      keywords: ["photo", "japanese"],
      char: "\uD83D\uDDFC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    factory: {
      keywords: ["building", "industry", "pollution", "smoke"],
      char: "\uD83C\uDFED",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fountain: {
      keywords: ["photo", "summer", "water", "fresh"],
      char: "\u26F2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rice_scene: {
      keywords: ["photo", "japan", "asia", "tsukimi"],
      char: "\uD83C\uDF91",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain: {
      keywords: ["photo", "nature", "environment"],
      char: "\u26F0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mountain_snow: {
      keywords: ["photo", "nature", "environment", "winter", "cold"],
      char: "\uD83C\uDFD4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mount_fuji: {
      keywords: ["photo", "mountain", "nature", "japanese"],
      char: "\uD83D\uDDFB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    volcano: {
      keywords: ["photo", "nature", "disaster"],
      char: "\uD83C\uDF0B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    japan: {
      keywords: ["nation", "country", "japanese", "asia"],
      char: "\uD83D\uDDFE",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    camping: {
      keywords: ["photo", "outdoors", "tent"],
      char: "\uD83C\uDFD5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    tent: {
      keywords: ["photo", "camping", "outdoors"],
      char: "\u26FA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    national_park: {
      keywords: ["photo", "environment", "nature"],
      char: "\uD83C\uDFDE",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    motorway: {
      keywords: ["road", "cupertino", "interstate", "highway"],
      char: "\uD83D\uDEE3",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    railway_track: {
      keywords: ["train", "transportation"],
      char: "\uD83D\uDEE4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sunrise: {
      keywords: ["morning", "view", "vacation", "photo"],
      char: "\uD83C\uDF05",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sunrise_over_mountains: {
      keywords: ["view", "vacation", "photo"],
      char: "\uD83C\uDF04",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    desert: {
      keywords: ["photo", "warm", "saharah"],
      char: "\uD83C\uDFDC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    beach_umbrella: {
      keywords: ["weather", "summer", "sunny", "sand", "mojito"],
      char: "\uD83C\uDFD6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    desert_island: {
      keywords: ["photo", "tropical", "mojito"],
      char: "\uD83C\uDFDD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    city_sunrise: {
      keywords: ["photo", "good morning", "dawn"],
      char: "\uD83C\uDF07",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    city_sunset: {
      keywords: ["photo", "evening", "sky", "buildings"],
      char: "\uD83C\uDF06",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    cityscape: {
      keywords: ["photo", "night life", "urban"],
      char: "\uD83C\uDFD9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    night_with_stars: {
      keywords: ["evening", "city", "downtown"],
      char: "\uD83C\uDF03",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bridge_at_night: {
      keywords: ["photo", "sanfrancisco"],
      char: "\uD83C\uDF09",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    milky_way: {
      keywords: ["photo", "space", "stars"],
      char: "\uD83C\uDF0C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    stars: {
      keywords: ["night", "photo"],
      char: "\uD83C\uDF20",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    sparkler: {
      keywords: ["stars", "night", "shine"],
      char: "\uD83C\uDF87",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    fireworks: {
      keywords: ["photo", "festival", "carnival", "congratulations"],
      char: "\uD83C\uDF86",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    rainbow: {
      keywords: ["nature", "happy", "unicorn_face", "photo", "sky", "spring"],
      char: "\uD83C\uDF08",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    houses: {
      keywords: ["buildings", "photo"],
      char: "\uD83C\uDFD8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    european_castle: {
      keywords: ["building", "royalty", "history"],
      char: "\uD83C\uDFF0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    japanese_castle: {
      keywords: ["photo", "building"],
      char: "\uD83C\uDFEF",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    stadium: {
      keywords: ["photo", "place", "sports", "concert", "venue"],
      char: "\uD83C\uDFDF",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    statue_of_liberty: {
      keywords: ["american", "newyork"],
      char: "\uD83D\uDDFD",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    house: {
      keywords: ["building", "home"],
      char: "\uD83C\uDFE0",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    house_with_garden: {
      keywords: ["home", "plant", "nature"],
      char: "\uD83C\uDFE1",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    derelict_house: {
      keywords: ["abandon", "evict", "broken", "building"],
      char: "\uD83C\uDFDA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    office: {
      keywords: ["building", "bureau", "work"],
      char: "\uD83C\uDFE2",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    department_store: {
      keywords: ["building", "shopping", "mall"],
      char: "\uD83C\uDFEC",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    post_office: {
      keywords: ["building", "envelope", "communication"],
      char: "\uD83C\uDFE3",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    european_post_office: {
      keywords: ["building", "email"],
      char: "\uD83C\uDFE4",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    hospital: {
      keywords: ["building", "health", "surgery", "doctor"],
      char: "\uD83C\uDFE5",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    bank: {
      keywords: ["building", "money", "sales", "cash", "business", "enterprise"],
      char: "\uD83C\uDFE6",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    hotel: {
      keywords: ["building", "accomodation", "checkin"],
      char: "\uD83C\uDFE8",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    convenience_store: {
      keywords: ["building", "shopping", "groceries"],
      char: "\uD83C\uDFEA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    school: {
      keywords: ["building", "student", "education", "learn", "teach"],
      char: "\uD83C\uDFEB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    love_hotel: {
      keywords: ["like", "affection", "dating"],
      char: "\uD83C\uDFE9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    wedding: {
      keywords: ["love", "like", "affection", "couple", "marriage", "bride", "groom"],
      char: "\uD83D\uDC92",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    classical_building: {
      keywords: ["art", "culture", "history"],
      char: "\uD83C\uDFDB",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    church: {
      keywords: ["building", "religion", "christ"],
      char: "\u26EA",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    mosque: {
      keywords: ["islam", "worship", "minaret"],
      char: "\uD83D\uDD4C",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    synagogue: {
      keywords: ["judaism", "worship", "temple", "jewish"],
      char: "\uD83D\uDD4D",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    kaaba: {
      keywords: ["mecca", "mosque", "islam"],
      char: "\uD83D\uDD4B",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    shinto_shrine: {
      keywords: ["temple", "japan", "kyoto"],
      char: "\u26E9",
      fitzpatrick_scale: false,
      category: "travel_and_places"
    },
    watch: {
      keywords: ["time", "accessories"],
      char: "\u231A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    iphone: {
      keywords: ["technology", "apple", "gadgets", "dial"],
      char: "\uD83D\uDCF1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    calling: {
      keywords: ["iphone", "incoming"],
      char: "\uD83D\uDCF2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    computer: {
      keywords: ["technology", "laptop", "screen", "display", "monitor"],
      char: "\uD83D\uDCBB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    keyboard: {
      keywords: ["technology", "computer", "type", "input", "text"],
      char: "\u2328",
      fitzpatrick_scale: false,
      category: "objects"
    },
    desktop_computer: {
      keywords: ["technology", "computing", "screen"],
      char: "\uD83D\uDDA5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    printer: {
      keywords: ["paper", "ink"],
      char: "\uD83D\uDDA8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    computer_mouse: {
      keywords: ["click"],
      char: "\uD83D\uDDB1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    trackball: {
      keywords: ["technology", "trackpad"],
      char: "\uD83D\uDDB2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    joystick: {
      keywords: ["game", "play"],
      char: "\uD83D\uDD79",
      fitzpatrick_scale: false,
      category: "objects"
    },
    clamp: {
      keywords: ["tool"],
      char: "\uD83D\uDDDC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    minidisc: {
      keywords: ["technology", "record", "data", "disk", "90s"],
      char: "\uD83D\uDCBD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    floppy_disk: {
      keywords: ["oldschool", "technology", "save", "90s", "80s"],
      char: "\uD83D\uDCBE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    cd: {
      keywords: ["technology", "dvd", "disk", "disc", "90s"],
      char: "\uD83D\uDCBF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dvd: {
      keywords: ["cd", "disk", "disc"],
      char: "\uD83D\uDCC0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    vhs: {
      keywords: ["record", "video", "oldschool", "90s", "80s"],
      char: "\uD83D\uDCFC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    camera: {
      keywords: ["gadgets", "photography"],
      char: "\uD83D\uDCF7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    camera_flash: {
      keywords: ["photography", "gadgets"],
      char: "\uD83D\uDCF8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    video_camera: {
      keywords: ["film", "record"],
      char: "\uD83D\uDCF9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    movie_camera: {
      keywords: ["film", "record"],
      char: "\uD83C\uDFA5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    film_projector: {
      keywords: ["video", "tape", "record", "movie"],
      char: "\uD83D\uDCFD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    film_strip: {
      keywords: ["movie"],
      char: "\uD83C\uDF9E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    telephone_receiver: {
      keywords: ["technology", "communication", "dial"],
      char: "\uD83D\uDCDE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    phone: {
      keywords: ["technology", "communication", "dial", "telephone"],
      char: "\u260E\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pager: {
      keywords: ["bbcall", "oldschool", "90s"],
      char: "\uD83D\uDCDF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    fax: {
      keywords: ["communication", "technology"],
      char: "\uD83D\uDCE0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    tv: {
      keywords: ["technology", "program", "oldschool", "show", "television"],
      char: "\uD83D\uDCFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    radio: {
      keywords: ["communication", "music", "podcast", "program"],
      char: "\uD83D\uDCFB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    studio_microphone: {
      keywords: ["sing", "recording", "artist", "talkshow"],
      char: "\uD83C\uDF99",
      fitzpatrick_scale: false,
      category: "objects"
    },
    level_slider: {
      keywords: ["scale"],
      char: "\uD83C\uDF9A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    control_knobs: {
      keywords: ["dial"],
      char: "\uD83C\uDF9B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    compass: {
      keywords: ["magnetic", "navigation", "orienteering"],
      char: "\uD83E\uDDED",
      fitzpatrick_scale: false,
      category: "objects"
    },
    stopwatch: {
      keywords: ["time", "deadline"],
      char: "\u23F1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    timer_clock: {
      keywords: ["alarm"],
      char: "\u23F2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    alarm_clock: {
      keywords: ["time", "wake"],
      char: "\u23F0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mantelpiece_clock: {
      keywords: ["time"],
      char: "\uD83D\uDD70",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hourglass_flowing_sand: {
      keywords: ["oldschool", "time", "countdown"],
      char: "\u23F3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hourglass: {
      keywords: ["time", "clock", "oldschool", "limit", "exam", "quiz", "test"],
      char: "\u231B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    satellite: {
      keywords: ["communication", "future", "radio", "space"],
      char: "\uD83D\uDCE1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    battery: {
      keywords: ["power", "energy", "sustain"],
      char: "\uD83D\uDD0B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    electric_plug: {
      keywords: ["charger", "power"],
      char: "\uD83D\uDD0C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bulb: {
      keywords: ["light", "electricity", "idea"],
      char: "\uD83D\uDCA1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    flashlight: {
      keywords: ["dark", "camping", "sight", "night"],
      char: "\uD83D\uDD26",
      fitzpatrick_scale: false,
      category: "objects"
    },
    candle: {
      keywords: ["fire", "wax"],
      char: "\uD83D\uDD6F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    fire_extinguisher: {
      keywords: ["quench"],
      char: "\uD83E\uDDEF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    wastebasket: {
      keywords: ["bin", "trash", "rubbish", "garbage", "toss"],
      char: "\uD83D\uDDD1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    oil_drum: {
      keywords: ["barrell"],
      char: "\uD83D\uDEE2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    money_with_wings: {
      keywords: ["dollar", "bills", "payment", "sale"],
      char: "\uD83D\uDCB8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dollar: {
      keywords: ["money", "sales", "bill", "currency"],
      char: "\uD83D\uDCB5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    yen: {
      keywords: ["money", "sales", "japanese", "dollar", "currency"],
      char: "\uD83D\uDCB4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    euro: {
      keywords: ["money", "sales", "dollar", "currency"],
      char: "\uD83D\uDCB6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pound: {
      keywords: ["british", "sterling", "money", "sales", "bills", "uk", "england", "currency"],
      char: "\uD83D\uDCB7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    moneybag: {
      keywords: ["dollar", "payment", "coins", "sale"],
      char: "\uD83D\uDCB0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    credit_card: {
      keywords: ["money", "sales", "dollar", "bill", "payment", "shopping"],
      char: "\uD83D\uDCB3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gem: {
      keywords: ["blue", "ruby", "diamond", "jewelry"],
      char: "\uD83D\uDC8E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    balance_scale: {
      keywords: ["law", "fairness", "weight"],
      char: "\u2696",
      fitzpatrick_scale: false,
      category: "objects"
    },
    toolbox: {
      keywords: ["tools", "diy", "fix", "maintainer", "mechanic"],
      char: "\uD83E\uDDF0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    wrench: {
      keywords: ["tools", "diy", "ikea", "fix", "maintainer"],
      char: "\uD83D\uDD27",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hammer: {
      keywords: ["tools", "build", "create"],
      char: "\uD83D\uDD28",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hammer_and_pick: {
      keywords: ["tools", "build", "create"],
      char: "\u2692",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hammer_and_wrench: {
      keywords: ["tools", "build", "create"],
      char: "\uD83D\uDEE0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pick: {
      keywords: ["tools", "dig"],
      char: "\u26CF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    nut_and_bolt: {
      keywords: ["handy", "tools", "fix"],
      char: "\uD83D\uDD29",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gear: {
      keywords: ["cog"],
      char: "\u2699",
      fitzpatrick_scale: false,
      category: "objects"
    },
    brick: {
      keywords: ["bricks"],
      char: "\uD83E\uDDF1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    chains: {
      keywords: ["lock", "arrest"],
      char: "\u26D3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    magnet: {
      keywords: ["attraction", "magnetic"],
      char: "\uD83E\uDDF2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gun: {
      keywords: ["violence", "weapon", "pistol", "revolver"],
      char: "\uD83D\uDD2B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bomb: {
      keywords: ["boom", "explode", "explosion", "terrorism"],
      char: "\uD83D\uDCA3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    firecracker: {
      keywords: ["dynamite", "boom", "explode", "explosion", "explosive"],
      char: "\uD83E\uDDE8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hocho: {
      keywords: ["knife", "blade", "cutlery", "kitchen", "weapon"],
      char: "\uD83D\uDD2A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dagger: {
      keywords: ["weapon"],
      char: "\uD83D\uDDE1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crossed_swords: {
      keywords: ["weapon"],
      char: "\u2694",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shield: {
      keywords: ["protection", "security"],
      char: "\uD83D\uDEE1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    smoking: {
      keywords: ["kills", "tobacco", "cigarette", "joint", "smoke"],
      char: "\uD83D\uDEAC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    skull_and_crossbones: {
      keywords: ["poison", "danger", "deadly", "scary", "death", "pirate", "evil"],
      char: "\u2620",
      fitzpatrick_scale: false,
      category: "objects"
    },
    coffin: {
      keywords: ["vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box"],
      char: "\u26B0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    funeral_urn: {
      keywords: ["dead", "die", "death", "rip", "ashes"],
      char: "\u26B1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    amphora: {
      keywords: ["vase", "jar"],
      char: "\uD83C\uDFFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crystal_ball: {
      keywords: ["disco", "party", "magic", "circus", "fortune_teller"],
      char: "\uD83D\uDD2E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    prayer_beads: {
      keywords: ["dhikr", "religious"],
      char: "\uD83D\uDCFF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    nazar_amulet: {
      keywords: ["bead", "charm"],
      char: "\uD83E\uDDFF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    barber: {
      keywords: ["hair", "salon", "style"],
      char: "\uD83D\uDC88",
      fitzpatrick_scale: false,
      category: "objects"
    },
    alembic: {
      keywords: ["distilling", "science", "experiment", "chemistry"],
      char: "\u2697",
      fitzpatrick_scale: false,
      category: "objects"
    },
    telescope: {
      keywords: ["stars", "space", "zoom", "science", "astronomy"],
      char: "\uD83D\uDD2D",
      fitzpatrick_scale: false,
      category: "objects"
    },
    microscope: {
      keywords: ["laboratory", "experiment", "zoomin", "science", "study"],
      char: "\uD83D\uDD2C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    hole: {
      keywords: ["embarrassing"],
      char: "\uD83D\uDD73",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pill: {
      keywords: ["health", "medicine", "doctor", "pharmacy", "drug"],
      char: "\uD83D\uDC8A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    syringe: {
      keywords: ["health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse"],
      char: "\uD83D\uDC89",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dna: {
      keywords: ["biologist", "genetics", "life"],
      char: "\uD83E\uDDEC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    microbe: {
      keywords: ["amoeba", "bacteria", "germs"],
      char: "\uD83E\uDDA0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    petri_dish: {
      keywords: ["bacteria", "biology", "culture", "lab"],
      char: "\uD83E\uDDEB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    test_tube: {
      keywords: ["chemistry", "experiment", "lab", "science"],
      char: "\uD83E\uDDEA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    thermometer: {
      keywords: ["weather", "temperature", "hot", "cold"],
      char: "\uD83C\uDF21",
      fitzpatrick_scale: false,
      category: "objects"
    },
    broom: {
      keywords: ["cleaning", "sweeping", "witch"],
      char: "\uD83E\uDDF9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    basket: {
      keywords: ["laundry"],
      char: "\uD83E\uDDFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    toilet_paper: {
      keywords: ["roll"],
      char: "\uD83E\uDDFB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    label: {
      keywords: ["sale", "tag"],
      char: "\uD83C\uDFF7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bookmark: {
      keywords: ["favorite", "label", "save"],
      char: "\uD83D\uDD16",
      fitzpatrick_scale: false,
      category: "objects"
    },
    toilet: {
      keywords: ["restroom", "wc", "washroom", "bathroom", "potty"],
      char: "\uD83D\uDEBD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shower: {
      keywords: ["clean", "water", "bathroom"],
      char: "\uD83D\uDEBF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bathtub: {
      keywords: ["clean", "shower", "bathroom"],
      char: "\uD83D\uDEC1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    soap: {
      keywords: ["bar", "bathing", "cleaning", "lather"],
      char: "\uD83E\uDDFC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    sponge: {
      keywords: ["absorbing", "cleaning", "porous"],
      char: "\uD83E\uDDFD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    lotion_bottle: {
      keywords: ["moisturizer", "sunscreen"],
      char: "\uD83E\uDDF4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    key: {
      keywords: ["lock", "door", "password"],
      char: "\uD83D\uDD11",
      fitzpatrick_scale: false,
      category: "objects"
    },
    old_key: {
      keywords: ["lock", "door", "password"],
      char: "\uD83D\uDDDD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    couch_and_lamp: {
      keywords: ["read", "chill"],
      char: "\uD83D\uDECB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    sleeping_bed: {
      keywords: ["bed", "rest"],
      char: "\uD83D\uDECC",
      fitzpatrick_scale: true,
      category: "objects"
    },
    bed: {
      keywords: ["sleep", "rest"],
      char: "\uD83D\uDECF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    door: {
      keywords: ["house", "entry", "exit"],
      char: "\uD83D\uDEAA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bellhop_bell: {
      keywords: ["service"],
      char: "\uD83D\uDECE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    teddy_bear: {
      keywords: ["plush", "stuffed"],
      char: "\uD83E\uDDF8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    framed_picture: {
      keywords: ["photography"],
      char: "\uD83D\uDDBC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    world_map: {
      keywords: ["location", "direction"],
      char: "\uD83D\uDDFA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    parasol_on_ground: {
      keywords: ["weather", "summer"],
      char: "\u26F1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    moyai: {
      keywords: ["rock", "easter island", "moai"],
      char: "\uD83D\uDDFF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shopping: {
      keywords: ["mall", "buy", "purchase"],
      char: "\uD83D\uDECD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    shopping_cart: {
      keywords: ["trolley"],
      char: "\uD83D\uDED2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    balloon: {
      keywords: ["party", "celebration", "birthday", "circus"],
      char: "\uD83C\uDF88",
      fitzpatrick_scale: false,
      category: "objects"
    },
    flags: {
      keywords: ["fish", "japanese", "koinobori", "carp", "banner"],
      char: "\uD83C\uDF8F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    ribbon: {
      keywords: ["decoration", "pink", "girl", "bowtie"],
      char: "\uD83C\uDF80",
      fitzpatrick_scale: false,
      category: "objects"
    },
    gift: {
      keywords: ["present", "birthday", "christmas", "xmas"],
      char: "\uD83C\uDF81",
      fitzpatrick_scale: false,
      category: "objects"
    },
    confetti_ball: {
      keywords: ["festival", "party", "birthday", "circus"],
      char: "\uD83C\uDF8A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    tada: {
      keywords: ["party", "congratulations", "birthday", "magic", "circus", "celebration"],
      char: "\uD83C\uDF89",
      fitzpatrick_scale: false,
      category: "objects"
    },
    dolls: {
      keywords: ["japanese", "toy", "kimono"],
      char: "\uD83C\uDF8E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    wind_chime: {
      keywords: ["nature", "ding", "spring", "bell"],
      char: "\uD83C\uDF90",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crossed_flags: {
      keywords: ["japanese", "nation", "country", "border"],
      char: "\uD83C\uDF8C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    izakaya_lantern: {
      keywords: ["light", "paper", "halloween", "spooky"],
      char: "\uD83C\uDFEE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    red_envelope: {
      keywords: ["gift"],
      char: "\uD83E\uDDE7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    email: {
      keywords: ["letter", "postal", "inbox", "communication"],
      char: "\u2709\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    envelope_with_arrow: {
      keywords: ["email", "communication"],
      char: "\uD83D\uDCE9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    incoming_envelope: {
      keywords: ["email", "inbox"],
      char: "\uD83D\uDCE8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    "e-mail": {
      keywords: ["communication", "inbox"],
      char: "\uD83D\uDCE7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    love_letter: {
      keywords: ["email", "like", "affection", "envelope", "valentines"],
      char: "\uD83D\uDC8C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    postbox: {
      keywords: ["email", "letter", "envelope"],
      char: "\uD83D\uDCEE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox_closed: {
      keywords: ["email", "communication", "inbox"],
      char: "\uD83D\uDCEA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox: {
      keywords: ["email", "inbox", "communication"],
      char: "\uD83D\uDCEB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox_with_mail: {
      keywords: ["email", "inbox", "communication"],
      char: "\uD83D\uDCEC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mailbox_with_no_mail: {
      keywords: ["email", "inbox"],
      char: "\uD83D\uDCED",
      fitzpatrick_scale: false,
      category: "objects"
    },
    package: {
      keywords: ["mail", "gift", "cardboard", "box", "moving"],
      char: "\uD83D\uDCE6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    postal_horn: {
      keywords: ["instrument", "music"],
      char: "\uD83D\uDCEF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    inbox_tray: {
      keywords: ["email", "documents"],
      char: "\uD83D\uDCE5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    outbox_tray: {
      keywords: ["inbox", "email"],
      char: "\uD83D\uDCE4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    scroll: {
      keywords: ["documents", "ancient", "history", "paper"],
      char: "\uD83D\uDCDC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    page_with_curl: {
      keywords: ["documents", "office", "paper"],
      char: "\uD83D\uDCC3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bookmark_tabs: {
      keywords: ["favorite", "save", "order", "tidy"],
      char: "\uD83D\uDCD1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    receipt: {
      keywords: ["accounting", "expenses"],
      char: "\uD83E\uDDFE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    bar_chart: {
      keywords: ["graph", "presentation", "stats"],
      char: "\uD83D\uDCCA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    chart_with_upwards_trend: {
      keywords: ["graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success"],
      char: "\uD83D\uDCC8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    chart_with_downwards_trend: {
      keywords: ["graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure"],
      char: "\uD83D\uDCC9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    page_facing_up: {
      keywords: ["documents", "office", "paper", "information"],
      char: "\uD83D\uDCC4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    date: {
      keywords: ["calendar", "schedule"],
      char: "\uD83D\uDCC5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    calendar: {
      keywords: ["schedule", "date", "planning"],
      char: "\uD83D\uDCC6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    spiral_calendar: {
      keywords: ["date", "schedule", "planning"],
      char: "\uD83D\uDDD3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    card_index: {
      keywords: ["business", "stationery"],
      char: "\uD83D\uDCC7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    card_file_box: {
      keywords: ["business", "stationery"],
      char: "\uD83D\uDDC3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    ballot_box: {
      keywords: ["election", "vote"],
      char: "\uD83D\uDDF3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    file_cabinet: {
      keywords: ["filing", "organizing"],
      char: "\uD83D\uDDC4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    clipboard: {
      keywords: ["stationery", "documents"],
      char: "\uD83D\uDCCB",
      fitzpatrick_scale: false,
      category: "objects"
    },
    spiral_notepad: {
      keywords: ["memo", "stationery"],
      char: "\uD83D\uDDD2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    file_folder: {
      keywords: ["documents", "business", "office"],
      char: "\uD83D\uDCC1",
      fitzpatrick_scale: false,
      category: "objects"
    },
    open_file_folder: {
      keywords: ["documents", "load"],
      char: "\uD83D\uDCC2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    card_index_dividers: {
      keywords: ["organizing", "business", "stationery"],
      char: "\uD83D\uDDC2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    newspaper_roll: {
      keywords: ["press", "headline"],
      char: "\uD83D\uDDDE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    newspaper: {
      keywords: ["press", "headline"],
      char: "\uD83D\uDCF0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    notebook: {
      keywords: ["stationery", "record", "notes", "paper", "study"],
      char: "\uD83D\uDCD3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    closed_book: {
      keywords: ["read", "library", "knowledge", "textbook", "learn"],
      char: "\uD83D\uDCD5",
      fitzpatrick_scale: false,
      category: "objects"
    },
    green_book: {
      keywords: ["read", "library", "knowledge", "study"],
      char: "\uD83D\uDCD7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    blue_book: {
      keywords: ["read", "library", "knowledge", "learn", "study"],
      char: "\uD83D\uDCD8",
      fitzpatrick_scale: false,
      category: "objects"
    },
    orange_book: {
      keywords: ["read", "library", "knowledge", "textbook", "study"],
      char: "\uD83D\uDCD9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    notebook_with_decorative_cover: {
      keywords: ["classroom", "notes", "record", "paper", "study"],
      char: "\uD83D\uDCD4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    ledger: {
      keywords: ["notes", "paper"],
      char: "\uD83D\uDCD2",
      fitzpatrick_scale: false,
      category: "objects"
    },
    books: {
      keywords: ["literature", "library", "study"],
      char: "\uD83D\uDCDA",
      fitzpatrick_scale: false,
      category: "objects"
    },
    open_book: {
      keywords: ["book", "read", "library", "knowledge", "literature", "learn", "study"],
      char: "\uD83D\uDCD6",
      fitzpatrick_scale: false,
      category: "objects"
    },
    safety_pin: {
      keywords: ["diaper"],
      char: "\uD83E\uDDF7",
      fitzpatrick_scale: false,
      category: "objects"
    },
    link: {
      keywords: ["rings", "url"],
      char: "\uD83D\uDD17",
      fitzpatrick_scale: false,
      category: "objects"
    },
    paperclip: {
      keywords: ["documents", "stationery"],
      char: "\uD83D\uDCCE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    paperclips: {
      keywords: ["documents", "stationery"],
      char: "\uD83D\uDD87",
      fitzpatrick_scale: false,
      category: "objects"
    },
    scissors: {
      keywords: ["stationery", "cut"],
      char: "\u2702\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    triangular_ruler: {
      keywords: ["stationery", "math", "architect", "sketch"],
      char: "\uD83D\uDCD0",
      fitzpatrick_scale: false,
      category: "objects"
    },
    straight_ruler: {
      keywords: ["stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch"],
      char: "\uD83D\uDCCF",
      fitzpatrick_scale: false,
      category: "objects"
    },
    abacus: {
      keywords: ["calculation"],
      char: "\uD83E\uDDEE",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pushpin: {
      keywords: ["stationery", "mark", "here"],
      char: "\uD83D\uDCCC",
      fitzpatrick_scale: false,
      category: "objects"
    },
    round_pushpin: {
      keywords: ["stationery", "location", "map", "here"],
      char: "\uD83D\uDCCD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    triangular_flag_on_post: {
      keywords: ["mark", "milestone", "place"],
      char: "\uD83D\uDEA9",
      fitzpatrick_scale: false,
      category: "objects"
    },
    white_flag: {
      keywords: ["losing", "loser", "lost", "surrender", "give up", "fail"],
      char: "\uD83C\uDFF3",
      fitzpatrick_scale: false,
      category: "objects"
    },
    black_flag: {
      keywords: ["pirate"],
      char: "\uD83C\uDFF4",
      fitzpatrick_scale: false,
      category: "objects"
    },
    rainbow_flag: {
      keywords: ["flag", "rainbow", "pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender"],
      char: "\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08",
      fitzpatrick_scale: false,
      category: "objects"
    },
    closed_lock_with_key: {
      keywords: ["security", "privacy"],
      char: "\uD83D\uDD10",
      fitzpatrick_scale: false,
      category: "objects"
    },
    lock: {
      keywords: ["security", "password", "padlock"],
      char: "\uD83D\uDD12",
      fitzpatrick_scale: false,
      category: "objects"
    },
    unlock: {
      keywords: ["privacy", "security"],
      char: "\uD83D\uDD13",
      fitzpatrick_scale: false,
      category: "objects"
    },
    lock_with_ink_pen: {
      keywords: ["security", "secret"],
      char: "\uD83D\uDD0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pen: {
      keywords: ["stationery", "writing", "write"],
      char: "\uD83D\uDD8A",
      fitzpatrick_scale: false,
      category: "objects"
    },
    fountain_pen: {
      keywords: ["stationery", "writing", "write"],
      char: "\uD83D\uDD8B",
      fitzpatrick_scale: false,
      category: "objects"
    },
    black_nib: {
      keywords: ["pen", "stationery", "writing", "write"],
      char: "\u2712\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    memo: {
      keywords: ["write", "documents", "stationery", "pencil", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose"],
      char: "\uD83D\uDCDD",
      fitzpatrick_scale: false,
      category: "objects"
    },
    pencil2: {
      keywords: ["stationery", "write", "paper", "writing", "school", "study"],
      char: "\u270F\uFE0F",
      fitzpatrick_scale: false,
      category: "objects"
    },
    crayon: {
      keywords: ["drawing", "creativity"],
      char: "\uD83D\uDD8D",
      fitzpatrick_scale: false,
      category: "objects"
    },
    paintbrush: {
      keywords: ["drawing", "creativity", "art"],
      char: "\uD83D\uDD8C",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mag: {
      keywords: ["search", "zoom", "find", "detective"],
      char: "\uD83D\uDD0D",
      fitzpatrick_scale: false,
      category: "objects"
    },
    mag_right: {
      keywords: ["search", "zoom", "find", "detective"],
      char: "\uD83D\uDD0E",
      fitzpatrick_scale: false,
      category: "objects"
    },
    heart: {
      keywords: ["love", "like", "valentines"],
      char: "\u2764\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    orange_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83E\uDDE1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    yellow_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    green_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    blue_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC99",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    purple_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_heart: {
      keywords: ["evil"],
      char: "\uD83D\uDDA4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    broken_heart: {
      keywords: ["sad", "sorry", "break", "heart", "heartbreak"],
      char: "\uD83D\uDC94",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_heart_exclamation: {
      keywords: ["decoration", "love"],
      char: "\u2763",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    two_hearts: {
      keywords: ["love", "like", "affection", "valentines", "heart"],
      char: "\uD83D\uDC95",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    revolving_hearts: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC9E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heartbeat: {
      keywords: ["love", "like", "affection", "valentines", "pink", "heart"],
      char: "\uD83D\uDC93",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heartpulse: {
      keywords: ["like", "love", "affection", "valentines", "pink"],
      char: "\uD83D\uDC97",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sparkling_heart: {
      keywords: ["love", "like", "affection", "valentines"],
      char: "\uD83D\uDC96",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cupid: {
      keywords: ["love", "like", "heart", "affection", "valentines"],
      char: "\uD83D\uDC98",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    gift_heart: {
      keywords: ["love", "valentines"],
      char: "\uD83D\uDC9D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heart_decoration: {
      keywords: ["purple-square", "love", "like"],
      char: "\uD83D\uDC9F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    peace_symbol: {
      keywords: ["hippie"],
      char: "\u262E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    latin_cross: {
      keywords: ["christianity"],
      char: "\u271D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    star_and_crescent: {
      keywords: ["islam"],
      char: "\u262A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    om: {
      keywords: ["hinduism", "buddhism", "sikhism", "jainism"],
      char: "\uD83D\uDD49",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wheel_of_dharma: {
      keywords: ["hinduism", "buddhism", "sikhism", "jainism"],
      char: "\u2638",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    star_of_david: {
      keywords: ["judaism"],
      char: "\u2721",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    six_pointed_star: {
      keywords: ["purple-square", "religion", "jewish", "hexagram"],
      char: "\uD83D\uDD2F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    menorah: {
      keywords: ["hanukkah", "candles", "jewish"],
      char: "\uD83D\uDD4E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    yin_yang: {
      keywords: ["balance"],
      char: "\u262F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    orthodox_cross: {
      keywords: ["suppedaneum", "religion"],
      char: "\u2626",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    place_of_worship: {
      keywords: ["religion", "church", "temple", "prayer"],
      char: "\uD83D\uDED0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ophiuchus: {
      keywords: ["sign", "purple-square", "constellation", "astrology"],
      char: "\u26CE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    aries: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u2648",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    taurus: {
      keywords: ["purple-square", "sign", "zodiac", "astrology"],
      char: "\u2649",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    gemini: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u264A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cancer: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u264B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    leo: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u264C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    virgo: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u264D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    libra: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u264E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    scorpius: {
      keywords: ["sign", "zodiac", "purple-square", "astrology", "scorpio"],
      char: "\u264F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sagittarius: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u2650",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    capricorn: {
      keywords: ["sign", "zodiac", "purple-square", "astrology"],
      char: "\u2651",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    aquarius: {
      keywords: ["sign", "purple-square", "zodiac", "astrology"],
      char: "\u2652",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    pisces: {
      keywords: ["purple-square", "sign", "zodiac", "astrology"],
      char: "\u2653",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    id: {
      keywords: ["purple-square", "words"],
      char: "\uD83C\uDD94",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    atom_symbol: {
      keywords: ["science", "physics", "chemistry"],
      char: "\u269B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7a7a: {
      keywords: ["kanji", "japanese", "chinese", "empty", "sky", "blue-square"],
      char: "\uD83C\uDE33",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u5272: {
      keywords: ["cut", "divide", "chinese", "kanji", "pink-square"],
      char: "\uD83C\uDE39",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    radioactive: {
      keywords: ["nuclear", "danger"],
      char: "\u2622",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    biohazard: {
      keywords: ["danger"],
      char: "\u2623",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mobile_phone_off: {
      keywords: ["mute", "orange-square", "silence", "quiet"],
      char: "\uD83D\uDCF4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    vibration_mode: {
      keywords: ["orange-square", "phone"],
      char: "\uD83D\uDCF3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6709: {
      keywords: ["orange-square", "chinese", "have", "kanji"],
      char: "\uD83C\uDE36",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7121: {
      keywords: ["nothing", "chinese", "kanji", "japanese", "orange-square"],
      char: "\uD83C\uDE1A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7533: {
      keywords: ["chinese", "japanese", "kanji", "orange-square"],
      char: "\uD83C\uDE38",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u55b6: {
      keywords: ["japanese", "opening hours", "orange-square"],
      char: "\uD83C\uDE3A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6708: {
      keywords: ["chinese", "month", "moon", "japanese", "orange-square", "kanji"],
      char: "\uD83C\uDE37\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eight_pointed_black_star: {
      keywords: ["orange-square", "shape", "polygon"],
      char: "\u2734\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    vs: {
      keywords: ["words", "orange-square"],
      char: "\uD83C\uDD9A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    accept: {
      keywords: ["ok", "good", "chinese", "kanji", "agree", "yes", "orange-circle"],
      char: "\uD83C\uDE51",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_flower: {
      keywords: ["japanese", "spring"],
      char: "\uD83D\uDCAE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ideograph_advantage: {
      keywords: ["chinese", "kanji", "obtain", "get", "circle"],
      char: "\uD83C\uDE50",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    secret: {
      keywords: ["privacy", "chinese", "sshh", "kanji", "red-circle"],
      char: "\u3299\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    congratulations: {
      keywords: ["chinese", "kanji", "japanese", "red-circle"],
      char: "\u3297\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u5408: {
      keywords: ["japanese", "chinese", "join", "kanji", "red-square"],
      char: "\uD83C\uDE34",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6e80: {
      keywords: ["full", "chinese", "japanese", "red-square", "kanji"],
      char: "\uD83C\uDE35",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u7981: {
      keywords: ["kanji", "japanese", "chinese", "forbidden", "limit", "restricted", "red-square"],
      char: "\uD83C\uDE32",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    a: {
      keywords: ["red-square", "alphabet", "letter"],
      char: "\uD83C\uDD70\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    b: {
      keywords: ["red-square", "alphabet", "letter"],
      char: "\uD83C\uDD71\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ab: {
      keywords: ["red-square", "alphabet"],
      char: "\uD83C\uDD8E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cl: {
      keywords: ["alphabet", "words", "red-square"],
      char: "\uD83C\uDD91",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    o2: {
      keywords: ["alphabet", "red-square", "letter"],
      char: "\uD83C\uDD7E\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sos: {
      keywords: ["help", "red-square", "words", "emergency", "911"],
      char: "\uD83C\uDD98",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_entry: {
      keywords: ["limit", "security", "privacy", "bad", "denied", "stop", "circle"],
      char: "\u26D4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    name_badge: {
      keywords: ["fire", "forbid"],
      char: "\uD83D\uDCDB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_entry_sign: {
      keywords: ["forbid", "stop", "limit", "denied", "disallow", "circle"],
      char: "\uD83D\uDEAB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    x: {
      keywords: ["no", "delete", "remove", "cancel", "red"],
      char: "\u274C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    o: {
      keywords: ["circle", "round"],
      char: "\u2B55",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    stop_sign: {
      keywords: ["stop"],
      char: "\uD83D\uDED1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    anger: {
      keywords: ["angry", "mad"],
      char: "\uD83D\uDCA2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    hotsprings: {
      keywords: ["bath", "warm", "relax"],
      char: "\u2668\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_pedestrians: {
      keywords: ["rules", "crossing", "walking", "circle"],
      char: "\uD83D\uDEB7",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    do_not_litter: {
      keywords: ["trash", "bin", "garbage", "circle"],
      char: "\uD83D\uDEAF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_bicycles: {
      keywords: ["cyclist", "prohibited", "circle"],
      char: "\uD83D\uDEB3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    "non-potable_water": {
      keywords: ["drink", "faucet", "tap", "circle"],
      char: "\uD83D\uDEB1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    underage: {
      keywords: ["18", "drink", "pub", "night", "minor", "circle"],
      char: "\uD83D\uDD1E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_mobile_phones: {
      keywords: ["iphone", "mute", "circle"],
      char: "\uD83D\uDCF5",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    exclamation: {
      keywords: ["heavy_exclamation_mark", "danger", "surprise", "punctuation", "wow", "warning"],
      char: "\u2757",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    grey_exclamation: {
      keywords: ["surprise", "punctuation", "gray", "wow", "warning"],
      char: "\u2755",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    question: {
      keywords: ["doubt", "confused"],
      char: "\u2753",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    grey_question: {
      keywords: ["doubts", "gray", "huh", "confused"],
      char: "\u2754",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    bangbang: {
      keywords: ["exclamation", "surprise"],
      char: "\u203C\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    interrobang: {
      keywords: ["wat", "punctuation", "surprise"],
      char: "\u2049\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    "100": {
      keywords: ["score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass", "hundred"],
      char: "\uD83D\uDCAF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    low_brightness: {
      keywords: ["sun", "afternoon", "warm", "summer"],
      char: "\uD83D\uDD05",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    high_brightness: {
      keywords: ["sun", "light"],
      char: "\uD83D\uDD06",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    trident: {
      keywords: ["weapon", "spear"],
      char: "\uD83D\uDD31",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    fleur_de_lis: {
      keywords: ["decorative", "scout"],
      char: "\u269C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    part_alternation_mark: {
      keywords: ["graph", "presentation", "stats", "business", "economics", "bad"],
      char: "\u303D\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    warning: {
      keywords: ["exclamation", "wip", "alert", "error", "problem", "issue"],
      char: "\u26A0\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    children_crossing: {
      keywords: ["school", "warning", "danger", "sign", "driving", "yellow-diamond"],
      char: "\uD83D\uDEB8",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    beginner: {
      keywords: ["badge", "shield"],
      char: "\uD83D\uDD30",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    recycle: {
      keywords: ["arrow", "environment", "garbage", "trash"],
      char: "\u267B\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    u6307: {
      keywords: ["chinese", "point", "green-square", "kanji"],
      char: "\uD83C\uDE2F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    chart: {
      keywords: ["green-square", "graph", "presentation", "stats"],
      char: "\uD83D\uDCB9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sparkle: {
      keywords: ["stars", "green-square", "awesome", "good", "fireworks"],
      char: "\u2747\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eight_spoked_asterisk: {
      keywords: ["star", "sparkle", "green-square"],
      char: "\u2733\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    negative_squared_cross_mark: {
      keywords: ["x", "green-square", "no", "deny"],
      char: "\u274E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_check_mark: {
      keywords: ["green-square", "ok", "agree", "vote", "election", "answer", "tick"],
      char: "\u2705",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    diamond_shape_with_a_dot_inside: {
      keywords: ["jewel", "blue", "gem", "crystal", "fancy"],
      char: "\uD83D\uDCA0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cyclone: {
      keywords: ["weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon"],
      char: "\uD83C\uDF00",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    loop: {
      keywords: ["tape", "cassette"],
      char: "\u27BF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    globe_with_meridians: {
      keywords: ["earth", "international", "world", "internet", "interweb", "i18n"],
      char: "\uD83C\uDF10",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    m: {
      keywords: ["alphabet", "blue-circle", "letter"],
      char: "\u24C2\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    atm: {
      keywords: ["money", "sales", "cash", "blue-square", "payment", "bank"],
      char: "\uD83C\uDFE7",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sa: {
      keywords: ["japanese", "blue-square", "katakana"],
      char: "\uD83C\uDE02\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    passport_control: {
      keywords: ["custom", "blue-square"],
      char: "\uD83D\uDEC2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    customs: {
      keywords: ["passport", "border", "blue-square"],
      char: "\uD83D\uDEC3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    baggage_claim: {
      keywords: ["blue-square", "airport", "transport"],
      char: "\uD83D\uDEC4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    left_luggage: {
      keywords: ["blue-square", "travel"],
      char: "\uD83D\uDEC5",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wheelchair: {
      keywords: ["blue-square", "disabled", "a11y", "accessibility"],
      char: "\u267F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_smoking: {
      keywords: ["cigarette", "blue-square", "smell", "smoke"],
      char: "\uD83D\uDEAD",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wc: {
      keywords: ["toilet", "restroom", "blue-square"],
      char: "\uD83D\uDEBE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    parking: {
      keywords: ["cars", "blue-square", "alphabet", "letter"],
      char: "\uD83C\uDD7F\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    potable_water: {
      keywords: ["blue-square", "liquid", "restroom", "cleaning", "faucet"],
      char: "\uD83D\uDEB0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mens: {
      keywords: ["toilet", "restroom", "wc", "blue-square", "gender", "male"],
      char: "\uD83D\uDEB9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    womens: {
      keywords: ["purple-square", "woman", "female", "toilet", "loo", "restroom", "gender"],
      char: "\uD83D\uDEBA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    baby_symbol: {
      keywords: ["orange-square", "child"],
      char: "\uD83D\uDEBC",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    restroom: {
      keywords: ["blue-square", "toilet", "refresh", "wc", "gender"],
      char: "\uD83D\uDEBB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    put_litter_in_its_place: {
      keywords: ["blue-square", "sign", "human", "info"],
      char: "\uD83D\uDEAE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cinema: {
      keywords: ["blue-square", "record", "film", "movie", "curtain", "stage", "theater"],
      char: "\uD83C\uDFA6",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    signal_strength: {
      keywords: ["blue-square", "reception", "phone", "internet", "connection", "wifi", "bluetooth", "bars"],
      char: "\uD83D\uDCF6",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    koko: {
      keywords: ["blue-square", "here", "katakana", "japanese", "destination"],
      char: "\uD83C\uDE01",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ng: {
      keywords: ["blue-square", "words", "shape", "icon"],
      char: "\uD83C\uDD96",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ok: {
      keywords: ["good", "agree", "yes", "blue-square"],
      char: "\uD83C\uDD97",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    up: {
      keywords: ["blue-square", "above", "high"],
      char: "\uD83C\uDD99",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    cool: {
      keywords: ["words", "blue-square"],
      char: "\uD83C\uDD92",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    new: {
      keywords: ["blue-square", "words", "start"],
      char: "\uD83C\uDD95",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    free: {
      keywords: ["blue-square", "words"],
      char: "\uD83C\uDD93",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    zero: {
      keywords: ["0", "numbers", "blue-square", "null"],
      char: "0\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    one: {
      keywords: ["blue-square", "numbers", "1"],
      char: "1\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    two: {
      keywords: ["numbers", "2", "prime", "blue-square"],
      char: "2\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    three: {
      keywords: ["3", "numbers", "prime", "blue-square"],
      char: "3\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    four: {
      keywords: ["4", "numbers", "blue-square"],
      char: "4\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    five: {
      keywords: ["5", "numbers", "blue-square", "prime"],
      char: "5\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    six: {
      keywords: ["6", "numbers", "blue-square"],
      char: "6\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    seven: {
      keywords: ["7", "numbers", "blue-square", "prime"],
      char: "7\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eight: {
      keywords: ["8", "blue-square", "numbers"],
      char: "8\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    nine: {
      keywords: ["blue-square", "numbers", "9"],
      char: "9\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    keycap_ten: {
      keywords: ["numbers", "10", "blue-square"],
      char: "\uD83D\uDD1F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    asterisk: {
      keywords: ["star", "keycap"],
      char: "*\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    "1234": {
      keywords: ["numbers", "blue-square"],
      char: "\uD83D\uDD22",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    eject_button: {
      keywords: ["blue-square"],
      char: "\u23CF\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_forward: {
      keywords: ["blue-square", "right", "direction", "play"],
      char: "\u25B6\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    pause_button: {
      keywords: ["pause", "blue-square"],
      char: "\u23F8",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    next_track_button: {
      keywords: ["forward", "next", "blue-square"],
      char: "\u23ED",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    stop_button: {
      keywords: ["blue-square"],
      char: "\u23F9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    record_button: {
      keywords: ["blue-square"],
      char: "\u23FA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    play_or_pause_button: {
      keywords: ["blue-square", "play", "pause"],
      char: "\u23EF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    previous_track_button: {
      keywords: ["backward"],
      char: "\u23EE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    fast_forward: {
      keywords: ["blue-square", "play", "speed", "continue"],
      char: "\u23E9",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    rewind: {
      keywords: ["play", "blue-square"],
      char: "\u23EA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    twisted_rightwards_arrows: {
      keywords: ["blue-square", "shuffle", "music", "random"],
      char: "\uD83D\uDD00",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    repeat: {
      keywords: ["loop", "record"],
      char: "\uD83D\uDD01",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    repeat_one: {
      keywords: ["blue-square", "loop"],
      char: "\uD83D\uDD02",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_backward: {
      keywords: ["blue-square", "left", "direction"],
      char: "\u25C0\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_up_small: {
      keywords: ["blue-square", "triangle", "direction", "point", "forward", "top"],
      char: "\uD83D\uDD3C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_down_small: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\uD83D\uDD3D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_double_up: {
      keywords: ["blue-square", "direction", "top"],
      char: "\u23EB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_double_down: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\u23EC",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_right: {
      keywords: ["blue-square", "next"],
      char: "\u27A1\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_left: {
      keywords: ["blue-square", "previous", "back"],
      char: "\u2B05\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_up: {
      keywords: ["blue-square", "continue", "top", "direction"],
      char: "\u2B06\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_down: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\u2B07\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_upper_right: {
      keywords: ["blue-square", "point", "direction", "diagonal", "northeast"],
      char: "\u2197\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_lower_right: {
      keywords: ["blue-square", "direction", "diagonal", "southeast"],
      char: "\u2198\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_lower_left: {
      keywords: ["blue-square", "direction", "diagonal", "southwest"],
      char: "\u2199\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_upper_left: {
      keywords: ["blue-square", "point", "direction", "diagonal", "northwest"],
      char: "\u2196\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_up_down: {
      keywords: ["blue-square", "direction", "way", "vertical"],
      char: "\u2195\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    left_right_arrow: {
      keywords: ["shape", "direction", "horizontal", "sideways"],
      char: "\u2194\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrows_counterclockwise: {
      keywords: ["blue-square", "sync", "cycle"],
      char: "\uD83D\uDD04",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_right_hook: {
      keywords: ["blue-square", "return", "rotate", "direction"],
      char: "\u21AA\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    leftwards_arrow_with_hook: {
      keywords: ["back", "return", "blue-square", "undo", "enter"],
      char: "\u21A9\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_heading_up: {
      keywords: ["blue-square", "direction", "top"],
      char: "\u2934\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrow_heading_down: {
      keywords: ["blue-square", "direction", "bottom"],
      char: "\u2935\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    hash: {
      keywords: ["symbol", "blue-square", "twitter"],
      char: "#\uFE0F\u20E3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    information_source: {
      keywords: ["blue-square", "alphabet", "letter"],
      char: "\u2139\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    abc: {
      keywords: ["blue-square", "alphabet"],
      char: "\uD83D\uDD24",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    abcd: {
      keywords: ["blue-square", "alphabet"],
      char: "\uD83D\uDD21",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    capital_abcd: {
      keywords: ["alphabet", "words", "blue-square"],
      char: "\uD83D\uDD20",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    symbols: {
      keywords: ["blue-square", "music", "note", "ampersand", "percent", "glyphs", "characters"],
      char: "\uD83D\uDD23",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    musical_note: {
      keywords: ["score", "tone", "sound"],
      char: "\uD83C\uDFB5",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    notes: {
      keywords: ["music", "score"],
      char: "\uD83C\uDFB6",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    wavy_dash: {
      keywords: ["draw", "line", "moustache", "mustache", "squiggle", "scribble"],
      char: "\u3030\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    curly_loop: {
      keywords: ["scribble", "draw", "shape", "squiggle"],
      char: "\u27B0",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_check_mark: {
      keywords: ["ok", "nike", "answer", "yes", "tick"],
      char: "\u2714\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    arrows_clockwise: {
      keywords: ["sync", "cycle", "round", "repeat"],
      char: "\uD83D\uDD03",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_plus_sign: {
      keywords: ["math", "calculation", "addition", "more", "increase"],
      char: "\u2795",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_minus_sign: {
      keywords: ["math", "calculation", "subtract", "less"],
      char: "\u2796",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_division_sign: {
      keywords: ["divide", "math", "calculation"],
      char: "\u2797",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_multiplication_x: {
      keywords: ["math", "calculation"],
      char: "\u2716\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    infinity: {
      keywords: ["forever"],
      char: "\u267E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    heavy_dollar_sign: {
      keywords: ["money", "sales", "payment", "currency", "buck"],
      char: "\uD83D\uDCB2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    currency_exchange: {
      keywords: ["money", "sales", "dollar", "travel"],
      char: "\uD83D\uDCB1",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    copyright: {
      keywords: ["ip", "license", "circle", "law", "legal"],
      char: "\xA9\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    registered: {
      keywords: ["alphabet", "circle"],
      char: "\xAE\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    tm: {
      keywords: ["trademark", "brand", "law", "legal"],
      char: "\u2122\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    end: {
      keywords: ["words", "arrow"],
      char: "\uD83D\uDD1A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    back: {
      keywords: ["arrow", "words", "return"],
      char: "\uD83D\uDD19",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    on: {
      keywords: ["arrow", "words"],
      char: "\uD83D\uDD1B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    top: {
      keywords: ["words", "blue-square"],
      char: "\uD83D\uDD1D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    soon: {
      keywords: ["arrow", "words"],
      char: "\uD83D\uDD1C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    ballot_box_with_check: {
      keywords: ["ok", "agree", "confirm", "black-square", "vote", "election", "yes", "tick"],
      char: "\u2611\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    radio_button: {
      keywords: ["input", "old", "music", "circle"],
      char: "\uD83D\uDD18",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_circle: {
      keywords: ["shape", "round"],
      char: "\u26AA",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_circle: {
      keywords: ["shape", "button", "round"],
      char: "\u26AB",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    red_circle: {
      keywords: ["shape", "error", "danger"],
      char: "\uD83D\uDD34",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    large_blue_circle: {
      keywords: ["shape", "icon", "button"],
      char: "\uD83D\uDD35",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_orange_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD38",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_blue_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD39",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    large_orange_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD36",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    large_blue_diamond: {
      keywords: ["shape", "jewel", "gem"],
      char: "\uD83D\uDD37",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_red_triangle: {
      keywords: ["shape", "direction", "up", "top"],
      char: "\uD83D\uDD3A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_small_square: {
      keywords: ["shape", "icon"],
      char: "\u25AA\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_small_square: {
      keywords: ["shape", "icon"],
      char: "\u25AB\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_large_square: {
      keywords: ["shape", "icon", "button"],
      char: "\u2B1B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_large_square: {
      keywords: ["shape", "icon", "stone", "button"],
      char: "\u2B1C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    small_red_triangle_down: {
      keywords: ["shape", "direction", "bottom"],
      char: "\uD83D\uDD3B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_medium_square: {
      keywords: ["shape", "button", "icon"],
      char: "\u25FC\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_medium_square: {
      keywords: ["shape", "stone", "icon"],
      char: "\u25FB\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_medium_small_square: {
      keywords: ["icon", "shape", "button"],
      char: "\u25FE",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_medium_small_square: {
      keywords: ["shape", "stone", "icon", "button"],
      char: "\u25FD",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_square_button: {
      keywords: ["shape", "input", "frame"],
      char: "\uD83D\uDD32",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    white_square_button: {
      keywords: ["shape", "input"],
      char: "\uD83D\uDD33",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    speaker: {
      keywords: ["sound", "volume", "silence", "broadcast"],
      char: "\uD83D\uDD08",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    sound: {
      keywords: ["volume", "speaker", "broadcast"],
      char: "\uD83D\uDD09",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    loud_sound: {
      keywords: ["volume", "noise", "noisy", "speaker", "broadcast"],
      char: "\uD83D\uDD0A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mute: {
      keywords: ["sound", "volume", "silence", "quiet"],
      char: "\uD83D\uDD07",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mega: {
      keywords: ["sound", "speaker", "volume"],
      char: "\uD83D\uDCE3",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    loudspeaker: {
      keywords: ["volume", "sound"],
      char: "\uD83D\uDCE2",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    bell: {
      keywords: ["sound", "notification", "christmas", "xmas", "chime"],
      char: "\uD83D\uDD14",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    no_bell: {
      keywords: ["sound", "volume", "mute", "quiet", "silent"],
      char: "\uD83D\uDD15",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    black_joker: {
      keywords: ["poker", "cards", "game", "play", "magic"],
      char: "\uD83C\uDCCF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    mahjong: {
      keywords: ["game", "play", "chinese", "kanji"],
      char: "\uD83C\uDC04",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    spades: {
      keywords: ["poker", "cards", "suits", "magic"],
      char: "\u2660\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clubs: {
      keywords: ["poker", "cards", "magic", "suits"],
      char: "\u2663\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    hearts: {
      keywords: ["poker", "cards", "magic", "suits"],
      char: "\u2665\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    diamonds: {
      keywords: ["poker", "cards", "magic", "suits"],
      char: "\u2666\uFE0F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    flower_playing_cards: {
      keywords: ["game", "sunset", "red"],
      char: "\uD83C\uDFB4",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    thought_balloon: {
      keywords: ["bubble", "cloud", "speech", "thinking", "dream"],
      char: "\uD83D\uDCAD",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    right_anger_bubble: {
      keywords: ["caption", "speech", "thinking", "mad"],
      char: "\uD83D\uDDEF",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    speech_balloon: {
      keywords: ["bubble", "words", "message", "talk", "chatting"],
      char: "\uD83D\uDCAC",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    left_speech_bubble: {
      keywords: ["words", "message", "talk", "chatting"],
      char: "\uD83D\uDDE8",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD50",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock2: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD51",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock3: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD52",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock4: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD53",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock5: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD54",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock6: {
      keywords: ["time", "late", "early", "schedule", "dawn", "dusk"],
      char: "\uD83D\uDD55",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock7: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD56",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock8: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD57",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock9: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD58",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock10: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD59",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock11: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5A",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock12: {
      keywords: ["time", "noon", "midnight", "midday", "late", "early", "schedule"],
      char: "\uD83D\uDD5B",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock130: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5C",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock230: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5D",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock330: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5E",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock430: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD5F",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock530: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD60",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock630: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD61",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock730: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD62",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock830: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD63",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock930: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD64",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1030: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD65",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1130: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD66",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    clock1230: {
      keywords: ["time", "late", "early", "schedule"],
      char: "\uD83D\uDD67",
      fitzpatrick_scale: false,
      category: "symbols"
    },
    afghanistan: {
      keywords: ["af", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    aland_islands: {
      keywords: ["\xC5land", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    albania: {
      keywords: ["al", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    algeria: {
      keywords: ["dz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    american_samoa: {
      keywords: ["american", "ws", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    andorra: {
      keywords: ["ad", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    angola: {
      keywords: ["ao", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    anguilla: {
      keywords: ["ai", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    antarctica: {
      keywords: ["aq", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    antigua_barbuda: {
      keywords: ["antigua", "barbuda", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    argentina: {
      keywords: ["ar", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    armenia: {
      keywords: ["am", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    aruba: {
      keywords: ["aw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    australia: {
      keywords: ["au", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    austria: {
      keywords: ["at", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    azerbaijan: {
      keywords: ["az", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bahamas: {
      keywords: ["bs", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bahrain: {
      keywords: ["bh", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bangladesh: {
      keywords: ["bd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    barbados: {
      keywords: ["bb", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    belarus: {
      keywords: ["by", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    belgium: {
      keywords: ["be", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    belize: {
      keywords: ["bz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    benin: {
      keywords: ["bj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bermuda: {
      keywords: ["bm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bhutan: {
      keywords: ["bt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bolivia: {
      keywords: ["bo", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    caribbean_netherlands: {
      keywords: ["bonaire", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bosnia_herzegovina: {
      keywords: ["bosnia", "herzegovina", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    botswana: {
      keywords: ["bw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    brazil: {
      keywords: ["br", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    british_indian_ocean_territory: {
      keywords: ["british", "indian", "ocean", "territory", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    british_virgin_islands: {
      keywords: ["british", "virgin", "islands", "bvi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    brunei: {
      keywords: ["bn", "darussalam", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    bulgaria: {
      keywords: ["bg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    burkina_faso: {
      keywords: ["burkina", "faso", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    burundi: {
      keywords: ["bi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cape_verde: {
      keywords: ["cabo", "verde", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cambodia: {
      keywords: ["kh", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cameroon: {
      keywords: ["cm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    canada: {
      keywords: ["ca", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    canary_islands: {
      keywords: ["canary", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cayman_islands: {
      keywords: ["cayman", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    central_african_republic: {
      keywords: ["central", "african", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    chad: {
      keywords: ["td", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    chile: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cn: {
      keywords: ["china", "chinese", "prc", "flag", "country", "nation", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    christmas_island: {
      keywords: ["christmas", "island", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cocos_islands: {
      keywords: ["cocos", "keeling", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    colombia: {
      keywords: ["co", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    comoros: {
      keywords: ["km", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    congo_brazzaville: {
      keywords: ["congo", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    congo_kinshasa: {
      keywords: ["congo", "democratic", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cook_islands: {
      keywords: ["cook", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    costa_rica: {
      keywords: ["costa", "rica", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    croatia: {
      keywords: ["hr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cuba: {
      keywords: ["cu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    curacao: {
      keywords: ["cura\xE7ao", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cyprus: {
      keywords: ["cy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    czech_republic: {
      keywords: ["cz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    denmark: {
      keywords: ["dk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    djibouti: {
      keywords: ["dj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    dominica: {
      keywords: ["dm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    dominican_republic: {
      keywords: ["dominican", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ecuador: {
      keywords: ["ec", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    egypt: {
      keywords: ["eg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    el_salvador: {
      keywords: ["el", "salvador", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    equatorial_guinea: {
      keywords: ["equatorial", "gn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    eritrea: {
      keywords: ["er", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    estonia: {
      keywords: ["ee", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ethiopia: {
      keywords: ["et", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    eu: {
      keywords: ["european", "union", "flag", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    falkland_islands: {
      keywords: ["falkland", "islands", "malvinas", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    faroe_islands: {
      keywords: ["faroe", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    fiji: {
      keywords: ["fj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    finland: {
      keywords: ["fi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    fr: {
      keywords: ["banner", "flag", "nation", "france", "french", "country"],
      char: "\uD83C\uDDEB\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    french_guiana: {
      keywords: ["french", "guiana", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    french_polynesia: {
      keywords: ["french", "polynesia", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    french_southern_territories: {
      keywords: ["french", "southern", "territories", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    gabon: {
      keywords: ["ga", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    gambia: {
      keywords: ["gm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    georgia: {
      keywords: ["ge", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    de: {
      keywords: ["german", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDE9\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ghana: {
      keywords: ["gh", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    gibraltar: {
      keywords: ["gi", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    greece: {
      keywords: ["gr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    greenland: {
      keywords: ["gl", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    grenada: {
      keywords: ["gd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guadeloupe: {
      keywords: ["gp", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guam: {
      keywords: ["gu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guatemala: {
      keywords: ["gt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guernsey: {
      keywords: ["gg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guinea: {
      keywords: ["gn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guinea_bissau: {
      keywords: ["gw", "bissau", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    guyana: {
      keywords: ["gy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    haiti: {
      keywords: ["ht", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    honduras: {
      keywords: ["hn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    hong_kong: {
      keywords: ["hong", "kong", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    hungary: {
      keywords: ["hu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDED\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    iceland: {
      keywords: ["is", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    india: {
      keywords: ["in", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    indonesia: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    iran: {
      keywords: ["iran,", "islamic", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    iraq: {
      keywords: ["iq", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ireland: {
      keywords: ["ie", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    isle_of_man: {
      keywords: ["isle", "man", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    israel: {
      keywords: ["il", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    it: {
      keywords: ["italy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEE\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    cote_divoire: {
      keywords: ["ivory", "coast", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jamaica: {
      keywords: ["jm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jp: {
      keywords: ["japanese", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jersey: {
      keywords: ["je", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    jordan: {
      keywords: ["jo", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEF\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kazakhstan: {
      keywords: ["kz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kenya: {
      keywords: ["ke", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kiribati: {
      keywords: ["ki", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kosovo: {
      keywords: ["xk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFD\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kuwait: {
      keywords: ["kw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kyrgyzstan: {
      keywords: ["kg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    laos: {
      keywords: ["lao", "democratic", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    latvia: {
      keywords: ["lv", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    lebanon: {
      keywords: ["lb", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    lesotho: {
      keywords: ["ls", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    liberia: {
      keywords: ["lr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    libya: {
      keywords: ["ly", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    liechtenstein: {
      keywords: ["li", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    lithuania: {
      keywords: ["lt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    luxembourg: {
      keywords: ["lu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    macau: {
      keywords: ["macao", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    macedonia: {
      keywords: ["macedonia,", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    madagascar: {
      keywords: ["mg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    malawi: {
      keywords: ["mw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    malaysia: {
      keywords: ["my", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    maldives: {
      keywords: ["mv", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mali: {
      keywords: ["ml", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    malta: {
      keywords: ["mt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    marshall_islands: {
      keywords: ["marshall", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    martinique: {
      keywords: ["mq", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mauritania: {
      keywords: ["mr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mauritius: {
      keywords: ["mu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mayotte: {
      keywords: ["yt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFE\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mexico: {
      keywords: ["mx", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    micronesia: {
      keywords: ["micronesia,", "federated", "states", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEB\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    moldova: {
      keywords: ["moldova,", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    monaco: {
      keywords: ["mc", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mongolia: {
      keywords: ["mn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    montenegro: {
      keywords: ["me", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    montserrat: {
      keywords: ["ms", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    morocco: {
      keywords: ["ma", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    mozambique: {
      keywords: ["mz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    myanmar: {
      keywords: ["mm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    namibia: {
      keywords: ["na", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nauru: {
      keywords: ["nr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nepal: {
      keywords: ["np", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    netherlands: {
      keywords: ["nl", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    new_caledonia: {
      keywords: ["new", "caledonia", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    new_zealand: {
      keywords: ["new", "zealand", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nicaragua: {
      keywords: ["ni", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    niger: {
      keywords: ["ne", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    nigeria: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    niue: {
      keywords: ["nu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    norfolk_island: {
      keywords: ["norfolk", "island", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    northern_mariana_islands: {
      keywords: ["northern", "mariana", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF2\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    north_korea: {
      keywords: ["north", "korea", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF5",
      fitzpatrick_scale: false,
      category: "flags"
    },
    norway: {
      keywords: ["no", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF3\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    oman: {
      keywords: ["om_symbol", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF4\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    pakistan: {
      keywords: ["pk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    palau: {
      keywords: ["pw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    palestinian_territories: {
      keywords: ["palestine", "palestinian", "territories", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    panama: {
      keywords: ["pa", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    papua_new_guinea: {
      keywords: ["papua", "new", "guinea", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    paraguay: {
      keywords: ["py", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    peru: {
      keywords: ["pe", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    philippines: {
      keywords: ["ph", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    pitcairn_islands: {
      keywords: ["pitcairn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    poland: {
      keywords: ["pl", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    portugal: {
      keywords: ["pt", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    puerto_rico: {
      keywords: ["puerto", "rico", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    qatar: {
      keywords: ["qa", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF6\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    reunion: {
      keywords: ["r\xE9union", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    romania: {
      keywords: ["ro", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ru: {
      keywords: ["russian", "federation", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    rwanda: {
      keywords: ["rw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_barthelemy: {
      keywords: ["saint", "barth\xE9lemy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE7\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_helena: {
      keywords: ["saint", "helena", "ascension", "tristan", "cunha", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_kitts_nevis: {
      keywords: ["saint", "kitts", "nevis", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_lucia: {
      keywords: ["saint", "lucia", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_pierre_miquelon: {
      keywords: ["saint", "pierre", "miquelon", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF5\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    st_vincent_grenadines: {
      keywords: ["saint", "vincent", "grenadines", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    samoa: {
      keywords: ["ws", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFC\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    san_marino: {
      keywords: ["san", "marino", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sao_tome_principe: {
      keywords: ["sao", "tome", "principe", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    saudi_arabia: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    senegal: {
      keywords: ["sn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    serbia: {
      keywords: ["rs", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF7\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    seychelles: {
      keywords: ["sc", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sierra_leone: {
      keywords: ["sierra", "leone", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    singapore: {
      keywords: ["sg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sint_maarten: {
      keywords: ["sint", "maarten", "dutch", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFD",
      fitzpatrick_scale: false,
      category: "flags"
    },
    slovakia: {
      keywords: ["sk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    slovenia: {
      keywords: ["si", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    solomon_islands: {
      keywords: ["solomon", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    somalia: {
      keywords: ["so", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    south_africa: {
      keywords: ["south", "africa", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFF\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    south_georgia_south_sandwich_islands: {
      keywords: ["south", "georgia", "sandwich", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEC\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    kr: {
      keywords: ["south", "korea", "nation", "flag", "country", "banner"],
      char: "\uD83C\uDDF0\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    south_sudan: {
      keywords: ["south", "sd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    es: {
      keywords: ["spain", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sri_lanka: {
      keywords: ["sri", "lanka", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF1\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sudan: {
      keywords: ["sd", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDE9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    suriname: {
      keywords: ["sr", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    swaziland: {
      keywords: ["sz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    sweden: {
      keywords: ["se", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    switzerland: {
      keywords: ["ch", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE8\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    syria: {
      keywords: ["syrian", "arab", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF8\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    taiwan: {
      keywords: ["tw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tajikistan: {
      keywords: ["tj", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDEF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tanzania: {
      keywords: ["tanzania,", "united", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    thailand: {
      keywords: ["th", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    timor_leste: {
      keywords: ["timor", "leste", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF1",
      fitzpatrick_scale: false,
      category: "flags"
    },
    togo: {
      keywords: ["tg", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tokelau: {
      keywords: ["tk", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF0",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tonga: {
      keywords: ["to", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF4",
      fitzpatrick_scale: false,
      category: "flags"
    },
    trinidad_tobago: {
      keywords: ["trinidad", "tobago", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF9",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tunisia: {
      keywords: ["tn", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tr: {
      keywords: ["turkey", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    turkmenistan: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    turks_caicos_islands: {
      keywords: ["turks", "caicos", "islands", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDE8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    tuvalu: {
      keywords: ["flag", "nation", "country", "banner"],
      char: "\uD83C\uDDF9\uD83C\uDDFB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uganda: {
      keywords: ["ug", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDEC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    ukraine: {
      keywords: ["ua", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    united_arab_emirates: {
      keywords: ["united", "arab", "emirates", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDE6\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uk: {
      keywords: ["united", "kingdom", "great", "britain", "northern", "ireland", "flag", "nation", "country", "banner", "british", "UK", "english", "england", "union jack"],
      char: "\uD83C\uDDEC\uD83C\uDDE7",
      fitzpatrick_scale: false,
      category: "flags"
    },
    england: {
      keywords: ["flag", "english"],
      char: "\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67\uDB40\uDC7F",
      fitzpatrick_scale: false,
      category: "flags"
    },
    scotland: {
      keywords: ["flag", "scottish"],
      char: "\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74\uDB40\uDC7F",
      fitzpatrick_scale: false,
      category: "flags"
    },
    wales: {
      keywords: ["flag", "welsh"],
      char: "\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73\uDB40\uDC7F",
      fitzpatrick_scale: false,
      category: "flags"
    },
    us: {
      keywords: ["united", "states", "america", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDF8",
      fitzpatrick_scale: false,
      category: "flags"
    },
    us_virgin_islands: {
      keywords: ["virgin", "islands", "us", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDEE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uruguay: {
      keywords: ["uy", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDFE",
      fitzpatrick_scale: false,
      category: "flags"
    },
    uzbekistan: {
      keywords: ["uz", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDFF",
      fitzpatrick_scale: false,
      category: "flags"
    },
    vanuatu: {
      keywords: ["vu", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDFA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    vatican_city: {
      keywords: ["vatican", "city", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDE6",
      fitzpatrick_scale: false,
      category: "flags"
    },
    venezuela: {
      keywords: ["ve", "bolivarian", "republic", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    vietnam: {
      keywords: ["viet", "nam", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFB\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    wallis_futuna: {
      keywords: ["wallis", "futuna", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFC\uD83C\uDDEB",
      fitzpatrick_scale: false,
      category: "flags"
    },
    western_sahara: {
      keywords: ["western", "sahara", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDEA\uD83C\uDDED",
      fitzpatrick_scale: false,
      category: "flags"
    },
    yemen: {
      keywords: ["ye", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFE\uD83C\uDDEA",
      fitzpatrick_scale: false,
      category: "flags"
    },
    zambia: {
      keywords: ["zm", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFF\uD83C\uDDF2",
      fitzpatrick_scale: false,
      category: "flags"
    },
    zimbabwe: {
      keywords: ["zw", "flag", "nation", "country", "banner"],
      char: "\uD83C\uDDFF\uD83C\uDDFC",
      fitzpatrick_scale: false,
      category: "flags"
    },
    united_nations: {
      keywords: ["un", "flag", "banner"],
      char: "\uD83C\uDDFA\uD83C\uDDF3",
      fitzpatrick_scale: false,
      category: "flags"
    },
    pirate_flag: {
      keywords: ["skull", "crossbones", "flag", "banner"],
      char: "\uD83C\uDFF4\u200D\u2620\uFE0F",
      fitzpatrick_scale: false,
      category: "flags"
    }
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/emojilib/ordered.json
var require_ordered = __commonJS((exports, module) => {
  module.exports = [
    "grinning",
    "smiley",
    "smile",
    "grin",
    "laughing",
    "sweat_smile",
    "joy",
    "rofl",
    "relaxed",
    "blush",
    "innocent",
    "slightly_smiling_face",
    "upside_down_face",
    "wink",
    "relieved",
    "heart_eyes",
    "smiling_face_with_three_hearts",
    "kissing_heart",
    "kissing",
    "kissing_smiling_eyes",
    "kissing_closed_eyes",
    "yum",
    "stuck_out_tongue",
    "stuck_out_tongue_closed_eyes",
    "stuck_out_tongue_winking_eye",
    "zany",
    "raised_eyebrow",
    "monocle",
    "nerd_face",
    "sunglasses",
    "star_struck",
    "partying",
    "smirk",
    "unamused",
    "disappointed",
    "pensive",
    "worried",
    "confused",
    "slightly_frowning_face",
    "frowning_face",
    "persevere",
    "confounded",
    "tired_face",
    "weary",
    "pleading",
    "cry",
    "sob",
    "triumph",
    "angry",
    "rage",
    "symbols_over_mouth",
    "exploding_head",
    "flushed",
    "hot",
    "cold",
    "scream",
    "fearful",
    "cold_sweat",
    "disappointed_relieved",
    "sweat",
    "hugs",
    "thinking",
    "hand_over_mouth",
    "shushing",
    "lying_face",
    "no_mouth",
    "neutral_face",
    "expressionless",
    "grimacing",
    "roll_eyes",
    "hushed",
    "frowning",
    "anguished",
    "open_mouth",
    "astonished",
    "sleeping",
    "drooling_face",
    "sleepy",
    "dizzy_face",
    "zipper_mouth_face",
    "woozy",
    "nauseated_face",
    "vomiting",
    "sneezing_face",
    "mask",
    "face_with_thermometer",
    "face_with_head_bandage",
    "money_mouth_face",
    "cowboy_hat_face",
    "smiling_imp",
    "imp",
    "japanese_ogre",
    "japanese_goblin",
    "clown_face",
    "poop",
    "ghost",
    "skull",
    "skull_and_crossbones",
    "alien",
    "space_invader",
    "robot",
    "jack_o_lantern",
    "smiley_cat",
    "smile_cat",
    "joy_cat",
    "heart_eyes_cat",
    "smirk_cat",
    "kissing_cat",
    "scream_cat",
    "crying_cat_face",
    "pouting_cat",
    "palms_up",
    "open_hands",
    "raised_hands",
    "clap",
    "handshake",
    "+1",
    "-1",
    "facepunch",
    "fist",
    "fist_left",
    "fist_right",
    "crossed_fingers",
    "v",
    "love_you",
    "metal",
    "ok_hand",
    "point_left",
    "point_right",
    "point_up",
    "point_down",
    "point_up_2",
    "raised_hand",
    "raised_back_of_hand",
    "raised_hand_with_fingers_splayed",
    "vulcan_salute",
    "wave",
    "call_me_hand",
    "muscle",
    "fu",
    "writing_hand",
    "pray",
    "foot",
    "leg",
    "ring",
    "lipstick",
    "kiss",
    "lips",
    "tooth",
    "tongue",
    "ear",
    "nose",
    "footprints",
    "eye",
    "eyes",
    "brain",
    "speaking_head",
    "bust_in_silhouette",
    "busts_in_silhouette",
    "baby",
    "girl",
    "child",
    "boy",
    "woman",
    "adult",
    "man",
    "blonde_woman",
    "blonde_man",
    "bearded_person",
    "older_woman",
    "older_adult",
    "older_man",
    "man_with_gua_pi_mao",
    "woman_with_headscarf",
    "woman_with_turban",
    "man_with_turban",
    "policewoman",
    "policeman",
    "construction_worker_woman",
    "construction_worker_man",
    "guardswoman",
    "guardsman",
    "female_detective",
    "male_detective",
    "woman_health_worker",
    "man_health_worker",
    "woman_farmer",
    "man_farmer",
    "woman_cook",
    "man_cook",
    "woman_student",
    "man_student",
    "woman_singer",
    "man_singer",
    "woman_teacher",
    "man_teacher",
    "woman_factory_worker",
    "man_factory_worker",
    "woman_technologist",
    "man_technologist",
    "woman_office_worker",
    "man_office_worker",
    "woman_mechanic",
    "man_mechanic",
    "woman_scientist",
    "man_scientist",
    "woman_artist",
    "man_artist",
    "woman_firefighter",
    "man_firefighter",
    "woman_pilot",
    "man_pilot",
    "woman_astronaut",
    "man_astronaut",
    "woman_judge",
    "man_judge",
    "bride_with_veil",
    "man_in_tuxedo",
    "princess",
    "prince",
    "woman_superhero",
    "man_superhero",
    "woman_supervillain",
    "man_supervillain",
    "mrs_claus",
    "santa",
    "sorceress",
    "wizard",
    "woman_elf",
    "man_elf",
    "woman_vampire",
    "man_vampire",
    "woman_zombie",
    "man_zombie",
    "woman_genie",
    "man_genie",
    "mermaid",
    "merman",
    "woman_fairy",
    "man_fairy",
    "angel",
    "pregnant_woman",
    "breastfeeding",
    "bowing_woman",
    "bowing_man",
    "tipping_hand_woman",
    "tipping_hand_man",
    "no_good_woman",
    "no_good_man",
    "ok_woman",
    "ok_man",
    "raising_hand_woman",
    "raising_hand_man",
    "woman_facepalming",
    "man_facepalming",
    "woman_shrugging",
    "man_shrugging",
    "pouting_woman",
    "pouting_man",
    "frowning_woman",
    "frowning_man",
    "haircut_woman",
    "haircut_man",
    "massage_woman",
    "massage_man",
    "woman_in_steamy_room",
    "man_in_steamy_room",
    "nail_care",
    "selfie",
    "dancer",
    "man_dancing",
    "dancing_women",
    "dancing_men",
    "business_suit_levitating",
    "walking_woman",
    "walking_man",
    "running_woman",
    "running_man",
    "couple",
    "two_women_holding_hands",
    "two_men_holding_hands",
    "couple_with_heart_woman_man",
    "couple_with_heart_woman_woman",
    "couple_with_heart_man_man",
    "couplekiss_man_woman",
    "couplekiss_woman_woman",
    "couplekiss_man_man",
    "family_man_woman_boy",
    "family_man_woman_girl",
    "family_man_woman_girl_boy",
    "family_man_woman_boy_boy",
    "family_man_woman_girl_girl",
    "family_woman_woman_boy",
    "family_woman_woman_girl",
    "family_woman_woman_girl_boy",
    "family_woman_woman_boy_boy",
    "family_woman_woman_girl_girl",
    "family_man_man_boy",
    "family_man_man_girl",
    "family_man_man_girl_boy",
    "family_man_man_boy_boy",
    "family_man_man_girl_girl",
    "family_woman_boy",
    "family_woman_girl",
    "family_woman_girl_boy",
    "family_woman_boy_boy",
    "family_woman_girl_girl",
    "family_man_boy",
    "family_man_girl",
    "family_man_girl_boy",
    "family_man_boy_boy",
    "family_man_girl_girl",
    "yarn",
    "thread",
    "coat",
    "labcoat",
    "womans_clothes",
    "tshirt",
    "jeans",
    "necktie",
    "dress",
    "bikini",
    "kimono",
    "flat_shoe",
    "high_heel",
    "sandal",
    "boot",
    "mans_shoe",
    "athletic_shoe",
    "hiking_boot",
    "socks",
    "gloves",
    "scarf",
    "tophat",
    "billed_hat",
    "womans_hat",
    "mortar_board",
    "rescue_worker_helmet",
    "crown",
    "pouch",
    "purse",
    "handbag",
    "briefcase",
    "school_satchel",
    "luggage",
    "eyeglasses",
    "dark_sunglasses",
    "goggles",
    "closed_umbrella",
    "dog",
    "cat",
    "mouse",
    "hamster",
    "rabbit",
    "fox_face",
    "bear",
    "panda_face",
    "koala",
    "tiger",
    "lion",
    "cow",
    "pig",
    "pig_nose",
    "frog",
    "monkey_face",
    "see_no_evil",
    "hear_no_evil",
    "speak_no_evil",
    "monkey",
    "chicken",
    "penguin",
    "bird",
    "baby_chick",
    "hatching_chick",
    "hatched_chick",
    "duck",
    "eagle",
    "owl",
    "bat",
    "wolf",
    "boar",
    "horse",
    "unicorn",
    "honeybee",
    "bug",
    "butterfly",
    "snail",
    "shell",
    "beetle",
    "ant",
    "mosquito",
    "grasshopper",
    "spider",
    "spider_web",
    "scorpion",
    "turtle",
    "snake",
    "lizard",
    "t-rex",
    "sauropod",
    "octopus",
    "squid",
    "shrimp",
    "lobster",
    "crab",
    "blowfish",
    "tropical_fish",
    "fish",
    "dolphin",
    "whale",
    "whale2",
    "shark",
    "crocodile",
    "tiger2",
    "leopard",
    "zebra",
    "gorilla",
    "elephant",
    "hippopotamus",
    "rhinoceros",
    "dromedary_camel",
    "giraffe",
    "kangaroo",
    "camel",
    "water_buffalo",
    "ox",
    "cow2",
    "racehorse",
    "pig2",
    "ram",
    "sheep",
    "llama",
    "goat",
    "deer",
    "dog2",
    "poodle",
    "cat2",
    "rooster",
    "turkey",
    "peacock",
    "parrot",
    "swan",
    "dove",
    "rabbit2",
    "raccoon",
    "badger",
    "rat",
    "mouse2",
    "chipmunk",
    "hedgehog",
    "paw_prints",
    "dragon",
    "dragon_face",
    "cactus",
    "christmas_tree",
    "evergreen_tree",
    "deciduous_tree",
    "palm_tree",
    "seedling",
    "herb",
    "shamrock",
    "four_leaf_clover",
    "bamboo",
    "tanabata_tree",
    "leaves",
    "fallen_leaf",
    "maple_leaf",
    "ear_of_rice",
    "hibiscus",
    "sunflower",
    "rose",
    "wilted_flower",
    "tulip",
    "blossom",
    "cherry_blossom",
    "bouquet",
    "mushroom",
    "earth_americas",
    "earth_africa",
    "earth_asia",
    "full_moon",
    "waning_gibbous_moon",
    "last_quarter_moon",
    "waning_crescent_moon",
    "new_moon",
    "waxing_crescent_moon",
    "first_quarter_moon",
    "waxing_gibbous_moon",
    "new_moon_with_face",
    "full_moon_with_face",
    "first_quarter_moon_with_face",
    "last_quarter_moon_with_face",
    "sun_with_face",
    "crescent_moon",
    "star",
    "star2",
    "dizzy",
    "sparkles",
    "comet",
    "sunny",
    "sun_behind_small_cloud",
    "partly_sunny",
    "sun_behind_large_cloud",
    "sun_behind_rain_cloud",
    "cloud",
    "cloud_with_rain",
    "cloud_with_lightning_and_rain",
    "cloud_with_lightning",
    "zap",
    "fire",
    "boom",
    "snowflake",
    "cloud_with_snow",
    "snowman",
    "snowman_with_snow",
    "wind_face",
    "dash",
    "tornado",
    "fog",
    "open_umbrella",
    "umbrella",
    "droplet",
    "sweat_drops",
    "ocean",
    "green_apple",
    "apple",
    "pear",
    "tangerine",
    "lemon",
    "banana",
    "watermelon",
    "grapes",
    "strawberry",
    "melon",
    "cherries",
    "peach",
    "mango",
    "pineapple",
    "coconut",
    "kiwi_fruit",
    "tomato",
    "eggplant",
    "avocado",
    "broccoli",
    "leafy_greens",
    "cucumber",
    "hot_pepper",
    "corn",
    "carrot",
    "potato",
    "sweet_potato",
    "croissant",
    "bagel",
    "bread",
    "baguette_bread",
    "pretzel",
    "cheese",
    "egg",
    "fried_egg",
    "pancakes",
    "bacon",
    "steak",
    "poultry_leg",
    "meat_on_bone",
    "bone",
    "hotdog",
    "hamburger",
    "fries",
    "pizza",
    "sandwich",
    "stuffed_flatbread",
    "taco",
    "burrito",
    "green_salad",
    "shallow_pan_of_food",
    "canned_food",
    "spaghetti",
    "ramen",
    "stew",
    "curry",
    "sushi",
    "bento",
    "fried_shrimp",
    "rice_ball",
    "rice",
    "rice_cracker",
    "fish_cake",
    "fortune_cookie",
    "moon_cake",
    "oden",
    "dango",
    "shaved_ice",
    "ice_cream",
    "icecream",
    "pie",
    "cupcake",
    "cake",
    "birthday",
    "custard",
    "lollipop",
    "candy",
    "chocolate_bar",
    "popcorn",
    "doughnut",
    "dumpling",
    "cookie",
    "chestnut",
    "peanuts",
    "honey_pot",
    "milk_glass",
    "baby_bottle",
    "coffee",
    "tea",
    "cup_with_straw",
    "sake",
    "beer",
    "beers",
    "clinking_glasses",
    "wine_glass",
    "tumbler_glass",
    "cocktail",
    "tropical_drink",
    "champagne",
    "spoon",
    "fork_and_knife",
    "plate_with_cutlery",
    "bowl_with_spoon",
    "takeout_box",
    "chopsticks",
    "salt",
    "soccer",
    "basketball",
    "football",
    "baseball",
    "softball",
    "tennis",
    "volleyball",
    "rugby_football",
    "flying_disc",
    "8ball",
    "golf",
    "golfing_woman",
    "golfing_man",
    "ping_pong",
    "badminton",
    "goal_net",
    "ice_hockey",
    "field_hockey",
    "lacrosse",
    "cricket",
    "ski",
    "skier",
    "snowboarder",
    "person_fencing",
    "women_wrestling",
    "men_wrestling",
    "woman_cartwheeling",
    "man_cartwheeling",
    "woman_playing_handball",
    "man_playing_handball",
    "ice_skate",
    "curling_stone",
    "skateboard",
    "sled",
    "bow_and_arrow",
    "fishing_pole_and_fish",
    "boxing_glove",
    "martial_arts_uniform",
    "rowing_woman",
    "rowing_man",
    "climbing_woman",
    "climbing_man",
    "swimming_woman",
    "swimming_man",
    "woman_playing_water_polo",
    "man_playing_water_polo",
    "woman_in_lotus_position",
    "man_in_lotus_position",
    "surfing_woman",
    "surfing_man",
    "basketball_woman",
    "basketball_man",
    "weight_lifting_woman",
    "weight_lifting_man",
    "biking_woman",
    "biking_man",
    "mountain_biking_woman",
    "mountain_biking_man",
    "horse_racing",
    "trophy",
    "running_shirt_with_sash",
    "medal_sports",
    "medal_military",
    "1st_place_medal",
    "2nd_place_medal",
    "3rd_place_medal",
    "reminder_ribbon",
    "rosette",
    "ticket",
    "tickets",
    "performing_arts",
    "art",
    "circus_tent",
    "woman_juggling",
    "man_juggling",
    "microphone",
    "headphones",
    "musical_score",
    "musical_keyboard",
    "drum",
    "saxophone",
    "trumpet",
    "guitar",
    "violin",
    "clapper",
    "video_game",
    "dart",
    "game_die",
    "chess_pawn",
    "slot_machine",
    "jigsaw",
    "bowling",
    "red_car",
    "taxi",
    "blue_car",
    "bus",
    "trolleybus",
    "racing_car",
    "police_car",
    "ambulance",
    "fire_engine",
    "minibus",
    "truck",
    "articulated_lorry",
    "tractor",
    "kick_scooter",
    "motorcycle",
    "bike",
    "motor_scooter",
    "rotating_light",
    "oncoming_police_car",
    "oncoming_bus",
    "oncoming_automobile",
    "oncoming_taxi",
    "aerial_tramway",
    "mountain_cableway",
    "suspension_railway",
    "railway_car",
    "train",
    "monorail",
    "bullettrain_side",
    "bullettrain_front",
    "light_rail",
    "mountain_railway",
    "steam_locomotive",
    "train2",
    "metro",
    "tram",
    "station",
    "flying_saucer",
    "helicopter",
    "small_airplane",
    "airplane",
    "flight_departure",
    "flight_arrival",
    "sailboat",
    "motor_boat",
    "speedboat",
    "ferry",
    "passenger_ship",
    "rocket",
    "artificial_satellite",
    "seat",
    "canoe",
    "anchor",
    "construction",
    "fuelpump",
    "busstop",
    "vertical_traffic_light",
    "traffic_light",
    "ship",
    "ferris_wheel",
    "roller_coaster",
    "carousel_horse",
    "building_construction",
    "foggy",
    "tokyo_tower",
    "factory",
    "fountain",
    "rice_scene",
    "mountain",
    "mountain_snow",
    "mount_fuji",
    "volcano",
    "japan",
    "camping",
    "tent",
    "national_park",
    "motorway",
    "railway_track",
    "sunrise",
    "sunrise_over_mountains",
    "desert",
    "beach_umbrella",
    "desert_island",
    "city_sunrise",
    "city_sunset",
    "cityscape",
    "night_with_stars",
    "bridge_at_night",
    "milky_way",
    "stars",
    "sparkler",
    "fireworks",
    "rainbow",
    "houses",
    "european_castle",
    "japanese_castle",
    "stadium",
    "statue_of_liberty",
    "house",
    "house_with_garden",
    "derelict_house",
    "office",
    "department_store",
    "post_office",
    "european_post_office",
    "hospital",
    "bank",
    "hotel",
    "convenience_store",
    "school",
    "love_hotel",
    "wedding",
    "classical_building",
    "church",
    "mosque",
    "synagogue",
    "kaaba",
    "shinto_shrine",
    "watch",
    "iphone",
    "calling",
    "computer",
    "keyboard",
    "desktop_computer",
    "printer",
    "computer_mouse",
    "trackball",
    "joystick",
    "clamp",
    "minidisc",
    "floppy_disk",
    "cd",
    "dvd",
    "vhs",
    "camera",
    "camera_flash",
    "video_camera",
    "movie_camera",
    "film_projector",
    "film_strip",
    "telephone_receiver",
    "phone",
    "pager",
    "fax",
    "tv",
    "radio",
    "studio_microphone",
    "level_slider",
    "control_knobs",
    "compass",
    "stopwatch",
    "timer_clock",
    "alarm_clock",
    "mantelpiece_clock",
    "hourglass_flowing_sand",
    "hourglass",
    "satellite",
    "battery",
    "electric_plug",
    "bulb",
    "flashlight",
    "candle",
    "fire_extinguisher",
    "wastebasket",
    "oil_drum",
    "money_with_wings",
    "dollar",
    "yen",
    "euro",
    "pound",
    "moneybag",
    "credit_card",
    "gem",
    "balance_scale",
    "toolbox",
    "wrench",
    "hammer",
    "hammer_and_pick",
    "hammer_and_wrench",
    "pick",
    "nut_and_bolt",
    "gear",
    "brick",
    "chains",
    "magnet",
    "gun",
    "bomb",
    "firecracker",
    "hocho",
    "dagger",
    "crossed_swords",
    "shield",
    "smoking",
    "coffin",
    "funeral_urn",
    "amphora",
    "crystal_ball",
    "prayer_beads",
    "nazar_amulet",
    "barber",
    "alembic",
    "telescope",
    "microscope",
    "hole",
    "pill",
    "syringe",
    "dna",
    "microbe",
    "petri_dish",
    "test_tube",
    "thermometer",
    "broom",
    "basket",
    "toilet_paper",
    "label",
    "bookmark",
    "toilet",
    "shower",
    "bathtub",
    "bath",
    "soap",
    "sponge",
    "lotion_bottle",
    "key",
    "old_key",
    "couch_and_lamp",
    "sleeping_bed",
    "bed",
    "door",
    "bellhop_bell",
    "teddy_bear",
    "framed_picture",
    "world_map",
    "parasol_on_ground",
    "moyai",
    "shopping",
    "shopping_cart",
    "balloon",
    "flags",
    "ribbon",
    "gift",
    "confetti_ball",
    "tada",
    "dolls",
    "wind_chime",
    "crossed_flags",
    "izakaya_lantern",
    "red_envelope",
    "email",
    "envelope_with_arrow",
    "incoming_envelope",
    "e-mail",
    "love_letter",
    "postbox",
    "mailbox_closed",
    "mailbox",
    "mailbox_with_mail",
    "mailbox_with_no_mail",
    "package",
    "postal_horn",
    "inbox_tray",
    "outbox_tray",
    "scroll",
    "page_with_curl",
    "bookmark_tabs",
    "receipt",
    "bar_chart",
    "chart_with_upwards_trend",
    "chart_with_downwards_trend",
    "page_facing_up",
    "date",
    "calendar",
    "spiral_calendar",
    "card_index",
    "card_file_box",
    "ballot_box",
    "file_cabinet",
    "clipboard",
    "spiral_notepad",
    "file_folder",
    "open_file_folder",
    "card_index_dividers",
    "newspaper_roll",
    "newspaper",
    "notebook",
    "closed_book",
    "green_book",
    "blue_book",
    "orange_book",
    "notebook_with_decorative_cover",
    "ledger",
    "books",
    "open_book",
    "safety_pin",
    "link",
    "paperclip",
    "paperclips",
    "scissors",
    "triangular_ruler",
    "straight_ruler",
    "abacus",
    "pushpin",
    "round_pushpin",
    "closed_lock_with_key",
    "lock",
    "unlock",
    "lock_with_ink_pen",
    "pen",
    "fountain_pen",
    "black_nib",
    "memo",
    "pencil2",
    "crayon",
    "paintbrush",
    "mag",
    "mag_right",
    "heart",
    "orange_heart",
    "yellow_heart",
    "green_heart",
    "blue_heart",
    "purple_heart",
    "black_heart",
    "broken_heart",
    "heavy_heart_exclamation",
    "two_hearts",
    "revolving_hearts",
    "heartbeat",
    "heartpulse",
    "sparkling_heart",
    "cupid",
    "gift_heart",
    "heart_decoration",
    "peace_symbol",
    "latin_cross",
    "star_and_crescent",
    "om",
    "wheel_of_dharma",
    "star_of_david",
    "six_pointed_star",
    "menorah",
    "yin_yang",
    "orthodox_cross",
    "place_of_worship",
    "ophiuchus",
    "aries",
    "taurus",
    "gemini",
    "cancer",
    "leo",
    "virgo",
    "libra",
    "scorpius",
    "sagittarius",
    "capricorn",
    "aquarius",
    "pisces",
    "id",
    "atom_symbol",
    "u7a7a",
    "u5272",
    "radioactive",
    "biohazard",
    "mobile_phone_off",
    "vibration_mode",
    "u6709",
    "u7121",
    "u7533",
    "u55b6",
    "u6708",
    "eight_pointed_black_star",
    "vs",
    "accept",
    "white_flower",
    "ideograph_advantage",
    "secret",
    "congratulations",
    "u5408",
    "u6e80",
    "u7981",
    "a",
    "b",
    "ab",
    "cl",
    "o2",
    "sos",
    "no_entry",
    "name_badge",
    "no_entry_sign",
    "x",
    "o",
    "stop_sign",
    "anger",
    "hotsprings",
    "no_pedestrians",
    "do_not_litter",
    "no_bicycles",
    "non-potable_water",
    "underage",
    "no_mobile_phones",
    "exclamation",
    "grey_exclamation",
    "question",
    "grey_question",
    "bangbang",
    "interrobang",
    "100",
    "low_brightness",
    "high_brightness",
    "trident",
    "fleur_de_lis",
    "part_alternation_mark",
    "warning",
    "children_crossing",
    "beginner",
    "recycle",
    "u6307",
    "chart",
    "sparkle",
    "eight_spoked_asterisk",
    "negative_squared_cross_mark",
    "white_check_mark",
    "diamond_shape_with_a_dot_inside",
    "cyclone",
    "loop",
    "globe_with_meridians",
    "m",
    "atm",
    "zzz",
    "sa",
    "passport_control",
    "customs",
    "baggage_claim",
    "left_luggage",
    "wheelchair",
    "no_smoking",
    "wc",
    "parking",
    "potable_water",
    "mens",
    "womens",
    "baby_symbol",
    "restroom",
    "put_litter_in_its_place",
    "cinema",
    "signal_strength",
    "koko",
    "ng",
    "ok",
    "up",
    "cool",
    "new",
    "free",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "keycap_ten",
    "asterisk",
    "1234",
    "eject_button",
    "arrow_forward",
    "pause_button",
    "next_track_button",
    "stop_button",
    "record_button",
    "play_or_pause_button",
    "previous_track_button",
    "fast_forward",
    "rewind",
    "twisted_rightwards_arrows",
    "repeat",
    "repeat_one",
    "arrow_backward",
    "arrow_up_small",
    "arrow_down_small",
    "arrow_double_up",
    "arrow_double_down",
    "arrow_right",
    "arrow_left",
    "arrow_up",
    "arrow_down",
    "arrow_upper_right",
    "arrow_lower_right",
    "arrow_lower_left",
    "arrow_upper_left",
    "arrow_up_down",
    "left_right_arrow",
    "arrows_counterclockwise",
    "arrow_right_hook",
    "leftwards_arrow_with_hook",
    "arrow_heading_up",
    "arrow_heading_down",
    "hash",
    "information_source",
    "abc",
    "abcd",
    "capital_abcd",
    "symbols",
    "musical_note",
    "notes",
    "wavy_dash",
    "curly_loop",
    "heavy_check_mark",
    "arrows_clockwise",
    "heavy_plus_sign",
    "heavy_minus_sign",
    "heavy_division_sign",
    "heavy_multiplication_x",
    "infinity",
    "heavy_dollar_sign",
    "currency_exchange",
    "copyright",
    "registered",
    "tm",
    "end",
    "back",
    "on",
    "top",
    "soon",
    "ballot_box_with_check",
    "radio_button",
    "white_circle",
    "black_circle",
    "red_circle",
    "large_blue_circle",
    "small_orange_diamond",
    "small_blue_diamond",
    "large_orange_diamond",
    "large_blue_diamond",
    "small_red_triangle",
    "black_small_square",
    "white_small_square",
    "black_large_square",
    "white_large_square",
    "small_red_triangle_down",
    "black_medium_square",
    "white_medium_square",
    "black_medium_small_square",
    "white_medium_small_square",
    "black_square_button",
    "white_square_button",
    "speaker",
    "sound",
    "loud_sound",
    "mute",
    "mega",
    "loudspeaker",
    "bell",
    "no_bell",
    "black_joker",
    "mahjong",
    "spades",
    "clubs",
    "hearts",
    "diamonds",
    "flower_playing_cards",
    "thought_balloon",
    "right_anger_bubble",
    "speech_balloon",
    "left_speech_bubble",
    "clock1",
    "clock2",
    "clock3",
    "clock4",
    "clock5",
    "clock6",
    "clock7",
    "clock8",
    "clock9",
    "clock10",
    "clock11",
    "clock12",
    "clock130",
    "clock230",
    "clock330",
    "clock430",
    "clock530",
    "clock630",
    "clock730",
    "clock830",
    "clock930",
    "clock1030",
    "clock1130",
    "clock1230",
    "white_flag",
    "black_flag",
    "pirate_flag",
    "checkered_flag",
    "triangular_flag_on_post",
    "rainbow_flag",
    "united_nations",
    "afghanistan",
    "aland_islands",
    "albania",
    "algeria",
    "american_samoa",
    "andorra",
    "angola",
    "anguilla",
    "antarctica",
    "antigua_barbuda",
    "argentina",
    "armenia",
    "aruba",
    "australia",
    "austria",
    "azerbaijan",
    "bahamas",
    "bahrain",
    "bangladesh",
    "barbados",
    "belarus",
    "belgium",
    "belize",
    "benin",
    "bermuda",
    "bhutan",
    "bolivia",
    "caribbean_netherlands",
    "bosnia_herzegovina",
    "botswana",
    "brazil",
    "british_indian_ocean_territory",
    "british_virgin_islands",
    "brunei",
    "bulgaria",
    "burkina_faso",
    "burundi",
    "cape_verde",
    "cambodia",
    "cameroon",
    "canada",
    "canary_islands",
    "cayman_islands",
    "central_african_republic",
    "chad",
    "chile",
    "cn",
    "christmas_island",
    "cocos_islands",
    "colombia",
    "comoros",
    "congo_brazzaville",
    "congo_kinshasa",
    "cook_islands",
    "costa_rica",
    "croatia",
    "cuba",
    "curacao",
    "cyprus",
    "czech_republic",
    "denmark",
    "djibouti",
    "dominica",
    "dominican_republic",
    "ecuador",
    "egypt",
    "el_salvador",
    "equatorial_guinea",
    "eritrea",
    "estonia",
    "ethiopia",
    "eu",
    "falkland_islands",
    "faroe_islands",
    "fiji",
    "finland",
    "fr",
    "french_guiana",
    "french_polynesia",
    "french_southern_territories",
    "gabon",
    "gambia",
    "georgia",
    "de",
    "ghana",
    "gibraltar",
    "greece",
    "greenland",
    "grenada",
    "guadeloupe",
    "guam",
    "guatemala",
    "guernsey",
    "guinea",
    "guinea_bissau",
    "guyana",
    "haiti",
    "honduras",
    "hong_kong",
    "hungary",
    "iceland",
    "india",
    "indonesia",
    "iran",
    "iraq",
    "ireland",
    "isle_of_man",
    "israel",
    "it",
    "cote_divoire",
    "jamaica",
    "jp",
    "jersey",
    "jordan",
    "kazakhstan",
    "kenya",
    "kiribati",
    "kosovo",
    "kuwait",
    "kyrgyzstan",
    "laos",
    "latvia",
    "lebanon",
    "lesotho",
    "liberia",
    "libya",
    "liechtenstein",
    "lithuania",
    "luxembourg",
    "macau",
    "macedonia",
    "madagascar",
    "malawi",
    "malaysia",
    "maldives",
    "mali",
    "malta",
    "marshall_islands",
    "martinique",
    "mauritania",
    "mauritius",
    "mayotte",
    "mexico",
    "micronesia",
    "moldova",
    "monaco",
    "mongolia",
    "montenegro",
    "montserrat",
    "morocco",
    "mozambique",
    "myanmar",
    "namibia",
    "nauru",
    "nepal",
    "netherlands",
    "new_caledonia",
    "new_zealand",
    "nicaragua",
    "niger",
    "nigeria",
    "niue",
    "norfolk_island",
    "northern_mariana_islands",
    "north_korea",
    "norway",
    "oman",
    "pakistan",
    "palau",
    "palestinian_territories",
    "panama",
    "papua_new_guinea",
    "paraguay",
    "peru",
    "philippines",
    "pitcairn_islands",
    "poland",
    "portugal",
    "puerto_rico",
    "qatar",
    "reunion",
    "romania",
    "ru",
    "rwanda",
    "st_barthelemy",
    "st_helena",
    "st_kitts_nevis",
    "st_lucia",
    "st_pierre_miquelon",
    "st_vincent_grenadines",
    "samoa",
    "san_marino",
    "sao_tome_principe",
    "saudi_arabia",
    "senegal",
    "serbia",
    "seychelles",
    "sierra_leone",
    "singapore",
    "sint_maarten",
    "slovakia",
    "slovenia",
    "solomon_islands",
    "somalia",
    "south_africa",
    "south_georgia_south_sandwich_islands",
    "kr",
    "south_sudan",
    "es",
    "sri_lanka",
    "sudan",
    "suriname",
    "swaziland",
    "sweden",
    "switzerland",
    "syria",
    "taiwan",
    "tajikistan",
    "tanzania",
    "thailand",
    "timor_leste",
    "togo",
    "tokelau",
    "tonga",
    "trinidad_tobago",
    "tunisia",
    "tr",
    "turkmenistan",
    "turks_caicos_islands",
    "tuvalu",
    "uganda",
    "ukraine",
    "united_arab_emirates",
    "uk",
    "england",
    "scotland",
    "wales",
    "us",
    "us_virgin_islands",
    "uruguay",
    "uzbekistan",
    "vanuatu",
    "vatican_city",
    "venezuela",
    "vietnam",
    "wallis_futuna",
    "western_sahara",
    "yemen",
    "zambia",
    "zimbabwe"
  ];
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/emojilib/index.js
var require_emojilib = __commonJS((exports, module) => {
  module.exports = {
    lib: require_emojis(),
    ordered: require_ordered(),
    fitzpatrick_scale_modifiers: ["\uD83C\uDFFB", "\uD83C\uDFFC", "\uD83C\uDFFD", "\uD83C\uDFFE", "\uD83C\uDFFF"]
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/char-regex/index.js
var require_char_regex = __commonJS((exports, module) => {
  module.exports = () => {
    const astralRange = "\\ud800-\\udfff";
    const comboMarksRange = "\\u0300-\\u036f";
    const comboHalfMarksRange = "\\ufe20-\\ufe2f";
    const comboSymbolsRange = "\\u20d0-\\u20ff";
    const comboMarksExtendedRange = "\\u1ab0-\\u1aff";
    const comboMarksSupplementRange = "\\u1dc0-\\u1dff";
    const comboRange = comboMarksRange + comboHalfMarksRange + comboSymbolsRange + comboMarksExtendedRange + comboMarksSupplementRange;
    const varRange = "\\ufe0e\\ufe0f";
    const familyRange = "\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83C\\uDF93";
    const astral = `[${astralRange}]`;
    const combo = `[${comboRange}]`;
    const fitz = "\\ud83c[\\udffb-\\udfff]";
    const modifier = `(?:${combo}|${fitz})`;
    const nonAstral = `[^${astralRange}]`;
    const regional = "(?:\\uD83C[\\uDDE6-\\uDDFF]){2}";
    const surrogatePair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    const zwj = "\\u200d";
    const blackFlag = "(?:\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40(?:\\udc65|\\udc73|\\udc77)\\udb40(?:\\udc6e|\\udc63|\\udc6c)\\udb40(?:\\udc67|\\udc74|\\udc73)\\udb40\\udc7f)";
    const family = `[${familyRange}]`;
    const optModifier = `${modifier}?`;
    const optVar = `[${varRange}]?`;
    const optJoin = `(?:${zwj}(?:${[nonAstral, regional, surrogatePair].join("|")})${optVar + optModifier})*`;
    const seq = optVar + optModifier + optJoin;
    const nonAstralCombo = `${nonAstral}${combo}?`;
    const symbol = `(?:${[nonAstralCombo, combo, regional, surrogatePair, astral, family].join("|")})`;
    return new RegExp(`${blackFlag}|${fitz}(?=${fitz})|${symbol + seq}`, "g");
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/unicode-emoji-modifier-base/index.js
var require_unicode_emoji_modifier_base = __commonJS((exports, module) => {
  module.exports = new Set([
    9757,
    9977,
    9994,
    9995,
    9996,
    9997,
    127877,
    127939,
    127940,
    127946,
    127947,
    128066,
    128067,
    128070,
    128071,
    128072,
    128073,
    128074,
    128075,
    128076,
    128077,
    128078,
    128079,
    128080,
    128102,
    128103,
    128104,
    128105,
    128110,
    128112,
    128113,
    128114,
    128115,
    128116,
    128117,
    128118,
    128119,
    128120,
    128124,
    128129,
    128130,
    128131,
    128133,
    128134,
    128135,
    128170,
    128373,
    128378,
    128400,
    128405,
    128406,
    128581,
    128582,
    128583,
    128587,
    128588,
    128589,
    128590,
    128591,
    128675,
    128692,
    128693,
    128694,
    128704,
    129304,
    129305,
    129306,
    129307,
    129308,
    129309,
    129310,
    129318,
    129328,
    129331,
    129332,
    129333,
    129334,
    129335,
    129336,
    129337,
    129340,
    129341,
    129342
  ]);
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/skin-tone/index.js
var require_skin_tone = __commonJS((exports, module) => {
  var emojiModifierBase = require_unicode_emoji_modifier_base();
  var skinTones = new Map([
    ["none", ""],
    ["white", "\uD83C\uDFFB"],
    ["creamWhite", "\uD83C\uDFFC"],
    ["lightBrown", "\uD83C\uDFFD"],
    ["brown", "\uD83C\uDFFE"],
    ["darkBrown", "\uD83C\uDFFF"]
  ]);
  module.exports = (emoji, tone) => {
    if (!skinTones.has(tone)) {
      throw new TypeError(`Unexpected \`skinTone\` name: ${tone}`);
    }
    emoji = emoji.replace(/[\u{1f3fb}-\u{1f3ff}]/u, "");
    if (emojiModifierBase.has(emoji.codePointAt(0)) && tone !== "none") {
      emoji += skinTones.get(tone);
    }
    return emoji;
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS((exports, module) => {
  var parseVersion = function(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      const m = /(\d{1,2})(\d{2})/.exec(versionString) || [];
      return {
        major: 0,
        minor: parseInt(m[1], 10),
        patch: parseInt(m[2], 10)
      };
    }
    const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  };
  var supportsHyperlink = function(stream) {
    const {
      CI,
      FORCE_HYPERLINK,
      NETLIFY,
      TEAMCITY_VERSION,
      TERM_PROGRAM,
      TERM_PROGRAM_VERSION,
      VTE_VERSION
    } = process.env;
    if (FORCE_HYPERLINK) {
      return !(FORCE_HYPERLINK.length > 0 && parseInt(FORCE_HYPERLINK, 10) === 0);
    }
    if (hasFlag2("no-hyperlink") || hasFlag2("no-hyperlinks") || hasFlag2("hyperlink=false") || hasFlag2("hyperlink=never")) {
      return false;
    }
    if (hasFlag2("hyperlink=true") || hasFlag2("hyperlink=always")) {
      return true;
    }
    if (NETLIFY) {
      return true;
    }
    if (!supportsColor2.supportsColor(stream)) {
      return false;
    }
    if (stream && !stream.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return false;
    }
    if (CI) {
      return false;
    }
    if (TEAMCITY_VERSION) {
      return false;
    }
    if (TERM_PROGRAM) {
      const version2 = parseVersion(TERM_PROGRAM_VERSION || "");
      switch (TERM_PROGRAM) {
        case "iTerm.app":
          if (version2.major === 3) {
            return version2.minor >= 1;
          }
          return version2.major > 3;
        case "WezTerm":
          return version2.major >= 20200620;
        case "vscode":
          return version2.major > 1 || version2.major === 1 && version2.minor >= 72;
      }
    }
    if (VTE_VERSION) {
      if (VTE_VERSION === "0.50.0") {
        return false;
      }
      const version2 = parseVersion(VTE_VERSION);
      return version2.major > 0 || version2.minor >= 50;
    }
    return false;
  };
  var supportsColor2 = require_supports_color();
  var hasFlag2 = require_has_flag();
  module.exports = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };
});

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/lib/platform-shims/esm.mjs
import {notStrictEqual, strictEqual} from "assert";

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cliui/build/lib/index.js
var addBorder = function(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
};
var _minWidth = function(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
};
var getWindowWidth = function() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
};
var alignRight = function(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
};
var alignCenter = function(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
};
function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === undefined ? undefined : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === undefined ? undefined : opts.wrap
  });
}
var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

class UI {
  constructor(opts) {
    var _a;
    this.width = opts.width;
    this.wrap = (_a = opts.wrap) !== null && _a !== undefined ? _a : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div("");
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === "string") {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str.split("\n").map((row) => row.split("\t"));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(...columns.map((r, i) => {
        return {
          text: r.trim(),
          padding: this.measurePadding(r),
          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }
  measurePadding(str) {
    const noAnsi = mixin.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r) => {
      let str = "";
      rrow.forEach((col, c) => {
        const { width } = row[c];
        const wrapWidth = this.negatePadding(row[c]);
        let ts = col;
        if (wrapWidth > mixin.stringWidth(col)) {
          ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
        }
        if (row[c].align && row[c].align !== "left" && this.wrap) {
          const fn = align[row[c].align];
          ts = fn(ts, wrapWidth);
          if (mixin.stringWidth(ts) < wrapWidth) {
            ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
          }
        }
        const padding = row[c].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += " ".repeat(padding[left]);
        }
        str += addBorder(row[c], ts, "| ");
        str += ts;
        str += addBorder(row[c], ts, " |");
        if (padding[right]) {
          str += " ".repeat(padding[right]);
        }
        if (r === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ""),
        span: row.span
      });
    });
    return lines;
  }
  renderInline(source, previousLine) {
    const match = source.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source;
    }
    previousLine.hidden = true;
    return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c) => {
      col.width = widths[c];
      if (this.wrap) {
        wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
      } else {
        wrapped = col.text.split("\n");
      }
      if (col.border) {
        wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
        wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
      }
      wrapped.forEach((str, r) => {
        if (!rrows[r]) {
          rrows.push([]);
        }
        const rrow = rrows[r];
        for (let i = 0;i < c; i++) {
          if (rrow[i] === undefined) {
            rrow.push("");
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w, i) => {
      if (w === undefined) {
        return Math.max(unsetWidth, _minWidth(row[i]));
      }
      return w;
    });
  }
}
var mixin;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cliui/build/lib/string-utils.js
function stripAnsi(str) {
  return str.replace(ansi, "");
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || ["", ""];
  str = stripAnsi(str);
  let wrapped = "";
  for (let i = 0;i < str.length; i++) {
    if (i !== 0 && i % width === 0) {
      wrapped += "\n";
    }
    wrapped += str.charAt(i);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}
var ansi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|" + "\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");

// /Users/karimshehadeh/dev/karim/hanto/node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length;
    },
    stripAnsi,
    wrap
  });
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/escalade/sync/index.mjs
import {dirname, resolve} from "path";
import {readdirSync, statSync} from "fs";
function sync_default(start, callback) {
  let dir = resolve(".", start);
  let tmp, stats = statSync(dir);
  if (!stats.isDirectory()) {
    dir = dirname(dir);
  }
  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp)
      return resolve(dir, tmp);
    dir = dirname(tmp = dir);
    if (tmp === dir)
      break;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/lib/platform-shims/esm.mjs
import {inspect} from "util";
import {readFileSync as readFileSync3} from "fs";
import {fileURLToPath} from "url";

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs-parser/build/lib/index.js
import {format} from "util";
import {normalize, resolve as resolve2} from "path";

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0;i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i = 0;i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === undefined)
    return false;
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x))
    return true;
  if (/^0[^.]/.test(x))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];
  for (let ii = 0;ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args[i])
      args[i] = "";
    args[i] += c;
  }
  return args;
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs-parser/build/lib/yargs-parser.js
var combineAliases = function(aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0;i < aliasArrays.length; i++) {
      for (let ii = i + 1;ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i, self2) {
      return self2.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== undefined && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
};
var increment = function(orig) {
  return orig !== undefined ? orig + 1 : 1;
};
var sanitizeKey = function(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
};
var stripQuotes = function(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
};
var mixin2;

class YargsParser {
  constructor(_mixin) {
    mixin2 = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: undefined,
      array: undefined,
      boolean: undefined,
      config: undefined,
      configObjects: undefined,
      configuration: undefined,
      coerce: undefined,
      count: undefined,
      default: undefined,
      envPrefix: undefined,
      narg: undefined,
      normalize: undefined,
      string: undefined,
      number: undefined,
      __: undefined,
      key: undefined
    }, options);
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = Object.create(null);
    const defaulted = Object.create(null);
    const __ = opts.__ || mixin2.format;
    const flags = {
      aliases: Object.create(null),
      arrays: Object.create(null),
      bools: Object.create(null),
      strings: Object.create(null),
      numbers: Object.create(null),
      counts: Object.create(null),
      normalize: Object.create(null),
      configs: Object.create(null),
      nargs: Object.create(null),
      coercions: Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value2]) => {
        if (typeof value2 === "number") {
          flags.nargs[key] = value2;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value2]) => {
        if (typeof value2 === "function") {
          flags.coercions[key] = value2;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value2]) => {
          if (typeof value2 === "boolean" || typeof value2 === "function") {
            flags.configs[key] = value2;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value2;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          if (checkAllAliases(m[1], flags.arrays)) {
            i = eatArray(i, m[1], args, m[2]);
          } else if (checkAllAliases(m[1], flags.nargs) !== false) {
            i = eatNargs(i, m[1], args, m[2]);
          } else {
            setArg(m[1], m[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m = arg.match(negatedBoolean);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m = arg.match(/^--?(.+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i + 1];
        m = arg.match(/^-(.\..+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j = 0;j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === "=") {
            value2 = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args, value2);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args, value2);
            } else {
              setArg(key, value2);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i + 1;ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i + 1;ii < consumed + i + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i + consumed;
    }
    function eatArray(i, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== undefined) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i + 1;ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value2 = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value2);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x) {
          const keyProperties = x.split(".");
          setKey(argv, keyProperties, value2);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        (flags.aliases[splitKey[0]] || []).forEach(function(x) {
          let keyProperties = x.split(".");
          const a = [].concat(splitKey);
          a.shift();
          keyProperties = keyProperties.concat(a);
          if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value2);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value3) {
              val = typeof value3 === "string" ? mixin2.normalize(value3) : value3;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value2 = Array.isArray(val) ? val.map(function(v) {
        return maybeCoerceNumber(key, v);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value2) || typeof value2 === "boolean")) {
        value2 = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value2 = val.map((val2) => {
            return mixin2.normalize(val2);
          });
        else
          value2 = mixin2.normalize(val);
      }
      return value2;
    }
    function maybeCoerceNumber(key, value2) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value2;
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value2)) {
        const shouldCoerceNumber = looksLikeNumber(value2) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value2}`)));
        if (shouldCoerceNumber || !isUndefined(value2) && checkAllAliases(key, flags.numbers)) {
          value2 = Number(value2);
        }
      }
      return value2;
    }
    function setConfig(argv2) {
      const configLookup = Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin2.resolve(mixin2.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin2.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value2 = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value2 === "object" && value2 !== null && !Array.isArray(value2) && configuration["dot-notation"]) {
          setConfigObject(value2, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value2);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env = mixin2.env();
      Object.keys(env).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i) {
            if (i === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = new Set;
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === "function") {
            try {
              const value2 = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value2;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = undefined;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x) {
            if (hasKey(obj, x.split(".")))
              return;
            setKey(obj, x.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== "object")
        return false;
      else
        return key in o;
    }
    function setKey(obj, keys, value2) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o === "object" && o[key2] === undefined) {
          o[key2] = {};
        }
        if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value2);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
          o[key] = undefined;
        }
      }
      if (value2 === increment()) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value2) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value2]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value2;
        } else {
          o[key] = o[key].concat([value2]);
        }
      } else if (o[key] === undefined && isTypeArray) {
        o[key] = isValueArray ? value2 : [value2];
      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o[key] = [o[key], value2];
      } else {
        o[key] = value2;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x) {
            if (/-/.test(x) && configuration["camel-case-expansion"]) {
              const c = camelCase(x);
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
              const c = decamelize(x, "-");
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x) {
            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
              return x !== y;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j = 0;j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: undefined,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === undefined;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs-parser/build/lib/index.js
import {readFileSync} from "fs";
var _a;
var _b;
var _c;
var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
var nodeVersion = (_b = (_a = process === null || process === undefined ? undefined : process.versions) === null || _a === undefined ? undefined : _a.node) !== null && _b !== undefined ? _b : (_c = process === null || process === undefined ? undefined : process.version) === null || _c === undefined ? undefined : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
var env = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format,
  normalize,
  resolve: resolve2,
  require: (path) => {
    if (typeof require !== "undefined") {
      return require(path);
    } else if (path.match(/\.json$/)) {
      return JSON.parse(readFileSync(path, "utf8"));
    } else {
      throw Error("only .json config files are supported in ESM");
    }
  }
});
var yargsParser = function Parser(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
var lib_default = yargsParser;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/lib/platform-shims/esm.mjs
import {basename, dirname as dirname2, extname, relative, resolve as resolve4} from "path";

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/process-argv.js
var getProcessArgvBinIndex = function() {
  if (isBundledElectronApp())
    return 0;
  return 1;
};
var isBundledElectronApp = function() {
  return isElectronApp() && !process.defaultApp;
};
var isElectronApp = function() {
  return !!process.versions.electron;
};
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/yerror.js
class YError extends Error {
  constructor(msg) {
    super(msg || "yargs error");
    this.name = "YError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, YError);
    }
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/y18n/build/lib/platform-shims/node.js
import {readFileSync as readFileSync2, statSync as statSync2, writeFile} from "fs";
import {format as format2} from "util";
import {resolve as resolve3} from "path";
var node_default = {
  fs: {
    readFileSync: readFileSync2,
    writeFile
  },
  format: format2,
  resolve: resolve3,
  exists: (file) => {
    try {
      return statSync2(file).isFile();
    } catch (err) {
      return false;
    }
  }
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/y18n/build/lib/index.js
function y18n(opts, _shim) {
  shim = _shim;
  const y18n2 = new Y18N(opts);
  return {
    __: y18n2.__.bind(y18n2),
    __n: y18n2.__n.bind(y18n2),
    setLocale: y18n2.setLocale.bind(y18n2),
    getLocale: y18n2.getLocale.bind(y18n2),
    updateLocale: y18n2.updateLocale.bind(y18n2),
    locale: y18n2.locale
  };
}
var shim;

class Y18N {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return shim.format.apply(shim.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = "";
    parts.forEach(function(part, i) {
      const arg = args[i + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim.fs.readFileSync) {
        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file = shim.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
      const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file = languageFile;
    }
    return file;
  }
  _fileExistsSync(file) {
    return shim.exists(file);
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/y18n/index.mjs
var y18n2 = (opts) => {
  return y18n(opts, node_default);
};
var y18n_default = y18n2;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/lib/platform-shims/esm.mjs
var REQUIRE_ERROR = "require is not supported by ESM";
var REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
var __dirname2;
try {
  __dirname2 = fileURLToPath(import.meta.url);
} catch (e) {
  __dirname2 = process.cwd();
}
var mainFilename = __dirname2.substring(0, __dirname2.lastIndexOf("node_modules"));
var esm_default = {
  assert: {
    notStrictEqual,
    strictEqual
  },
  cliui: ui,
  findUp: sync_default,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: lib_default,
  path: {
    basename,
    dirname: dirname2,
    extname,
    relative,
    resolve: resolve4
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
  },
  readFileSync: readFileSync3,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n_default({
    directory: resolve4(__dirname2, "../../../locales"),
    updateFiles: false
  })
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/typings/common-types.js
function assertNotStrictEqual(actual, expected, shim2, message) {
  shim2.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim2) {
  shim2.assert.strictEqual(typeof actual, "string");
}
function objectKeys(object) {
  return Object.keys(object);
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/is-promise.js
function isPromise(maybePromise) {
  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/parse-command.js
function parseCommand(cmd) {
  const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
  const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  const bregex = /\.*[\][<>]/g;
  const firstCommand = splitCommand.shift();
  if (!firstCommand)
    throw new Error(`No command found in: ${cmd}`);
  const parsedCommand = {
    cmd: firstCommand.replace(bregex, ""),
    demanded: [],
    optional: []
  };
  splitCommand.forEach((cmd2, i) => {
    let variadic = false;
    cmd2 = cmd2.replace(/\s/g, "");
    if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
      variadic = true;
    if (/^\[/.test(cmd2)) {
      parsedCommand.optional.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    }
  });
  return parsedCommand;
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/argsert.js
function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return typeof arg1 === "object" ? [{ demanded: [], optional: [] }, arg1, arg2] : [
      parseCommand(`cmd ${arg1}`),
      arg2,
      arg3
    ];
  }
  try {
    let position = 0;
    const [parsed, callerArguments, _length] = parseArgs();
    const args = [].slice.call(callerArguments);
    while (args.length && args[args.length - 1] === undefined)
      args.pop();
    const length = _length || args.length;
    if (length < parsed.demanded.length) {
      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
    }
    const totalCommands = parsed.demanded.length + parsed.optional.length;
    if (length > totalCommands) {
      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
    }
    parsed.demanded.forEach((demanded) => {
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach((optional) => {
      if (args.length === 0)
        return;
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}
var guessType = function(arg) {
  if (Array.isArray(arg)) {
    return "array";
  } else if (arg === null) {
    return "null";
  }
  return typeof arg;
};
var argumentTypeError = function(observedType, allowedTypes, position) {
  throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
};
var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/middleware.js
function commandMiddlewareFactory(commandMiddleware) {
  if (!commandMiddleware)
    return [];
  return commandMiddleware.map((middleware) => {
    middleware.applyBeforeValidation = false;
    return middleware;
  });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
  return middlewares.reduce((acc, middleware) => {
    if (middleware.applyBeforeValidation !== beforeValidation) {
      return acc;
    }
    if (middleware.mutates) {
      if (middleware.applied)
        return acc;
      middleware.applied = true;
    }
    if (isPromise(acc)) {
      return acc.then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
    } else {
      const result = middleware(acc, yargs);
      return isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
    }
  }, argv);
}

class GlobalMiddleware {
  constructor(yargs) {
    this.globalMiddleware = [];
    this.frozens = [];
    this.yargs = yargs;
  }
  addMiddleware(callback, applyBeforeValidation, global2 = true, mutates = false) {
    argsert("<array|function> [boolean] [boolean] [boolean]", [callback, applyBeforeValidation, global2], arguments.length);
    if (Array.isArray(callback)) {
      for (let i = 0;i < callback.length; i++) {
        if (typeof callback[i] !== "function") {
          throw Error("middleware must be a function");
        }
        const m = callback[i];
        m.applyBeforeValidation = applyBeforeValidation;
        m.global = global2;
      }
      Array.prototype.push.apply(this.globalMiddleware, callback);
    } else if (typeof callback === "function") {
      const m = callback;
      m.applyBeforeValidation = applyBeforeValidation;
      m.global = global2;
      m.mutates = mutates;
      this.globalMiddleware.push(callback);
    }
    return this.yargs;
  }
  addCoerceMiddleware(callback, option) {
    const aliases = this.yargs.getAliases();
    this.globalMiddleware = this.globalMiddleware.filter((m) => {
      const toCheck = [...aliases[option] || [], option];
      if (!m.option)
        return true;
      else
        return !toCheck.includes(m.option);
    });
    callback.option = option;
    return this.addMiddleware(callback, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    if (frozen !== undefined)
      this.globalMiddleware = frozen;
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((m) => m.global);
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/maybe-async-result.js
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err) => {
  throw err;
}) {
  try {
    const result = isFunction(getResult) ? getResult() : getResult;
    return isPromise(result) ? result.then((result2) => resultHandler(result2)) : resultHandler(result);
  } catch (err) {
    return errorHandler(err);
  }
}
var isFunction = function(arg) {
  return typeof arg === "function";
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/which-module.js
function whichModule(exported) {
  if (typeof require === "undefined")
    return null;
  for (let i = 0, files = Object.keys(require.cache), mod;i < files.length; i++) {
    mod = require.cache[files[i]];
    if (mod.exports === exported)
      return mod;
  }
  return null;
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/command.js
function command(usage, validation, globalMiddleware, shim2) {
  return new CommandInstance(usage, validation, globalMiddleware, shim2);
}
function isCommandBuilderDefinition(builder) {
  return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
}
var isCommandAndAliases = function(cmd) {
  return cmd.every((c) => typeof c === "string");
};
function isCommandBuilderCallback(builder) {
  return typeof builder === "function";
}
var isCommandBuilderOptionDefinitions = function(builder) {
  return typeof builder === "object";
};
function isCommandHandlerDefinition(cmd) {
  return typeof cmd === "object" && !Array.isArray(cmd);
}
var DEFAULT_MARKER = /(^\*)|(^\$0)/;

class CommandInstance {
  constructor(usage, validation, globalMiddleware, shim2) {
    this.requireCache = new Set;
    this.handlers = {};
    this.aliasMap = {};
    this.frozens = [];
    this.shim = shim2;
    this.usage = usage;
    this.globalMiddleware = globalMiddleware;
    this.validation = validation;
  }
  addDirectory(dir, req, callerFile, opts) {
    opts = opts || {};
    if (typeof opts.recurse !== "boolean")
      opts.recurse = false;
    if (!Array.isArray(opts.extensions))
      opts.extensions = ["js"];
    const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
    opts.visit = (obj, joined, filename) => {
      const visited = parentVisit(obj, joined, filename);
      if (visited) {
        if (this.requireCache.has(joined))
          return visited;
        else
          this.requireCache.add(joined);
        this.addHandler(visited);
      }
      return visited;
    };
    this.shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
  }
  addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
    let aliases = [];
    const middlewares = commandMiddlewareFactory(commandMiddleware);
    handler = handler || (() => {
    });
    if (Array.isArray(cmd)) {
      if (isCommandAndAliases(cmd)) {
        [cmd, ...aliases] = cmd;
      } else {
        for (const command2 of cmd) {
          this.addHandler(command2);
        }
      }
    } else if (isCommandHandlerDefinition(cmd)) {
      let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : this.moduleName(cmd);
      if (cmd.aliases)
        command2 = [].concat(command2).concat(cmd.aliases);
      this.addHandler(command2, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
      return;
    } else if (isCommandBuilderDefinition(builder)) {
      this.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
      return;
    }
    if (typeof cmd === "string") {
      const parsedCommand = parseCommand(cmd);
      aliases = aliases.map((alias) => parseCommand(alias).cmd);
      let isDefault = false;
      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
        if (DEFAULT_MARKER.test(c)) {
          isDefault = true;
          return false;
        }
        return true;
      });
      if (parsedAliases.length === 0 && isDefault)
        parsedAliases.push("$0");
      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }
      aliases.forEach((alias) => {
        this.aliasMap[alias] = parsedCommand.cmd;
      });
      if (description !== false) {
        this.usage.command(cmd, description, isDefault, aliases, deprecated);
      }
      this.handlers[parsedCommand.cmd] = {
        original: cmd,
        description,
        handler,
        builder: builder || {},
        middlewares,
        deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      };
      if (isDefault)
        this.defaultCommand = this.handlers[parsedCommand.cmd];
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(command2, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
    const commandHandler = this.handlers[command2] || this.handlers[this.aliasMap[command2]] || this.defaultCommand;
    const currentContext = yargs.getInternalMethods().getContext();
    const parentCommands = currentContext.commands.slice();
    const isDefaultCommand = !command2;
    if (command2) {
      currentContext.commands.push(command2);
      currentContext.fullCommands.push(commandHandler.original);
    }
    const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
    return isPromise(builderResult) ? builderResult.then((result) => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
  }
  applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
    const builder = commandHandler.builder;
    let innerYargs = yargs;
    if (isCommandBuilderCallback(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
      if (isPromise(builderOutput)) {
        return builderOutput.then((output) => {
          innerYargs = isYargsInstance(output) ? output : yargs;
          return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
        });
      }
    } else if (isCommandBuilderOptionDefinitions(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      innerYargs = yargs.getInternalMethods().reset(aliases);
      Object.keys(commandHandler.builder).forEach((key) => {
        innerYargs.option(key, builder[key]);
      });
    }
    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
  }
  parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
    if (isDefaultCommand)
      innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
    if (this.shouldUpdateUsage(innerYargs)) {
      innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
    }
    const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
    return isPromise(innerArgv) ? innerArgv.then((argv) => ({
      aliases: innerYargs.parsed.aliases,
      innerArgv: argv
    })) : {
      aliases: innerYargs.parsed.aliases,
      innerArgv
    };
  }
  shouldUpdateUsage(yargs) {
    return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
  }
  usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
    const pc = parentCommands.filter((c2) => {
      return !DEFAULT_MARKER.test(c2);
    });
    pc.push(c);
    return `\$0 ${pc.join(" ")}`;
  }
  handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
    if (!yargs.getInternalMethods().getHasOutput()) {
      const validation = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        validation(result);
        return result;
      });
    }
    if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
      yargs.getInternalMethods().setHasOutput();
      const populateDoubleDash = !!yargs.getOptions().configuration["populate--"];
      yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        const handlerResult = commandHandler.handler(result);
        return isPromise(handlerResult) ? handlerResult.then(() => result) : result;
      });
      if (!isDefaultCommand) {
        yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
      }
      if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
        innerArgv.catch((error) => {
          try {
            yargs.getInternalMethods().getUsageInstance().fail(null, error);
          } catch (_err) {
          }
        });
      }
    }
    if (!isDefaultCommand) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }
    return innerArgv;
  }
  applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
    let positionalMap = {};
    if (helpOnly)
      return innerArgv;
    if (!yargs.getInternalMethods().getHasOutput()) {
      positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    }
    const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
    const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
    return isPromise(maybePromiseArgv) ? maybePromiseArgv.then((resolvedInnerArgv) => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap)) : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
  }
  populatePositionals(commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length);
    const demanded = commandHandler.demanded.slice(0);
    const optional = commandHandler.optional.slice(0);
    const positionalMap = {};
    this.validation.positionalCount(demanded.length, argv._.length);
    while (demanded.length) {
      const demand = demanded.shift();
      this.populatePositional(demand, argv, positionalMap);
    }
    while (optional.length) {
      const maybe = optional.shift();
      this.populatePositional(maybe, argv, positionalMap);
    }
    argv._ = context.commands.concat(argv._.map((a) => "" + a));
    this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
    return positionalMap;
  }
  populatePositional(positional, argv, positionalMap) {
    const cmd = positional.cmd[0];
    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length)
        positionalMap[cmd] = [String(argv._.shift())];
    }
  }
  cmdToParseOptions(cmdString) {
    const parseOptions = {
      array: [],
      default: {},
      alias: {},
      demand: {}
    };
    const parsed = parseCommand(cmdString);
    parsed.demanded.forEach((d) => {
      const [cmd, ...aliases] = d.cmd;
      if (d.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach((o) => {
      const [cmd, ...aliases] = o.cmd;
      if (o.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
    });
    return parseOptions;
  }
  postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
    const options = Object.assign({}, yargs.getOptions());
    options.default = Object.assign(parseOptions.default, options.default);
    for (const key of Object.keys(parseOptions.alias)) {
      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    }
    options.array = options.array.concat(parseOptions.array);
    options.config = {};
    const unparsed = [];
    Object.keys(positionalMap).forEach((key) => {
      positionalMap[key].map((value2) => {
        if (options.configuration["unknown-options-as-args"])
          options.key[key] = true;
        unparsed.push(`--${key}`);
        unparsed.push(value2);
      });
    });
    if (!unparsed.length)
      return;
    const config = Object.assign({}, options.configuration, {
      "populate--": false
    });
    const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
      configuration: config
    }));
    if (parsed.error) {
      yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      const positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach((key) => {
        positionalKeys.push(...parsed.aliases[key]);
      });
      Object.keys(parsed.argv).forEach((key) => {
        if (positionalKeys.includes(key)) {
          if (!positionalMap[key])
            positionalMap[key] = parsed.argv[key];
          if (!this.isInConfigs(yargs, key) && !this.isDefaulted(yargs, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
            argv[key] = [].concat(argv[key], parsed.argv[key]);
          } else {
            argv[key] = parsed.argv[key];
          }
        }
      });
    }
  }
  isDefaulted(yargs, key) {
    const { default: defaults } = yargs.getOptions();
    return Object.prototype.hasOwnProperty.call(defaults, key) || Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key));
  }
  isInConfigs(yargs, key) {
    const { configObjects } = yargs.getOptions();
    return configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, key)) || configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key)));
  }
  runDefaultBuilderOn(yargs) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(yargs)) {
      const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
    }
    const builder = this.defaultCommand.builder;
    if (isCommandBuilderCallback(builder)) {
      return builder(yargs, true);
    } else if (!isCommandBuilderDefinition(builder)) {
      Object.keys(builder).forEach((key) => {
        yargs.option(key, builder[key]);
      });
    }
    return;
  }
  moduleName(obj) {
    const mod = whichModule(obj);
    if (!mod)
      throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
    return this.commandFromFilename(mod.filename);
  }
  commandFromFilename(filename) {
    return this.shim.path.basename(filename, this.shim.path.extname(filename));
  }
  extractDesc({ describe, description, desc }) {
    for (const test of [describe, description, desc]) {
      if (typeof test === "string" || test === false)
        return test;
      assertNotStrictEqual(test, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    });
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    assertNotStrictEqual(frozen, undefined, this.shim);
    ({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    } = frozen);
  }
  reset() {
    this.handlers = {};
    this.aliasMap = {};
    this.defaultCommand = undefined;
    this.requireCache = new Set;
    return this;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/obj-filter.js
function objFilter(original = {}, filter = () => true) {
  const obj = {};
  objectKeys(original).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key];
    }
  });
  return obj;
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/set-blocking.js
function setBlocking(blocking) {
  if (typeof process === "undefined")
    return;
  [process.stdout, process.stderr].forEach((_stream) => {
    const stream = _stream;
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
      stream._handle.setBlocking(blocking);
    }
  });
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/usage.js
var isBoolean = function(fail) {
  return typeof fail === "boolean";
};
function usage(yargs, shim2) {
  const __ = shim2.y18n.__;
  const self2 = {};
  const fails = [];
  self2.failFn = function failFn(f) {
    fails.push(f);
  };
  let failMessage = null;
  let globalFailMessage = null;
  let showHelpOnFail = true;
  self2.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
    const [enabled, message] = typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }
    failMessage = message;
    showHelpOnFail = enabled;
    return self2;
  };
  let failureOutput = false;
  self2.fail = function fail(msg, err) {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (fails.length) {
      for (let i = fails.length - 1;i >= 0; --i) {
        const fail = fails[i];
        if (isBoolean(fail)) {
          if (err)
            throw err;
          else if (msg)
            throw Error(msg);
        } else {
          fail(msg, err, self2);
        }
      }
    } else {
      if (yargs.getExitProcess())
        setBlocking(true);
      if (!failureOutput) {
        failureOutput = true;
        if (showHelpOnFail) {
          yargs.showHelp("error");
          logger.error();
        }
        if (msg || err)
          logger.error(msg || err);
        const globalOrCommandFailMessage = failMessage || globalFailMessage;
        if (globalOrCommandFailMessage) {
          if (msg || err)
            logger.error("");
          logger.error(globalOrCommandFailMessage);
        }
      }
      err = err || new YError(msg);
      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  };
  let usages = [];
  let usageDisabled = false;
  self2.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self2;
    }
    usageDisabled = false;
    usages.push([msg, description || ""]);
    return self2;
  };
  self2.getUsage = () => {
    return usages;
  };
  self2.getUsageDisabled = () => {
    return usageDisabled;
  };
  self2.getPositionalGroupName = () => {
    return __("Positionals:");
  };
  let examples = [];
  self2.example = (cmd, description) => {
    examples.push([cmd, description || ""]);
  };
  let commands = [];
  self2.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false;
        return cmdArray;
      });
    }
    commands.push([cmd, description || "", isDefault, aliases, deprecated]);
  };
  self2.getCommands = () => commands;
  let descriptions = {};
  self2.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach((k) => {
        self2.describe(k, desc);
      });
    } else if (typeof keyOrKeys === "object") {
      Object.keys(keyOrKeys).forEach((k) => {
        self2.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };
  self2.getDescriptions = () => descriptions;
  let epilogs = [];
  self2.epilog = (msg) => {
    epilogs.push(msg);
  };
  let wrapSet = false;
  let wrap2;
  self2.wrap = (cols) => {
    wrapSet = true;
    wrap2 = cols;
  };
  self2.getWrap = () => {
    if (shim2.getEnv("YARGS_DISABLE_WRAP")) {
      return null;
    }
    if (!wrapSet) {
      wrap2 = windowWidth();
      wrapSet = true;
    }
    return wrap2;
  };
  const deferY18nLookupPrefix = "__yargsString__:";
  self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
  self2.help = function help() {
    if (cachedHelpMessage)
      return cachedHelpMessage;
    normalizeAliases();
    const base$0 = yargs.customScriptName ? yargs.$0 : shim2.path.basename(yargs.$0);
    const demandedOptions = yargs.getDemandedOptions();
    const demandedCommands = yargs.getDemandedCommands();
    const deprecatedOptions = yargs.getDeprecatedOptions();
    const groups = yargs.getGroups();
    const options = yargs.getOptions();
    let keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options.default));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce((acc, key) => {
      if (key !== "_")
        acc[key] = true;
      return acc;
    }, {}));
    const theWrap = self2.getWrap();
    const ui2 = shim2.cliui({
      width: theWrap,
      wrap: !!theWrap
    });
    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach((usage2) => {
          ui2.div({ text: `${usage2[0].replace(/\$0/g, base$0)}` });
          if (usage2[1]) {
            ui2.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
          }
        });
        ui2.div();
      } else if (commands.length) {
        let u = null;
        if (demandedCommands._) {
          u = `${base$0} <${__("command")}>\n`;
        } else {
          u = `${base$0} [${__("command")}]\n`;
        }
        ui2.div(`${u}`);
      }
    }
    if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
      ui2.div(__("Commands:"));
      const context = yargs.getInternalMethods().getContext();
      const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
      if (yargs.getInternalMethods().getParserConfiguration()["sort-commands"] === true) {
        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
      }
      const prefix = base$0 ? `${base$0} ` : "";
      commands.forEach((command2) => {
        const commandString = `${prefix}${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
        ui2.span({
          text: commandString,
          padding: [0, 2, 0, 2],
          width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
        }, { text: command2[1] });
        const hints = [];
        if (command2[2])
          hints.push(`[${__("default")}]`);
        if (command2[3] && command2[3].length) {
          hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
        }
        if (command2[4]) {
          if (typeof command2[4] === "string") {
            hints.push(`[${__("deprecated: %s", command2[4])}]`);
          } else {
            hints.push(`[${__("deprecated")}]`);
          }
        }
        if (hints.length) {
          ui2.div({
            text: hints.join(" "),
            padding: [0, 0, 0, 2],
            align: "right"
          });
        } else {
          ui2.div();
        }
      });
      ui2.div();
    }
    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
    const defaultGroup = __("Options:");
    if (!groups[defaultGroup])
      groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);
    const isLongSwitch = (sw) => /^--/.test(getText(sw));
    const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
        if (aliasKeys.includes(key))
          return key;
        for (let i = 0, aliasKey;(aliasKey = aliasKeys[i]) !== undefined; i++) {
          if ((options.alias[aliasKey] || []).includes(key))
            return aliasKey;
        }
        return key;
      });
      return { groupName, normalizedKeys };
    }).filter(({ normalizedKeys }) => normalizedKeys.length > 0).map(({ groupName, normalizedKeys }) => {
      const switches = normalizedKeys.reduce((acc, key) => {
        acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
          if (groupName === self2.getPositionalGroupName())
            return sw;
          else {
            return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
          }
        }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
        return acc;
      }, {});
      return { groupName, normalizedKeys, switches };
    });
    const shortSwitchesUsed = displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).some(({ normalizedKeys, switches }) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
    if (shortSwitchesUsed) {
      displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).forEach(({ normalizedKeys, switches }) => {
        normalizedKeys.forEach((key) => {
          if (isLongSwitch(switches[key])) {
            switches[key] = addIndentation(switches[key], "-x, ".length);
          }
        });
      });
    }
    displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
      ui2.div(groupName);
      normalizedKeys.forEach((key) => {
        const kswitch = switches[key];
        let desc = descriptions[key] || "";
        let type = null;
        if (desc.includes(deferY18nLookupPrefix))
          desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options.boolean.includes(key))
          type = `[${__("boolean")}]`;
        if (options.count.includes(key))
          type = `[${__("count")}]`;
        if (options.string.includes(key))
          type = `[${__("string")}]`;
        if (options.normalize.includes(key))
          type = `[${__("string")}]`;
        if (options.array.includes(key))
          type = `[${__("array")}]`;
        if (options.number.includes(key))
          type = `[${__("number")}]`;
        const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
        const extra = [
          key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
          type,
          key in demandedOptions ? `[${__("required")}]` : null,
          options.choices && options.choices[key] ? `[${__("choices:")} ${self2.stringifiedValues(options.choices[key])}]` : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(" ");
        ui2.span({
          text: getText(kswitch),
          padding: [0, 2, 0, 2 + getIndentation(kswitch)],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        const shouldHideOptionExtras = yargs.getInternalMethods().getUsageConfiguration()["hide-types"] === true;
        if (extra && !shouldHideOptionExtras)
          ui2.div({ text: extra, padding: [0, 0, 0, 2], align: "right" });
        else
          ui2.div();
      });
      ui2.div();
    });
    if (examples.length) {
      ui2.div(__("Examples:"));
      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach((example) => {
        if (example[1] === "") {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2]
          });
        } else {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui2.div();
    }
    if (epilogs.length > 0) {
      const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
      ui2.div(`${e}\n`);
    }
    return ui2.toString().replace(/\s*$/, "");
  };
  function maxWidth(table, theWrap, modifier) {
    let width = 0;
    if (!Array.isArray(table)) {
      table = Object.values(table).map((v) => [v]);
    }
    table.forEach((v) => {
      width = Math.max(shim2.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
    });
    if (theWrap)
      width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }
  function normalizeAliases() {
    const demandedOptions = yargs.getDemandedOptions();
    const options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        if (descriptions[alias])
          self2.describe(key, descriptions[alias]);
        if (alias in demandedOptions)
          yargs.demandOption(key, demandedOptions[alias]);
        if (options.boolean.includes(alias))
          yargs.boolean(key);
        if (options.count.includes(alias))
          yargs.count(key);
        if (options.string.includes(alias))
          yargs.string(key);
        if (options.normalize.includes(alias))
          yargs.normalize(key);
        if (options.array.includes(alias))
          yargs.array(key);
        if (options.number.includes(alias))
          yargs.number(key);
      });
    });
  }
  let cachedHelpMessage;
  self2.cacheHelpMessage = function() {
    cachedHelpMessage = this.help();
  };
  self2.clearCachedHelpMessage = function() {
    cachedHelpMessage = undefined;
  };
  self2.hasCachedHelpMessage = function() {
    return !!cachedHelpMessage;
  };
  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    let groupedKeys = [];
    let toCheck = null;
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach((key) => {
      toCheck = [key].concat(aliases[key]);
      if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }
  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }
  self2.showHelp = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(self2.help());
  };
  self2.functionDescription = (fn) => {
    const description = fn.name ? shim2.Parser.decamelize(fn.name, "-") : __("generated-value");
    return ["(", description, ")"].join("");
  };
  self2.stringifiedValues = function stringifiedValues(values, separator) {
    let string = "";
    const sep = separator || ", ";
    const array = [].concat(values);
    if (!values || !array.length)
      return string;
    array.forEach((value2) => {
      if (string.length)
        string += sep;
      string += JSON.stringify(value2);
    });
    return string;
  };
  function defaultString(value2, defaultDescription) {
    let string = `[${__("default:")} `;
    if (value2 === undefined && !defaultDescription)
      return null;
    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (typeof value2) {
        case "string":
          string += `"${value2}"`;
          break;
        case "object":
          string += JSON.stringify(value2);
          break;
        default:
          string += value2;
      }
    }
    return `${string}]`;
  }
  function windowWidth() {
    const maxWidth2 = 80;
    if (shim2.process.stdColumns) {
      return Math.min(maxWidth2, shim2.process.stdColumns);
    } else {
      return maxWidth2;
    }
  }
  let version = null;
  self2.version = (ver) => {
    version = ver;
  };
  self2.showVersion = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(version);
  };
  self2.reset = function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = objFilter(descriptions, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      failMessage,
      failureOutput,
      usages,
      usageDisabled,
      epilogs,
      examples,
      commands,
      descriptions
    });
  };
  self2.unfreeze = function unfreeze(defaultCommand = false) {
    const frozen = frozens.pop();
    if (!frozen)
      return;
    if (defaultCommand) {
      descriptions = { ...frozen.descriptions, ...descriptions };
      commands = [...frozen.commands, ...commands];
      usages = [...frozen.usages, ...usages];
      examples = [...frozen.examples, ...examples];
      epilogs = [...frozen.epilogs, ...epilogs];
    } else {
      ({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions
      } = frozen);
    }
  };
  return self2;
}
var isIndentedText = function(text) {
  return typeof text === "object";
};
var addIndentation = function(text, indent) {
  return isIndentedText(text) ? { text: text.text, indentation: text.indentation + indent } : { text, indentation: indent };
};
var getIndentation = function(text) {
  return isIndentedText(text) ? text.indentation : 0;
};
var getText = function(text) {
  return isIndentedText(text) ? text.text : text;
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/completion-templates.js
var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
var completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/completion.js
function completion(yargs, usage2, command3, shim2) {
  return new Completion(yargs, usage2, command3, shim2);
}
var isSyncCompletionFunction = function(completionFunction) {
  return completionFunction.length < 3;
};
var isFallbackCompletionFunction = function(completionFunction) {
  return completionFunction.length > 3;
};

class Completion {
  constructor(yargs, usage2, command3, shim2) {
    var _a2, _b2, _c2;
    this.yargs = yargs;
    this.usage = usage2;
    this.command = command3;
    this.shim = shim2;
    this.completionKey = "get-yargs-completions";
    this.aliases = null;
    this.customCompletionFunction = null;
    this.indexAfterLastReset = 0;
    this.zshShell = (_c2 = ((_a2 = this.shim.getEnv("SHELL")) === null || _a2 === undefined ? undefined : _a2.includes("zsh")) || ((_b2 = this.shim.getEnv("ZSH_NAME")) === null || _b2 === undefined ? undefined : _b2.includes("zsh"))) !== null && _c2 !== undefined ? _c2 : false;
  }
  defaultCompletion(args, argv, current, done) {
    const handlers = this.command.getCommandHandlers();
    for (let i = 0, ii = args.length;i < ii; ++i) {
      if (handlers[args[i]] && handlers[args[i]].builder) {
        const builder = handlers[args[i]].builder;
        if (isCommandBuilderCallback(builder)) {
          this.indexAfterLastReset = i + 1;
          const y = this.yargs.getInternalMethods().reset();
          builder(y, true);
          return y.argv;
        }
      }
    }
    const completions = [];
    this.commandCompletions(completions, args, current);
    this.optionCompletions(completions, args, argv, current);
    this.choicesFromOptionsCompletions(completions, args, argv, current);
    this.choicesFromPositionalsCompletions(completions, args, argv, current);
    done(null, completions);
  }
  commandCompletions(completions, args, current) {
    const parentCommands = this.yargs.getInternalMethods().getContext().commands;
    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
      this.usage.getCommands().forEach((usageCommand) => {
        const commandName = parseCommand(usageCommand[0]).cmd;
        if (args.indexOf(commandName) === -1) {
          if (!this.zshShell) {
            completions.push(commandName);
          } else {
            const desc = usageCommand[1] || "";
            completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
          }
        }
      });
    }
  }
  optionCompletions(completions, args, argv, current) {
    if ((current.match(/^-/) || current === "" && completions.length === 0) && !this.previousArgHasChoices(args)) {
      const options = this.yargs.getOptions();
      const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(options.key).forEach((key) => {
        const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
        const isPositionalKey = positionalKeys.includes(key);
        if (!isPositionalKey && !options.hiddenOptions.includes(key) && !this.argsContainKey(args, key, negable)) {
          this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
        }
      });
    }
  }
  choicesFromOptionsCompletions(completions, args, argv, current) {
    if (this.previousArgHasChoices(args)) {
      const choices = this.getPreviousArgChoices(args);
      if (choices && choices.length > 0) {
        completions.push(...choices.map((c) => c.replace(/:/g, "\\:")));
      }
    }
  }
  choicesFromPositionalsCompletions(completions, args, argv, current) {
    if (current === "" && completions.length > 0 && this.previousArgHasChoices(args)) {
      return;
    }
    const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
    const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1);
    const positionalKey = positionalKeys[argv._.length - offset - 1];
    if (!positionalKey) {
      return;
    }
    const choices = this.yargs.getOptions().choices[positionalKey] || [];
    for (const choice of choices) {
      if (choice.startsWith(current)) {
        completions.push(choice.replace(/:/g, "\\:"));
      }
    }
  }
  getPreviousArgChoices(args) {
    if (args.length < 1)
      return;
    let previousArg = args[args.length - 1];
    let filter = "";
    if (!previousArg.startsWith("-") && args.length > 1) {
      filter = previousArg;
      previousArg = args[args.length - 2];
    }
    if (!previousArg.startsWith("-"))
      return;
    const previousArgKey = previousArg.replace(/^-+/, "");
    const options = this.yargs.getOptions();
    const possibleAliases = [
      previousArgKey,
      ...this.yargs.getAliases()[previousArgKey] || []
    ];
    let choices;
    for (const possibleAlias of possibleAliases) {
      if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) && Array.isArray(options.choices[possibleAlias])) {
        choices = options.choices[possibleAlias];
        break;
      }
    }
    if (choices) {
      return choices.filter((choice) => !filter || choice.startsWith(filter));
    }
  }
  previousArgHasChoices(args) {
    const choices = this.getPreviousArgChoices(args);
    return choices !== undefined && choices.length > 0;
  }
  argsContainKey(args, key, negable) {
    const argsContains = (s) => args.indexOf((/^[^0-9]$/.test(s) ? "-" : "--") + s) !== -1;
    if (argsContains(key))
      return true;
    if (negable && argsContains(`no-${key}`))
      return true;
    if (this.aliases) {
      for (const alias of this.aliases[key]) {
        if (argsContains(alias))
          return true;
      }
    }
    return false;
  }
  completeOptionKey(key, completions, current, negable) {
    var _a2, _b2, _c2, _d;
    let keyWithDesc = key;
    if (this.zshShell) {
      const descs = this.usage.getDescriptions();
      const aliasKey = (_b2 = (_a2 = this === null || this === undefined ? undefined : this.aliases) === null || _a2 === undefined ? undefined : _a2[key]) === null || _b2 === undefined ? undefined : _b2.find((alias) => {
        const desc2 = descs[alias];
        return typeof desc2 === "string" && desc2.length > 0;
      });
      const descFromAlias = aliasKey ? descs[aliasKey] : undefined;
      const desc = (_d = (_c2 = descs[key]) !== null && _c2 !== undefined ? _c2 : descFromAlias) !== null && _d !== undefined ? _d : "";
      keyWithDesc = `${key.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const startsByTwoDashes = (s) => /^--/.test(s);
    const isShortOption = (s) => /^[^0-9]$/.test(s);
    const dashes = !startsByTwoDashes(current) && isShortOption(key) ? "-" : "--";
    completions.push(dashes + keyWithDesc);
    if (negable) {
      completions.push(dashes + "no-" + keyWithDesc);
    }
  }
  customCompletion(args, argv, current, done) {
    assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
    if (isSyncCompletionFunction(this.customCompletionFunction)) {
      const result = this.customCompletionFunction(current, argv);
      if (isPromise(result)) {
        return result.then((list) => {
          this.shim.process.nextTick(() => {
            done(null, list);
          });
        }).catch((err) => {
          this.shim.process.nextTick(() => {
            done(err, undefined);
          });
        });
      }
      return done(null, result);
    } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
      return this.customCompletionFunction(current, argv, (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted), (completions) => {
        done(null, completions);
      });
    } else {
      return this.customCompletionFunction(current, argv, (completions) => {
        done(null, completions);
      });
    }
  }
  getCompletion(args, done) {
    const current = args.length ? args[args.length - 1] : "";
    const argv = this.yargs.parse(args, true);
    const completionFunction = this.customCompletionFunction ? (argv2) => this.customCompletion(args, argv2, current, done) : (argv2) => this.defaultCompletion(args, argv2, current, done);
    return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
  }
  generateCompletionScript($0, cmd) {
    let script = this.zshShell ? completionZshTemplate : completionShTemplate;
    const name = this.shim.path.basename($0);
    if ($0.match(/\.js$/))
      $0 = `./${$0}`;
    script = script.replace(/{{app_name}}/g, name);
    script = script.replace(/{{completion_command}}/g, cmd);
    return script.replace(/{{app_path}}/g, $0);
  }
  registerFunction(fn) {
    this.customCompletionFunction = fn;
  }
  setParsed(parsed) {
    this.aliases = parsed.aliases;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/levenshtein.js
function levenshtein(a, b) {
  if (a.length === 0)
    return b.length;
  if (b.length === 0)
    return a.length;
  const matrix = [];
  let i;
  for (i = 0;i <= b.length; i++) {
    matrix[i] = [i];
  }
  let j;
  for (j = 0;j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (i = 1;i <= b.length; i++) {
    for (j = 1;j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) {
          matrix[i][j] = matrix[i - 2][j - 2] + 1;
        } else {
          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
        }
      }
    }
  }
  return matrix[b.length][a.length];
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/validation.js
function validation(yargs, usage2, shim2) {
  const __ = shim2.y18n.__;
  const __n = shim2.y18n.__n;
  const self2 = {};
  self2.nonOptionCount = function nonOptionCount(argv) {
    const demandedCommands = yargs.getDemandedCommands();
    const positionalCount = argv._.length + (argv["--"] ? argv["--"].length : 0);
    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
        }
      }
    }
  };
  self2.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
    }
  };
  self2.requiredArguments = function requiredArguments(argv, demandedOptions) {
    let missing = null;
    for (const key of Object.keys(demandedOptions)) {
      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
        missing = missing || {};
        missing[key] = demandedOptions[key];
      }
    }
    if (missing) {
      const customMsgs = [];
      for (const key of Object.keys(missing)) {
        const msg = missing[key];
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }
      const customMsg = customMsgs.length ? `\n${customMsgs.join("\n")}` : "";
      usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
    }
  };
  self2.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
    var _a2;
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv).forEach((key) => {
      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self2.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });
    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (checkPositionals) {
      const demandedCommands = yargs.getDemandedCommands();
      const maxNonOptDemanded = ((_a2 = demandedCommands._) === null || _a2 === undefined ? undefined : _a2.max) || 0;
      const expected = currentContext.commands.length + maxNonOptDemanded;
      if (expected < argv._.length) {
        argv._.slice(expected).forEach((key) => {
          key = String(key);
          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }
    if (unknown.length) {
      usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.map((s) => s.trim() ? s : `"${s}"`).join(", ")));
    }
  };
  self2.unknownCommands = function unknownCommands(argv) {
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (unknown.length > 0) {
      usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
      return true;
    } else {
      return false;
    }
  };
  self2.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }
    const newAliases = yargs.parsed.newAliases;
    return [key, ...aliases[key]].some((a) => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
  };
  self2.limitedChoices = function limitedChoices(argv) {
    const options = yargs.getOptions();
    const invalid = {};
    if (!Object.keys(options.choices).length)
      return;
    Object.keys(argv).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv[key]).forEach((value2) => {
          if (options.choices[key].indexOf(value2) === -1 && value2 !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value2);
          }
        });
      }
    });
    const invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length)
      return;
    let msg = __("Invalid values:");
    invalidKeys.forEach((key) => {
      msg += `\n  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
    });
    usage2.fail(msg);
  };
  let implied = {};
  self2.implies = function implies(key, value2) {
    argsert("<string|object> [array|number|string]", [key, value2], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.implies(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!implied[key]) {
        implied[key] = [];
      }
      if (Array.isArray(value2)) {
        value2.forEach((i) => self2.implies(key, i));
      } else {
        assertNotStrictEqual(value2, undefined, shim2);
        implied[key].push(value2);
      }
    }
  };
  self2.getImplied = function getImplied() {
    return implied;
  };
  function keyExists(argv, val) {
    const num = Number(val);
    val = isNaN(num) ? val : num;
    if (typeof val === "number") {
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv, val);
    }
    return val;
  }
  self2.implications = function implications(argv) {
    const implyFail = [];
    Object.keys(implied).forEach((key) => {
      const origKey = key;
      (implied[key] || []).forEach((value2) => {
        let key2 = origKey;
        const origValue = value2;
        key2 = keyExists(argv, key2);
        value2 = keyExists(argv, value2);
        if (key2 && !value2) {
          implyFail.push(` ${origKey} -> ${origValue}`);
        }
      });
    });
    if (implyFail.length) {
      let msg = `${__("Implications failed:")}\n`;
      implyFail.forEach((value2) => {
        msg += value2;
      });
      usage2.fail(msg);
    }
  };
  let conflicting = {};
  self2.conflicts = function conflicts(key, value2) {
    argsert("<string|object> [array|string]", [key, value2], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!conflicting[key]) {
        conflicting[key] = [];
      }
      if (Array.isArray(value2)) {
        value2.forEach((i) => self2.conflicts(key, i));
      } else {
        conflicting[key].push(value2);
      }
    }
  };
  self2.getConflicting = () => conflicting;
  self2.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value2) => {
          if (value2 && argv[key] !== undefined && argv[value2] !== undefined) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value2));
          }
        });
      }
    });
    if (yargs.getInternalMethods().getParserConfiguration()["strip-dashed"]) {
      Object.keys(conflicting).forEach((key) => {
        conflicting[key].forEach((value2) => {
          if (value2 && argv[shim2.Parser.camelCase(key)] !== undefined && argv[shim2.Parser.camelCase(value2)] !== undefined) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value2));
          }
        });
      });
    }
  };
  self2.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    const threshold = 3;
    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
    let recommended = null;
    let bestDistance = Infinity;
    for (let i = 0, candidate;(candidate = potentialCommands[i]) !== undefined; i++) {
      const d = levenshtein(cmd, candidate);
      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }
    if (recommended)
      usage2.fail(__("Did you mean %s?", recommended));
  };
  self2.reset = function reset(localLookup) {
    implied = objFilter(implied, (k) => !localLookup[k]);
    conflicting = objFilter(conflicting, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      implied,
      conflicting
    });
  };
  self2.unfreeze = function unfreeze() {
    const frozen = frozens.pop();
    assertNotStrictEqual(frozen, undefined, shim2);
    ({ implied, conflicting } = frozen);
  };
  return self2;
}
var specialKeys = ["$0", "--", "_"];

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/utils/apply-extends.js
function applyExtends(config, cwd, mergeExtends, _shim) {
  shim2 = _shim;
  let defaultConfig = {};
  if (Object.prototype.hasOwnProperty.call(config, "extends")) {
    if (typeof config.extends !== "string")
      return defaultConfig;
    const isPath = /\.json|\..*rc$/.test(config.extends);
    let pathToDefault = null;
    if (!isPath) {
      try {
        pathToDefault = require.resolve(config.extends);
      } catch (_err) {
        return config;
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends);
    }
    checkForCircularExtends(pathToDefault);
    previouslyVisitedConfigs.push(pathToDefault);
    defaultConfig = isPath ? JSON.parse(shim2.readFileSync(pathToDefault, "utf8")) : require(config.extends);
    delete config.extends;
    defaultConfig = applyExtends(defaultConfig, shim2.path.dirname(pathToDefault), mergeExtends, shim2);
  }
  previouslyVisitedConfigs = [];
  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
var checkForCircularExtends = function(cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`);
  }
};
var getPathToDefaultConfig = function(cwd, pathToExtend) {
  return shim2.path.resolve(cwd, pathToExtend);
};
var mergeDeep = function(config1, config2) {
  const target = {};
  function isObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  Object.assign(target, config1);
  for (const key of Object.keys(config2)) {
    if (isObject(config2[key]) && isObject(target[key])) {
      target[key] = mergeDeep(config1[key], config2[key]);
    } else {
      target[key] = config2[key];
    }
  }
  return target;
};
var previouslyVisitedConfigs = [];
var shim2;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/build/lib/yargs-factory.js
function YargsFactory(_shim) {
  return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
    const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
    Object.defineProperty(yargs, "argv", {
      get: () => {
        return yargs.parse();
      },
      enumerable: true
    });
    yargs.help();
    yargs.version();
    return yargs;
  };
}
function isYargsInstance(y) {
  return !!y && typeof y.getInternalMethods === "function";
}
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command;
var _YargsInstance_cwd;
var _YargsInstance_context;
var _YargsInstance_completion;
var _YargsInstance_completionCommand;
var _YargsInstance_defaultShowHiddenOpt;
var _YargsInstance_exitError;
var _YargsInstance_detectLocale;
var _YargsInstance_emittedWarnings;
var _YargsInstance_exitProcess;
var _YargsInstance_frozens;
var _YargsInstance_globalMiddleware;
var _YargsInstance_groups;
var _YargsInstance_hasOutput;
var _YargsInstance_helpOpt;
var _YargsInstance_isGlobalContext;
var _YargsInstance_logger;
var _YargsInstance_output;
var _YargsInstance_options;
var _YargsInstance_parentRequire;
var _YargsInstance_parserConfig;
var _YargsInstance_parseFn;
var _YargsInstance_parseContext;
var _YargsInstance_pkgs;
var _YargsInstance_preservedGroups;
var _YargsInstance_processArgs;
var _YargsInstance_recommendCommands;
var _YargsInstance_shim;
var _YargsInstance_strict;
var _YargsInstance_strictCommands;
var _YargsInstance_strictOptions;
var _YargsInstance_usage;
var _YargsInstance_usageConfig;
var _YargsInstance_versionOpt;
var _YargsInstance_validation;
var kCopyDoubleDash = Symbol("copyDoubleDash");
var kCreateLogger = Symbol("copyDoubleDash");
var kDeleteFromParserHintObject = Symbol("deleteFromParserHintObject");
var kEmitWarning = Symbol("emitWarning");
var kFreeze = Symbol("freeze");
var kGetDollarZero = Symbol("getDollarZero");
var kGetParserConfiguration = Symbol("getParserConfiguration");
var kGetUsageConfiguration = Symbol("getUsageConfiguration");
var kGuessLocale = Symbol("guessLocale");
var kGuessVersion = Symbol("guessVersion");
var kParsePositionalNumbers = Symbol("parsePositionalNumbers");
var kPkgUp = Symbol("pkgUp");
var kPopulateParserHintArray = Symbol("populateParserHintArray");
var kPopulateParserHintSingleValueDictionary = Symbol("populateParserHintSingleValueDictionary");
var kPopulateParserHintArrayDictionary = Symbol("populateParserHintArrayDictionary");
var kPopulateParserHintDictionary = Symbol("populateParserHintDictionary");
var kSanitizeKey = Symbol("sanitizeKey");
var kSetKey = Symbol("setKey");
var kUnfreeze = Symbol("unfreeze");
var kValidateAsync = Symbol("validateAsync");
var kGetCommandInstance = Symbol("getCommandInstance");
var kGetContext = Symbol("getContext");
var kGetHasOutput = Symbol("getHasOutput");
var kGetLoggerInstance = Symbol("getLoggerInstance");
var kGetParseContext = Symbol("getParseContext");
var kGetUsageInstance = Symbol("getUsageInstance");
var kGetValidationInstance = Symbol("getValidationInstance");
var kHasParseCallback = Symbol("hasParseCallback");
var kIsGlobalContext = Symbol("isGlobalContext");
var kPostProcess = Symbol("postProcess");
var kRebase = Symbol("rebase");
var kReset = Symbol("reset");
var kRunYargsParserAndExecuteCommands = Symbol("runYargsParserAndExecuteCommands");
var kRunValidation = Symbol("runValidation");
var kSetHasOutput = Symbol("setHasOutput");
var kTrackManuallySetKeys = Symbol("kTrackManuallySetKeys");

class YargsInstance {
  constructor(processArgs = [], cwd, parentRequire, shim3) {
    this.customScriptName = false;
    this.parsed = false;
    _YargsInstance_command.set(this, undefined);
    _YargsInstance_cwd.set(this, undefined);
    _YargsInstance_context.set(this, { commands: [], fullCommands: [] });
    _YargsInstance_completion.set(this, null);
    _YargsInstance_completionCommand.set(this, null);
    _YargsInstance_defaultShowHiddenOpt.set(this, "show-hidden");
    _YargsInstance_exitError.set(this, null);
    _YargsInstance_detectLocale.set(this, true);
    _YargsInstance_emittedWarnings.set(this, {});
    _YargsInstance_exitProcess.set(this, true);
    _YargsInstance_frozens.set(this, []);
    _YargsInstance_globalMiddleware.set(this, undefined);
    _YargsInstance_groups.set(this, {});
    _YargsInstance_hasOutput.set(this, false);
    _YargsInstance_helpOpt.set(this, null);
    _YargsInstance_isGlobalContext.set(this, true);
    _YargsInstance_logger.set(this, undefined);
    _YargsInstance_output.set(this, "");
    _YargsInstance_options.set(this, undefined);
    _YargsInstance_parentRequire.set(this, undefined);
    _YargsInstance_parserConfig.set(this, {});
    _YargsInstance_parseFn.set(this, null);
    _YargsInstance_parseContext.set(this, null);
    _YargsInstance_pkgs.set(this, {});
    _YargsInstance_preservedGroups.set(this, {});
    _YargsInstance_processArgs.set(this, undefined);
    _YargsInstance_recommendCommands.set(this, false);
    _YargsInstance_shim.set(this, undefined);
    _YargsInstance_strict.set(this, false);
    _YargsInstance_strictCommands.set(this, false);
    _YargsInstance_strictOptions.set(this, false);
    _YargsInstance_usage.set(this, undefined);
    _YargsInstance_usageConfig.set(this, {});
    _YargsInstance_versionOpt.set(this, null);
    _YargsInstance_validation.set(this, undefined);
    __classPrivateFieldSet(this, _YargsInstance_shim, shim3, "f");
    __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
    __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
    __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
    __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
    this.$0 = this[kGetDollarZero]();
    this[kReset]();
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
  }
  addHelpOpt(opt, msg) {
    const defaultHelpOpt = "help";
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
      __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
    }
    if (opt === false && msg === undefined)
      return this;
    __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === "string" ? opt : defaultHelpOpt, "f");
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show help"));
    return this;
  }
  help(opt, msg) {
    return this.addHelpOpt(opt, msg);
  }
  addShowHiddenOpt(opt, msg) {
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (opt === false && msg === undefined)
      return this;
    const showHiddenOpt = typeof opt === "string" ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    this.boolean(showHiddenOpt);
    this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show hidden options"));
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
    return this;
  }
  showHidden(opt, msg) {
    return this.addShowHiddenOpt(opt, msg);
  }
  alias(key, value2) {
    argsert("<object|string|array> [string|array]", [key, value2], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.alias.bind(this), "alias", key, value2);
    return this;
  }
  array(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("array", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  boolean(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("boolean", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  check(f, global2) {
    argsert("<function> [boolean]", [f, global2], arguments.length);
    this.middleware((argv, _yargs) => {
      return maybeAsyncResult(() => {
        return f(argv, _yargs.getOptions());
      }, (result) => {
        if (!result) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__("Argument check failed: %s", f.toString()));
        } else if (typeof result === "string" || result instanceof Error) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
        }
        return argv;
      }, (err) => {
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
        return argv;
      });
    }, false, global2);
    return this;
  }
  choices(key, value2) {
    argsert("<object|string|array> [string|array]", [key, value2], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.choices.bind(this), "choices", key, value2);
    return this;
  }
  coerce(keys, value2) {
    argsert("<object|string|array> [function]", [keys, value2], arguments.length);
    if (Array.isArray(keys)) {
      if (!value2) {
        throw new YError("coerce callback must be provided");
      }
      for (const key of keys) {
        this.coerce(key, value2);
      }
      return this;
    } else if (typeof keys === "object") {
      for (const key of Object.keys(keys)) {
        this.coerce(key, keys[key]);
      }
      return this;
    }
    if (!value2) {
      throw new YError("coerce callback must be provided");
    }
    __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs) => {
      let aliases;
      const shouldCoerce = Object.prototype.hasOwnProperty.call(argv, keys);
      if (!shouldCoerce) {
        return argv;
      }
      return maybeAsyncResult(() => {
        aliases = yargs.getAliases();
        return value2(argv[keys]);
      }, (result) => {
        argv[keys] = result;
        const stripAliased = yargs.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (aliases[keys] && stripAliased !== true) {
          for (const alias of aliases[keys]) {
            argv[alias] = result;
          }
        }
        return argv;
      }, (err) => {
        throw new YError(err.message);
      });
    }, keys);
    return this;
  }
  conflicts(key1, key2) {
    argsert("<string|object> [string|array]", [key1, key2], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
    return this;
  }
  config(key = "config", msg, parseFn) {
    argsert("[object|string] [string|function] [function]", [key, msg, parseFn], arguments.length);
    if (typeof key === "object" && !Array.isArray(key)) {
      key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
      return this;
    }
    if (typeof msg === "function") {
      parseFn = msg;
      msg = undefined;
    }
    this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Path to JSON config file"));
    (Array.isArray(key) ? key : [key]).forEach((k) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
    });
    return this;
  }
  completion(cmd, desc, fn) {
    argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
    if (typeof desc === "function") {
      fn = desc;
      desc = undefined;
    }
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion", "f");
    if (!desc && desc !== false) {
      desc = "generate completion script";
    }
    this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
    if (fn)
      __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
    return this;
  }
  command(cmd, description, builder, handler, middlewares, deprecated) {
    argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
    return this;
  }
  commands(cmd, description, builder, handler, middlewares, deprecated) {
    return this.command(cmd, description, builder, handler, middlewares, deprecated);
  }
  commandDir(dir, opts) {
    argsert("<string> [object]", [dir, opts], arguments.length);
    const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
    return this;
  }
  count(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("count", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  default(key, value2, defaultDescription) {
    argsert("<object|string|array> [*] [string]", [key, value2, defaultDescription], arguments.length);
    if (defaultDescription) {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
    }
    if (typeof value2 === "function") {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key])
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value2);
      value2 = value2.call();
    }
    this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), "default", key, value2);
    return this;
  }
  defaults(key, value2, defaultDescription) {
    return this.default(key, value2, defaultDescription);
  }
  demandCommand(min = 1, max, minMsg, maxMsg) {
    argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
    if (typeof max !== "number") {
      minMsg = max;
      max = Infinity;
    }
    this.global("_", false);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
      min,
      max,
      minMsg,
      maxMsg
    };
    return this;
  }
  demand(keys, max, msg) {
    if (Array.isArray(max)) {
      max.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
      max = Infinity;
    } else if (typeof max !== "number") {
      msg = max;
      max = Infinity;
    }
    if (typeof keys === "number") {
      assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      this.demandCommand(keys, max, msg, msg);
    } else if (Array.isArray(keys)) {
      keys.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
    } else {
      if (typeof msg === "string") {
        this.demandOption(keys, msg);
      } else if (msg === true || typeof msg === "undefined") {
        this.demandOption(keys);
      }
    }
    return this;
  }
  demandOption(keys, msg) {
    argsert("<object|string|array> [string]", [keys, msg], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), "demandedOptions", keys, msg);
    return this;
  }
  deprecateOption(option, message) {
    argsert("<string> [string|boolean]", [option, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
    return this;
  }
  describe(keys, description) {
    argsert("<object|string|array> [string]", [keys, description], arguments.length);
    this[kSetKey](keys, true);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
    return this;
  }
  detectLocale(detect) {
    argsert("<boolean>", [detect], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
    return this;
  }
  env(prefix) {
    argsert("[string|boolean]", [prefix], arguments.length);
    if (prefix === false)
      delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    else
      __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || "";
    return this;
  }
  epilogue(msg) {
    argsert("<string>", [msg], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
    return this;
  }
  epilog(msg) {
    return this.epilogue(msg);
  }
  example(cmd, description) {
    argsert("<string|array> [string]", [cmd, description], arguments.length);
    if (Array.isArray(cmd)) {
      cmd.forEach((exampleParams) => this.example(...exampleParams));
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
    }
    return this;
  }
  exit(code, err) {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
  }
  exitProcess(enabled = true) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
    return this;
  }
  fail(f) {
    argsert("<function|boolean>", [f], arguments.length);
    if (typeof f === "boolean" && f !== false) {
      throw new YError("Invalid first argument. Expected function or boolean 'false'");
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
    return this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(args, done) {
    argsert("<array> [function]", [args, done], arguments.length);
    if (!done) {
      return new Promise((resolve5, reject) => {
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions) => {
          if (err)
            reject(err);
          else
            resolve5(completions);
        });
      });
    } else {
      return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
    }
  }
  getDemandedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
  }
  getDemandedCommands() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
  }
  getExitProcess() {
    return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
  }
  getGroups() {
    return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
  }
  getHelp() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
        if (isPromise(parse)) {
          return parse.then(() => {
            return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
          });
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        return builderResponse.then(() => {
          return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
        });
      }
    }
    return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
  }
  getOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_options, "f");
  }
  getStrict() {
    return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
  }
  getStrictCommands() {
    return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
  }
  getStrictOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
  }
  global(globals, global2) {
    argsert("<string|array> [boolean]", [globals, global2], arguments.length);
    globals = [].concat(globals);
    if (global2 !== false) {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l) => globals.indexOf(l) === -1);
    } else {
      globals.forEach((g) => {
        if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g))
          __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
      });
    }
    return this;
  }
  group(opts, groupName) {
    argsert("<string|array> <string>", [opts, groupName], arguments.length);
    const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
    if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
      delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
    }
    const seen = {};
    __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key) => {
      if (seen[key])
        return false;
      return seen[key] = true;
    });
    return this;
  }
  hide(key) {
    argsert("<string>", [key], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
    return this;
  }
  implies(key, value2) {
    argsert("<string|object> [number|string|array]", [key, value2], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value2);
    return this;
  }
  locale(locale) {
    argsert("[string]", [locale], arguments.length);
    if (locale === undefined) {
      this[kGuessLocale]();
      return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
    }
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
    return this;
  }
  middleware(callback, applyBeforeValidation, global2) {
    return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global2);
  }
  nargs(key, value2) {
    argsert("<string|object|array> [number]", [key, value2], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), "narg", key, value2);
    return this;
  }
  normalize(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("normalize", keys);
    return this;
  }
  number(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("number", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  option(key, opt) {
    argsert("<string|object> [object]", [key, opt], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        this.options(k, key[k]);
      });
    } else {
      if (typeof opt !== "object") {
        opt = {};
      }
      this[kTrackManuallySetKeys](key);
      if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === "version" || (opt === null || opt === undefined ? undefined : opt.alias) === "version")) {
        this[kEmitWarning]([
          '"version" is a reserved word.',
          "Please do one of the following:",
          '- Disable version with `yargs.version(false)` if using "version" as an option',
          "- Use the built-in `yargs.version` method instead (if applicable)",
          "- Use a different option key",
          "https://yargs.js.org/docs/#api-reference-version"
        ].join("\n"), undefined, "versionWarning");
      }
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
      if (opt.alias)
        this.alias(key, opt.alias);
      const deprecate = opt.deprecate || opt.deprecated;
      if (deprecate) {
        this.deprecateOption(key, deprecate);
      }
      const demand = opt.demand || opt.required || opt.require;
      if (demand) {
        this.demand(key, demand);
      }
      if (opt.demandOption) {
        this.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : undefined);
      }
      if (opt.conflicts) {
        this.conflicts(key, opt.conflicts);
      }
      if ("default" in opt) {
        this.default(key, opt.default);
      }
      if (opt.implies !== undefined) {
        this.implies(key, opt.implies);
      }
      if (opt.nargs !== undefined) {
        this.nargs(key, opt.nargs);
      }
      if (opt.config) {
        this.config(key, opt.configParser);
      }
      if (opt.normalize) {
        this.normalize(key);
      }
      if (opt.choices) {
        this.choices(key, opt.choices);
      }
      if (opt.coerce) {
        this.coerce(key, opt.coerce);
      }
      if (opt.group) {
        this.group(key, opt.group);
      }
      if (opt.boolean || opt.type === "boolean") {
        this.boolean(key);
        if (opt.alias)
          this.boolean(opt.alias);
      }
      if (opt.array || opt.type === "array") {
        this.array(key);
        if (opt.alias)
          this.array(opt.alias);
      }
      if (opt.number || opt.type === "number") {
        this.number(key);
        if (opt.alias)
          this.number(opt.alias);
      }
      if (opt.string || opt.type === "string") {
        this.string(key);
        if (opt.alias)
          this.string(opt.alias);
      }
      if (opt.count || opt.type === "count") {
        this.count(key);
      }
      if (typeof opt.global === "boolean") {
        this.global(key, opt.global);
      }
      if (opt.defaultDescription) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
      }
      if (opt.skipValidation) {
        this.skipValidation(key);
      }
      const desc = opt.describe || opt.description || opt.desc;
      const descriptions = __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions();
      if (!Object.prototype.hasOwnProperty.call(descriptions, key) || typeof desc === "string") {
        this.describe(key, desc);
      }
      if (opt.hidden) {
        this.hide(key);
      }
      if (opt.requiresArg) {
        this.requiresArg(key);
      }
    }
    return this;
  }
  options(key, opt) {
    return this.option(key, opt);
  }
  parse(args, shortCircuit, _parseFn) {
    argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
    this[kFreeze]();
    if (typeof args === "undefined") {
      args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    }
    if (typeof shortCircuit === "object") {
      __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
      shortCircuit = _parseFn;
    }
    if (typeof shortCircuit === "function") {
      __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
      shortCircuit = false;
    }
    if (!shortCircuit)
      __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
      __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
    const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
    const tmpParsed = this.parsed;
    __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
    if (isPromise(parsed)) {
      return parsed.then((argv) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        return argv;
      }).catch((err) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        }
        throw err;
      }).finally(() => {
        this[kUnfreeze]();
        this.parsed = tmpParsed;
      });
    } else {
      if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
        __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
      this[kUnfreeze]();
      this.parsed = tmpParsed;
    }
    return parsed;
  }
  parseAsync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
  }
  parseSync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    if (isPromise(maybePromise)) {
      throw new YError(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    }
    return maybePromise;
  }
  parserConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
    return this;
  }
  pkgConf(key, rootPath) {
    argsert("<string> [string]", [key, rootPath], arguments.length);
    let conf = null;
    const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
    if (obj[key] && typeof obj[key] === "object") {
      conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
    }
    return this;
  }
  positional(key, opts) {
    argsert("<string> <object>", [key, opts], arguments.length);
    const supportedOpts = [
      "default",
      "defaultDescription",
      "implies",
      "normalize",
      "choices",
      "conflicts",
      "coerce",
      "type",
      "describe",
      "desc",
      "description",
      "alias"
    ];
    opts = objFilter(opts, (k, v) => {
      if (k === "type" && !["string", "number", "boolean"].includes(v))
        return false;
      return supportedOpts.includes(k);
    });
    const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
    const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
      array: [],
      alias: {},
      default: {},
      demand: {}
    };
    objectKeys(parseOptions).forEach((pk) => {
      const parseOption = parseOptions[pk];
      if (Array.isArray(parseOption)) {
        if (parseOption.indexOf(key) !== -1)
          opts[pk] = true;
      } else {
        if (parseOption[key] && !(pk in opts))
          opts[pk] = parseOption[key];
      }
    });
    this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
    return this.option(key, opts);
  }
  recommendCommands(recommend = true) {
    argsert("[boolean]", [recommend], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
    return this;
  }
  required(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  require(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  requiresArg(keys) {
    argsert("<array|string|object> [number]", [keys], arguments.length);
    if (typeof keys === "string" && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
      return this;
    } else {
      this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), "narg", keys, NaN);
    }
    return this;
  }
  showCompletionScript($0, cmd) {
    argsert("[string] [string]", [$0, cmd], arguments.length);
    $0 = $0 || this.$0;
    __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion"));
    return this;
  }
  showHelp(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
        if (isPromise(parse)) {
          parse.then(() => {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
          });
          return this;
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        builderResponse.then(() => {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        });
        return this;
      }
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
    return this;
  }
  scriptName(scriptName) {
    this.customScriptName = true;
    this.$0 = scriptName;
    return this;
  }
  showHelpOnFail(enabled, message) {
    argsert("[boolean|string] [string]", [enabled, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
    return this;
  }
  showVersion(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
    return this;
  }
  skipValidation(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("skipValidation", keys);
    return this;
  }
  strict(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
    return this;
  }
  strictCommands(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
    return this;
  }
  strictOptions(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
    return this;
  }
  string(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("string", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  terminalWidth() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
  }
  updateLocale(obj) {
    return this.updateStrings(obj);
  }
  updateStrings(obj) {
    argsert("<object>", [obj], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
    return this;
  }
  usage(msg, description, builder, handler) {
    argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
    if (description !== undefined) {
      assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if ((msg || "").match(/^\$0( |$)/)) {
        return this.command(msg, description, builder, handler);
      } else {
        throw new YError(".usage() description must start with $0 if being used as alias for .command()");
      }
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
      return this;
    }
  }
  usageConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_usageConfig, config, "f");
    return this;
  }
  version(opt, msg, ver) {
    const defaultVersionOpt = "version";
    argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(undefined);
      __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
    }
    if (arguments.length === 0) {
      ver = this[kGuessVersion]();
      opt = defaultVersionOpt;
    } else if (arguments.length === 1) {
      if (opt === false) {
        return this;
      }
      ver = opt;
      opt = defaultVersionOpt;
    } else if (arguments.length === 2) {
      ver = msg;
      msg = undefined;
    }
    __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === "string" ? opt : defaultVersionOpt, "f");
    msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show version number");
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || undefined);
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
    return this;
  }
  wrap(cols) {
    argsert("<number|null|undefined>", [cols], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
    return this;
  }
  [(_YargsInstance_command = new WeakMap, _YargsInstance_cwd = new WeakMap, _YargsInstance_context = new WeakMap, _YargsInstance_completion = new WeakMap, _YargsInstance_completionCommand = new WeakMap, _YargsInstance_defaultShowHiddenOpt = new WeakMap, _YargsInstance_exitError = new WeakMap, _YargsInstance_detectLocale = new WeakMap, _YargsInstance_emittedWarnings = new WeakMap, _YargsInstance_exitProcess = new WeakMap, _YargsInstance_frozens = new WeakMap, _YargsInstance_globalMiddleware = new WeakMap, _YargsInstance_groups = new WeakMap, _YargsInstance_hasOutput = new WeakMap, _YargsInstance_helpOpt = new WeakMap, _YargsInstance_isGlobalContext = new WeakMap, _YargsInstance_logger = new WeakMap, _YargsInstance_output = new WeakMap, _YargsInstance_options = new WeakMap, _YargsInstance_parentRequire = new WeakMap, _YargsInstance_parserConfig = new WeakMap, _YargsInstance_parseFn = new WeakMap, _YargsInstance_parseContext = new WeakMap, _YargsInstance_pkgs = new WeakMap, _YargsInstance_preservedGroups = new WeakMap, _YargsInstance_processArgs = new WeakMap, _YargsInstance_recommendCommands = new WeakMap, _YargsInstance_shim = new WeakMap, _YargsInstance_strict = new WeakMap, _YargsInstance_strictCommands = new WeakMap, _YargsInstance_strictOptions = new WeakMap, _YargsInstance_usage = new WeakMap, _YargsInstance_usageConfig = new WeakMap, _YargsInstance_versionOpt = new WeakMap, _YargsInstance_validation = new WeakMap, kCopyDoubleDash)](argv) {
    if (!argv._ || !argv["--"])
      return argv;
    argv._.push.apply(argv._, argv["--"]);
    try {
      delete argv["--"];
    } catch (_err) {
    }
    return argv;
  }
  [kCreateLogger]() {
    return {
      log: (...args) => {
        if (!this[kHasParseCallback]())
          console.log(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      },
      error: (...args) => {
        if (!this[kHasParseCallback]())
          console.error(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      }
    };
  }
  [kDeleteFromParserHintObject](optionKey) {
    objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey) => {
      if (((key) => key === "configObjects")(hintKey))
        return;
      const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
      if (Array.isArray(hint)) {
        if (hint.includes(optionKey))
          hint.splice(hint.indexOf(optionKey), 1);
      } else if (typeof hint === "object") {
        delete hint[optionKey];
      }
    });
    delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
  }
  [kEmitWarning](warning, type, deduplicationId) {
    if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
      __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
    }
  }
  [kFreeze]() {
    __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
      options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
      configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
      exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
      groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
      strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
      strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
      strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
      completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
      output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
      exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
      hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
      parsed: this.parsed,
      parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
      parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
    });
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
  }
  [kGetDollarZero]() {
    let $0 = "";
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
    } else {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
    }
    $0 = default$0.map((x) => {
      const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
      return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
    }).join(" ").trim();
    if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_") && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_")) {
      $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_").replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, "");
    }
    return $0;
  }
  [kGetParserConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
  }
  [kGetUsageConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_usageConfig, "f");
  }
  [kGuessLocale]() {
    if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f"))
      return;
    const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_ALL") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_MESSAGES") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANG") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(locale.replace(/[.:].*/, ""));
  }
  [kGuessVersion]() {
    const obj = this[kPkgUp]();
    return obj.version || "unknown";
  }
  [kParsePositionalNumbers](argv) {
    const args = argv["--"] ? argv["--"] : argv._;
    for (let i = 0, arg;(arg = args[i]) !== undefined; i++) {
      if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
        args[i] = Number(arg);
      }
    }
    return argv;
  }
  [kPkgUp](rootPath) {
    const npath = rootPath || "*";
    if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath])
      return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
    let obj = {};
    try {
      let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
      if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
        startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
      }
      const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names) => {
        if (names.includes("package.json")) {
          return "package.json";
        } else {
          return;
        }
      });
      assertNotStrictEqual(pkgJsonPath, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, "utf8"));
    } catch (_noop) {
    }
    __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
    return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
  }
  [kPopulateParserHintArray](type, keys) {
    keys = [].concat(keys);
    keys.forEach((key) => {
      key = this[kSanitizeKey](key);
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
    });
  }
  [kPopulateParserHintSingleValueDictionary](builder, type, key, value2) {
    this[kPopulateParserHintDictionary](builder, type, key, value2, (type2, key2, value3) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = value3;
    });
  }
  [kPopulateParserHintArrayDictionary](builder, type, key, value2) {
    this[kPopulateParserHintDictionary](builder, type, key, value2, (type2, key2, value3) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] || []).concat(value3);
    });
  }
  [kPopulateParserHintDictionary](builder, type, key, value2, singleKeyHandler) {
    if (Array.isArray(key)) {
      key.forEach((k) => {
        builder(k, value2);
      });
    } else if (((key2) => typeof key2 === "object")(key)) {
      for (const k of objectKeys(key)) {
        builder(k, key[k]);
      }
    } else {
      singleKeyHandler(type, this[kSanitizeKey](key), value2);
    }
  }
  [kSanitizeKey](key) {
    if (key === "__proto__")
      return "___proto___";
    return key;
  }
  [kSetKey](key, set) {
    this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), "key", key, set);
    return this;
  }
  [kUnfreeze]() {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
    assertNotStrictEqual(frozen, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
    let configObjects;
    _a2 = this, _b2 = this, _c2 = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, {
      options: { set value(_o) {
        __classPrivateFieldSet(_a2, _YargsInstance_options, _o, "f");
      } }.value,
      configObjects,
      exitProcess: { set value(_o) {
        __classPrivateFieldSet(_b2, _YargsInstance_exitProcess, _o, "f");
      } }.value,
      groups: { set value(_o) {
        __classPrivateFieldSet(_c2, _YargsInstance_groups, _o, "f");
      } }.value,
      output: { set value(_o) {
        __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
      } }.value,
      exitError: { set value(_o) {
        __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
      } }.value,
      hasOutput: { set value(_o) {
        __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
      } }.value,
      parsed: this.parsed,
      strict: { set value(_o) {
        __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
      } }.value,
      strictCommands: { set value(_o) {
        __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
      } }.value,
      strictOptions: { set value(_o) {
        __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
      } }.value,
      completionCommand: { set value(_o) {
        __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
      } }.value,
      parseFn: { set value(_o) {
        __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
      } }.value,
      parseContext: { set value(_o) {
        __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
      } }.value
    } = frozen;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
  }
  [kValidateAsync](validation3, argv) {
    return maybeAsyncResult(argv, (result) => {
      validation3(result);
      return result;
    });
  }
  getInternalMethods() {
    return {
      getCommandInstance: this[kGetCommandInstance].bind(this),
      getContext: this[kGetContext].bind(this),
      getHasOutput: this[kGetHasOutput].bind(this),
      getLoggerInstance: this[kGetLoggerInstance].bind(this),
      getParseContext: this[kGetParseContext].bind(this),
      getParserConfiguration: this[kGetParserConfiguration].bind(this),
      getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
      getUsageInstance: this[kGetUsageInstance].bind(this),
      getValidationInstance: this[kGetValidationInstance].bind(this),
      hasParseCallback: this[kHasParseCallback].bind(this),
      isGlobalContext: this[kIsGlobalContext].bind(this),
      postProcess: this[kPostProcess].bind(this),
      reset: this[kReset].bind(this),
      runValidation: this[kRunValidation].bind(this),
      runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
      setHasOutput: this[kSetHasOutput].bind(this)
    };
  }
  [kGetCommandInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_command, "f");
  }
  [kGetContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_context, "f");
  }
  [kGetHasOutput]() {
    return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
  }
  [kGetLoggerInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
  }
  [kGetParseContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
  }
  [kGetUsageInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
  }
  [kGetValidationInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
  }
  [kHasParseCallback]() {
    return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
  }
  [kIsGlobalContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_isGlobalContext, "f");
  }
  [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
    if (calledFromCommand)
      return argv;
    if (isPromise(argv))
      return argv;
    if (!populateDoubleDash) {
      argv = this[kCopyDoubleDash](argv);
    }
    const parsePositionalNumbers = this[kGetParserConfiguration]()["parse-positional-numbers"] || this[kGetParserConfiguration]()["parse-positional-numbers"] === undefined;
    if (parsePositionalNumbers) {
      argv = this[kParsePositionalNumbers](argv);
    }
    if (runGlobalMiddleware) {
      argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
    }
    return argv;
  }
  [kReset](aliases = {}) {
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
    const tmpOptions = {};
    tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
    tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
    const localLookup = {};
    tmpOptions.local.forEach((l) => {
      localLookup[l] = true;
      (aliases[l] || []).forEach((a) => {
        localLookup[a] = true;
      });
    });
    Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName) => {
      const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key) => !(key in localLookup));
      if (keys.length > 0) {
        acc[groupName] = keys;
      }
      return acc;
    }, {}));
    __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
    const arrayOptions = [
      "array",
      "boolean",
      "string",
      "skipValidation",
      "count",
      "normalize",
      "number",
      "hiddenOptions"
    ];
    const objectOptions = [
      "narg",
      "key",
      "alias",
      "default",
      "defaultDescription",
      "config",
      "choices",
      "demandedOptions",
      "demandedCommands",
      "deprecatedOptions"
    ];
    arrayOptions.forEach((k) => {
      tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k2) => !localLookup[k2]);
    });
    objectOptions.forEach((k) => {
      tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k2) => !localLookup[k2]);
    });
    tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f"))
      __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_output, "", "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
    this.parsed = false;
    return this;
  }
  [kRebase](base, dir) {
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
  }
  [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
    let skipValidation = !!calledFromCommand || helpOnly;
    args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
    const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration["populate--"];
    const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
      "populate--": true
    });
    const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
      configuration: { "parse-positional-numbers": false, ...config }
    }));
    const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
    let argvPromise = undefined;
    const aliases = parsed.aliases;
    let helpOptSet = false;
    let versionOptSet = false;
    Object.keys(argv).forEach((key) => {
      if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) {
        helpOptSet = true;
      } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) {
        versionOptSet = true;
      }
    });
    argv.$0 = this.$0;
    this.parsed = parsed;
    if (commandIndex === 0) {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
    }
    try {
      this[kGuessLocale]();
      if (shortCircuit) {
        return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
        const helpCmds = [__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k) => k.length > 1);
        if (helpCmds.includes("" + argv._[argv._.length - 1])) {
          argv._.pop();
          helpOptSet = true;
        }
      }
      __classPrivateFieldSet(this, _YargsInstance_isGlobalContext, false, "f");
      const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
      const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
      const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
      if (argv._.length) {
        if (handlerKeys.length) {
          let firstUnknownCommand;
          for (let i = commandIndex || 0, cmd;argv._[i] !== undefined; i++) {
            cmd = String(argv._[i]);
            if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
              return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              firstUnknownCommand = cmd;
              break;
            }
          }
          if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
          }
        }
        if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          this.showCompletionScript();
          this.exit(0);
        }
      }
      if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
        const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
        return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (requestCompletions) {
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
          setBlocking(true);
        args = [].concat(args);
        const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions) => {
          if (err)
            throw new YError(err.message);
          (completions || []).forEach((completion3) => {
            __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion3);
          });
          this.exit(0);
        });
        return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
      }
      if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
        if (helpOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          this.showHelp("log");
          this.exit(0);
        } else if (versionOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion("log");
          this.exit(0);
        }
      }
      if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
        skipValidation = Object.keys(argv).some((key) => __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true);
      }
      if (!skipValidation) {
        if (parsed.error)
          throw new YError(parsed.error.message);
        if (!requestCompletions) {
          const validation3 = this[kRunValidation](aliases, {}, parsed.error);
          if (!calledFromCommand) {
            argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
          }
          argvPromise = this[kValidateAsync](validation3, argvPromise !== null && argvPromise !== undefined ? argvPromise : argv);
          if (isPromise(argvPromise) && !calledFromCommand) {
            argvPromise = argvPromise.then(() => {
              return applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
            });
          }
        }
      }
    } catch (err) {
      if (err instanceof YError)
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
      else
        throw err;
    }
    return this[kPostProcess](argvPromise !== null && argvPromise !== undefined ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
  }
  [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
    const demandedOptions = { ...this.getDemandedOptions() };
    return (argv) => {
      if (parseErrors)
        throw new YError(parseErrors.message);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
      let failedStrictCommands = false;
      if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
        failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
      } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
      }
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
    };
  }
  [kSetHasOutput]() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
  }
  [kTrackManuallySetKeys](keys) {
    if (typeof keys === "string") {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    } else {
      for (const k of keys) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
      }
    }
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yargs/index.mjs
var Yargs = YargsFactory(esm_default);
var yargs_default = Yargs;

// src/commands/info.tsx
import {existsSync as existsSync3} from "fs";

// src/tui/composer.ts
function build(optionalStartString) {
  return new Composer(optionalStartString);
}

class Composer {
  parts = [];
  constructor(start = "") {
    if (start instanceof Composer) {
      this.parts = start.parts;
    } else {
      this.parts = [start];
    }
  }
  h1(text) {
    return this.add(`# ${text}`);
  }
  h2(text) {
    return this.add(`## ${text}`);
  }
  h3(text) {
    return this.add(`### ${text}`);
  }
  h4(text) {
    return this.add(`#### ${text}`);
  }
  h5(text) {
    return this.add(`##### ${text}`);
  }
  h6(text) {
    return this.add(`###### ${text}`);
  }
  list(composer, options = {}) {
    if (composer.length === 0) {
      return this.add(options.emptyMessage || "");
    }
    return this.add(composer.map((c) => c.render()).join("\n"));
  }
  p(text) {
    return this.add(text);
  }
  code(text) {
    return this.add(`\`\`\`${text}\`\`\``);
  }
  blockquote(text) {
    return this.add(`> ${text}`);
  }
  listItem(text) {
    return this.add(`* ${text}`);
  }
  add(text) {
    if (!text) {
      return this;
    }
    this.parts.push(text);
    return this;
  }
  append(composer) {
    return this.add(composer.parts.join("\n"));
  }
  render(data) {
    return this.tpl(this.parts.join("\n"), data);
  }
  tpl(text, data) {
    if (!data) {
      return text;
    }
    return text.replace(/\${(\w+)}/g, (_, key) => {
      return data[key];
    });
  }
}

// src/components/property.ts
function propertyView(prop) {
  const value2 = typeof prop.value === "function" ? "<Bound Function>" : prop.value;
  return build().listItem(`${prop.name}: ${value2}`);
}

// src/components/loader.ts
function loaderView(loader) {
  return build().h3(`Loader: ${loader.name}`).p(loader.description).h4("Properties").list(Object.values(loader.properties).map((prop) => propertyView(prop)), { emptyMessage: "No properties found" });
}

// src/components/rule.ts
function ruleView(rule) {
  return build().h1(`Rule: ${rule.name}`).p(rule.description);
}

// src/components/project.ts
function projectView(project) {
  return build().h1(`Project: ${project.config?.name}`).p(project.config?.description).h2("Loaders").list(project.loaders.map((loader2) => loaderView(loader2))).h2("Rules").list(project.validator.rules.map((rule2) => ruleView(rule2)));
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/uuid/wrapper.mjs
var dist = __toESM(require_dist(), 1);
var v1 = dist.default.v1;
var v3 = dist.default.v3;
var v4 = dist.default.v4;
var v5 = dist.default.v5;
var NIL = dist.default.NIL;
var version = dist.default.version;
var validate = dist.default.validate;
var stringify = dist.default.stringify;
var parse = dist.default.parse;

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/project.ts
import fs2 from "fs";
import path2 from "path";

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/orchestrator.ts
class Orchestrator {
  projects = [];
  constructor() {
    this.projects = [];
  }
  add(project) {
    this.projects.push(project);
  }
  project(projectId) {
    return this.projects.find((p) => p.id === projectId);
  }
}
var orchestrator_default = new Orchestrator;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/zod/lib/index.mjs
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value2) => {
    if (typeof value2 === "bigint") {
      return value2.toString();
    }
    return value2;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value2 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value2.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value2.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value2.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value2) => ({ status: "dirty", value: value2 });
var OK = (value2) => ({ status: "valid", value: value2 });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value2, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value2;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === undefined ? undefined : params.async) !== null && _a2 !== undefined ? _a2 : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult2 = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult2) ? maybeAsyncResult2 : Promise.resolve(maybeAsyncResult2));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation3, message) {
    return this.refinement((data) => regex.test(data), {
      validation: validation3,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a2 = options === null || options === undefined ? undefined : options.offset) !== null && _a2 !== undefined ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value2, options) {
    return this._addCheck({
      kind: "includes",
      value: value2,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value2, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value2, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value2 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value2 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a2, _b2, _c2, _d;
          const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === undefined ? undefined : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== undefined ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value2 of discriminatorValues) {
        if (optionsMap.has(value2)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value2)}`);
        }
        optionsMap.set(value2, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left2, right2]) => handleParsed(left2, right2));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left2, right2, params) => {
  return new ZodIntersection({
    left: left2,
    right: right2,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value2], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          if (key.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value2.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value2.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value2 = pair.value;
        if (key.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value2.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value2.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value2, params) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b2;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a2 = p.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/helpers/config.ts
var import_toml = __toESM(require_toml(), 1);
import {existsSync as existsSync2, readFileSync as readFileSync4} from "fs";
import {dirname as dirname3, extname as extname2, basename as basename2, resolve as resolve5} from "path";

// /Users/karimshehadeh/dev/karim/hanto/node_modules/yaml/dist/index.js
var composer5 = require_composer();
var Document = require_Document();
var Schema = require_Schema();
var errors = require_errors();
var Alias = require_Alias();
var identity = require_identity();
var Pair = require_Pair();
var Scalar = require_Scalar();
var YAMLMap = require_YAMLMap();
var YAMLSeq = require_YAMLSeq();
var cst = require_cst();
var lexer = require_lexer();
var lineCounter = require_line_counter();
var parser2 = require_parser2();
var publicApi = require_public_api();
var visit = require_visit();
var $Composer = composer5.Composer;
var $Document = Document.Document;
var $Schema = Schema.Schema;
var $YAMLError = errors.YAMLError;
var $YAMLParseError = errors.YAMLParseError;
var $YAMLWarning = errors.YAMLWarning;
var $Alias = Alias.Alias;
var $isAlias = identity.isAlias;
var $isCollection = identity.isCollection;
var $isDocument = identity.isDocument;
var $isMap = identity.isMap;
var $isNode = identity.isNode;
var $isPair = identity.isPair;
var $isScalar = identity.isScalar;
var $isSeq = identity.isSeq;
var $Pair = Pair.Pair;
var $Scalar = Scalar.Scalar;
var $YAMLMap = YAMLMap.YAMLMap;
var $YAMLSeq = YAMLSeq.YAMLSeq;
var $Lexer = lexer.Lexer;
var $LineCounter = lineCounter.LineCounter;
var $Parser = parser2.Parser;
var $parse = publicApi.parse;
var $parseAllDocuments = publicApi.parseAllDocuments;
var $parseDocument = publicApi.parseDocument;
var $stringify = publicApi.stringify;
var $visit = visit.visit;
var $visitAsync = visit.visitAsync;

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/helpers/file-helpers.ts
import * as fs from "fs";
import * as path from "path";
function isValidFile(file) {
  return fs.existsSync(file) && fs.statSync(file).isFile();
}
function isValidDirectory(dir) {
  return fs.existsSync(dir) && fs.statSync(dir).isDirectory();
}

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/helpers/config.ts
var parseJson = JSON.parse;
var configParsers = [
  {
    name: "JS/TS Parser",
    extensions: [".js", ".jsx", ".mjs", ".cjs", ".ts", ".tsx"],
    parser: async (file) => {
      return await import(file);
    }
  },
  {
    name: "JSON Parser",
    extensions: [".json", ".json5"],
    parser: (file) => {
      return parseJson(readFileSync4(file, "utf8"));
    }
  },
  {
    name: "TOML Parser",
    extensions: [".toml"],
    parser: (file) => {
      return import_toml.parse(readFileSync4(file, "utf8"));
    }
  },
  {
    name: "YAML Parser",
    extensions: [".yaml", ".yml"],
    parser: (file) => {
      return $parse(readFileSync4(file, "utf8"));
    }
  }
];
var configBaseNames = [".hanto.config", "hanto.config", "hanto", ".hanto"];
var CongigSchema = z.object({
  name: z.string(),
  version: z.string().optional(),
  description: z.string().optional(),
  root: z.string().optional(),
  loaders: z.array(z.string()).optional()
});

class ProjectConfig {
  _path = undefined;
  _config = undefined;
  warnings = [];
  errors = [];
  constructor(root) {
    let configPath = undefined;
    if (isValidFile(root)) {
      configPath = root;
    } else if (isValidDirectory(root)) {
      let configFiles = this.findInUpwardsDirectory(root);
      if (configFiles.length === 0) {
        configFiles = this.findInConfigDirectory(root);
      }
      if (configFiles.length > 0) {
        if (configFiles.length > 1) {
          this.warnings.push({
            message: `Found multiple config files in ${root}. Using ${configFiles[0]}`
          });
        }
        configPath = configFiles[0];
      }
    } else {
      this.errors.push({
        message: `Could not find config file in ${root}`
      });
    }
    if (configPath) {
      this._config = this.parse(configPath);
      if (this._config) {
        this._path = configPath;
      }
    }
  }
  findInUpwardsDirectory(dir) {
    const configFiles = this.findInDirectory(dir);
    if (configFiles.length > 0) {
      return configFiles;
    } else {
      const parentDir = resolve5(dir, "..");
      if (parentDir !== dir) {
        return this.findInUpwardsDirectory(parentDir);
      }
    }
    return [];
  }
  get path() {
    return this._path;
  }
  get ob() {
    return this._config;
  }
  get root() {
    if (this._config?.root) {
      return this._config.root;
    } else {
      return this.path ? dirname3(this.path) : resolve5(".");
    }
  }
  findInConfigDirectory(dir) {
    const configFiles = this.findInDirectory(resolve5(dir, "config"));
    if (configFiles.length > 0) {
      return configFiles;
    } else {
      return [];
    }
  }
  findInDirectory(dir) {
    const extensions = this.allowedExtensions();
    const configFiles = configBaseNames.map((baseName) => {
      const foundExtension = extensions.find((ext) => {
        const fileName = resolve5(dir, `${baseName}${ext}`);
        if (existsSync2(fileName)) {
          return true;
        }
      });
      if (foundExtension) {
        return resolve5(dir, `${baseName}${foundExtension}`);
      }
    }).filter((f) => f !== undefined);
    return configFiles;
  }
  allowedExtensions() {
    return configParsers.flatMap((p) => p.extensions);
  }
  parse(fileName) {
    try {
      const baseName = basename2(fileName);
      if (configBaseNames.find((b) => baseName.startsWith(b))) {
        const ext = extname2(fileName);
        const parser3 = configParsers.find((parser4) => {
          return parser4.extensions.includes(ext);
        });
        const ob = parser3?.parser(fileName);
        const result = CongigSchema.safeParse(ob);
        if (result.success) {
          return result.data;
        } else {
          result.error.issues.forEach((e) => {
            this.errors.push({
              message: e.message,
              path: e.path
            });
          });
        }
      }
    } catch (error) {
      this.errors.push({
        message: `Could not parse config file ${fileName}: ${error}`,
        path: [fileName]
      });
    }
    return;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/validator.ts
class Validator {
  _projectId;
  _valid;
  _errors;
  _warnings;
  _rules;
  constructor() {
    this._projectId = "";
    this._valid = false;
    this._errors = [];
    this._warnings = [];
    this._rules = [];
  }
  initialize(projectId) {
    this._projectId = projectId;
    this._rules.forEach((r) => {
      if (!r.initialize(projectId)) {
        this._errors.push({
          message: `Failed to initialize rule ${r.name}`
        });
      }
    });
    return this._errors.length === 0;
  }
  add(rule2) {
    this._rules.push(rule2);
  }
  get rules() {
    return this._rules;
  }
  async validate() {
    for (const rule2 of this._rules) {
      if (!rule2.active) {
        continue;
      }
      const result = await rule2.check();
      if (!result) {
        this._errors.push(...rule2.errors);
        this._warnings.push(...rule2.warnings);
      } else {
        this._warnings.push(...rule2.warnings);
        if (rule2.isErrorAsWarning) {
          this._warnings.push(...rule2.errors);
        } else {
          this._errors.push(...rule2.errors);
        }
      }
    }
    return this._errors.length === 0;
  }
  get project() {
    return orchestrator_default.project(this._projectId);
  }
  get errors() {
    return this._errors;
  }
  get warnings() {
    return this._warnings;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/project.ts
async function createProject(path3) {
  const project = new Project(path3);
  orchestrator_default.add(project);
  await project.load();
  return project;
}

class Project {
  _id;
  _loaders = [];
  _validator = new Validator;
  _config = undefined;
  _errors = [];
  _warnings = [];
  constructor(path3) {
    this._id = v5("https://www.w3.org/", v5.URL);
    if (path3) {
      this._config = new ProjectConfig(path3);
      if (this._config.errors.length > 0) {
        throw new Error(`Could not load project at ${path3}: \n\t${this._config.errors.map((e) => e.message).join("\n\t")}`);
      }
    }
  }
  get id() {
    return this._id;
  }
  get config() {
    return this._config?.ob;
  }
  get dir() {
    return this._config?.root;
  }
  async add(loader2) {
    if (this._loaders.find((l) => l.name === loader2.name)) {
      throw new Error(`Loader ${loader2.name} already exists`);
    }
    if (loader2.initialize(this.id)) {
      this._loaders.push(loader2);
    }
  }
  get validator() {
    return this._validator;
  }
  loader(name) {
    return this._loaders.find((l) => l.name === name);
  }
  get loaders() {
    return this._loaders;
  }
  async load() {
    const loaders = this._config?.ob?.loaders;
    if (loaders) {
      for (const l of loaders) {
        try {
          const { default: api } = await import(l);
          if (api) {
            this.add(api.loader);
            if (api.rules) {
              for (const rule2 of api.rules) {
                this._validator.add(rule2);
              }
            }
          }
        } catch (err) {
          this.errors.push({
            message: `Could not load loader ${l}: ${err}`,
            path: [l]
          });
        }
      }
    }
    for (const loader2 of this._loaders) {
      await loader2.load();
    }
  }
  get errors() {
    return this._errors;
  }
  get warnings() {
    return this._warnings;
  }
  findFile(pathToSearch, fileName, depth = 0) {
    const entries = fs2.readdirSync(pathToSearch, {
      withFileTypes: true
    });
    for (const entry of entries) {
      const entryPath = path2.join(pathToSearch, entry.name);
      if (entry.isDirectory()) {
        if (depth !== 0) {
          const nestedPath = this.findFile(entryPath, fileName, depth - 1);
          if (nestedPath) {
            return nestedPath;
          }
        }
      } else if (entry.name === fileName) {
        return entryPath;
      }
    }
    return null;
  }
}
// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/loader.ts
class Loader {
  _projectId;
  _valid;
  _errors;
  _warnings;
  _properties;
  _propertyDefinitions;
  constructor(propertyDefinitions) {
    this._projectId = "";
    this._valid = false;
    this._errors = [];
    this._warnings = [];
    this._properties = {};
    this._propertyDefinitions = propertyDefinitions;
  }
  initialize(projectId) {
    this._projectId = projectId;
    return true;
  }
  get project() {
    return orchestrator_default.project(this._projectId);
  }
  get valid() {
    return this._valid;
  }
  get errors() {
    return this._errors;
  }
  get warnings() {
    return this._warnings;
  }
  get properties() {
    return this._propertyDefinitions.reduce((final, p) => {
      final[p.name] = {
        ...p,
        value: this._properties[p.name]
      };
      return final;
    }, {});
  }
  set(name, value2) {
    const def = this._propertyDefinitions.find((p) => p.name === name);
    if (!def) {
      throw new Error(`Property ${name} invalid`);
    }
    if (def.valueSchema && typeof value2 !== "function") {
      const parseResult = def.valueSchema.safeParse(value2);
      if (!parseResult.success) {
        throw new Error(`Property ${name} has an invalid type: ${parseResult.error.issues.map((i) => i.message).join(", ")}`);
      }
    }
    this._properties[name] = value2;
  }
  str(name) {
    const val = this.prop(name)?.value;
    return val?.toString();
  }
  num(name) {
    const val = this.prop(name)?.value;
    if (typeof val === "number") {
      return val;
    }
  }
  prop(name) {
    const p = this._propertyDefinitions.find((p2) => p2.name === name);
    if (p) {
      return {
        ...p,
        value: this._properties[p.name]
      };
    }
    return;
  }
  call(name, options) {
    const prop = this.prop(name);
    if (typeof prop?.value === "function") {
      const optionsParsed = prop.optionsSchema?.safeParse(options);
      if (optionsParsed?.success) {
        const val = prop?.value(optionsParsed.data);
        if (prop.valueSchema) {
          const parseResult = prop.valueSchema.safeParse(val);
          if (!parseResult.success) {
            throw new Error(`Function ${name} returned an invalid type: ${parseResult.error.issues.map((i) => i.message).join(", ")}`);
          }
        }
        return val;
      } else {
        throw new Error(`Invalid options given to call function ${name}`);
      }
    } else {
      throw new Error(`Property ${name} is not a function or doesn't exist`);
    }
  }
}
// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/rule.ts
class Rule {
  _projectId;
  _valid;
  _errors;
  _warnings;
  _active;
  _errorsAsWarnings;
  constructor() {
    this._projectId = "";
    this._valid = false;
    this._errors = [];
    this._warnings = [];
    this._active = true;
    this._errorsAsWarnings = false;
  }
  initialize(projectId) {
    this._projectId = projectId;
    return true;
  }
  get project() {
    return orchestrator_default.project(this._projectId);
  }
  get errors() {
    return this._errors;
  }
  get warnings() {
    return this._warnings;
  }
  get isErrorAsWarning() {
    return this._errorsAsWarnings;
  }
  get active() {
    return this._active;
  }
  set active(value2) {
    this._active = value2;
  }
  set errorsAsWarnings(value2) {
    this._errorsAsWarnings = value2;
  }
}
// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/parser/file.ts
import fs4 from "fs";
var core = __toESM(require_lib33(), 1);

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/parser/import.ts
import path4 from "path";

// /Users/karimshehadeh/dev/karim/hanto/packages/core/src/lib/helpers/nearest-project-root.ts
import path3 from "path";
import fs3 from "fs";
// /Users/karimshehadeh/dev/karim/hanto/node_modules/marked/lib/marked.esm.js
var _getDefaults = function() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
};
var changeDefaults = function(newDefaults) {
  _defaults = newDefaults;
};
var escape$1 = function(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
};
var unescape2 = function(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
};
var edit = function(regex, opt) {
  let source = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
};
var cleanUrl = function(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
};
var splitCells = function(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (;i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
};
var rtrim = function(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
};
var findClosingBracket = function(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0;i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
};
var outputLink = function(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape$1(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape$1(text)
  };
};
var indentCodeCompensation = function(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node2) => {
    const matchIndentInNode = node2.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node2;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node2.slice(indentToCode.length);
    }
    return node2;
  }).join("\n");
};
var marked = function(src, opt) {
  return markedInstance.parse(src, opt);
};
var _defaults = _getDefaults();
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
var caret = /(^|[^\[])\^/g;
var noopTest = { exec: () => null };

class _Tokenizer {
  options;
  rules;
  lexer;
  constructor(options) {
    this.options = options || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ""), "\n");
      const top2 = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top2;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|\$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|\$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|\$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimEnd();
      list.items[list.items.length - 1].text = itemContents.trimEnd();
      list.raw = list.raw.trimEnd();
      for (let i = 0;i < list.items.length; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (let i = 0;i < list.items.length; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!/[:|]/.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
    const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align2 of aligns) {
      if (/^ *-+: *$/.test(align2)) {
        item.align.push("right");
      } else if (/^ *:-+: *$/.test(align2)) {
        item.align.push("center");
      } else if (/^ *:-+ *$/.test(align2)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (const header of headers) {
      item.header.push({
        text: header,
        tokens: this.lexer.inline(header)
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell)
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape$1(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
      const link = links[linkString.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape$1(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape$1(cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape$1(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape$1(cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? "";
        } while (prevCapZero !== cap[0]);
        text = escape$1(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = cap[0];
      } else {
        text = escape$1(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
}
var newline = /^(?: *(?:\n|$))+/;
var blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheading = edit(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
};
var blockPedantic = {
  ...blockNormal,
  html: edit('^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
};
var escape2 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = "\\p{P}$+<=>`^|~";
var punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape2,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
};
var inlineGfm = {
  ...inlineNormal,
  escape: edit(escape2).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
var inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};

class _Lexer {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer;
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  static get rules() {
    return {
      block,
      inline
    };
  }
  static lex(src, options) {
    const lexer2 = new _Lexer(options);
    return lexer2.lex(src);
  }
  static lexInline(src, options) {
    const lexer2 = new _Lexer(options);
    return lexer2.inlineTokens(src);
  }
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0;i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}

class _Renderer {
  options;
  constructor(options) {
    this.options = options || _defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/^\S*/)?.[0];
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape$1(lang) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>\n${quote}</blockquote>\n`;
  }
  html(html2, block2) {
    return html2;
  }
  heading(text, level, raw) {
    return `<h${level}>${text}</h${level}>\n`;
  }
  hr() {
    return "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text, task, checked) {
    return `<li>${text}</li>\n`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(text) {
    return `<p>${text}</p>\n`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>\n${content}</tr>\n`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag2 = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>\n`;
  }
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  em(text) {
    return `<em>${text}</em>`;
  }
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return "<br>";
  }
  del(text) {
    return `<del>${text}</del>`;
  }
  link(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ">";
    return out;
  }
  text(text) {
    return text;
  }
}

class _TextRenderer {
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
}

class _Parser {
  options;
  renderer;
  textRenderer;
  constructor(options) {
    this.options = options || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer;
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer;
  }
  static parse(tokens, options) {
    const parser3 = new _Parser(options);
    return parser3.parse(tokens);
  }
  static parseInline(tokens, options) {
    const parser3 = new _Parser(options);
    return parser3.parseInline(tokens);
  }
  parse(tokens, top2 = true) {
    let out = "";
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const genericToken = token;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token;
          out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape2(this.parseInline(headingToken.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const codeToken = token;
          out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token;
          let header = "";
          let cell = "";
          for (let j = 0;j < tableToken.header.length; j++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j = 0;j < tableToken.rows.length; j++) {
            const row = tableToken.rows[j];
            cell = "";
            for (let k = 0;k < row.length; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token;
          const body = this.parse(blockquoteToken.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token;
          const ordered = listToken.ordered;
          const start = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j = 0;j < listToken.items.length; j++) {
            const item = listToken.items[j];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox + " "
                  });
                }
              } else {
                itemBody += checkbox + " ";
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          const htmlToken = token;
          out += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token;
          out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out += top2 ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "";
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          const escapeToken = token;
          out += renderer.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token;
          out += renderer.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token;
          out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
          break;
        }
        case "image": {
          const imageToken = token;
          out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token;
          out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
          break;
        }
        case "em": {
          const emToken = token;
          out += renderer.em(this.parseInline(emToken.tokens, renderer));
          break;
        }
        case "codespan": {
          const codespanToken = token;
          out += renderer.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          const delToken = token;
          out += renderer.del(this.parseInline(delToken.tokens, renderer));
          break;
        }
        case "text": {
          const textToken = token;
          out += renderer.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}

class _Hooks {
  options;
  constructor(options) {
    this.options = options || _defaults;
  }
  static passThroughHooks = new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]);
  preprocess(markdown) {
    return markdown;
  }
  postprocess(html2) {
    return html2;
  }
  processAllTokens(tokens) {
    return tokens;
  }
}

class Marked {
  defaults = _getDefaults();
  options = this.setOptions;
  parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
  parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
  Parser = _Parser;
  Renderer = _Renderer;
  TextRenderer = _TextRenderer;
  Lexer = _Lexer;
  Tokenizer = _Tokenizer;
  Hooks = _Hooks;
  constructor(...args) {
    this.use(...args);
  }
  walkTokens(tokens, callback) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              values = values.concat(this.walkTokens(genericToken[childTokens], callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks;
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens) {
            values = values.concat(walkTokens.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options) {
    return _Lexer.lex(src, options ?? this.defaults);
  }
  parser(tokens, options) {
    return _Parser.parse(tokens, options ?? this.defaults);
  }
  #parseMarkdown(lexer2, parser3) {
    return (src, options) => {
      const origOpt = { ...options };
      const opt = { ...this.defaults, ...origOpt };
      if (this.defaults.async === true && origOpt.async === false) {
        if (!opt.silent) {
          console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
        }
        opt.async = true;
      }
      const throwError = this.#onError(!!opt.silent, !!opt.async);
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser3(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser3(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
  }
  #onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
}
var markedInstance = new Marked;
marked.options = marked.setOptions = function(options) {
  markedInstance.setOptions(options);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser3 = _Parser.parse;
var lexer2 = _Lexer.lex;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/chalk/source/vendor/ansi-styles/index.js
var assembleStyles = function() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value2 = Math.max(red, green, blue) * 2;
        if (value2 === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value2 === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
};
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
var hasFlag = function(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
var envForceColor = function() {
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      return 1;
    }
    if (env2.FORCE_COLOR === "false") {
      return 0;
    }
    return env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
  }
};
var translateLevel = function(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
};
var _supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env2 && "AGENT_NAME" in env2) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env2.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env2) {
    if ("GITHUB_ACTIONS" in env2 || "GITEA_ACTIONS" in env2) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env2) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env2.COLORTERM === "truecolor") {
    return 3;
  }
  if (env2.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env2) {
    const version2 = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env2.TERM_PROGRAM) {
      case "iTerm.app": {
        return version2 >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env2.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env2) {
    return 1;
  }
  return min;
};
function createSupportsColor(stream, options2 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options2
  });
  return translateLevel(level);
}
var { env: env2 } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// /Users/karimshehadeh/dev/karim/hanto/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/chalk/source/index.js
var createChalk = function(options2) {
  return chalkFactory(options2);
};
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options2 = {}) => {
  if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options2.level === undefined ? colorLevel : options2.level;
};
var chalkFactory = (options2) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options2);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/tui/renderer.ts
var import_cli_table3 = __toESM(require_table(), 1);
var import_cardinal = __toESM(require_cardinal(), 1);

// /Users/karimshehadeh/dev/karim/hanto/node_modules/node-emoji/lib/index.js
var import_emojilib = __toESM(require_emojilib(), 1);
var import_char_regex = __toESM(require_char_regex(), 1);
var normalizeCode = function(code) {
  return code.replace(nonSpacingRegex, "");
};
var normalizeName = function(name) {
  return /:.+:/.test(name) ? name.slice(1, -1) : name;
};
var is = __toESM(require_dist2(), 1);
var import_skin_tone = __toESM(require_skin_tone(), 1);
var charRegexMatcher = import_char_regex.default();
var NON_SPACING_MARK = String.fromCharCode(65039);
var nonSpacingRegex = new RegExp(NON_SPACING_MARK, "g");
var emojiData = Object.entries(import_emojilib.default.lib).map(([name, { char: emoji }]) => [name, emoji]);
var emojiCodesByName = new Map(emojiData);
var emojiNamesByCode = new Map(emojiData.map(([name, emoji]) => [normalizeCode(emoji), name]));
var get = (codeOrName) => {
  is.assert.string(codeOrName);
  return emojiCodesByName.get(normalizeName(codeOrName));
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/ansi-escapes/index.js
import process3 from "node:process";
var ESC = "\x1B[";
var OSC = "\x1B]";
var BEL = "\x07";
var SEP = ";";
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isTerminalApp = !isBrowser && process3.env.TERM_PROGRAM === "Apple_Terminal";
var isWindows = !isBrowser && process3.platform === "win32";
var cwdFunction = isBrowser ? () => {
  throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process3.cwd;
var ansiEscapes = {};
ansiEscapes.cursorTo = (x, y) => {
  if (typeof x !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  if (typeof y !== "number") {
    return ESC + (x + 1) + "G";
  }
  return ESC + (y + 1) + SEP + (x + 1) + "H";
};
ansiEscapes.cursorMove = (x, y) => {
  if (typeof x !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  let returnValue = "";
  if (x < 0) {
    returnValue += ESC + -x + "D";
  } else if (x > 0) {
    returnValue += ESC + x + "C";
  }
  if (y < 0) {
    returnValue += ESC + -y + "A";
  } else if (y > 0) {
    returnValue += ESC + y + "B";
  }
  return returnValue;
};
ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
ansiEscapes.cursorLeft = ESC + "G";
ansiEscapes.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
ansiEscapes.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
ansiEscapes.cursorGetPosition = ESC + "6n";
ansiEscapes.cursorNextLine = ESC + "E";
ansiEscapes.cursorPrevLine = ESC + "F";
ansiEscapes.cursorHide = ESC + "?25l";
ansiEscapes.cursorShow = ESC + "?25h";
ansiEscapes.eraseLines = (count) => {
  let clear = "";
  for (let i = 0;i < count; i++) {
    clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
  }
  if (count) {
    clear += ansiEscapes.cursorLeft;
  }
  return clear;
};
ansiEscapes.eraseEndLine = ESC + "K";
ansiEscapes.eraseStartLine = ESC + "1K";
ansiEscapes.eraseLine = ESC + "2K";
ansiEscapes.eraseDown = ESC + "J";
ansiEscapes.eraseUp = ESC + "1J";
ansiEscapes.eraseScreen = ESC + "2J";
ansiEscapes.scrollUp = ESC + "S";
ansiEscapes.scrollDown = ESC + "T";
ansiEscapes.clearScreen = "\x1Bc";
ansiEscapes.clearTerminal = isWindows ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
ansiEscapes.enterAlternativeScreen = ESC + "?1049h";
ansiEscapes.exitAlternativeScreen = ESC + "?1049l";
ansiEscapes.beep = BEL;
ansiEscapes.link = (text, url) => [
  OSC,
  "8",
  SEP,
  SEP,
  url,
  BEL,
  text,
  OSC,
  "8",
  SEP,
  SEP,
  BEL
].join("");
ansiEscapes.image = (buffer, options2 = {}) => {
  let returnValue = `${OSC}1337;File=inline=1`;
  if (options2.width) {
    returnValue += `;width=${options2.width}`;
  }
  if (options2.height) {
    returnValue += `;height=${options2.height}`;
  }
  if (options2.preserveAspectRatio === false) {
    returnValue += ";preserveAspectRatio=0";
  }
  return returnValue + ":" + buffer.toString("base64") + BEL;
};
ansiEscapes.iTerm = {
  setCwd: (cwd = cwdFunction()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
  annotation(message, options2 = {}) {
    let returnValue = `${OSC}1337;`;
    const hasX = typeof options2.x !== "undefined";
    const hasY = typeof options2.y !== "undefined";
    if ((hasX || hasY) && !(hasX && hasY && typeof options2.length !== "undefined")) {
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    }
    message = message.replace(/\|/g, "");
    returnValue += options2.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
    if (options2.length > 0) {
      returnValue += (hasX ? [message, options2.length, options2.x, options2.y] : [options2.length, message]).join("|");
    } else {
      returnValue += message;
    }
    return returnValue + BEL;
  }
};
var ansi_escapes_default = ansiEscapes;

// src/tui/renderer.ts
var import_supports_hyperlinks = __toESM(require_supports_hyperlinks(), 1);
var compose = function(...fns) {
  return (initialValue) => {
    return fns.reduce((accumulator, currentFunction) => {
      return currentFunction ? currentFunction(accumulator) : accumulator ? accumulator : "";
    }, initialValue);
  };
};
var markedTerminal = function(options2, highlightOptions) {
  const r = new Renderer(options2, highlightOptions);
  const extension = {
    renderer: {
      code: r.code.bind(r),
      blockquote: r.blockquote.bind(r),
      html: r.html.bind(r),
      heading: r.heading.bind(r),
      hr: r.hr.bind(r),
      list: r.list.bind(r),
      listitem: r.listitem.bind(r),
      checkbox: r.checkbox.bind(r),
      paragraph: r.paragraph.bind(r),
      table: r.table.bind(r),
      tablerow: r.tablerow.bind(r),
      tablecell: r.tablecell.bind(r),
      strong: r.strong.bind(r),
      em: r.em.bind(r),
      codespan: r.codespan.bind(r),
      br: r.br.bind(r),
      del: r.del.bind(r),
      link: r.link.bind(r),
      image: r.image.bind(r),
      text: r.text.bind(r),
      options: r.o
    }
  };
  return extension;
};
function renderMarkdown(text) {
  const options2 = {
    ...defaultOptions,
    unescape: true,
    emoji: true,
    sanitize: true,
    width: 80,
    showSectionPrefix: false,
    reflowText: false,
    tab: 4,
    tableOptions: {},
    gfm: true
  };
  return marked(text, markedTerminal(options2, {}));
}

class Renderer {
  static TABLE_CELL_SPLIT = "^*||*^";
  static TABLE_ROW_WRAP = "*|*|*|*";
  static TABLE_ROW_WRAP_REGEXP = new RegExp(Renderer.escapeRegExp(Renderer.TABLE_ROW_WRAP), "g");
  static COLON_REPLACER = "*#COLON|*";
  static COLON_REPLACER_REGEXP = new RegExp(Renderer.escapeRegExp(Renderer.COLON_REPLACER), "g");
  static TAB_ALLOWED_CHARACTERS = ["\t"];
  static BULLET_POINT = "* ";
  static BULLET_POINT_REGEX = "\\*";
  static NUMBERED_POINT_REGEX = "\\d+\\.";
  static POINT_REGEX = "(?:" + [Renderer.BULLET_POINT_REGEX, Renderer.NUMBERED_POINT_REGEX].join("|") + ")";
  static HARD_RETURN_RE = new RegExp("\r");
  static HARD_RETURN_GFM_RE = new RegExp("\r|<br />");
  o;
  tab;
  emoji;
  unescape;
  highlightOptions;
  transform;
  constructor(options2, highlightOptions) {
    this.o = options2;
    this.tab = Renderer.sanitizeTab(this.o.tab, defaultOptions.tab);
    this.emoji = this.o.emoji ? Renderer.insertEmojis : Renderer.identity;
    this.unescape = this.o.unescape ? Renderer.unescapeEntities : Renderer.identity;
    this.highlightOptions = highlightOptions || {};
    this.transform = compose(Renderer.undoColon, this.o.unescape ? Renderer.unescapeEntities : undefined, this.o.emoji ? Renderer.insertEmojis : undefined);
  }
  static undoColon(str) {
    return str?.replace(Renderer.COLON_REPLACER_REGEXP, ":");
  }
  static fixHardReturn(text, reflow) {
    return reflow ? text.replace("\r", "\n") : text;
  }
  text(text) {
    return this.o.text(text);
  }
  code(code, lang, escaped) {
    return Renderer.section(Renderer.indentify(this.tab, this.highlight(code, lang)));
  }
  blockquote(quote) {
    return Renderer.section(this.o.blockquote(Renderer.indentify(this.tab, quote.trim())));
  }
  html(html2) {
    return this.o.html(html2);
  }
  heading(text, level, raw) {
    text = this.transform(text);
    const prefix = this.o.showSectionPrefix ? new Array(level + 1).join("#") + " " : "";
    text = prefix + text;
    if (this.o.reflowText) {
      text = Renderer.reflowText(text, this.o.width, true);
    }
    const levelFunc = (level2) => {
      switch (level2) {
        case 1:
          return this.o.h1;
        case 2:
          return this.o.h2;
        case 3:
          return this.o.h3;
        case 4:
          return this.o.h4;
        case 5:
          return this.o.h5;
        case 6:
          return this.o.h6;
        default:
          return this.o.h1;
      }
    };
    return Renderer.section(levelFunc(level)(text));
  }
  hr() {
    return Renderer.section(this.o.hr(Renderer.drawLine("-", this.o.width)));
  }
  list(body, ordered) {
    body = body.trim();
    body = ordered ? Renderer.numberedLines(body, this.tab) : Renderer.bulletPointLines(body, this.tab);
    return Renderer.section(Renderer.fixNestedLists(Renderer.indentLines(this.tab, body), this.tab));
  }
  listitem(text) {
    const transform = compose(this.o.listitem, this.transform);
    const isNested = text.indexOf("\n") !== -1;
    if (isNested)
      text = text.trim();
    return "\n" + Renderer.BULLET_POINT + transform(text);
  }
  checkbox(checked) {
    return "[" + (checked ? "X" : " ") + "] ";
  }
  paragraph(text) {
    const transform = compose(this.o.paragraph, this.transform);
    text = transform(text);
    if (this.o.reflowText) {
      text = Renderer.reflowText(text, this.o.width, this.o.gfm);
    }
    return Renderer.section(text);
  }
  table(header, body) {
    const table = new import_cli_table3.default(Object.assign({}, {
      head: Renderer.generateTableRow(header, this.transform)[0]
    }, this.o.tableOptions));
    Renderer.generateTableRow(body, this.transform).forEach((row) => {
      table.push(row);
    });
    return Renderer.section(this.o.table(table.toString()));
  }
  tablerow(content) {
    return Renderer.TABLE_ROW_WRAP + content + Renderer.TABLE_ROW_WRAP + "\n";
  }
  tablecell(content, flags) {
    return content + Renderer.TABLE_CELL_SPLIT;
  }
  strong(text) {
    return this.o.strong(text);
  }
  em(text) {
    text = Renderer.fixHardReturn(text, this.o.reflowText);
    return this.o.em(text);
  }
  codespan(text) {
    text = Renderer.fixHardReturn(text, this.o.reflowText);
    return this.o.codespan(text.replace(/:/g, Renderer.COLON_REPLACER));
  }
  br() {
    return this.o.reflowText ? "\r" : "\n";
  }
  del(text) {
    return this.o.del?.(text);
  }
  link(href, title, text) {
    if (this.o.sanitize) {
      try {
        const prot = decodeURIComponent(this.unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
        if (prot.indexOf("javascript:") === 0) {
          return "";
        }
      } catch (e) {
        return "";
      }
    }
    const hasText = text && text !== href;
    let out = "";
    if (import_supports_hyperlinks.default.stdout) {
      let link2 = "";
      if (text) {
        link2 = this.o.href(this.emoji?.(text));
      } else {
        link2 = this.o.href(href);
      }
      out = ansi_escapes_default.link(link2, href);
    } else {
      if (hasText)
        out += this.emoji(text) + " (";
      out += this.o.href(href);
      if (hasText)
        out += ")";
    }
    return this.o.link(out);
  }
  image(href, title, text) {
    let out = "![" + text;
    if (title)
      out += " \u2013 " + title;
    return out + "](" + href + ")\n";
  }
  highlight(code, lang) {
    if (source_default.level === 0)
      return code;
    const style = this.o.code;
    code = Renderer.fixHardReturn(code, this.o.reflowText);
    if (lang !== "javascript" && lang !== "js") {
      return style(code);
    }
    try {
      return import_cardinal.default.highlight(code, this.highlightOptions);
    } catch (e) {
      return style(code);
    }
  }
  static indentify(indent, text) {
    if (!text)
      return text;
    return indent + text.split("\n").join("\n" + indent);
  }
  static reflowText(text, width, gfm) {
    const splitRe = gfm ? Renderer.HARD_RETURN_GFM_RE : Renderer.HARD_RETURN_RE;
    const sections = text.split(splitRe);
    const reflowed = [];
    sections.forEach((section) => {
      const fragments = section.split(/(\u001b\[(?:\d{1,3})(?:;\d{1,3})*m)/g);
      let column = 0;
      let currentLine = "";
      let lastWasEscapeChar = false;
      while (fragments.length) {
        const fragment = fragments[0];
        if (fragment === "") {
          fragments.splice(0, 1);
          lastWasEscapeChar = false;
          continue;
        }
        if (!Renderer.textLength(fragment)) {
          currentLine += fragment;
          fragments.splice(0, 1);
          lastWasEscapeChar = true;
          continue;
        }
        const words = fragment.split(/[ \t\n]+/);
        for (let i = 0;i < words.length; i++) {
          let word = words[i];
          let addSpace = column !== 0;
          if (lastWasEscapeChar)
            addSpace = false;
          if (column + word.length + (addSpace ? 1 : 0) > width) {
            if (word.length <= width) {
              reflowed.push(currentLine);
              currentLine = word;
              column = word.length;
            } else {
              const w = word.substr(0, width - column - (addSpace ? 1 : 0));
              if (addSpace)
                currentLine += " ";
              currentLine += w;
              reflowed.push(currentLine);
              currentLine = "";
              column = 0;
              word = word.substr(w.length);
              while (word.length) {
                const w2 = word.substr(0, width);
                if (!w2.length)
                  break;
                if (w2.length < width) {
                  currentLine = w2;
                  column = w2.length;
                  break;
                } else {
                  reflowed.push(w2);
                  word = word.substr(width);
                }
              }
            }
          } else {
            if (addSpace) {
              currentLine += " ";
              column++;
            }
            currentLine += word;
            column += word.length;
          }
          lastWasEscapeChar = false;
        }
        fragments.splice(0, 1);
      }
      if (Renderer.textLength(currentLine))
        reflowed.push(currentLine);
    });
    return reflowed.join("\n");
  }
  static textLength(str) {
    return str.replace(/\u001b\[(?:\d{1,3})(?:;\d{1,3})*m/g, "").length;
  }
  static indentLines(indent, text) {
    return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
  }
  static fixNestedLists(body, indent) {
    const regex = new RegExp("(\\S(?: |  )?)((?:" + indent + ")+)(" + Renderer.POINT_REGEX + "(?:.*)+)$", "gm");
    return body.replace(regex, "$1\n" + indent + "$2$3");
  }
  static isPointedLine(line, indent) {
    return line.match("^(?:" + indent + ")*" + Renderer.POINT_REGEX);
  }
  static toSpaces(str) {
    return " ".repeat(str.length);
  }
  static bulletPointLine(indent, line) {
    return Renderer.isPointedLine(line, indent) ? line : Renderer.toSpaces(Renderer.BULLET_POINT) + line;
  }
  static bulletPointLines(lines, indent) {
    return lines.split("\n").filter(Renderer.identity).map((line) => Renderer.bulletPointLine(indent, line)).join("\n");
  }
  static numberedPoint(n) {
    return `${n}. `;
  }
  static numberedLine(indent, line, num) {
    return this.isPointedLine(line, indent) ? {
      num: num + 1,
      line: line.replace(Renderer.BULLET_POINT, this.numberedPoint(num + 1))
    } : {
      num,
      line: this.toSpaces(Renderer.numberedPoint(num)) + line
    };
  }
  static numberedLines(lines, indent) {
    let num = 0;
    return lines.split("\n").filter(Renderer.identity).map((line) => {
      const numbered = Renderer.numberedLine(line, indent, num);
      num = numbered.num;
      return numbered.line;
    }).join("\n");
  }
  static section(text) {
    return text + "\n\n";
  }
  static insertEmojis(text) {
    return text?.replace(/:([A-Za-z0-9_\-\+]+?):/g, (emojiString) => {
      const emojiSign = get(emojiString);
      if (!emojiSign)
        return emojiString;
      return emojiSign + " ";
    });
  }
  static drawLine(inputHrStr, length) {
    length = length || process.stdout.columns;
    return new Array(length).join(inputHrStr);
  }
  static generateTableRow(text, escape3) {
    if (!text)
      return [];
    escape3 = escape3 || Renderer.identity;
    const lines = escape3(text).split("\n");
    const data = [];
    lines.forEach((line) => {
      if (!line)
        return;
      const parsed = line.replace(Renderer.TABLE_ROW_WRAP_REGEXP, "").split(Renderer.TABLE_CELL_SPLIT);
      data.push(parsed.splice(0, parsed.length - 1));
    });
    return data;
  }
  static escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  static unescapeEntities(html2) {
    return html2?.replace(/&amp;/g, "&")?.replace(/&lt;/g, "<")?.replace(/&gt;/g, ">")?.replace(/&quot;/g, '"')?.replace(/&#39;/g, "'");
  }
  static identity(str) {
    return str;
  }
  static isAllowedTabString(str) {
    return Renderer.TAB_ALLOWED_CHARACTERS.some((char) => {
      return str.match("^(" + char + ")+$");
    });
  }
  static sanitizeTab(tab, fallbackTab) {
    if (typeof tab === "number") {
      return new Array(tab + 1).join(" ");
    } else if (typeof tab === "string" && Renderer.isAllowedTabString(tab)) {
      return tab;
    } else {
      return new Array(fallbackTab + 1).join(" ");
    }
  }
}
var defaultOptions = {
  code: source_default.yellow,
  blockquote: source_default.gray.italic,
  html: source_default.gray,
  h1: source_default.green.underline.bold,
  h2: source_default.green.bold,
  h3: source_default.yellow.underline.bold,
  h4: source_default.yellow.bold,
  h5: source_default.gray.bold,
  h6: source_default.gray,
  hr: source_default.reset,
  listitem: source_default.reset,
  table: source_default.reset,
  paragraph: source_default.reset,
  strong: source_default.bold,
  em: source_default.italic,
  codespan: source_default.yellow,
  del: source_default.dim.gray.strikethrough,
  link: source_default.blue,
  href: source_default.blue.underline,
  text: Renderer.identity,
  unescape: true,
  emoji: true,
  sanitize: true,
  width: 80,
  showSectionPrefix: false,
  reflowText: false,
  tab: 4,
  tableOptions: {},
  gfm: true
};

// src/commands/info.tsx
async function infoCommand(dir) {
  let projectDir = dir || process.cwd();
  if (!existsSync3(projectDir)) {
    throw new Error(`Directory ${projectDir} does not exist`);
  }
  const prj = await createProject(projectDir);
  const markdown = build().h1(`Project: ${prj.config?.name}`).h2(prj.config?.description).append(projectView(prj)).render();
  console.log(renderMarkdown(markdown));
}
var command4 = {
  command: "info [directory]",
  describe: "Process information about the given project directory",
  builder: {
    directory: {
      alias: "d",
      demandOption: false,
      describe: "The directory to examine (defaults to current directory)",
      type: "string"
    }
  },
  handler: async (argv) => {
    await infoCommand(argv.directory);
  }
};
var info_default = command4;

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-git/src/lib/run-git.ts
function runGit(cmd, cwd) {
  return new Promise((resolve6, reject) => {
    const child = __require("child_process").spawn("git", cmd.split(" "), {
      cwd
    });
    let output = "";
    child.stdout.on("data", (data) => {
      output += data;
    });
    child.stderr.on("data", (data) => {
      output += data;
    });
    child.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(output));
      } else {
        resolve6(output);
      }
    });
  });
}

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-git/src/loader.ts
class GitLoader extends Loader {
  constructor() {
    super([
      {
        name: "isFileTracked",
        description: "Determine if a file is tracked by git",
        type: "function",
        valueSchema: z.string(),
        optionsSchema: z.object({
          relativePath: z.string()
        })
      },
      {
        name: "isGitRepository",
        description: "Determine if the project is a git repository",
        valueSchema: z.boolean()
      }
    ]);
  }
  get name() {
    return "git";
  }
  get description() {
    return "Reads and understands git repos";
  }
  get dependencies() {
    return [];
  }
  async isFileTracked(relativePath) {
    const project2 = this.project;
    if (!project2)
      throw new Error("Loader not initialized");
    if (!project2.dir)
      throw new Error("Project dir not set");
    const result = await runGit(`ls-files --error-unmatch ${relativePath}`, project2.dir);
    return result === relativePath;
  }
  async load() {
    const project2 = this.project;
    if (!project2)
      throw new Error("Loader not initialized");
    if (!project2.dir)
      throw new Error("Project dir not set");
    this.set("isFileTracked", this.isFileTracked.bind(this));
    const isGitRepo = await runGit("rev-parse --is-inside-work-tree", project2.dir);
    this.set("isGitRepository", isGitRepo.trim() === "true");
    return this.errors.length === 0;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@hanto/plugin-git/index.ts
var plugin_git_default = {
  loader: new GitLoader
};

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-npm/src/loader.ts
import fs5 from "fs";

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-npm/src/schemas/package.schema.ts
var package_schema_default = z.object({
  name: z.string().regex(/^(?:(?:@(?:[a-z0-9-*~][a-z0-9-*._~]*)?\/[a-z0-9-._~])|[a-z0-9-~])[a-z0-9-._~]*$/).min(1).max(214).describe("The name of the package.").optional(),
  version: z.string().describe("Version must be parseable by node-semver, which is bundled with npm as a dependency.").optional(),
  description: z.string().describe("This helps people discover your package, as it's listed in 'npm search'.").optional(),
  keywords: z.array(z.string()).describe("This helps people discover your package as it's listed in 'npm search'.").optional(),
  homepage: z.string().describe("The url to the project homepage.").optional(),
  bugs: z.union([
    z.object({
      url: z.string().url().describe("The url to your project's issue tracker.").optional(),
      email: z.string().email().describe("The email address to which issues should be reported.").optional()
    }).describe("The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package."),
    z.string().describe("The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.")
  ]).describe("The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.").optional(),
  license: z.any().describe("You should specify a license for your package so that people know how they are permitted to use it, and any restrictions you're placing on it.").optional(),
  licenses: z.array(z.object({
    type: z.any().optional(),
    url: z.string().url().optional()
  })).describe('DEPRECATED: Instead, use SPDX expressions, like this: { "license": "ISC" } or { "license": "(MIT OR Apache-2.0)" } see: \'https://docs.npmjs.com/files/package.json#license\'.').optional(),
  author: z.any().optional(),
  contributors: z.array(z.any()).describe("A list of people who contributed to this package.").optional(),
  maintainers: z.array(z.any()).describe("A list of people who maintains this package.").optional(),
  files: z.array(z.string()).describe("The 'files' field is an array of files to include in your project. If you name a folder in the array, then it will also include the files inside that folder.").optional(),
  main: z.string().describe("The main field is a module ID that is the primary entry point to your program.").optional(),
  exports: z.any().superRefine((x, ctx) => {
    const schemas = [
      z.any().describe('The module path that is resolved when the module specifier matches "name", shadows the "main" field.'),
      z.object({
        ".": z.any().describe('The module path that is resolved when the module specifier matches "name", shadows the "main" field.').optional()
      }).catchall(z.union([
        z.any().describe('The module path prefix that is resolved when the module specifier starts with "name/", set to "./*" to allow external modules to import any subpath.'),
        z.never()
      ])).superRefine((value2, ctx2) => {
        for (const key in value2) {
          let evaluated = ["."].includes(key);
          if (RegExp(/^\.\/.+/).exec(key)) {
            evaluated = true;
            const result = z.any().describe('The module path prefix that is resolved when the module specifier starts with "name/", set to "./*" to allow external modules to import any subpath.').safeParse(value2[key]);
            if (!result.success) {
              ctx2.addIssue({
                path: [...ctx2.path, key],
                code: "custom",
                message: `Invalid input: Key matching regex /${key}/ must match schema`,
                params: {
                  issues: result.error.issues
                }
              });
            }
          }
          if (!evaluated) {
            const result = z.never().safeParse(value2[key]);
            if (!result.success) {
              ctx2.addIssue({
                path: [...ctx2.path, key],
                code: "custom",
                message: `Invalid input: must match catchall schema`,
                params: {
                  issues: result.error.issues
                }
              });
            }
          }
        }
      }),
      z.any().describe('The module path that is resolved when the module specifier matches "name", shadows the "main" field.'),
      z.any().describe('The module path that is resolved when the module specifier matches "name", shadows the "main" field.')
    ];
    const errors2 = schemas.reduce((errors3, schema) => ((result) => ("error" in result) ? [...errors3, result.error] : errors3)(schema.safeParse(x)), []);
    if (schemas.length - errors2.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors2,
        message: "Invalid input: Should pass single schema"
      });
    }
  }).describe('The "exports" field is used to restrict external access to non-exported module files, also enables a module to import itself using "name".').optional(),
  bin: z.union([z.string(), z.record(z.string())]).optional(),
  type: z.enum(["commonjs", "module"]).describe('When set to "module", the type field allows a package to specify all .js files within are ES modules. If the "type" field is omitted or set to "commonjs", all .js files are treated as CommonJS.').default("commonjs"),
  types: z.string().describe("Set the types property to point to your bundled declaration file.").optional(),
  typings: z.string().describe('Note that the "typings" field is synonymous with "types", and could be used as well.').optional(),
  typesVersions: z.record(z.object({
    "*": z.array(z.string().regex(/^[^*]*(?:\*[^*]*)?$/)).describe("Maps all file paths to the file paths specified in the array.").optional()
  }).catchall(z.union([
    z.array(z.string()).describe("Maps the file path matching the property key to the file paths specified in the array."),
    z.array(z.string().regex(/^[^*]*(?:\*[^*]*)?$/)).describe("Maps file paths matching the pattern specified in property key to file paths specified in the array."),
    z.never()
  ])).superRefine((value2, ctx) => {
    for (const key in value2) {
      let evaluated = ["*"].includes(key);
      if (RegExp(/^[^*]+$/).exec(key)) {
        evaluated = true;
        const result = z.array(z.string()).describe("Maps the file path matching the property key to the file paths specified in the array.").safeParse(value2[key]);
        if (!result.success) {
          ctx.addIssue({
            path: [...ctx.path, key],
            code: "custom",
            message: `Invalid input: Key matching regex /${key}/ must match schema`,
            params: {
              issues: result.error.issues
            }
          });
        }
      }
      if (RegExp(/^[^*]*\*[^*]*$/).exec(key)) {
        evaluated = true;
        const result = z.array(z.string().regex(/^[^*]*(?:\*[^*]*)?$/)).describe("Maps file paths matching the pattern specified in property key to file paths specified in the array.").safeParse(value2[key]);
        if (!result.success) {
          ctx.addIssue({
            path: [...ctx.path, key],
            code: "custom",
            message: `Invalid input: Key matching regex /${key}/ must match schema`,
            params: {
              issues: result.error.issues
            }
          });
        }
      }
      if (!evaluated) {
        const result = z.never().safeParse(value2[key]);
        if (!result.success) {
          ctx.addIssue({
            path: [...ctx.path, key],
            code: "custom",
            message: `Invalid input: must match catchall schema`,
            params: {
              issues: result.error.issues
            }
          });
        }
      }
    }
  }).describe("Contains overrides for the TypeScript version that matches the version range matching the property key.")).describe('The "typesVersions" field is used since TypeScript 3.1 to support features that were only made available in newer TypeScript versions.').optional(),
  man: z.union([
    z.array(z.string()).describe("Specify either a single file or an array of filenames to put in place for the man program to find."),
    z.string().describe("Specify either a single file or an array of filenames to put in place for the man program to find.")
  ]).describe("Specify either a single file or an array of filenames to put in place for the man program to find.").optional(),
  directories: z.object({
    bin: z.string().describe("If you specify a 'bin' directory, then all the files in that folder will be used as the 'bin' hash.").optional(),
    doc: z.string().describe("Put markdown files in here. Eventually, these will be displayed nicely, maybe, someday.").optional(),
    example: z.string().describe("Put example scripts in here. Someday, it might be exposed in some clever way.").optional(),
    lib: z.string().describe("Tell people where the bulk of your library is. Nothing special is done with the lib folder in any way, but it's useful meta info.").optional(),
    man: z.string().describe("A folder that is full of man pages. Sugar to generate a 'man' array by walking the folder.").optional(),
    test: z.string().optional()
  }).optional(),
  repository: z.union([
    z.object({
      type: z.string().optional(),
      url: z.string().optional(),
      directory: z.string().optional()
    }).describe("Specify the place where your code lives. This is helpful for people who want to contribute."),
    z.string().describe("Specify the place where your code lives. This is helpful for people who want to contribute.")
  ]).describe("Specify the place where your code lives. This is helpful for people who want to contribute.").optional(),
  funding: z.any().superRefine((x, ctx) => {
    const schemas = [
      z.any(),
      z.any(),
      z.array(z.any().superRefine((x2, ctx2) => {
        const schemas2 = [z.any(), z.any()];
        const errors3 = schemas2.reduce((errors4, schema) => ((result) => ("error" in result) ? [...errors4, result.error] : errors4)(schema.safeParse(x2)), []);
        if (schemas2.length - errors3.length !== 1) {
          ctx2.addIssue({
            path: ctx2.path,
            code: "invalid_union",
            unionErrors: errors3,
            message: "Invalid input: Should pass single schema"
          });
        }
      })).min(1)
    ];
    const errors2 = schemas.reduce((errors3, schema) => ((result) => ("error" in result) ? [...errors3, result.error] : errors3)(schema.safeParse(x)), []);
    if (schemas.length - errors2.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors2,
        message: "Invalid input: Should pass single schema"
      });
    }
  }).optional(),
  scripts: z.object({
    lint: z.string().describe("Run code quality tools, e.g. ESLint, TSLint, etc.").optional(),
    prepublish: z.string().describe("Run BEFORE the package is published (Also run on local npm install without any arguments).").optional(),
    prepare: z.string().describe("Run both BEFORE the package is packed and published, and on local npm install without any arguments. This is run AFTER prepublish, but BEFORE prepublishOnly.").optional(),
    prepublishOnly: z.string().describe("Run BEFORE the package is prepared and packed, ONLY on npm publish.").optional(),
    prepack: z.string().describe("run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies).").optional(),
    postpack: z.string().describe("Run AFTER the tarball has been generated and moved to its final destination.").optional(),
    publish: z.string().describe("Publishes a package to the registry so that it can be installed by name. See https://docs.npmjs.com/cli/v8/commands/npm-publish").optional(),
    postpublish: z.any().optional(),
    preinstall: z.string().describe("Run BEFORE the package is installed.").optional(),
    install: z.any().optional(),
    postinstall: z.any().optional(),
    preuninstall: z.any().optional(),
    uninstall: z.any().optional(),
    postuninstall: z.string().describe("Run AFTER the package is uninstalled.").optional(),
    preversion: z.any().optional(),
    version: z.any().optional(),
    postversion: z.string().describe("Run AFTER bump the package version.").optional(),
    pretest: z.any().optional(),
    test: z.any().optional(),
    posttest: z.any().optional(),
    prestop: z.any().optional(),
    stop: z.any().optional(),
    poststop: z.any().optional(),
    prestart: z.any().optional(),
    start: z.any().optional(),
    poststart: z.any().optional(),
    prerestart: z.any().optional(),
    restart: z.any().optional(),
    postrestart: z.any().optional(),
    serve: z.string().describe("Start dev server to serve application files").optional()
  }).catchall(z.string()).describe("The 'scripts' member is an object hash of script commands that are run at various times in the lifecycle of your package. The key is the lifecycle event, and the value is the command to run at that point.").optional(),
  config: z.record(z.any()).describe("A 'config' hash can be used to set configuration parameters used in package scripts that persist across upgrades.").optional(),
  dependencies: z.any().optional(),
  devDependencies: z.any().optional(),
  optionalDependencies: z.any().optional(),
  peerDependencies: z.any().optional(),
  peerDependenciesMeta: z.record(z.object({
    optional: z.boolean().describe("Specifies that this peer dependency is optional and should not be installed automatically.").optional()
  }).catchall(z.any())).describe('When a user installs your package, warnings are emitted if packages specified in "peerDependencies" are not already installed. The "peerDependenciesMeta" field serves to provide more information on how your peer dependencies are utilized. Most commonly, it allows peer dependencies to be marked as optional. Metadata for this field is specified with a simple hash of the package name to a metadata object.').optional(),
  bundledDependencies: z.any().superRefine((x, ctx) => {
    const schemas = [z.array(z.string()), z.boolean()];
    const errors2 = schemas.reduce((errors3, schema) => ((result) => ("error" in result) ? [...errors3, result.error] : errors3)(schema.safeParse(x)), []);
    if (schemas.length - errors2.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors2,
        message: "Invalid input: Should pass single schema"
      });
    }
  }).describe("Array of package names that will be bundled when publishing the package.").optional(),
  bundleDependencies: z.any().superRefine((x, ctx) => {
    const schemas = [z.array(z.string()), z.boolean()];
    const errors2 = schemas.reduce((errors3, schema) => ((result) => ("error" in result) ? [...errors3, result.error] : errors3)(schema.safeParse(x)), []);
    if (schemas.length - errors2.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors2,
        message: "Invalid input: Should pass single schema"
      });
    }
  }).describe('DEPRECATED: This field is honored, but "bundledDependencies" is the correct field name.').optional(),
  resolutions: z.record(z.any()).describe("Resolutions is used to support selective version resolutions using yarn, which lets you define custom package versions or ranges inside your dependencies. For npm, use overrides instead. See: https://classic.yarnpkg.com/en/docs/selective-version-resolutions").optional(),
  overrides: z.record(z.any()).describe("Overrides is used to support selective version overrides using npm, which lets you define custom package versions or ranges inside your dependencies. For yarn, use resolutions instead. See: https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides").optional(),
  packageManager: z.string().regex(/(npm|pnpm|yarn|bun)@\d+\.\d+\.\d+(-.+)?/).describe("Defines which package manager is expected to be used when working on the current project. This field is currently experimental and needs to be opted-in; see https://nodejs.org/api/corepack.html").optional(),
  engines: z.object({ node: z.string().optional() }).catchall(z.string()).optional(),
  volta: z.object({
    extends: z.string().describe('The value of that entry should be a path to another JSON file which also has a "volta" section').optional()
  }).catchall(z.string()).superRefine((value2, ctx) => {
    for (const key in value2) {
      if (RegExp(/(node|npm|pnpm|yarn)/).exec(key)) {
        const result = z.string().safeParse(value2[key]);
        if (!result.success) {
          ctx.addIssue({
            path: [...ctx.path, key],
            code: "custom",
            message: `Invalid input: Key matching regex /${key}/ must match schema`,
            params: {
              issues: result.error.issues
            }
          });
        }
      }
    }
  }).describe("Defines which tools and versions are expected to be used when Volta is installed.").optional(),
  engineStrict: z.boolean().optional(),
  os: z.array(z.string()).describe("Specify which operating systems your module will run on.").optional(),
  cpu: z.array(z.string()).describe("Specify that your code only runs on certain cpu architectures.").optional(),
  preferGlobal: z.boolean().describe("DEPRECATED: This option used to trigger an npm warning, but it will no longer warn. It is purely there for informational purposes. It is now recommended that you install any binaries as local devDependencies wherever possible.").optional(),
  private: z.any().superRefine((x, ctx) => {
    const schemas = [z.boolean(), z.enum(["false", "true"])];
    const errors2 = schemas.reduce((errors3, schema) => ((result) => ("error" in result) ? [...errors3, result.error] : errors3)(schema.safeParse(x)), []);
    if (schemas.length - errors2.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors2,
        message: "Invalid input: Should pass single schema"
      });
    }
  }).describe("If set to true, then npm will refuse to publish it.").optional(),
  publishConfig: z.object({
    access: z.enum(["public", "restricted"]).optional(),
    tag: z.string().optional(),
    registry: z.string().url().optional()
  }).catchall(z.any()).optional(),
  dist: z.object({
    shasum: z.string().optional(),
    tarball: z.string().optional()
  }).optional(),
  readme: z.string().optional(),
  module: z.string().describe("An ECMAScript module ID that is the primary entry point to your program.").optional(),
  esnext: z.union([
    z.string().describe("A module ID with untranspiled code that is the primary entry point to your program."),
    z.object({
      main: z.string().optional(),
      browser: z.string().optional()
    }).catchall(z.string()).describe("A module ID with untranspiled code that is the primary entry point to your program.")
  ]).describe("A module ID with untranspiled code that is the primary entry point to your program.").optional(),
  workspaces: z.union([
    z.array(z.string()).describe("Workspace package paths. Glob patterns are supported."),
    z.object({
      packages: z.array(z.string()).describe("Workspace package paths. Glob patterns are supported.").optional(),
      nohoist: z.array(z.string()).describe("Packages to block from hoisting to the workspace root. Currently only supported in Yarn only.").optional()
    })
  ]).describe('Allows packages within a directory to depend on one another using direct linking of local files. Additionally, dependencies within a workspace are hoisted to the workspace root when possible to reduce duplication. Note: It\'s also a good idea to set "private" to true when using this feature.').optional(),
  jspm: z.any().optional(),
  eslintConfig: z.any().optional(),
  prettier: z.any().optional(),
  stylelint: z.any().optional(),
  ava: z.any().optional(),
  release: z.any().optional(),
  jscpd: z.any().optional()
}).catchall(z.any().describe("Any property starting with _ is valid.")).superRefine((value2, ctx) => {
  for (const key in value2) {
    if (RegExp(/^_/).exec(key)) {
      const result = z.any().describe("Any property starting with _ is valid.").safeParse(value2[key]);
      if (!result.success) {
        ctx.addIssue({
          path: [...ctx.path, key],
          code: "custom",
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        });
      }
    }
  }
}).and(z.union([z.record(z.any()), z.record(z.any()), z.record(z.any())]));

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-npm/src/lib/run-npm.ts
function runNpm(cmd, cwd) {
  return new Promise((resolve6, reject) => {
    const child = __require("child_process").spawn("npm", [cmd], {
      cwd
    });
    let output = "";
    child.stdout.on("data", (data) => {
      output += data;
    });
    child.stderr.on("data", (data) => {
      output += data;
    });
    child.on("close", (code) => {
      if (code !== 0) {
        reject(new Error(output));
      } else {
        resolve6(output);
      }
    });
  });
}

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-npm/src/loader.ts
class NpmLoader extends Loader {
  _packageJson = null;
  constructor() {
    super([
      {
        name: "startingFile",
        description: "Starting file for the project",
        valueSchema: z.string()
      },
      {
        name: "numberOfTopLevelDependencies",
        description: "Number of top level dependencies",
        valueSchema: z.number()
      },
      {
        name: "numberOfTopLevelDevDependencies",
        description: "Number of top level dev dependencies",
        valueSchema: z.number()
      },
      {
        name: "getDependencyVersion",
        description: "Gets the version of a dependency",
        type: "function",
        optionsSchema: z.object({
          name: z.string()
        }),
        valueSchema: z.string()
      },
      {
        name: "resolveDependencyFolder",
        description: "Returns the folder of a given dependency for this project",
        type: "function",
        optionsSchema: z.object({
          name: z.string()
        }),
        valueSchema: z.string()
      }
    ]);
  }
  get name() {
    return "npm";
  }
  get description() {
    return "Reads and understands npm packages";
  }
  get dependencies() {
    return [];
  }
  processStartingFile(packageJson) {
    let startingFile = "";
    if (packageJson.main) {
      startingFile = packageJson.main;
    } else if (packageJson.module) {
      startingFile = packageJson.module;
    }
    if (startingFile) {
      this.set("startingFile", startingFile);
    }
  }
  processDependencies(packageJson) {
    if (packageJson.dependencies) {
      this.set("numberOfTopLevelDependencies", Object.keys(packageJson.dependencies).length);
    }
    if (packageJson.devDependencies) {
      this.set("numberOfTopLevelDevDependencies", Object.keys(packageJson.devDependencies).length);
    }
  }
  loadPackageJson() {
    const project2 = this.project;
    if (!project2)
      throw new Error("Loader not initialized");
    if (!project2.dir)
      throw new Error("Project directory not set");
    const packageJson = project2.findFile(project2.dir, "package.json", 0);
    if (packageJson) {
      const packageJsonContents = fs5.readFileSync(packageJson, {
        encoding: "utf-8"
      });
      const parseResult = package_schema_default.safeParse(JSON.parse(packageJsonContents));
      if (!parseResult.success) {
        if (parseResult.error.issues.length > 0) {
          this.errors.push(...parseResult.error.issues.map((i) => ({
            message: i.message,
            path: i.path
          })));
        } else {
          this.errors.push({
            message: "package.json is not a valid package.json file"
          });
        }
      } else {
        return parseResult.data;
      }
    } else {
      this.errors.push({
        message: "No package.json file found"
      });
    }
    return null;
  }
  getDependencyVersion(dependencyName) {
    if (typeof dependencyName !== "string")
      throw new Error("Invalid name");
    if (this._packageJson?.dependencies?.[dependencyName]) {
      return this._packageJson.dependencies[dependencyName];
    } else if (this._packageJson?.devDependencies?.[dependencyName]) {
      return this._packageJson.devDependencies[dependencyName];
    } else {
      return null;
    }
  }
  resolveDependencyFolder(dependencyName) {
    const project2 = this.project;
    if (!project2)
      throw new Error("Loader not initialized");
    if (!project2.dir)
      throw new Error("Project directory not set");
    if (typeof dependencyName !== "string")
      throw new Error("Invalid name");
    const root = runNpm("root", project2.dir);
  }
  async load() {
    this._packageJson = this.loadPackageJson();
    if (this._packageJson) {
      this.set("getDependencyVersion", this.getDependencyVersion);
      this.set("resolveDependencyFolder", this.resolveDependencyFolder);
      this.processDependencies(this._packageJson);
      this.processStartingFile(this._packageJson);
    }
    return this.errors.length === 0;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/packages/plugin-npm/src/rules/package-lock-checked-in.ts
class PackageLockCheckedInRule extends Rule {
  constructor() {
    super(...arguments);
  }
  get name() {
    return "package-lock-checked-in";
  }
  get description() {
    return "Checks if package-lock.json is checked in";
  }
  async check() {
    if (!this.project) {
      this._errors.push({
        message: "project is required for package-lock-checked-in rule"
      });
      return false;
    }
    const gitLoader = this.project.loader("git");
    if (!gitLoader) {
      this._errors.push({
        message: "git loader is required for package-lock-checked-in rule"
      });
      return false;
    }
    const result = gitLoader.call("isFileTracked", {
      relativePath: "package-lock.json"
    });
    if (!result) {
      this._errors.push({
        message: "package-lock.json being tracked in git"
      });
    }
    return true;
  }
}

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@hanto/plugin-npm/index.ts
var plugin_npm_default = {
  loader: new NpmLoader,
  rules: [new PackageLockCheckedInRule]
};

// /Users/karimshehadeh/dev/karim/hanto/node_modules/@hanto/plugin-nextjs/index.ts
class NextJsLoader extends Loader {
  _startingFile = undefined;
  get name() {
    return "nextjs";
  }
  get description() {
    return "Reads and understands NextJS projects";
  }
  get dependencies() {
    return ["npm"];
  }
  constructor() {
    super([]);
  }
  initialize(projectId) {
    super.initialize(projectId);
    const npmLoader = this.project?.loader("npm");
    if (!npmLoader) {
      this._errors.push({
        message: "npm loader is required for nextjs loader"
      });
      return false;
    }
    return true;
  }
  async load() {
    const project2 = this.project;
    if (!project2)
      throw new Error("Loader not initialized");
    const npmLoader = project2.loader("npm");
    if (!npmLoader) {
      throw new Error("npm loader is required for typescript loader");
    }
    return true;
  }
}
var plugin_nextjs_default = {
  loader: new NextJsLoader
};

// index.ts
yargs_default(process.argv.slice(2)).scriptName("hanto").usage("$0 <cmd> [args]").command(info_default).demandCommand(1, "You need at least one command before moving on").help().argv;
